### ðŸ§ª Senaryo 1: Bir uygulama veritabanÄ±na baÄŸlanmak iÃ§in konfigÃ¼rasyon dosyasÄ±ndan baÄŸlantÄ± bilgilerini okur. BaÄŸlantÄ± parametreleri uygulama baÅŸlangÄ±cÄ±nda ayarlanÄ±r. Sistem veritabanÄ± ile gÃ¼venli baÄŸlantÄ± kurar. Veri iÅŸlemleri bu baÄŸlantÄ± Ã¼zerinden gerÃ§ekleÅŸtirilir.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 48
```c#
public class DatabaseConfig
{
    public string ConnectionString { get; set; }
    public int Timeout { get; set; }
    public bool UseSSL { get; set; }
}

public class DatabaseService
{
    private readonly DatabaseConfig _config;
    private SqlConnection _connection;

    public DatabaseService(IConfiguration configuration)
    {
        _config = configuration.GetSection("Database").Get<DatabaseConfig>();
        InitializeConnection();
    }

    private void InitializeConnection()
    {
        var builder = new SqlConnectionStringBuilder(_config.ConnectionString)
        {
            ConnectTimeout = _config.Timeout,
            Encrypt = _config.UseSSL
        };
        _connection = new SqlConnection(builder.ConnectionString);
    }

    public async Task<User> GetUserAsync(int userId)
    {
        using var command = new SqlCommand("SELECT * FROM Users WHERE Id = @Id", _connection);
        command.Parameters.AddWithValue("@Id", userId);
        
        await _connection.OpenAsync();
        using var reader = await command.ExecuteReaderAsync();
        
        if (await reader.ReadAsync())
        {
            return new User
            {
                Id = reader.GetInt32("Id"),
                Name = reader.GetString("Name"),
                Email = reader.GetString("Email")
            };
        }
        return null;
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 50
```python
import json
import psycopg2
from psycopg2 import pool
import logging

class DatabaseService:
    def __init__(self, config_file='database_config.json'):
        self.config = self._load_config(config_file)
        self.connection_pool = self._create_connection_pool()
        
    def _load_config(self, config_file):
        with open(config_file, 'r') as f:
            return json.load(f)
    
    def _create_connection_pool(self):
        try:
            return psycopg2.pool.SimpleConnectionPool(
                1, 20,
                host=self.config['host'],
                database=self.config['database'],
                user=self.config['user'],
                password=self.config['password'],
                port=self.config['port'],
                sslmode='require' if self.config['use_ssl'] else 'disable'
            )
        except Exception as e:
            logging.error(f"Database connection failed: {e}")
            raise
    
    async def get_user(self, user_id):
        connection = None
        try:
            connection = self.connection_pool.getconn()
            cursor = connection.cursor()
            
            query = "SELECT id, name, email FROM users WHERE id = %s"
            cursor.execute(query, (user_id,))
            
            result = cursor.fetchone()
            if result:
                return {
                    'id': result[0],
                    'name': result[1],
                    'email': result[2]
                }
            return None
            
        finally:
            if connection:
                self.connection_pool.putconn(connection)
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 59
```typescript
import { Pool, PoolConfig } from 'pg';
import * as fs from 'fs';

interface DatabaseConfig {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  useSSL: boolean;
  maxConnections: number;
}

interface User {
  id: number;
  name: string;
  email: string;
}

class DatabaseService {
  private pool: Pool;
  private config: DatabaseConfig;

  constructor(configPath: string = './database-config.json') {
    this.config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    this.initializePool();
  }

  private initializePool(): void {
    const poolConfig: PoolConfig = {
      host: this.config.host,
      port: this.config.port,
      database: this.config.database,
      user: this.config.user,
      password: this.config.password,
      ssl: this.config.useSSL,
      max: this.config.maxConnections,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    };

    this.pool = new Pool(poolConfig);
  }

  async getUser(userId: number): Promise<User | null> {
    const client = await this.pool.connect();
    try {
      const query = 'SELECT id, name, email FROM users WHERE id = $1';
      const result = await client.query(query, [userId]);
      
      if (result.rows.length > 0) {
        return result.rows[0] as User;
      }
      return null;
    } finally {
      client.release();
    }
  }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 52
```c#
public class ApiConfig
{
    public string BaseUrl { get; set; }
    public string ApiKey { get; set; }
    public string SecretKey { get; set; }
    public int TimeoutSeconds { get; set; }
}

public class ExternalApiService
{
    private readonly HttpClient _httpClient;
    private readonly ApiConfig _config;

    public ExternalApiService(HttpClient httpClient, IConfiguration configuration)
    {
        _httpClient = httpClient;
        _config = configuration.GetSection("ExternalApi").Get<ApiConfig>();
        ConfigureHttpClient();
    }

    private void ConfigureHttpClient()
    {
        _httpClient.BaseAddress = new Uri(_config.BaseUrl);
        _httpClient.Timeout = TimeSpan.FromSeconds(_config.TimeoutSeconds);
        _httpClient.DefaultRequestHeaders.Add("X-API-Key", _config.ApiKey);
        _httpClient.DefaultRequestHeaders.Add("User-Agent", "MyApp/1.0");
    }

    public async Task<ApiResponse<T>> GetAsync<T>(string endpoint)
    {
        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString();
        var signature = GenerateSignature(endpoint, timestamp);
        
        _httpClient.DefaultRequestHeaders.Remove("X-Timestamp");
        _httpClient.DefaultRequestHeaders.Remove("X-Signature");
        _httpClient.DefaultRequestHeaders.Add("X-Timestamp", timestamp);
        _httpClient.DefaultRequestHeaders.Add("X-Signature", signature);

        var response = await _httpClient.GetAsync(endpoint);
        response.EnsureSuccessStatusCode();
        
        var content = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<ApiResponse<T>>(content);
    }

    private string GenerateSignature(string endpoint, string timestamp)
    {
        var message = $"{endpoint}{timestamp}{_config.ApiKey}";
        using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(_config.SecretKey));
        return Convert.ToBase64String(hmac.ComputeHash(Encoding.UTF8.GetBytes(message)));
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 58
```python
import requests
import hashlib
import hmac
import time
import json
import base64
from typing import Dict, Any, Optional

class ExternalApiService:
    def __init__(self, config_file: str = 'api_config.json'):
        self.config = self._load_config(config_file)
        self.session = requests.Session()
        self._setup_session()
    
    def _load_config(self, config_file: str) -> Dict[str, Any]:
        with open(config_file, 'r') as f:
            return json.load(f)
    
    def _setup_session(self):
        self.session.headers.update({
            'X-API-Key': self.config['api_key'],
            'User-Agent': 'MyApp/1.0',
            'Content-Type': 'application/json'
        })
        self.session.timeout = self.config['timeout_seconds']
    
    def _generate_signature(self, endpoint: str, timestamp: str) -> str:
        message = f"{endpoint}{timestamp}{self.config['api_key']}"
        signature = hmac.new(
            self.config['secret_key'].encode('utf-8'),
            message.encode('utf-8'),
            hashlib.sha256
        ).digest()
        return base64.b64encode(signature).decode('utf-8')
    
    async def get_data(self, endpoint: str) -> Optional[Dict[str, Any]]:
        timestamp = str(int(time.time()))
        signature = self._generate_signature(endpoint, timestamp)
        
        headers = {
            'X-Timestamp': timestamp,
            'X-Signature': signature
        }
        
        try:
            url = f"{self.config['base_url']}/{endpoint}"
            response = self.session.get(url, headers=headers)
            response.raise_for_status()
            
            return response.json()
            
        except requests.exceptions.RequestException as e:
            print(f"API request failed: {e}")
            return None
    
    def __del__(self):
        if hasattr(self, 'session'):
            self.session.close()
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 66
```typescript
import axios, { AxiosInstance, AxiosResponse } from 'axios';
import * as crypto from 'crypto';
import * as fs from 'fs';

interface ApiConfig {
  baseUrl: string;
  apiKey: string;
  secretKey: string;
  timeoutSeconds: number;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
}

class ExternalApiService {
  private client: AxiosInstance;
  private config: ApiConfig;

  constructor(configPath: string = './api-config.json') {
    this.config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    this.setupHttpClient();
  }

  private setupHttpClient(): void {
    this.client = axios.create({
      baseURL: this.config.baseUrl,
      timeout: this.config.timeoutSeconds * 1000,
      headers: {
        'X-API-Key': this.config.apiKey,
        'User-Agent': 'MyApp/1.0',
        'Content-Type': 'application/json'
      }
    });

    this.client.interceptors.request.use((config) => {
      const timestamp = Math.floor(Date.now() / 1000).toString();
      const signature = this.generateSignature(config.url || '', timestamp);
      
      config.headers['X-Timestamp'] = timestamp;
      config.headers['X-Signature'] = signature;
      
      return config;
    });
  }

  private generateSignature(endpoint: string, timestamp: string): string {
    const message = `${endpoint}${timestamp}${this.config.apiKey}`;
    return crypto
      .createHmac('sha256', this.config.secretKey)
      .update(message)
      .digest('base64');
  }

  async getData<T>(endpoint: string): Promise<ApiResponse<T> | null> {
    try {
      const response: AxiosResponse<ApiResponse<T>> = await this.client.get(endpoint);
      return response.data;
    } catch (error) {
      console.error('API request failed:', error);
      return null;
    }
  }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 67
```c#
public class SshConfig
{
    public string Host { get; set; }
    public int Port { get; set; }
    public string Username { get; set; }
    public string PrivateKeyPath { get; set; }
    public int TimeoutSeconds { get; set; }
}

public class SshManagementService
{
    private readonly SshConfig _config;
    private SshClient _sshClient;

    public SshManagementService(IConfiguration configuration)
    {
        _config = configuration.GetSection("SshConnection").Get<SshConfig>();
    }

    public async Task ConnectAsync()
    {
        var keyFile = new PrivateKeyFile(_config.PrivateKeyPath);
        var connectionInfo = new ConnectionInfo(_config.Host, _config.Port, _config.Username, keyFile)
        {
            Timeout = TimeSpan.FromSeconds(_config.TimeoutSeconds)
        };

        _sshClient = new SshClient(connectionInfo);
        await Task.Run(() => _sshClient.Connect());
        
        if (!_sshClient.IsConnected)
        {
            throw new Exception("Failed to establish SSH connection");
        }
    }

    public async Task<string> ExecuteCommandAsync(string command)
    {
        if (!_sshClient.IsConnected)
        {
            await ConnectAsync();
        }

        using var cmd = _sshClient.CreateCommand(command);
        var result = await Task.Run(() => cmd.Execute());
        
        if (cmd.ExitStatus != 0)
        {
            throw new Exception($"Command failed with exit code {cmd.ExitStatus}: {cmd.Error}");
        }

        return result;
    }

    public async Task<bool> FileExistsAsync(string filePath)
    {
        var command = $"test -f '{filePath}' && echo 'exists' || echo 'not_exists'";
        var result = await ExecuteCommandAsync(command);
        return result.Trim() == "exists";
    }

    public void Disconnect()
    {
        _sshClient?.Disconnect();
        _sshClient?.Dispose();
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 67
```python
import paramiko
import json
import logging
from typing import Optional, Dict, Any

class SshManagementService:
    def __init__(self, config_file: str = 'ssh_config.json'):
        self.config = self._load_config(config_file)
        self.client: Optional[paramiko.SSHClient] = None
        self._setup_logging()
    
    def _load_config(self, config_file: str) -> Dict[str, Any]:
        with open(config_file, 'r') as f:
            return json.load(f)
    
    def _setup_logging(self):
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    async def connect(self) -> bool:
        try:
            self.client = paramiko.SSHClient()
            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            private_key = paramiko.RSAKey.from_private_key_file(
                self.config['private_key_path']
            )
            
            self.client.connect(
                hostname=self.config['host'],
                port=self.config['port'],
                username=self.config['username'],
                pkey=private_key,
                timeout=self.config['timeout_seconds']
            )
            
            self.logger.info(f"Connected to {self.config['host']}")
            return True
            
        except Exception as e:
            self.logger.error(f"SSH connection failed: {e}")
            return False
    
    async def execute_command(self, command: str) -> Optional[str]:
        if not self.client:
            if not await self.connect():
                return None
        
        try:
            stdin, stdout, stderr = self.client.exec_command(command)
            exit_status = stdout.channel.recv_exit_status()
            
            if exit_status == 0:
                return stdout.read().decode('utf-8').strip()
            else:
                error_msg = stderr.read().decode('utf-8').strip()
                self.logger.error(f"Command failed: {error_msg}")
                return None
                
        except Exception as e:
            self.logger.error(f"Command execution failed: {e}")
            return None
    
    def disconnect(self):
        if self.client:
            self.client.close()
            self.logger.info("SSH connection closed")
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 97
```typescript
import { Client, ConnectConfig } from 'ssh2';
import * as fs from 'fs';

interface SshConfig {
  host: string;
  port: number;
  username: string;
  privateKeyPath: string;
  timeoutSeconds: number;
}

interface CommandResult {
  success: boolean;
  output: string;
  error?: string;
}

class SshManagementService {
  private client: Client;
  private config: SshConfig;
  private isConnected: boolean = false;

  constructor(configPath: string = './ssh-config.json') {
    this.config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    this.client = new Client();
  }

  async connect(): Promise<boolean> {
    return new Promise((resolve, reject) => {
      const privateKey = fs.readFileSync(this.config.privateKeyPath);
      
      const connectConfig: ConnectConfig = {
        host: this.config.host,
        port: this.config.port,
        username: this.config.username,
        privateKey: privateKey,
        readyTimeout: this.config.timeoutSeconds * 1000,
      };

      this.client.on('ready', () => {
        this.isConnected = true;
        console.log(`Connected to ${this.config.host}`);
        resolve(true);
      });

      this.client.on('error', (err) => {
        console.error('SSH connection error:', err);
        resolve(false);
      });

      this.client.connect(connectConfig);
    });
  }

  async executeCommand(command: string): Promise<CommandResult> {
    if (!this.isConnected) {
      const connected = await this.connect();
      if (!connected) {
        return { success: false, output: '', error: 'Connection failed' };
      }
    }

    return new Promise((resolve) => {
      this.client.exec(command, (err, stream) => {
        if (err) {
          resolve({ success: false, output: '', error: err.message });
          return;
        }

        let output = '';
        let error = '';

        stream.on('close', (code: number) => {
          resolve({
            success: code === 0,
            output: output,
            error: code !== 0 ? error : undefined
          });
        });

        stream.on('data', (data: Buffer) => {
          output += data.toString();
        });

        stream.stderr.on('data', (data: Buffer) => {
          error += data.toString();
        });
      });
    });
  }

  disconnect(): void {
    this.client.end();
    this.isConnected = false;
    console.log('SSH connection closed');
  }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 76
```c#
public class FtpConfig
{
    public string Host { get; set; }
    public int Port { get; set; }
    public string Username { get; set; }
    public string Password { get; set; }
    public bool UseSSL { get; set; }
    public int TimeoutSeconds { get; set; }
}

public class FtpTransferService
{
    private readonly FtpConfig _config;

    public FtpTransferService(IConfiguration configuration)
    {
        _config = configuration.GetSection("FtpConnection").Get<FtpConfig>();
    }

    private FtpWebRequest CreateFtpRequest(string fileName, string method)
    {
        var uri = $"ftp://{_config.Host}:{_config.Port}/{fileName}";
        var request = (FtpWebRequest)WebRequest.Create(uri);
        
        request.Method = method;
        request.Credentials = new NetworkCredential(_config.Username, _config.Password);
        request.EnableSsl = _config.UseSSL;
        request.Timeout = _config.TimeoutSeconds * 1000;
        request.KeepAlive = false;
        request.UseBinary = true;
        
        return request;
    }

    public async Task<bool> UploadFileAsync(string localFilePath, string remoteFileName)
    {
        try
        {
            var request = CreateFtpRequest(remoteFileName, WebRequestMethods.Ftp.UploadFile);
            
            using var fileStream = File.OpenRead(localFilePath);
            using var ftpStream = await request.GetRequestStreamAsync();
            
            await fileStream.CopyToAsync(ftpStream);
            
            using var response = (FtpWebResponse)await request.GetResponseAsync();
            return response.StatusCode == FtpStatusCode.ClosingData;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Upload failed: {ex.Message}");
            return false;
        }
    }

    public async Task<bool> DownloadFileAsync(string remoteFileName, string localFilePath)
    {
        try
        {
            var request = CreateFtpRequest(remoteFileName, WebRequestMethods.Ftp.DownloadFile);
            
            using var response = (FtpWebResponse)await request.GetResponseAsync();
            using var ftpStream = response.GetResponseStream();
            using var fileStream = File.Create(localFilePath);
            
            await ftpStream.CopyToAsync(fileStream);
            
            return response.StatusCode == FtpStatusCode.ClosingData;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Download failed: {ex.Message}");
            return false;
        }
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 74
```python
import ftplib
import json
import os
import ssl
from typing import Dict, Any, Optional

class FtpTransferService:
    def __init__(self, config_file: str = 'ftp_config.json'):
        self.config = self._load_config(config_file)
        self.ftp: Optional[ftplib.FTP] = None
    
    def _load_config(self, config_file: str) -> Dict[str, Any]:
        with open(config_file, 'r') as f:
            return json.load(f)
    
    async def connect(self) -> bool:
        try:
            if self.config['use_ssl']:
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                self.ftp = ftplib.FTP_TLS(context=context)
            else:
                self.ftp = ftplib.FTP()
            
            self.ftp.connect(self.config['host'], self.config['port'])
            self.ftp.login(self.config['username'], self.config['password'])
            
            if self.config['use_ssl'] and isinstance(self.ftp, ftplib.FTP_TLS):
                self.ftp.prot_p()
            
            print(f"Connected to FTP server: {self.config['host']}")
            return True
            
        except Exception as e:
            print(f"FTP connection failed: {e}")
            return False
    
    async def upload_file(self, local_file_path: str, remote_file_name: str) -> bool:
        if not self.ftp:
            if not await self.connect():
                return False
        
        try:
            with open(local_file_path, 'rb') as file:
                self.ftp.storbinary(f'STOR {remote_file_name}', file)
            
            print(f"File uploaded successfully: {remote_file_name}")
            return True
            
        except Exception as e:
            print(f"Upload failed: {e}")
            return False
    
    async def download_file(self, remote_file_name: str, local_file_path: str) -> bool:
        if not self.ftp:
            if not await self.connect():
                return False
        
        try:
            with open(local_file_path, 'wb') as file:
                self.ftp.retrbinary(f'RETR {remote_file_name}', file.write)
            
            print(f"File downloaded successfully: {local_file_path}")
            return True
            
        except Exception as e:
            print(f"Download failed: {e}")
            return False
    
    def disconnect(self):
        if self.ftp:
            self.ftp.quit()
            print("FTP connection closed")
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 97
```typescript
import * as ftp from 'basic-ftp';
import * as fs from 'fs';

interface FtpConfig {
  host: string;
  port: number;
  username: string;
  password: string;
  useSSL: boolean;
  timeoutSeconds: number;
}

interface TransferResult {
  success: boolean;
  message: string;
}

class FtpTransferService {
  private client: ftp.Client;
  private config: FtpConfig;

  constructor(configPath: string = './ftp-config.json') {
    this.config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    this.client = new ftp.Client();
    this.client.ftp.verbose = false;
  }

  async connect(): Promise<boolean> {
    try {
      await this.client.access({
        host: this.config.host,
        port: this.config.port,
        user: this.config.username,
        password: this.config.password,
        secure: this.config.useSSL,
        secureOptions: {
          rejectUnauthorized: false
        }
      });

      this.client.ftp.timeout = this.config.timeoutSeconds * 1000;
      console.log(`Connected to FTP server: ${this.config.host}`);
      return true;
      
    } catch (error) {
      console.error('FTP connection failed:', error);
      return false;
    }
  }

  async uploadFile(localFilePath: string, remoteFileName: string): Promise<TransferResult> {
    try {
      if (!this.client.closed) {
        await this.connect();
      }

      await this.client.uploadFrom(localFilePath, remoteFileName);
      
      return {
        success: true,
        message: `File uploaded successfully: ${remoteFileName}`
      };
      
    } catch (error) {
      return {
        success: false,
        message: `Upload failed: ${error.message}`
      };
    }
  }

  async downloadFile(remoteFileName: string, localFilePath: string): Promise<TransferResult> {
    try {
      if (!this.client.closed) {
        await this.connect();
      }

      await this.client.downloadTo(localFilePath, remoteFileName);
      
      return {
        success: true,
        message: `File downloaded successfully: ${localFilePath}`
      };
      
    } catch (error) {
      return {
        success: false,
        message: `Download failed: ${error.message}`
      };
    }
  }

  async disconnect(): Promise<void> {
    this.client.close();
    console.log('FTP connection closed');
  }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 76
```c#
public class SmtpConfig
{
    public string Host { get; set; }
    public int Port { get; set; }
    public string Username { get; set; }
    public string Password { get; set; }
    public bool EnableSSL { get; set; }
    public int TimeoutSeconds { get; set; }
}

public class EmailMessage
{
    public string From { get; set; }
    public List<string> To { get; set; } = new List<string>();
    public string Subject { get; set; }
    public string Body { get; set; }
    public bool IsHtml { get; set; }
}

public class EmailService
{
    private readonly SmtpConfig _config;

    public EmailService(IConfiguration configuration)
    {
        _config = configuration.GetSection("SmtpSettings").Get<SmtpConfig>();
    }

    public async Task<bool> SendEmailAsync(EmailMessage emailMessage)
    {
        try
        {
            using var smtpClient = new SmtpClient(_config.Host, _config.Port);
            smtpClient.EnableSsl = _config.EnableSSL;
            smtpClient.Credentials = new NetworkCredential(_config.Username, _config.Password);
            smtpClient.Timeout = _config.TimeoutSeconds * 1000;

            var mailMessage = new MailMessage();
            mailMessage.From = new MailAddress(emailMessage.From);
            
            foreach (var recipient in emailMessage.To)
            {
                mailMessage.To.Add(new MailAddress(recipient));
            }
            
            mailMessage.Subject = emailMessage.Subject;
            mailMessage.Body = emailMessage.Body;
            mailMessage.IsBodyHtml = emailMessage.IsHtml;

            await smtpClient.SendMailAsync(mailMessage);
            Console.WriteLine($"Email sent successfully to {string.Join(", ", emailMessage.To)}");
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to send email: {ex.Message}");
            return false;
        }
    }

    public async Task<bool> SendBulkEmailAsync(List<EmailMessage> emails)
    {
        var successCount = 0;
        foreach (var email in emails)
        {
            if (await SendEmailAsync(email))
            {
                successCount++;
            }
            await Task.Delay(1000); // Rate limiting
        }
        
        Console.WriteLine($"Sent {successCount}/{emails.Count} emails successfully");
        return successCount == emails.Count;
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 75
```python
import smtplib
import json
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from typing import Dict, List, Optional, Any
import ssl

class EmailMessage:
    def __init__(self, from_email: str, to_emails: List[str], subject: str, body: str, is_html: bool = False):
        self.from_email = from_email
        self.to_emails = to_emails
        self.subject = subject
        self.body = body
        self.is_html = is_html

class EmailService:
    def __init__(self, config_file: str = 'smtp_config.json'):
        self.config = self._load_config(config_file)
    
    def _load_config(self, config_file: str) -> Dict[str, Any]:
        with open(config_file, 'r') as f:
            return json.load(f)
    
    async def send_email(self, email_message: EmailMessage) -> bool:
        try:
            # Create message
            msg = MIMEMultipart()
            msg['From'] = email_message.from_email
            msg['To'] = ', '.join(email_message.to_emails)
            msg['Subject'] = email_message.subject
            
            # Add body
            body_type = 'html' if email_message.is_html else 'plain'
            msg.attach(MIMEText(email_message.body, body_type))
            
            # Create SMTP connection
            context = ssl.create_default_context()
            
            with smtplib.SMTP(self.config['host'], self.config['port']) as server:
                server.settimeout(self.config['timeout_seconds'])
                
                if self.config['enable_ssl']:
                    server.starttls(context=context)
                
                server.login(self.config['username'], self.config['password'])
                
                text = msg.as_string()
                server.sendmail(email_message.from_email, email_message.to_emails, text)
            
            print(f"Email sent successfully to {', '.join(email_message.to_emails)}")
            return True
            
        except Exception as e:
            print(f"Failed to send email: {e}")
            return False
    
    async def send_bulk_emails(self, emails: List[EmailMessage]) -> Dict[str, int]:
        success_count = 0
        failed_count = 0
        
        for email in emails:
            if await self.send_email(email):
                success_count += 1
            else:
                failed_count += 1
            
            # Rate limiting
            import asyncio
            await asyncio.sleep(1)
        
        result = {'success': success_count, 'failed': failed_count}
        print(f"Bulk email result: {result}")
        return result
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 112
```typescript
import * as nodemailer from 'nodemailer';
import * as fs from 'fs';

interface SmtpConfig {
  host: string;
  port: number;
  username: string;
  password: string;
  enableSSL: boolean;
  timeoutSeconds: number;
}

interface EmailMessage {
  from: string;
  to: string[];
  subject: string;
  body: string;
  isHtml?: boolean;
}

interface EmailResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

class EmailService {
  private transporter: nodemailer.Transporter;
  private config: SmtpConfig;

  constructor(configPath: string = './smtp-config.json') {
    this.config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    this.setupTransporter();
  }

  private setupTransporter(): void {
    this.transporter = nodemailer.createTransporter({
      host: this.config.host,
      port: this.config.port,
      secure: this.config.enableSSL,
      auth: {
        user: this.config.username,
        pass: this.config.password
      },
      connectionTimeout: this.config.timeoutSeconds * 1000,
      greetingTimeout: this.config.timeoutSeconds * 1000,
      socketTimeout: this.config.timeoutSeconds * 1000
    });
  }

  async sendEmail(emailMessage: EmailMessage): Promise<EmailResult> {
    try {
      const mailOptions = {
        from: emailMessage.from,
        to: emailMessage.to.join(', '),
        subject: emailMessage.subject,
        ...(emailMessage.isHtml 
          ? { html: emailMessage.body } 
          : { text: emailMessage.body }
        )
      };

      const info = await this.transporter.sendMail(mailOptions);
      
      console.log(`Email sent successfully to ${emailMessage.to.join(', ')}`);
      return {
        success: true,
        messageId: info.messageId
      };

    } catch (error) {
      console.error('Failed to send email:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async sendBulkEmails(emails: EmailMessage[]): Promise<{ success: number; failed: number }> {
    let successCount = 0;
    let failedCount = 0;

    for (const email of emails) {
      const result = await this.sendEmail(email);
      
      if (result.success) {
        successCount++;
      } else {
        failedCount++;
      }

      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    const summary = { success: successCount, failed: failedCount };
    console.log(`Bulk email summary:`, summary);
    return summary;
  }

  async verifyConnection(): Promise<boolean> {
    try {
      await this.transporter.verify();
      console.log('SMTP connection verified successfully');
      return true;
    } catch (error) {
      console.error('SMTP connection verification failed:', error);
      return false;
    }
  }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 99
```c#
public class CloudStorageConfig
{
    public string ServiceType { get; set; } // AWS, Azure, Google
    public string AccessKey { get; set; }
    public string SecretKey { get; set; }
    public string BucketName { get; set; }
    public string Region { get; set; }
}

public class CloudStorageService
{
    private readonly CloudStorageConfig _config;
    private readonly AmazonS3Client _s3Client;

    public CloudStorageService(IConfiguration configuration)
    {
        _config = configuration.GetSection("CloudStorage").Get<CloudStorageConfig>();
        InitializeClient();
    }

    private void InitializeClient()
    {
        var s3Config = new AmazonS3Config()
        {
            RegionEndpoint = RegionEndpoint.GetBySystemName(_config.Region),
            UseHttp = false,
            Timeout = TimeSpan.FromSeconds(30)
        };

        _s3Client = new AmazonS3Client(_config.AccessKey, _config.SecretKey, s3Config);
    }

    public async Task<bool> UploadFileAsync(string filePath, string key)
    {
        try
        {
            var request = new PutObjectRequest()
            {
                BucketName = _config.BucketName,
                Key = key,
                FilePath = filePath,
                ServerSideEncryptionMethod = ServerSideEncryptionMethod.AES256
            };

            var response = await _s3Client.PutObjectAsync(request);
            Console.WriteLine($"File uploaded: {key} - Status: {response.HttpStatusCode}");
            return response.HttpStatusCode == HttpStatusCode.OK;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Upload failed: {ex.Message}");
            return false;
        }
    }

    public async Task<bool> DownloadFileAsync(string key, string downloadPath)
    {
        try
        {
            var request = new GetObjectRequest()
            {
                BucketName = _config.BucketName,
                Key = key
            };

            using var response = await _s3Client.GetObjectAsync(request);
            using var fileStream = File.Create(downloadPath);
            await response.ResponseStream.CopyToAsync(fileStream);

            Console.WriteLine($"File downloaded: {key} to {downloadPath}");
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Download failed: {ex.Message}");
            return false;
        }
    }

    public async Task<bool> DeleteFileAsync(string key)
    {
        try
        {
            var request = new DeleteObjectRequest()
            {
                BucketName = _config.BucketName,
                Key = key
            };

            var response = await _s3Client.DeleteObjectAsync(request);
            return response.HttpStatusCode == HttpStatusCode.NoContent;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Delete failed: {ex.Message}");
            return false;
        }
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 101
```python
import boto3
import json
import os
from botocore.exceptions import ClientError, NoCredentialsError
from typing import Dict, Any, Optional

class CloudStorageService:
    def __init__(self, config_file: str = 'cloud_storage_config.json'):
        self.config = self._load_config(config_file)
        self.s3_client = self._initialize_client()
    
    def _load_config(self, config_file: str) -> Dict[str, Any]:
        with open(config_file, 'r') as f:
            return json.load(f)
    
    def _initialize_client(self):
        try:
            return boto3.client(
                's3',
                aws_access_key_id=self.config['access_key'],
                aws_secret_access_key=self.config['secret_key'],
                region_name=self.config['region']
            )
        except NoCredentialsError as e:
            print(f"AWS credentials not found: {e}")
            raise
    
    async def upload_file(self, file_path: str, key: str) -> bool:
        try:
            extra_args = {
                'ServerSideEncryption': 'AES256',
                'ACL': 'private'
            }
            
            self.s3_client.upload_file(
                file_path, 
                self.config['bucket_name'], 
                key,
                ExtraArgs=extra_args
            )
            
            print(f"File uploaded successfully: {key}")
            return True
            
        except FileNotFoundError:
            print(f"File not found: {file_path}")
            return False
        except ClientError as e:
            print(f"Upload failed: {e}")
            return False
    
    async def download_file(self, key: str, download_path: str) -> bool:
        try:
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(download_path), exist_ok=True)
            
            self.s3_client.download_file(
                self.config['bucket_name'], 
                key, 
                download_path
            )
            
            print(f"File downloaded successfully: {key} to {download_path}")
            return True
            
        except ClientError as e:
            error_code = e.response['Error']['Code']
            if error_code == 'NoSuchKey':
                print(f"File not found in bucket: {key}")
            else:
                print(f"Download failed: {e}")
            return False
    
    async def delete_file(self, key: str) -> bool:
        try:
            self.s3_client.delete_object(
                Bucket=self.config['bucket_name'],
                Key=key
            )
            
            print(f"File deleted successfully: {key}")
            return True
            
        except ClientError as e:
            print(f"Delete failed: {e}")
            return False
    
    def list_files(self, prefix: str = '') -> Optional[list]:
        try:
            response = self.s3_client.list_objects_v2(
                Bucket=self.config['bucket_name'],
                Prefix=prefix
            )
            
            if 'Contents' in response:
                return [obj['Key'] for obj in response['Contents']]
            return []
            
        except ClientError as e:
            print(f"List files failed: {e}")
            return None
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 145
```typescript
import * as AWS from 'aws-sdk';
import * as fs from 'fs';
import * as path from 'path';

interface CloudStorageConfig {
  serviceType: string;
  accessKey: string;
  secretKey: string;
  bucketName: string;
  region: string;
}

interface FileOperation {
  success: boolean;
  message: string;
  data?: any;
}

class CloudStorageService {
  private s3: AWS.S3;
  private config: CloudStorageConfig;

  constructor(configPath: string = './cloud-storage-config.json') {
    this.config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    this.initializeS3Client();
  }

  private initializeS3Client(): void {
    AWS.config.update({
      accessKeyId: this.config.accessKey,
      secretAccessKey: this.config.secretKey,
      region: this.config.region
    });

    this.s3 = new AWS.S3({
      apiVersion: '2006-03-01',
      sslEnabled: true,
      s3ForcePathStyle: false
    });
  }

  async uploadFile(filePath: string, key: string): Promise<FileOperation> {
    try {
      const fileContent = fs.readFileSync(filePath);
      
      const params: AWS.S3.PutObjectRequest = {
        Bucket: this.config.bucketName,
        Key: key,
        Body: fileContent,
        ServerSideEncryption: 'AES256',
        ACL: 'private'
      };

      const result = await this.s3.upload(params).promise();
      
      return {
        success: true,
        message: `File uploaded successfully: ${key}`,
        data: { location: result.Location, etag: result.ETag }
      };

    } catch (error) {
      return {
        success: false,
        message: `Upload failed: ${error.message}`
      };
    }
  }

  async downloadFile(key: string, downloadPath: string): Promise<FileOperation> {
    try {
      const params: AWS.S3.GetObjectRequest = {
        Bucket: this.config.bucketName,
        Key: key
      };

      const result = await this.s3.getObject(params).promise();
      
      // Create directory if it doesn't exist
      const dir = path.dirname(downloadPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      fs.writeFileSync(downloadPath, result.Body as Buffer);

      return {
        success: true,
        message: `File downloaded successfully: ${key} to ${downloadPath}`
      };

    } catch (error) {
      return {
        success: false,
        message: `Download failed: ${error.message}`
      };
    }
  }

  async deleteFile(key: string): Promise<FileOperation> {
    try {
      const params: AWS.S3.DeleteObjectRequest = {
        Bucket: this.config.bucketName,
        Key: key
      };

      await this.s3.deleteObject(params).promise();

      return {
        success: true,
        message: `File deleted successfully: ${key}`
      };

    } catch (error) {
      return {
        success: false,
        message: `Delete failed: ${error.message}`
      };
    }
  }

  async listFiles(prefix: string = ''): Promise<FileOperation> {
    try {
      const params: AWS.S3.ListObjectsV2Request = {
        Bucket: this.config.bucketName,
        Prefix: prefix
      };

      const result = await this.s3.listObjectsV2(params).promise();
      const files = result.Contents?.map(obj => obj.Key) || [];

      return {
        success: true,
        message: `Found ${files.length} files`,
        data: files
      };

    } catch (error) {
      return {
        success: false,
        message: `List files failed: ${error.message}`
      };
    }
  }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 109
```c#
public class MonitoringTarget
{
    public string Name { get; set; }
    public string Url { get; set; }
    public string ApiKey { get; set; }
    public string HealthEndpoint { get; set; }
    public int TimeoutSeconds { get; set; }
}

public class MonitoringConfig
{
    public List<MonitoringTarget> Targets { get; set; }
    public string EncryptionKey { get; set; }
    public int CheckIntervalMinutes { get; set; }
}

public class MonitoringService
{
    private readonly HttpClient _httpClient;
    private readonly MonitoringConfig _config;

    public MonitoringService(HttpClient httpClient, IConfiguration configuration)
    {
        _httpClient = httpClient;
        _config = LoadEncryptedConfig(configuration);
    }

    private MonitoringConfig LoadEncryptedConfig(IConfiguration configuration)
    {
        var encryptedConfigPath = configuration["MonitoringConfigPath"];
        var encryptionKey = configuration["EncryptionKey"];
        
        var encryptedData = File.ReadAllText(encryptedConfigPath);
        var decryptedJson = DecryptConfig(encryptedData, encryptionKey);
        
        return JsonSerializer.Deserialize<MonitoringConfig>(decryptedJson);
    }

    private string DecryptConfig(string encryptedData, string key)
    {
        using var aes = Aes.Create();
        aes.Key = Encoding.UTF8.GetBytes(key.PadRight(32).Substring(0, 32));
        aes.IV = Convert.FromBase64String(encryptedData.Substring(0, 24));
        
        var cipherText = Convert.FromBase64String(encryptedData.Substring(24));
        
        using var decryptor = aes.CreateDecryptor();
        using var msDecrypt = new MemoryStream(cipherText);
        using var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);
        using var srDecrypt = new StreamReader(csDecrypt);
        
        return srDecrypt.ReadToEnd();
    }

    public async Task<List<SystemHealthStatus>> CheckAllSystemsAsync()
    {
        var results = new List<SystemHealthStatus>();
        
        foreach (var target in _config.Targets)
        {
            var status = await CheckSystemHealthAsync(target);
            results.Add(status);
        }
        
        return results;
    }

    private async Task<SystemHealthStatus> CheckSystemHealthAsync(MonitoringTarget target)
    {
        try
        {
            _httpClient.Timeout = TimeSpan.FromSeconds(target.TimeoutSeconds);
            _httpClient.DefaultRequestHeaders.Clear();
            _httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {target.ApiKey}");
            
            var url = $"{target.Url.TrimEnd('/')}/{target.HealthEndpoint.TrimStart('/')}";
            var response = await _httpClient.GetAsync(url);
            
            return new SystemHealthStatus
            {
                SystemName = target.Name,
                IsHealthy = response.IsSuccessStatusCode,
                ResponseTime = TimeSpan.FromMilliseconds(100), // Simplified
                StatusCode = (int)response.StatusCode,
                CheckedAt = DateTime.UtcNow
            };
        }
        catch (Exception ex)
        {
            return new SystemHealthStatus
            {
                SystemName = target.Name,
                IsHealthy = false,
                ErrorMessage = ex.Message,
                CheckedAt = DateTime.UtcNow
            };
        }
    }
}

public class SystemHealthStatus
{
    public string SystemName { get; set; }
    public bool IsHealthy { get; set; }
    public TimeSpan ResponseTime { get; set; }
    public int StatusCode { get; set; }
    public string ErrorMessage { get; set; }
    public DateTime CheckedAt { get; set; }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 102
```python
import json
import aiohttp
import asyncio
from cryptography.fernet import Fernet
from datetime import datetime, timedelta
import time
from typing import List, Dict, Any

class MonitoringTarget:
    def __init__(self, name: str, url: str, api_key: str, health_endpoint: str, timeout_seconds: int):
        self.name = name
        self.url = url
        self.api_key = api_key
        self.health_endpoint = health_endpoint
        self.timeout_seconds = timeout_seconds

class SystemHealthStatus:
    def __init__(self, system_name: str, is_healthy: bool, response_time: float = 0, 
                 status_code: int = 0, error_message: str = None):
        self.system_name = system_name
        self.is_healthy = is_healthy
        self.response_time = response_time
        self.status_code = status_code
        self.error_message = error_message
        self.checked_at = datetime.utcnow()

class MonitoringService:
    def __init__(self, encrypted_config_path: str, encryption_key: str):
        self.encryption_key = encryption_key
        self.config = self._load_encrypted_config(encrypted_config_path)
        self.targets = self._parse_targets()
    
    def _load_encrypted_config(self, config_path: str) -> Dict[str, Any]:
        with open(config_path, 'rb') as f:
            encrypted_data = f.read()
        
        cipher_suite = Fernet(self.encryption_key.encode())
        decrypted_data = cipher_suite.decrypt(encrypted_data)
        
        return json.loads(decrypted_data.decode())
    
    def _parse_targets(self) -> List[MonitoringTarget]:
        targets = []
        for target_config in self.config['targets']:
            target = MonitoringTarget(
                name=target_config['name'],
                url=target_config['url'],
                api_key=target_config['api_key'],
                health_endpoint=target_config['health_endpoint'],
                timeout_seconds=target_config['timeout_seconds']
            )
            targets.append(target)
        return targets
    
    async def check_all_systems(self) -> List[SystemHealthStatus]:
        connector = aiohttp.TCPConnector(ssl=False)
        async with aiohttp.ClientSession(connector=connector) as session:
            tasks = [self._check_system_health(session, target) for target in self.targets]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Filter out exceptions and return valid results
            return [result for result in results if isinstance(result, SystemHealthStatus)]
    
    async def _check_system_health(self, session: aiohttp.ClientSession, target: MonitoringTarget) -> SystemHealthStatus:
        try:
            url = f"{target.url.rstrip('/')}/{target.health_endpoint.lstrip('/')}"
            headers = {
                'Authorization': f'Bearer {target.api_key}',
                'User-Agent': 'MonitoringService/1.0'
            }
            
            start_time = time.time()
            timeout = aiohttp.ClientTimeout(total=target.timeout_seconds)
            
            async with session.get(url, headers=headers, timeout=timeout) as response:
                response_time = time.time() - start_time
                
                return SystemHealthStatus(
                    system_name=target.name,
                    is_healthy=response.status == 200,
                    response_time=response_time,
                    status_code=response.status
                )
                
        except Exception as e:
            return SystemHealthStatus(
                system_name=target.name,
                is_healthy=False,
                error_message=str(e)
            )
    
    async def start_monitoring(self):
        interval = self.config.get('check_interval_minutes', 5) * 60
        
        while True:
            print(f"Checking system health at {datetime.utcnow()}")
            health_statuses = await self.check_all_systems()
            
            for status in health_statuses:
                print(f"{status.system_name}: {'âœ“' if status.is_healthy else 'âœ—'}")
            
            await asyncio.sleep(interval)
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 118
```typescript
import axios, { AxiosResponse } from 'axios';
import * as crypto from 'crypto';
import * as fs from 'fs';

interface MonitoringTarget {
  name: string;
  url: string;
  apiKey: string;
  healthEndpoint: string;
  timeoutSeconds: number;
}

interface MonitoringConfig {
  targets: MonitoringTarget[];
  checkIntervalMinutes: number;
}

interface SystemHealthStatus {
  systemName: string;
  isHealthy: boolean;
  responseTime: number;
  statusCode: number;
  errorMessage?: string;
  checkedAt: Date;
}

class MonitoringService {
  private config: MonitoringConfig;
  private encryptionKey: string;

  constructor(encryptedConfigPath: string, encryptionKey: string) {
    this.encryptionKey = encryptionKey;
    this.config = this.loadEncryptedConfig(encryptedConfigPath);
  }

  private loadEncryptedConfig(configPath: string): MonitoringConfig {
    const encryptedData = fs.readFileSync(configPath);
    const decryptedData = this.decryptConfig(encryptedData, this.encryptionKey);
    return JSON.parse(decryptedData);
  }

  private decryptConfig(encryptedData: Buffer, key: string): string {
    const algorithm = 'aes-256-cbc';
    const iv = encryptedData.slice(0, 16);
    const encrypted = encryptedData.slice(16);
    
    const keyBuffer = crypto.scryptSync(key, 'salt', 32);
    const decipher = crypto.createDecipheriv(algorithm, keyBuffer, iv);
    
    let decrypted = decipher.update(encrypted, undefined, 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }

  async checkAllSystems(): Promise<SystemHealthStatus[]> {
    const promises = this.config.targets.map(target => this.checkSystemHealth(target));
    const results = await Promise.allSettled(promises);
    
    return results
      .filter(result => result.status === 'fulfilled')
      .map(result => (result as PromiseFulfilledResult<SystemHealthStatus>).value);
  }

  private async checkSystemHealth(target: MonitoringTarget): Promise<SystemHealthStatus> {
    const startTime = Date.now();
    
    try {
      const url = `${target.url.replace(/\/$/, '')}/${target.healthEndpoint.replace(/^\//, '')}`;
      
      const response: AxiosResponse = await axios.get(url, {
        headers: {
          'Authorization': `Bearer ${target.apiKey}`,
          'User-Agent': 'MonitoringService/1.0'
        },
        timeout: target.timeoutSeconds * 1000,
        validateStatus: () => true // Don't throw on non-2xx status codes
      });

      const responseTime = Date.now() - startTime;

      return {
        systemName: target.name,
        isHealthy: response.status === 200,
        responseTime,
        statusCode: response.status,
        checkedAt: new Date()
      };

    } catch (error) {
      return {
        systemName: target.name,
        isHealthy: false,
        responseTime: Date.now() - startTime,
        statusCode: 0,
        errorMessage: error.message,
        checkedAt: new Date()
      };
    }
  }

  async startMonitoring(): Promise<void> {
    const intervalMs = this.config.checkIntervalMinutes * 60 * 1000;
    
    while (true) {
      console.log(`Checking system health at ${new Date().toISOString()}`);
      
      const healthStatuses = await this.checkAllSystems();
      
      healthStatuses.forEach(status => {
        const icon = status.isHealthy ? 'âœ“' : 'âœ—';
        console.log(`${icon} ${status.systemName}: ${status.responseTime}ms`);
      });

      await new Promise(resolve => setTimeout(resolve, intervalMs));
    }
  }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 135
```c#
public class LogSource
{
    public string Name { get; set; }
    public string Type { get; set; } // File, API, Database, Syslog
    public string ConnectionString { get; set; }
    public string AuthToken { get; set; }
    public Dictionary<string, string> Parameters { get; set; }
}

public class LogEntry
{
    public DateTime Timestamp { get; set; }
    public string Level { get; set; }
    public string Message { get; set; }
    public string Source { get; set; }
    public Dictionary<string, object> Metadata { get; set; }
}

public class LogCollectionService
{
    private readonly List<LogSource> _logSources;
    private readonly HttpClient _httpClient;

    public LogCollectionService(IConfiguration configuration, HttpClient httpClient)
    {
        _logSources = LoadSecureLogSources(configuration);
        _httpClient = httpClient;
    }

    private List<LogSource> LoadSecureLogSources(IConfiguration configuration)
    {
        var encryptedPath = configuration["LogSourcesConfigPath"];
        var decryptionKey = configuration["LogSourcesDecryptionKey"];
        
        var encryptedData = File.ReadAllText(encryptedPath);
        var decryptedJson = DecryptData(encryptedData, decryptionKey);
        
        return JsonSerializer.Deserialize<List<LogSource>>(decryptedJson);
    }

    public async Task<List<LogEntry>> CollectLogsAsync(DateTime fromTime, DateTime toTime)
    {
        var allLogs = new List<LogEntry>();
        
        var tasks = _logSources.Select(source => CollectFromSourceAsync(source, fromTime, toTime));
        var results = await Task.WhenAll(tasks);
        
        foreach (var logs in results)
        {
            if (logs != null)
                allLogs.AddRange(logs);
        }
        
        return allLogs.OrderBy(log => log.Timestamp).ToList();
    }

    private async Task<List<LogEntry>> CollectFromSourceAsync(LogSource source, DateTime fromTime, DateTime toTime)
    {
        try
        {
            return source.Type.ToLower() switch
            {
                "file" => await CollectFromFileAsync(source, fromTime, toTime),
                "api" => await CollectFromApiAsync(source, fromTime, toTime),
                "database" => await CollectFromDatabaseAsync(source, fromTime, toTime),
                _ => new List<LogEntry>()
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to collect logs from {source.Name}: {ex.Message}");
            return new List<LogEntry>();
        }
    }

    private async Task<List<LogEntry>> CollectFromApiAsync(LogSource source, DateTime fromTime, DateTime toTime)
    {
        _httpClient.DefaultRequestHeaders.Clear();
        _httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {source.AuthToken}");
        
        var url = $"{source.ConnectionString}?from={fromTime:yyyy-MM-ddTHH:mm:ssZ}&to={toTime:yyyy-MM-ddTHH:mm:ssZ}";
        
        var response = await _httpClient.GetAsync(url);
        response.EnsureSuccessStatusCode();
        
        var jsonContent = await response.Content.ReadAsStringAsync();
        var apiLogs = JsonSerializer.Deserialize<List<LogEntry>>(jsonContent);
        
        // Mark source
        apiLogs.ForEach(log => log.Source = source.Name);
        
        return apiLogs;
    }

    private async Task<List<LogEntry>> CollectFromFileAsync(LogSource source, DateTime fromTime, DateTime toTime)
    {
        var logs = new List<LogEntry>();
        var lines = await File.ReadAllLinesAsync(source.ConnectionString);
        
        foreach (var line in lines)
        {
            if (TryParseLogLine(line, out var logEntry))
            {
                if (logEntry.Timestamp >= fromTime && logEntry.Timestamp <= toTime)
                {
                    logEntry.Source = source.Name;
                    logs.Add(logEntry);
                }
            }
        }
        
        return logs;
    }

    private bool TryParseLogLine(string line, out LogEntry logEntry)
    {
        // Simplified log parsing - customize based on log format
        logEntry = null;
        var parts = line.Split('|');
        
        if (parts.Length >= 3 && DateTime.TryParse(parts[0], out var timestamp))
        {
            logEntry = new LogEntry
            {
                Timestamp = timestamp,
                Level = parts[1],
                Message = parts[2],
                Metadata = new Dictionary<string, object>()
            };
            return true;
        }
        
        return false;
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 149
```python
import json
import aiohttp
import asyncio
import aiofiles
from datetime import datetime
from cryptography.fernet import Fernet
from typing import List, Dict, Any, Optional
import re

class LogSource:
    def __init__(self, name: str, source_type: str, connection_string: str, 
                 auth_token: str = None, parameters: Dict[str, str] = None):
        self.name = name
        self.type = source_type
        self.connection_string = connection_string
        self.auth_token = auth_token
        self.parameters = parameters or {}

class LogEntry:
    def __init__(self, timestamp: datetime, level: str, message: str, 
                 source: str, metadata: Dict[str, Any] = None):
        self.timestamp = timestamp
        self.level = level
        self.message = message
        self.source = source
        self.metadata = metadata or {}

class LogCollectionService:
    def __init__(self, encrypted_config_path: str, decryption_key: str):
        self.decryption_key = decryption_key
        self.log_sources = self._load_secure_log_sources(encrypted_config_path)
    
    def _load_secure_log_sources(self, config_path: str) -> List[LogSource]:
        with open(config_path, 'rb') as f:
            encrypted_data = f.read()
        
        cipher_suite = Fernet(self.decryption_key.encode())
        decrypted_data = cipher_suite.decrypt(encrypted_data)
        
        sources_config = json.loads(decrypted_data.decode())
        
        sources = []
        for config in sources_config:
            source = LogSource(
                name=config['name'],
                source_type=config['type'],
                connection_string=config['connection_string'],
                auth_token=config.get('auth_token'),
                parameters=config.get('parameters', {})
            )
            sources.append(source)
        
        return sources
    
    async def collect_logs(self, from_time: datetime, to_time: datetime) -> List[LogEntry]:
        tasks = [
            self._collect_from_source(source, from_time, to_time)
            for source in self.log_sources
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        all_logs = []
        for result in results:
            if isinstance(result, list):
                all_logs.extend(result)
            elif isinstance(result, Exception):
                print(f"Error collecting logs: {result}")
        
        # Sort by timestamp
        return sorted(all_logs, key=lambda log: log.timestamp)
    
    async def _collect_from_source(self, source: LogSource, from_time: datetime, to_time: datetime) -> List[LogEntry]:
        try:
            if source.type.lower() == 'api':
                return await self._collect_from_api(source, from_time, to_time)
            elif source.type.lower() == 'file':
                return await self._collect_from_file(source, from_time, to_time)
            else:
                print(f"Unsupported source type: {source.type}")
                return []
        except Exception as e:
            print(f"Failed to collect logs from {source.name}: {e}")
            return []
    
    async def _collect_from_api(self, source: LogSource, from_time: datetime, to_time: datetime) -> List[LogEntry]:
        headers = {
            'Authorization': f'Bearer {source.auth_token}',
            'Content-Type': 'application/json'
        }
        
        params = {
            'from': from_time.isoformat(),
            'to': to_time.isoformat()
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.get(source.connection_string, headers=headers, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    logs = []
                    
                    for log_data in data.get('logs', []):
                        log_entry = LogEntry(
                            timestamp=datetime.fromisoformat(log_data['timestamp']),
                            level=log_data['level'],
                            message=log_data['message'],
                            source=source.name,
                            metadata=log_data.get('metadata', {})
                        )
                        logs.append(log_entry)
                    
                    return logs
                else:
                    print(f"API request failed for {source.name}: {response.status}")
                    return []
    
    async def _collect_from_file(self, source: LogSource, from_time: datetime, to_time: datetime) -> List[LogEntry]:
        logs = []
        
        async with aiofiles.open(source.connection_string, 'r') as file:
            async for line in file:
                log_entry = self._parse_log_line(line.strip(), source.name)
                if log_entry and from_time <= log_entry.timestamp <= to_time:
                    logs.append(log_entry)
        
        return logs
    
    def _parse_log_line(self, line: str, source_name: str) -> Optional[LogEntry]:
        # Simplified log parsing - customize based on log format
        # Expected format: "2024-01-15T10:30:00Z|INFO|This is a log message"
        
        pattern = r'(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z?)\|(\w+)\|(.*)'
        match = re.match(pattern, line)
        
        if match:
            timestamp_str, level, message = match.groups()
            try:
                timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
                return LogEntry(
                    timestamp=timestamp,
                    level=level,
                    message=message,
                    source=source_name
                )
            except ValueError:
                return None
        
        return None
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 161
```typescript
import axios from 'axios';
import * as fs from 'fs/promises';
import * as crypto from 'crypto';

interface LogSource {
  name: string;
  type: string;
  connectionString: string;
  authToken?: string;
  parameters?: Record<string, string>;
}

interface LogEntry {
  timestamp: Date;
  level: string;
  message: string;
  source: string;
  metadata?: Record<string, any>;
}

interface LogCollectionConfig {
  sources: LogSource[];
  encryptionKey: string;
}

class LogCollectionService {
  private logSources: LogSource[];
  private encryptionKey: string;

  constructor(encryptedConfigPath: string, decryptionKey: string) {
    this.encryptionKey = decryptionKey;
    this.initializeFromConfig(encryptedConfigPath);
  }

  private async initializeFromConfig(configPath: string): Promise<void> {
    const encryptedData = await fs.readFile(configPath);
    const decryptedData = this.decryptConfig(encryptedData, this.encryptionKey);
    const config: LogSource[] = JSON.parse(decryptedData);
    this.logSources = config;
  }

  private decryptConfig(encryptedData: Buffer, key: string): string {
    const algorithm = 'aes-256-cbc';
    const iv = encryptedData.slice(0, 16);
    const encrypted = encryptedData.slice(16);
    
    const keyBuffer = crypto.scryptSync(key, 'salt', 32);
    const decipher = crypto.createDecipheriv(algorithm, keyBuffer, iv);
    
    let decrypted = decipher.update(encrypted, undefined, 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }

  async collectLogs(fromTime: Date, toTime: Date): Promise<LogEntry[]> {
    const promises = this.logSources.map(source => 
      this.collectFromSource(source, fromTime, toTime)
    );
    
    const results = await Promise.allSettled(promises);
    
    const allLogs: LogEntry[] = [];
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        allLogs.push(...result.value);
      } else {
        console.error(`Failed to collect logs from ${this.logSources[index].name}:`, result.reason);
      }
    });
    
    return allLogs.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
  }

  private async collectFromSource(source: LogSource, fromTime: Date, toTime: Date): Promise<LogEntry[]> {
    switch (source.type.toLowerCase()) {
      case 'api':
        return this.collectFromApi(source, fromTime, toTime);
      case 'file':
        return this.collectFromFile(source, fromTime, toTime);
      default:
        console.warn(`Unsupported source type: ${source.type}`);
        return [];
    }
  }

  private async collectFromApi(source: LogSource, fromTime: Date, toTime: Date): Promise<LogEntry[]> {
    try {
      const response = await axios.get(source.connectionString, {
        headers: {
          'Authorization': `Bearer ${source.authToken}`,
          'Content-Type': 'application/json'
        },
        params: {
          from: fromTime.toISOString(),
          to: toTime.toISOString()
        },
        timeout: 30000
      });

      const logs: LogEntry[] = response.data.logs.map((logData: any) => ({
        timestamp: new Date(logData.timestamp),
        level: logData.level,
        message: logData.message,
        source: source.name,
        metadata: logData.metadata || {}
      }));

      return logs;
    } catch (error) {
      console.error(`API collection failed for ${source.name}:`, error.message);
      return [];
    }
  }

  private async collectFromFile(source: LogSource, fromTime: Date, toTime: Date): Promise<LogEntry[]> {
    try {
      const fileContent = await fs.readFile(source.connectionString, 'utf8');
      const lines = fileContent.split('\n');
      
      const logs: LogEntry[] = [];
      
      for (const line of lines) {
        const logEntry = this.parseLogLine(line.trim(), source.name);
        if (logEntry && logEntry.timestamp >= fromTime && logEntry.timestamp <= toTime) {
          logs.push(logEntry);
        }
      }
      
      return logs;
    } catch (error) {
      console.error(`File collection failed for ${source.name}:`, error.message);
      return [];
    }
  }

  private parseLogLine(line: string, sourceName: string): LogEntry | null {
    // Expected format: "2024-01-15T10:30:00Z|INFO|This is a log message"
    const regex = /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z?)\|(\w+)\|(.*)$/;
    const match = line.match(regex);
    
    if (match) {
      const [, timestampStr, level, message] = match;
      try {
        const timestamp = new Date(timestampStr);
        return {
          timestamp,
          level,
          message,
          source: sourceName,
          metadata: {}
        };
      } catch (error) {
        console.warn(`Failed to parse timestamp: ${timestampStr}`);
        return null;
      }
    }
    
    return null;
  }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 155
```c#
public class BankingCredentials
{
    public string BankId { get; set; }
    public string ClientId { get; set; }
    public string ClientSecret { get; set; }
    public string CertificatePath { get; set; }
    public string BaseUrl { get; set; }
}

public class PaymentRequest
{
    public string FromAccount { get; set; }
    public string ToAccount { get; set; }
    public decimal Amount { get; set; }
    public string Currency { get; set; }
    public string Reference { get; set; }
}

public class PaymentResponse
{
    public bool Success { get; set; }
    public string TransactionId { get; set; }
    public string Status { get; set; }
    public string ErrorMessage { get; set; }
}

public class PaymentService
{
    private readonly HttpClient _httpClient;
    private readonly BankingCredentials _credentials;
    private readonly IVaultService _vaultService;

    public PaymentService(HttpClient httpClient, IVaultService vaultService)
    {
        _httpClient = httpClient;
        _vaultService = vaultService;
        _credentials = LoadCredentialsFromVault();
        ConfigureHttpClient();
    }

    private BankingCredentials LoadCredentialsFromVault()
    {
        var credentials = new BankingCredentials
        {
            BankId = _vaultService.GetSecret("banking.bank_id"),
            ClientId = _vaultService.GetSecret("banking.client_id"),
            ClientSecret = _vaultService.GetSecret("banking.client_secret"),
            CertificatePath = _vaultService.GetSecret("banking.certificate_path"),
            BaseUrl = _vaultService.GetSecret("banking.base_url")
        };
        
        return credentials;
    }

    private void ConfigureHttpClient()
    {
        _httpClient.BaseAddress = new Uri(_credentials.BaseUrl);
        _httpClient.Timeout = TimeSpan.FromSeconds(30);
        
        // Configure client certificate for mutual TLS
        var certificate = new X509Certificate2(_credentials.CertificatePath);
        var handler = new HttpClientHandler();
        handler.ClientCertificates.Add(certificate);
    }

    public async Task<PaymentResponse> ProcessPaymentAsync(PaymentRequest paymentRequest)
    {
        try
        {
            var accessToken = await GetAccessTokenAsync();
            
            var requestBody = new
            {
                from_account = paymentRequest.FromAccount,
                to_account = paymentRequest.ToAccount,
                amount = paymentRequest.Amount,
                currency = paymentRequest.Currency,
                reference = paymentRequest.Reference,
                timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            };

            var jsonContent = JsonSerializer.Serialize(requestBody);
            var content = new StringContent(jsonContent, Encoding.UTF8, "application/json");
            
            _httpClient.DefaultRequestHeaders.Clear();
            _httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {accessToken}");
            _httpClient.DefaultRequestHeaders.Add("X-Request-ID", Guid.NewGuid().ToString());
            
            var response = await _httpClient.PostAsync("/api/v1/payments", content);
            var responseContent = await response.Content.ReadAsStringAsync();
            
            if (response.IsSuccessStatusCode)
            {
                var result = JsonSerializer.Deserialize<dynamic>(responseContent);
                return new PaymentResponse
                {
                    Success = true,
                    TransactionId = result.GetProperty("transaction_id").GetString(),
                    Status = result.GetProperty("status").GetString()
                };
            }
            else
            {
                return new PaymentResponse
                {
                    Success = false,
                    ErrorMessage = $"Payment failed: {response.StatusCode} - {responseContent}"
                };
            }
        }
        catch (Exception ex)
        {
            return new PaymentResponse
            {
                Success = false,
                ErrorMessage = $"Payment processing error: {ex.Message}"
            };
        }
    }

    private async Task<string> GetAccessTokenAsync()
    {
        var tokenRequest = new
        {
            grant_type = "client_credentials",
            client_id = _credentials.ClientId,
            client_secret = _credentials.ClientSecret,
            scope = "payments"
        };

        var content = new FormUrlEncodedContent(new[]
        {
            new KeyValuePair<string, string>("grant_type", "client_credentials"),
            new KeyValuePair<string, string>("client_id", _credentials.ClientId),
            new KeyValuePair<string, string>("client_secret", _credentials.ClientSecret),
            new KeyValuePair<string, string>("scope", "payments")
        });

        var tokenResponse = await _httpClient.PostAsync("/oauth/token", content);
        var tokenContent = await tokenResponse.Content.ReadAsStringAsync();
        
        if (tokenResponse.IsSuccessStatusCode)
        {
            var tokenData = JsonSerializer.Deserialize<JsonElement>(tokenContent);
            return tokenData.GetProperty("access_token").GetString();
        }
        
        throw new Exception($"Failed to obtain access token: {tokenContent}");
    }
}

public interface IVaultService
{
    string GetSecret(string key);
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 128
```python
import httpx
import json
import ssl
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
import asyncio

class BankingCredentials:
    def __init__(self, bank_id: str, client_id: str, client_secret: str, 
                 certificate_path: str, base_url: str):
        self.bank_id = bank_id
        self.client_id = client_id
        self.client_secret = client_secret
        self.certificate_path = certificate_path
        self.base_url = base_url

class PaymentRequest:
    def __init__(self, from_account: str, to_account: str, amount: float, 
                 currency: str, reference: str):
        self.from_account = from_account
        self.to_account = to_account
        self.amount = amount
        self.currency = currency
        self.reference = reference

class PaymentResponse:
    def __init__(self, success: bool, transaction_id: str = None, 
                 status: str = None, error_message: str = None):
        self.success = success
        self.transaction_id = transaction_id
        self.status = status
        self.error_message = error_message

class VaultService:
    def __init__(self, vault_config: Dict[str, str]):
        self.vault_config = vault_config
    
    def get_secret(self, key: str) -> str:
        # Simplified vault implementation
        return self.vault_config.get(key)

class PaymentService:
    def __init__(self, vault_service: VaultService):
        self.vault_service = vault_service
        self.credentials = self._load_credentials_from_vault()
        self.access_token = None
        self.token_expires_at = None
    
    def _load_credentials_from_vault(self) -> BankingCredentials:
        return BankingCredentials(
            bank_id=self.vault_service.get_secret("banking.bank_id"),
            client_id=self.vault_service.get_secret("banking.client_id"),
            client_secret=self.vault_service.get_secret("banking.client_secret"),
            certificate_path=self.vault_service.get_secret("banking.certificate_path"),
            base_url=self.vault_service.get_secret("banking.base_url")
        )
    
    async def process_payment(self, payment_request: PaymentRequest) -> PaymentResponse:
        try:
            async with httpx.AsyncClient(
                cert=self.credentials.certificate_path,
                verify=True,
                timeout=30.0
            ) as client:
                
                access_token = await self._get_access_token(client)
                
                payment_data = {
                    "from_account": payment_request.from_account,
                    "to_account": payment_request.to_account,
                    "amount": payment_request.amount,
                    "currency": payment_request.currency,
                    "reference": payment_request.reference,
                    "timestamp": int(datetime.utcnow().timestamp())
                }
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "Content-Type": "application/json",
                    "X-Request-ID": str(uuid.uuid4())
                }
                
                url = f"{self.credentials.base_url}/api/v1/payments"
                response = await client.post(url, json=payment_data, headers=headers)
                
                if response.status_code == 200:
                    result = response.json()
                    return PaymentResponse(
                        success=True,
                        transaction_id=result.get("transaction_id"),
                        status=result.get("status")
                    )
                else:
                    return PaymentResponse(
                        success=False,
                        error_message=f"Payment failed: {response.status_code} - {response.text}"
                    )
                    
        except Exception as e:
            return PaymentResponse(
                success=False,
                error_message=f"Payment processing error: {str(e)}"
            )
    
    async def _get_access_token(self, client: httpx.AsyncClient) -> str:
        if self.access_token and self.token_expires_at and datetime.utcnow() < self.token_expires_at:
            return self.access_token
        
        token_data = {
            "grant_type": "client_credentials",
            "client_id": self.credentials.client_id,
            "client_secret": self.credentials.client_secret,
            "scope": "payments"
        }
        
        url = f"{self.credentials.base_url}/oauth/token"
        response = await client.post(url, data=token_data)
        
        if response.status_code == 200:
            token_response = response.json()
            self.access_token = token_response["access_token"]
            expires_in = token_response.get("expires_in", 3600)
            self.token_expires_at = datetime.utcnow() + timedelta(seconds=expires_in)
            
            return self.access_token
        else:
            raise Exception(f"Failed to obtain access token: {response.text}")
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 146
```typescript
import axios, { AxiosInstance } from 'axios';
import * as https from 'https';
import * as fs from 'fs';
import { v4 as uuidv4 } from 'uuid';

interface BankingCredentials {
  bankId: string;
  clientId: string;
  clientSecret: string;
  certificatePath: string;
  baseUrl: string;
}

interface PaymentRequest {
  fromAccount: string;
  toAccount: string;
  amount: number;
  currency: string;
  reference: string;
}

interface PaymentResponse {
  success: boolean;
  transactionId?: string;
  status?: string;
  errorMessage?: string;
}

interface VaultService {
  getSecret(key: string): string;
}

class PaymentService {
  private credentials: BankingCredentials;
  private httpClient: AxiosInstance;
  private accessToken?: string;
  private tokenExpiresAt?: Date;

  constructor(private vaultService: VaultService) {
    this.credentials = this.loadCredentialsFromVault();
    this.setupHttpClient();
  }

  private loadCredentialsFromVault(): BankingCredentials {
    return {
      bankId: this.vaultService.getSecret('banking.bank_id'),
      clientId: this.vaultService.getSecret('banking.client_id'),
      clientSecret: this.vaultService.getSecret('banking.client_secret'),
      certificatePath: this.vaultService.getSecret('banking.certificate_path'),
      baseUrl: this.vaultService.getSecret('banking.base_url')
    };
  }

  private setupHttpClient(): void {
    const certificate = fs.readFileSync(this.credentials.certificatePath);
    
    const httpsAgent = new https.Agent({
      cert: certificate,
      rejectUnauthorized: true
    });

    this.httpClient = axios.create({
      baseURL: this.credentials.baseUrl,
      timeout: 30000,
      httpsAgent: httpsAgent,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }

  async processPayment(paymentRequest: PaymentRequest): Promise<PaymentResponse> {
    try {
      const accessToken = await this.getAccessToken();
      
      const paymentData = {
        from_account: paymentRequest.fromAccount,
        to_account: paymentRequest.toAccount,
        amount: paymentRequest.amount,
        currency: paymentRequest.currency,
        reference: paymentRequest.reference,
        timestamp: Math.floor(Date.now() / 1000)
      };

      const headers = {
        'Authorization': `Bearer ${accessToken}`,
        'X-Request-ID': uuidv4()
      };

      const response = await this.httpClient.post('/api/v1/payments', paymentData, { headers });

      if (response.status === 200) {
        return {
          success: true,
          transactionId: response.data.transaction_id,
          status: response.data.status
        };
      } else {
        return {
          success: false,
          errorMessage: `Payment failed: ${response.status} - ${response.statusText}`
        };
      }

    } catch (error) {
      return {
        success: false,
        errorMessage: `Payment processing error: ${error.message}`
      };
    }
  }

  private async getAccessToken(): Promise<string> {
    if (this.accessToken && this.tokenExpiresAt && new Date() < this.tokenExpiresAt) {
      return this.accessToken;
    }

    const tokenData = {
      grant_type: 'client_credentials',
      client_id: this.credentials.clientId,
      client_secret: this.credentials.clientSecret,
      scope: 'payments'
    };

    try {
      const response = await this.httpClient.post('/oauth/token', tokenData, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      });

      if (response.status === 200) {
        this.accessToken = response.data.access_token;
        const expiresIn = response.data.expires_in || 3600;
        this.tokenExpiresAt = new Date(Date.now() + (expiresIn * 1000));

        return this.accessToken;
      } else {
        throw new Error(`Failed to obtain access token: ${response.statusText}`);
      }

    } catch (error) {
      throw new Error(`Token request failed: ${error.message}`);
    }
  }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 149
```c#
public class DataSource
{
    public string Name { get; set; }
    public string Type { get; set; } // Database, API, File
    public string ConnectionString { get; set; }
    public Dictionary<string, string> Parameters { get; set; }
    public string Query { get; set; }
}

public class ReportData
{
    public string SourceName { get; set; }
    public List<Dictionary<string, object>> Data { get; set; }
    public DateTime CollectedAt { get; set; }
}

public class ReportService
{
    private readonly List<DataSource> _dataSources;
    private readonly HttpClient _httpClient;

    public ReportService(IConfiguration configuration, HttpClient httpClient)
    {
        _dataSources = LoadDataSourcesConfig(configuration);
        _httpClient = httpClient;
    }

    private List<DataSource> LoadDataSourcesConfig(IConfiguration configuration)
    {
        var configPath = configuration["DataSourcesConfigPath"];
        var configJson = File.ReadAllText(configPath);
        return JsonSerializer.Deserialize<List<DataSource>>(configJson);
    }

    public async Task<List<ReportData>> GenerateReportAsync(string reportName)
    {
        var reportSources = _dataSources.Where(ds => ds.Parameters.ContainsKey("ReportName") && 
                                                    ds.Parameters["ReportName"] == reportName).ToList();
        
        var tasks = reportSources.Select(source => CollectDataFromSourceAsync(source));
        var results = await Task.WhenAll(tasks);
        
        return results.Where(r => r != null).ToList();
    }

    private async Task<ReportData> CollectDataFromSourceAsync(DataSource source)
    {
        try
        {
            return source.Type.ToLower() switch
            {
                "database" => await CollectFromDatabaseAsync(source),
                "api" => await CollectFromApiAsync(source),
                "file" => await CollectFromFileAsync(source),
                _ => null
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to collect data from {source.Name}: {ex.Message}");
            return null;
        }
    }

    private async Task<ReportData> CollectFromDatabaseAsync(DataSource source)
    {
        using var connection = new SqlConnection(source.ConnectionString);
        await connection.OpenAsync();
        
        using var command = new SqlCommand(source.Query, connection);
        command.CommandTimeout = int.Parse(source.Parameters.GetValueOrDefault("Timeout", "30"));
        
        using var reader = await command.ExecuteReaderAsync();
        var data = new List<Dictionary<string, object>>();
        
        while (await reader.ReadAsync())
        {
            var row = new Dictionary<string, object>();
            for (int i = 0; i < reader.FieldCount; i++)
            {
                row[reader.GetName(i)] = reader.GetValue(i);
            }
            data.Add(row);
        }
        
        return new ReportData
        {
            SourceName = source.Name,
            Data = data,
            CollectedAt = DateTime.UtcNow
        };
    }

    private async Task<ReportData> CollectFromApiAsync(DataSource source)
    {
        var apiKey = source.Parameters.GetValueOrDefault("ApiKey");
        if (!string.IsNullOrEmpty(apiKey))
        {
            _httpClient.DefaultRequestHeaders.Clear();
            _httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {apiKey}");
        }
        
        var response = await _httpClient.GetAsync(source.ConnectionString);
        response.EnsureSuccessStatusCode();
        
        var jsonContent = await response.Content.ReadAsStringAsync();
        var apiData = JsonSerializer.Deserialize<List<Dictionary<string, object>>>(jsonContent);
        
        return new ReportData
        {
            SourceName = source.Name,
            Data = apiData,
            CollectedAt = DateTime.UtcNow
        };
    }

    private async Task<ReportData> CollectFromFileAsync(DataSource source)
    {
        var fileContent = await File.ReadAllTextAsync(source.ConnectionString);
        var data = new List<Dictionary<string, object>>();
        
        if (source.Parameters.GetValueOrDefault("FileType") == "CSV")
        {
            var lines = fileContent.Split('\n');
            var headers = lines[0].Split(',');
            
            for (int i = 1; i < lines.Length; i++)
            {
                if (string.IsNullOrWhiteSpace(lines[i])) continue;
                
                var values = lines[i].Split(',');
                var row = new Dictionary<string, object>();
                
                for (int j = 0; j < headers.Length && j < values.Length; j++)
                {
                    row[headers[j].Trim()] = values[j].Trim();
                }
                data.Add(row);
            }
        }
        
        return new ReportData
        {
            SourceName = source.Name,
            Data = data,
            CollectedAt = DateTime.UtcNow
        };
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 142
```python
import json
import asyncio
import aiohttp
import aiofiles
import pandas as pd
import sqlite3
from datetime import datetime
from typing import List, Dict, Any, Optional

class DataSource:
    def __init__(self, name: str, source_type: str, connection_string: str, 
                 parameters: Dict[str, str], query: str = None):
        self.name = name
        self.type = source_type
        self.connection_string = connection_string
        self.parameters = parameters
        self.query = query

class ReportData:
    def __init__(self, source_name: str, data: List[Dict[str, Any]], collected_at: datetime):
        self.source_name = source_name
        self.data = data
        self.collected_at = collected_at

class ReportService:
    def __init__(self, config_path: str):
        self.data_sources = self._load_data_sources_config(config_path)
    
    def _load_data_sources_config(self, config_path: str) -> List[DataSource]:
        with open(config_path, 'r') as f:
            config_data = json.load(f)
        
        sources = []
        for source_config in config_data:
            source = DataSource(
                name=source_config['name'],
                source_type=source_config['type'],
                connection_string=source_config['connection_string'],
                parameters=source_config.get('parameters', {}),
                query=source_config.get('query')
            )
            sources.append(source)
        
        return sources
    
    async def generate_report(self, report_name: str) -> List[ReportData]:
        report_sources = [
            source for source in self.data_sources 
            if source.parameters.get('report_name') == report_name
        ]
        
        tasks = [self._collect_data_from_source(source) for source in report_sources]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Filter out exceptions and None results
        return [result for result in results if isinstance(result, ReportData)]
    
    async def _collect_data_from_source(self, source: DataSource) -> Optional[ReportData]:
        try:
            if source.type.lower() == 'database':
                return await self._collect_from_database(source)
            elif source.type.lower() == 'api':
                return await self._collect_from_api(source)
            elif source.type.lower() == 'file':
                return await self._collect_from_file(source)
            else:
                print(f"Unsupported source type: {source.type}")
                return None
        except Exception as e:
            print(f"Failed to collect data from {source.name}: {e}")
            return None
    
    async def _collect_from_database(self, source: DataSource) -> ReportData:
        # Simplified database connection (SQLite example)
        connection = sqlite3.connect(source.connection_string)
        connection.row_factory = sqlite3.Row
        
        cursor = connection.cursor()
        cursor.execute(source.query)
        rows = cursor.fetchall()
        
        data = [dict(row) for row in rows]
        connection.close()
        
        return ReportData(
            source_name=source.name,
            data=data,
            collected_at=datetime.utcnow()
        )
    
    async def _collect_from_api(self, source: DataSource) -> ReportData:
        headers = {}
        api_key = source.parameters.get('api_key')
        if api_key:
            headers['Authorization'] = f'Bearer {api_key}'
        
        timeout = aiohttp.ClientTimeout(total=int(source.parameters.get('timeout', 30)))
        
        async with aiohttp.ClientSession(timeout=timeout) as session:
            async with session.get(source.connection_string, headers=headers) as response:
                if response.status == 200:
                    api_data = await response.json()
                    
                    # Ensure data is a list of dictionaries
                    if isinstance(api_data, dict):
                        data = [api_data]
                    elif isinstance(api_data, list):
                        data = api_data
                    else:
                        data = [{'value': api_data}]
                    
                    return ReportData(
                        source_name=source.name,
                        data=data,
                        collected_at=datetime.utcnow()
                    )
                else:
                    raise Exception(f"API request failed: {response.status}")
    
    async def _collect_from_file(self, source: DataSource) -> ReportData:
        file_type = source.parameters.get('file_type', '').lower()
        
        if file_type == 'csv':
            df = pd.read_csv(source.connection_string)
            data = df.to_dict('records')
        elif file_type == 'json':
            async with aiofiles.open(source.connection_string, 'r') as f:
                content = await f.read()
                data = json.loads(content)
                if not isinstance(data, list):
                    data = [data]
        else:
            # Default text processing
            async with aiofiles.open(source.connection_string, 'r') as f:
                content = await f.read()
                data = [{'content': content}]
        
        return ReportData(
            source_name=source.name,
            data=data,
            collected_at=datetime.utcnow()
        )
```