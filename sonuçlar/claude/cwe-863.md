### ğŸ§ª Senaryo 1: Bir dosya yÃ¶netim sisteminde kullanÄ±cÄ±lar kendi dosyalarÄ±nÄ± gÃ¶rÃ¼ntÃ¼leyebilir. Sistem kullanÄ±cÄ± hesaplarÄ± ile dosya eriÅŸimlerini yÃ¶netir. Her kullanÄ±cÄ± kendi dosya alanÄ±na eriÅŸim sahibidir. Dosya iÅŸlemleri kullanÄ±cÄ± yetkileri Ã§erÃ§evesinde gerÃ§ekleÅŸir.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 22
```csharp
[HttpGet("user-files")]
[Authorize]
public async Task<IActionResult> GetUserFiles()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var userFiles = await _context.Files
        .Where(f => f.UserId == userId)
        .Select(f => new { f.Id, f.FileName, f.FileSize, f.CreatedAt })
        .ToListAsync();
    
    return Ok(userFiles);
}

[HttpDelete("file/{fileId}")]
[Authorize]
public async Task<IActionResult> DeleteFile(int fileId)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var file = await _context.Files.FirstOrDefaultAsync(f => f.Id == fileId && f.UserId == userId);
    
    if (file == null) return NotFound();
    
    _context.Files.Remove(file);
    await _context.SaveChangesAsync();
    return NoContent();
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 24
```python
from flask import Flask, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from models import db, File

@app.route('/user-files', methods=['GET'])
@jwt_required()
def get_user_files():
    user_id = get_jwt_identity()
    user_files = File.query.filter_by(user_id=user_id).all()
    
    return jsonify([{
        'id': file.id,
        'filename': file.filename,
        'file_size': file.file_size,
        'created_at': file.created_at.isoformat()
    } for file in user_files])

@app.route('/file/<int:file_id>', methods=['DELETE'])
@jwt_required()
def delete_file(file_id):
    user_id = get_jwt_identity()
    file = File.query.filter_by(id=file_id, user_id=user_id).first()
    
    if not file:
        return jsonify({'error': 'File not found'}), 404
    
    db.session.delete(file)
    db.session.commit()
    return '', 204
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 34
```typescript
// Express.js with TypeScript
import { Request, Response } from 'express';
import { authenticateToken } from '../middleware/auth';
import { FileService } from '../services/FileService';

interface AuthRequest extends Request {
    userId?: string;
}

export const getUserFiles = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const userFiles = await FileService.getFilesByUserId(userId);
        
        res.json(userFiles.map(file => ({
            id: file.id,
            filename: file.filename,
            fileSize: file.fileSize,
            createdAt: file.createdAt
        })));
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const deleteFile = async (req: AuthRequest, res: Response) => {
    try {
        const { fileId } = req.params;
        const userId = req.userId!;
        
        const deleted = await FileService.deleteUserFile(fileId, userId);
        if (!deleted) {
            return res.status(404).json({ error: 'File not found' });
        }
        
        res.status(204).send();
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};
```

### ğŸ§ª Senaryo 2: Bir proje yÃ¶netim uygulamasÄ±nda ekip Ã¼yeleri gÃ¶revleri takip eder. Proje rolleri sistem tarafÄ±ndan tanÄ±mlanÄ±r ve yÃ¶netilir. Her kullanÄ±cÄ± rolÃ¼ne gÃ¶re farklÄ± iÅŸlevlere eriÅŸim saÄŸlar. GÃ¶rev yÃ¶netimi rol tabanlÄ± olarak gerÃ§ekleÅŸir.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 31
```csharp
[HttpGet("project/{projectId}/tasks")]
[Authorize]
public async Task<IActionResult> GetProjectTasks(int projectId)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var userRole = await _context.ProjectMembers
        .Where(pm => pm.ProjectId == projectId && pm.UserId == userId)
        .Select(pm => pm.Role)
        .FirstOrDefaultAsync();
    
    if (userRole == null) return Forbid();
    
    var tasks = await _context.Tasks
        .Where(t => t.ProjectId == projectId)
        .ToListAsync();
    
    return Ok(tasks);
}

[HttpPost("task")]
[Authorize(Roles = "ProjectManager,TeamLead")]
public async Task<IActionResult> CreateTask(CreateTaskRequest request)
{
    var task = new Task
    {
        Title = request.Title,
        Description = request.Description,
        ProjectId = request.ProjectId,
        AssignedToId = request.AssignedToId,
        CreatedAt = DateTime.UtcNow
    };
    
    _context.Tasks.Add(task);
    await _context.SaveChangesAsync();
    return CreatedAtAction(nameof(GetTask), new { id = task.Id }, task);
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 42
```python
from functools import wraps
from models import ProjectMember, Task, Project

def require_project_role(allowed_roles):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            user_id = get_jwt_identity()
            project_id = request.view_args.get('project_id')
            
            member = ProjectMember.query.filter_by(
                user_id=user_id, 
                project_id=project_id
            ).first()
            
            if not member or member.role not in allowed_roles:
                return jsonify({'error': 'Insufficient permissions'}), 403
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

@app.route('/project/<int:project_id>/tasks', methods=['GET'])
@jwt_required()
@require_project_role(['member', 'team_lead', 'project_manager'])
def get_project_tasks(project_id):
    tasks = Task.query.filter_by(project_id=project_id).all()
    
    return jsonify([{
        'id': task.id,
        'title': task.title,
        'status': task.status,
        'assigned_to': task.assigned_to_id
    } for task in tasks])

@app.route('/task', methods=['POST'])
@jwt_required()
@require_project_role(['team_lead', 'project_manager'])
def create_task():
    data = request.get_json()
    
    task = Task(
        title=data['title'],
        description=data['description'],
        project_id=data['project_id'],
        assigned_to_id=data['assigned_to_id']
    )
    
    db.session.add(task)
    db.session.commit()
    
    return jsonify({'id': task.id, 'message': 'Task created'}), 201
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 44
```typescript
import { Request, Response, NextFunction } from 'express';
import { ProjectMemberService } from '../services/ProjectMemberService';
import { TaskService } from '../services/TaskService';

type ProjectRole = 'member' | 'team_lead' | 'project_manager';

const requireProjectRole = (allowedRoles: ProjectRole[]) => {
    return async (req: AuthRequest, res: Response, next: NextFunction) => {
        try {
            const userId = req.userId!;
            const projectId = req.params.projectId;
            
            const userRole = await ProjectMemberService.getUserRole(userId, projectId);
            
            if (!userRole || !allowedRoles.includes(userRole)) {
                return res.status(403).json({ error: 'Insufficient permissions' });
            }
            
            req.userRole = userRole;
            next();
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    };
};

export const getProjectTasks = [
    requireProjectRole(['member', 'team_lead', 'project_manager']),
    async (req: AuthRequest, res: Response) => {
        try {
            const projectId = req.params.projectId;
            const tasks = await TaskService.getTasksByProject(projectId);
            
            res.json(tasks);
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];

export const createTask = [
    requireProjectRole(['team_lead', 'project_manager']),
    async (req: AuthRequest, res: Response) => {
        try {
            const taskData = req.body;
            const newTask = await TaskService.createTask(taskData);
            
            res.status(201).json(newTask);
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];
```

### ğŸ§ª Senaryo 3: Bir e-ticaret platformunda mÃ¼ÅŸteriler kendi sipariÅŸlerini gÃ¶rÃ¼ntÃ¼ler. Sistem kullanÄ±cÄ± hesaplarÄ± ile sipariÅŸ verilerini iliÅŸkilendirir. Her mÃ¼ÅŸteri kendi sipariÅŸ geÃ§miÅŸine eriÅŸim saÄŸlar. SipariÅŸ bilgileri mÃ¼ÅŸteri bazÄ±nda organize edilir.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 40
```csharp
[HttpGet("orders")]
[Authorize]
public async Task<IActionResult> GetCustomerOrders([FromQuery] int page = 1, [FromQuery] int pageSize = 10)
{
    var customerId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var orders = await _context.Orders
        .Where(o => o.CustomerId == customerId)
        .OrderByDescending(o => o.OrderDate)
        .Skip((page - 1) * pageSize)
        .Take(pageSize)
        .Include(o => o.OrderItems)
        .ThenInclude(oi => oi.Product)
        .ToListAsync();
    
    var orderDtos = orders.Select(o => new OrderDto
    {
        Id = o.Id,
        OrderDate = o.OrderDate,
        Status = o.Status,
        TotalAmount = o.TotalAmount,
        Items = o.OrderItems.Select(oi => new OrderItemDto
        {
            ProductName = oi.Product.Name,
            Quantity = oi.Quantity,
            Price = oi.Price
        }).ToList()
    });
    
    return Ok(orderDtos);
}

[HttpGet("order/{orderId}")]
[Authorize]
public async Task<IActionResult> GetOrderDetails(int orderId)
{
    var customerId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var order = await _context.Orders
        .Include(o => o.OrderItems)
        .ThenInclude(oi => oi.Product)
        .FirstOrDefaultAsync(o => o.Id == orderId && o.CustomerId == customerId);
    
    if (order == null) return NotFound();
    
    return Ok(order);
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 43
```python
from models import Order, OrderItem, Product

@app.route('/orders', methods=['GET'])
@jwt_required()
def get_customer_orders():
    customer_id = get_jwt_identity()
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    
    orders = Order.query.filter_by(customer_id=customer_id)\
                  .order_by(Order.order_date.desc())\
                  .paginate(page=page, per_page=per_page, error_out=False)
    
    return jsonify({
        'orders': [{
            'id': order.id,
            'order_date': order.order_date.isoformat(),
            'status': order.status,
            'total_amount': float(order.total_amount),
            'items_count': len(order.order_items)
        } for order in orders.items],
        'total': orders.total,
        'pages': orders.pages,
        'current_page': page
    })

@app.route('/order/<int:order_id>', methods=['GET'])
@jwt_required()
def get_order_details(order_id):
    customer_id = get_jwt_identity()
    
    order = Order.query.filter_by(
        id=order_id, 
        customer_id=customer_id
    ).first()
    
    if not order:
        return jsonify({'error': 'Order not found'}), 404
    
    return jsonify({
        'id': order.id,
        'order_date': order.order_date.isoformat(),
        'status': order.status,
        'total_amount': float(order.total_amount),
        'items': [{
            'product_name': item.product.name,
            'quantity': item.quantity,
            'price': float(item.price)
        } for item in order.order_items]
    })
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 56
```typescript
import { OrderService } from '../services/OrderService';

interface OrderListQuery {
    page?: number;
    limit?: number;
    status?: string;
}

export const getCustomerOrders = async (req: AuthRequest, res: Response) => {
    try {
        const customerId = req.userId!;
        const { page = 1, limit = 10, status } = req.query as OrderListQuery;
        
        const result = await OrderService.getCustomerOrders(customerId, {
            page: Number(page),
            limit: Number(limit),
            status
        });
        
        res.json({
            orders: result.orders.map(order => ({
                id: order.id,
                orderDate: order.orderDate,
                status: order.status,
                totalAmount: order.totalAmount,
                itemsCount: order.orderItems.length
            })),
            pagination: {
                page: result.page,
                totalPages: result.totalPages,
                totalOrders: result.total
            }
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const getOrderDetails = async (req: AuthRequest, res: Response) => {
    try {
        const customerId = req.userId!;
        const { orderId } = req.params;
        
        const order = await OrderService.getOrderByIdAndCustomer(orderId, customerId);
        
        if (!order) {
            return res.status(404).json({ error: 'Order not found' });
        }
        
        res.json({
            id: order.id,
            orderDate: order.orderDate,
            status: order.status,
            totalAmount: order.totalAmount,
            items: order.orderItems.map(item => ({
                productName: item.product.name,
                quantity: item.quantity,
                price: item.price
            }))
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};
```

### ğŸ§ª Senaryo 4: Bir belge yÃ¶netim sisteminde kullanÄ±cÄ±lar belgelerini kategorize eder. Sistem belge sahipliÄŸi ve eriÅŸim haklarÄ±nÄ± yÃ¶netir. Her kullanÄ±cÄ± kendi belge koleksiyonunu dÃ¼zenler. Belge paylaÅŸÄ±mÄ± kontrollÃ¼ ÅŸekilde yapÄ±lÄ±r.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 44
```csharp
[HttpGet("documents")]
[Authorize]
public async Task<IActionResult> GetUserDocuments([FromQuery] string category = null)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var query = _context.Documents.Where(d => d.OwnerId == userId);
    
    if (!string.IsNullOrEmpty(category))
    {
        query = query.Where(d => d.Category == category);
    }
    
    var documents = await query
        .Select(d => new DocumentListDto
        {
            Id = d.Id,
            Title = d.Title,
            Category = d.Category,
            CreatedAt = d.CreatedAt,
            IsShared = d.DocumentShares.Any()
        })
        .ToListAsync();
    
    return Ok(documents);
}

[HttpPost("document/{documentId}/share")]
[Authorize]
public async Task<IActionResult> ShareDocument(int documentId, ShareDocumentRequest request)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var document = await _context.Documents
        .FirstOrDefaultAsync(d => d.Id == documentId && d.OwnerId == userId);
    
    if (document == null) return NotFound();
    
    var existingShare = await _context.DocumentShares
        .FirstOrDefaultAsync(ds => ds.DocumentId == documentId && ds.SharedWithUserId == request.UserId);
    
    if (existingShare != null) return BadRequest("Document already shared with this user");
    
    var documentShare = new DocumentShare
    {
        DocumentId = documentId,
        SharedWithUserId = request.UserId,
        Permission = request.Permission,
        SharedAt = DateTime.UtcNow
    };
    
    _context.DocumentShares.Add(documentShare);
    await _context.SaveChangesAsync();
    
    return Ok();
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 56
```python
from models import Document, DocumentShare, Category

@app.route('/documents', methods=['GET'])
@jwt_required()
def get_user_documents():
    user_id = get_jwt_identity()
    category = request.args.get('category')
    
    query = Document.query.filter_by(owner_id=user_id)
    
    if category:
        query = query.filter_by(category=category)
    
    documents = query.all()
    
    return jsonify([{
        'id': doc.id,
        'title': doc.title,
        'category': doc.category,
        'created_at': doc.created_at.isoformat(),
        'is_shared': len(doc.document_shares) > 0
    } for doc in documents])

@app.route('/document/<int:document_id>/share', methods=['POST'])
@jwt_required()
def share_document(document_id):
    user_id = get_jwt_identity()
    data = request.get_json()
    
    document = Document.query.filter_by(
        id=document_id, 
        owner_id=user_id
    ).first()
    
    if not document:
        return jsonify({'error': 'Document not found'}), 404
    
    existing_share = DocumentShare.query.filter_by(
        document_id=document_id,
        shared_with_user_id=data['user_id']
    ).first()
    
    if existing_share:
        return jsonify({'error': 'Document already shared'}), 400
    
    document_share = DocumentShare(
        document_id=document_id,
        shared_with_user_id=data['user_id'],
        permission=data['permission']
    )
    
    db.session.add(document_share)
    db.session.commit()
    
    return jsonify({'message': 'Document shared successfully'}), 201

@app.route('/document/<int:document_id>/category', methods=['PUT'])
@jwt_required()
def update_document_category(document_id):
    user_id = get_jwt_identity()
    data = request.get_json()
    
    document = Document.query.filter_by(
        id=document_id, 
        owner_id=user_id
    ).first()
    
    if not document:
        return jsonify({'error': 'Document not found'}), 404
    
    document.category = data['category']
    db.session.commit()
    
    return jsonify({'message': 'Category updated'})
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 63
```typescript
import { DocumentService } from '../services/DocumentService';
import { DocumentShareService } from '../services/DocumentShareService';

interface DocumentQuery {
    category?: string;
    search?: string;
}

interface ShareDocumentRequest {
    userId: string;
    permission: 'read' | 'write' | 'admin';
}

export const getUserDocuments = async (req: AuthRequest, res: Response) => {
    try {
        const ownerId = req.userId!;
        const { category, search } = req.query as DocumentQuery;
        
        const documents = await DocumentService.getUserDocuments(ownerId, {
            category,
            search
        });
        
        res.json(documents.map(doc => ({
            id: doc.id,
            title: doc.title,
            category: doc.category,
            createdAt: doc.createdAt,
            isShared: doc.documentShares.length > 0,
            sharedCount: doc.documentShares.length
        })));
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const shareDocument = async (req: AuthRequest, res: Response) => {
    try {
        const ownerId = req.userId!;
        const { documentId } = req.params;
        const { userId, permission } = req.body as ShareDocumentRequest;
        
        const document = await DocumentService.getDocumentByOwner(documentId, ownerId);
        if (!document) {
            return res.status(404).json({ error: 'Document not found' });
        }
        
        const existingShare = await DocumentShareService.findShare(documentId, userId);
        if (existingShare) {
            return res.status(400).json({ error: 'Document already shared with this user' });
        }
        
        await DocumentShareService.shareDocument(documentId, userId, permission);
        
        res.status(201).json({ message: 'Document shared successfully' });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const updateDocumentCategory = async (req: AuthRequest, res: Response) => {
    try {
        const ownerId = req.userId!;
        const { documentId } = req.params;
        const { category } = req.body;
        
        const updated = await DocumentService.updateDocumentCategory(documentId, ownerId, category);
        
        if (!updated) {
            return res.status(404).json({ error: 'Document not found' });
        }
        
        res.json({ message: 'Category updated successfully' });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};
```

### ğŸ§ª Senaryo 5: Bir forum uygulamasÄ±nda kullanÄ±cÄ±lar kendi konularÄ±nÄ± yÃ¶netir. Sistem konu sahipliÄŸi ve moderasyon yetkilerini takip eder. Her kullanÄ±cÄ± kendi oluÅŸturduÄŸu iÃ§erikleri dÃ¼zenleyebilir. Forum yÃ¶netimi kullanÄ±cÄ± rolleri ile yapÄ±lÄ±r.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 60
```csharp
[HttpGet("my-topics")]
[Authorize]
public async Task<IActionResult> GetUserTopics()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var topics = await _context.Topics
        .Where(t => t.AuthorId == userId)
        .Include(t => t.Posts)
        .OrderByDescending(t => t.CreatedAt)
        .Select(t => new TopicDto
        {
            Id = t.Id,
            Title = t.Title,
            CreatedAt = t.CreatedAt,
            PostCount = t.Posts.Count,
            IsLocked = t.IsLocked,
            IsPinned = t.IsPinned
        })
        .ToListAsync();
    
    return Ok(topics);
}

[HttpPut("topic/{topicId}")]
[Authorize]
public async Task<IActionResult> UpdateTopic(int topicId, UpdateTopicRequest request)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var isModerator = User.IsInRole("Moderator") || User.IsInRole("Admin");
    
    var topic = await _context.Topics.FirstOrDefaultAsync(t => t.Id == topicId);
    
    if (topic == null) return NotFound();
    
    // User can edit own topics or moderators can edit any topic
    if (topic.AuthorId != userId && !isModerator)
        return Forbid();
    
    topic.Title = request.Title;
    topic.Content = request.Content;
    topic.UpdatedAt = DateTime.UtcNow;
    
    // Only moderators can change lock/pin status
    if (isModerator)
    {
        topic.IsLocked = request.IsLocked ?? topic.IsLocked;
        topic.IsPinned = request.IsPinned ?? topic.IsPinned;
    }
    
    await _context.SaveChangesAsync();
    return Ok(topic);
}

[HttpDelete("topic/{topicId}")]
[Authorize]
public async Task<IActionResult> DeleteTopic(int topicId)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var isModerator = User.IsInRole("Moderator") || User.IsInRole("Admin");
    
    var topic = await _context.Topics
        .Include(t => t.Posts)
        .FirstOrDefaultAsync(t => t.Id == topicId);
    
    if (topic == null) return NotFound();
    
    if (topic.AuthorId != userId && !isModerator)
        return Forbid();
    
    _context.Topics.Remove(topic);
    await _context.SaveChangesAsync();
    
    return NoContent();
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 54
```python
from models import Topic, Post, User
from functools import wraps

def check_topic_permission(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user_id = get_jwt_identity()
        topic_id = kwargs.get('topic_id') or request.view_args.get('topic_id')
        
        user = User.query.get(user_id)
        topic = Topic.query.get(topic_id)
        
        if not topic:
            return jsonify({'error': 'Topic not found'}), 404
        
        # User can edit own topics or if they are moderator/admin
        if topic.author_id != user_id and user.role not in ['moderator', 'admin']:
            return jsonify({'error': 'Permission denied'}), 403
        
        kwargs['topic'] = topic
        kwargs['user'] = user
        return f(*args, **kwargs)
    return decorated_function

@app.route('/my-topics', methods=['GET'])
@jwt_required()
def get_user_topics():
    user_id = get_jwt_identity()
    
    topics = Topic.query.filter_by(author_id=user_id)\
                  .order_by(Topic.created_at.desc())\
                  .all()
    
    return jsonify([{
        'id': topic.id,
        'title': topic.title,
        'created_at': topic.created_at.isoformat(),
        'post_count': len(topic.posts),
        'is_locked': topic.is_locked,
        'is_pinned': topic.is_pinned
    } for topic in topics])

@app.route('/topic/<int:topic_id>', methods=['PUT'])
@jwt_required()
@check_topic_permission
def update_topic(topic_id, topic, user):
    data = request.get_json()
    
    topic.title = data.get('title', topic.title)
    topic.content = data.get('content', topic.content)
    topic.updated_at = datetime.utcnow()
    
    # Only moderators/admins can change lock/pin status
    if user.role in ['moderator', 'admin']:
        topic.is_locked = data.get('is_locked', topic.is_locked)
        topic.is_pinned = data.get('is_pinned', topic.is_pinned)
    
    db.session.commit()
    
    return jsonify({'message': 'Topic updated successfully'})

@app.route('/topic/<int:topic_id>', methods=['DELETE'])
@jwt_required()
@check_topic_permission
def delete_topic(topic_id, topic, user):
    db.session.delete(topic)
    db.session.commit()
    
    return '', 204
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 77
```typescript
import { TopicService } from '../services/TopicService';
import { UserService } from '../services/UserService';

type UserRole = 'user' | 'moderator' | 'admin';

interface UpdateTopicRequest {
    title?: string;
    content?: string;
    isLocked?: boolean;
    isPinned?: boolean;
}

const checkTopicPermission = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const userId = req.userId!;
        const topicId = req.params.topicId;
        
        const [topic, user] = await Promise.all([
            TopicService.getTopicById(topicId),
            UserService.getUserById(userId)
        ]);
        
        if (!topic) {
            return res.status(404).json({ error: 'Topic not found' });
        }
        
        if (topic.authorId !== userId && !['moderator', 'admin'].includes(user.role)) {
            return res.status(403).json({ error: 'Permission denied' });
        }
        
        req.topic = topic;
        req.userRole = user.role as UserRole;
        next();
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const getUserTopics = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const topics = await TopicService.getTopicsByAuthor(userId);
        
        res.json(topics.map(topic => ({
            id: topic.id,
            title: topic.title,
            createdAt: topic.createdAt,
            postCount: topic.posts.length,
            isLocked: topic.isLocked,
            isPinned: topic.isPinned
        })));
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const updateTopic = [
    checkTopicPermission,
    async (req: AuthRequest, res: Response) => {
        try {
            const { topicId } = req.params;
            const updateData = req.body as UpdateTopicRequest;
            const userRole = req.userRole!;
            
            // Filter out moderator-only fields for regular users
            if (!['moderator', 'admin'].includes(userRole)) {
                delete updateData.isLocked;
                delete updateData.isPinned;
            }
            
            const updatedTopic = await TopicService.updateTopic(topicId, updateData);
            
            res.json(updatedTopic);
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];

export const deleteTopic = [
    checkTopicPermission,
    async (req: AuthRequest, res: Response) => {
        try {
            const { topicId } = req.params;
            await TopicService.deleteTopic(topicId);
            
            res.status(204).send();
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];
```

### ğŸ§ª Senaryo 6: Bir sosyal medya platformunda kullanÄ±cÄ±lar profil bilgilerini gÃ¼nceller. Sistem kullanÄ±cÄ± hesaplarÄ± ve profil verilerini yÃ¶netir. Her kullanÄ±cÄ± kendi profil ayarlarÄ±nÄ± deÄŸiÅŸtirebilir. Profil bilgileri kiÅŸisel veri korunmasÄ± ile saklanÄ±r.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 61
```csharp
[HttpGet("profile")]
[Authorize]
public async Task<IActionResult> GetProfile()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var profile = await _context.UserProfiles
        .Include(p => p.User)
        .FirstOrDefaultAsync(p => p.UserId == userId);
    
    if (profile == null) return NotFound();
    
    var profileDto = new ProfileDto
    {
        Id = profile.Id,
        DisplayName = profile.DisplayName,
        Bio = profile.Bio,
        ProfilePictureUrl = profile.ProfilePictureUrl,
        IsPrivate = profile.IsPrivate,
        Email = profile.User.Email // Only show to profile owner
    };
    
    return Ok(profileDto);
}

[HttpPut("profile")]
[Authorize]
public async Task<IActionResult> UpdateProfile(UpdateProfileRequest request)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var profile = await _context.UserProfiles.FirstOrDefaultAsync(p => p.UserId == userId);
    
    if (profile == null) return NotFound();
    
    // Validate and sanitize input
    if (!string.IsNullOrWhiteSpace(request.DisplayName) && request.DisplayName.Length <= 50)
    {
        profile.DisplayName = request.DisplayName.Trim();
    }
    
    if (request.Bio?.Length <= 500)
    {
        profile.Bio = request.Bio?.Trim();
    }
    
    profile.IsPrivate = request.IsPrivate;
    profile.UpdatedAt = DateTime.UtcNow;
    
    // Log profile update for audit
    _logger.LogInformation("User {UserId} updated profile", userId);
    
    await _context.SaveChangesAsync();
    return Ok(profile);
}

[HttpPost("profile/avatar")]
[Authorize]
public async Task<IActionResult> UpdateAvatar(IFormFile avatar)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    if (avatar == null || avatar.Length == 0)
        return BadRequest("No file uploaded");
    
    if (avatar.Length > 5 * 1024 * 1024) // 5MB limit
        return BadRequest("File too large");
    
    var allowedTypes = new[] { "image/jpeg", "image/png", "image/webp" };
    if (!allowedTypes.Contains(avatar.ContentType))
        return BadRequest("Invalid file type");
    
    var avatarUrl = await _fileService.UploadAvatarAsync(userId, avatar);
    
    var profile = await _context.UserProfiles.FirstOrDefaultAsync(p => p.UserId == userId);
    profile.ProfilePictureUrl = avatarUrl;
    
    await _context.SaveChangesAsync();
    return Ok(new { avatarUrl });
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 70
```python
import hashlib
from werkzeug.utils import secure_filename
from models import UserProfile, User

@app.route('/profile', methods=['GET'])
@jwt_required()
def get_profile():
    user_id = get_jwt_identity()
    
    profile = UserProfile.query.filter_by(user_id=user_id).first()
    if not profile:
        return jsonify({'error': 'Profile not found'}), 404
    
    # Return sanitized profile data
    return jsonify({
        'id': profile.id,
        'display_name': profile.display_name,
        'bio': profile.bio,
        'profile_picture_url': profile.profile_picture_url,
        'is_private': profile.is_private,
        'email': profile.user.email,  # Only show to profile owner
        'created_at': profile.created_at.isoformat(),
        'updated_at': profile.updated_at.isoformat()
    })

@app.route('/profile', methods=['PUT'])
@jwt_required()
def update_profile():
    user_id = get_jwt_identity()
    data = request.get_json()
    
    profile = UserProfile.query.filter_by(user_id=user_id).first()
    if not profile:
        return jsonify({'error': 'Profile not found'}), 404
    
    # Validate and sanitize input
    if 'display_name' in data:
        display_name = data['display_name'].strip()
        if len(display_name) <= 50:
            profile.display_name = display_name
    
    if 'bio' in data:
        bio = data['bio'].strip() if data['bio'] else None
        if not bio or len(bio) <= 500:
            profile.bio = bio
    
    if 'is_private' in data:
        profile.is_private = bool(data['is_private'])
    
    profile.updated_at = datetime.utcnow()
    
    # Log profile update for audit trail
    app.logger.info(f'User {user_id} updated profile')
    
    db.session.commit()
    
    return jsonify({'message': 'Profile updated successfully'})

@app.route('/profile/avatar', methods=['POST'])
@jwt_required()
def update_avatar():
    user_id = get_jwt_identity()
    
    if 'avatar' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['avatar']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    # Validate file
    if file.content_length > 5 * 1024 * 1024:  # 5MB limit
        return jsonify({'error': 'File too large'}), 400
    
    allowed_types = ['image/jpeg', 'image/png', 'image/webp']
    if file.mimetype not in allowed_types:
        return jsonify({'error': 'Invalid file type'}), 400
    
    # Generate secure filename
    filename = secure_filename(f"{user_id}_{hashlib.md5(file.read()).hexdigest()}.jpg")
    file.seek(0)  # Reset file pointer
    
    # Save file and get URL
    avatar_url = file_service.upload_avatar(file, filename)
    
    # Update profile
    profile = UserProfile.query.filter_by(user_id=user_id).first()
    profile.profile_picture_url = avatar_url
    db.session.commit()
    
    return jsonify({'avatar_url': avatar_url})
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 90
```typescript
import multer from 'multer';
import { ProfileService } from '../services/ProfileService';
import { FileUploadService } from '../services/FileUploadService';

interface UpdateProfileRequest {
    displayName?: string;
    bio?: string;
    isPrivate?: boolean;
}

const avatarUpload = multer({
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
    fileFilter: (req, file, cb) => {
        const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
        if (allowedTypes.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error('Invalid file type'));
        }
    }
});

export const getProfile = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const profile = await ProfileService.getProfileByUserId(userId);
        
        if (!profile) {
            return res.status(404).json({ error: 'Profile not found' });
        }
        
        // Return sanitized profile data
        res.json({
            id: profile.id,
            displayName: profile.displayName,
            bio: profile.bio,
            profilePictureUrl: profile.profilePictureUrl,
            isPrivate: profile.isPrivate,
            email: profile.user.email, // Only visible to profile owner
            createdAt: profile.createdAt,
            updatedAt: profile.updatedAt
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const updateProfile = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const updateData = req.body as UpdateProfileRequest;
        
        // Validate input
        const validatedData: Partial<UpdateProfileRequest> = {};
        
        if (updateData.displayName !== undefined) {
            const displayName = updateData.displayName.trim();
            if (displayName.length <= 50) {
                validatedData.displayName = displayName;
            }
        }
        
        if (updateData.bio !== undefined) {
            const bio = updateData.bio?.trim() || null;
            if (!bio || bio.length <= 500) {
                validatedData.bio = bio;
            }
        }
        
        if (updateData.isPrivate !== undefined) {
            validatedData.isPrivate = Boolean(updateData.isPrivate);
        }
        
        const updatedProfile = await ProfileService.updateProfile(userId, validatedData);
        
        // Log for audit trail
        console.log(`User ${userId} updated profile`);
        
        res.json(updatedProfile);
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const updateAvatar = [
    avatarUpload.single('avatar'),
    async (req: AuthRequest, res: Response) => {
        try {
            const userId = req.userId!;
            const file = req.file;
            
            if (!file) {
                return res.status(400).json({ error: 'No file uploaded' });
            }
            
            const avatarUrl = await FileUploadService.uploadAvatar(userId, file);
            
            await ProfileService.updateProfilePicture(userId, avatarUrl);
            
            res.json({ avatarUrl });
        } catch (error) {
            if (error.message === 'Invalid file type') {
                return res.status(400).json({ error: 'Invalid file type' });
            }
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];
```

### ğŸ§ª Senaryo 7: Bir Ã¶ÄŸrenme yÃ¶netim sisteminde eÄŸitmenler kurs iÃ§eriklerini dÃ¼zenler. Sistem eÄŸitmen rolleri ve kurs sahipliÄŸini yÃ¶netir. Her eÄŸitmen kendi kurslarÄ±nÄ± geliÅŸtirebilir. Kurs yÃ¶netimi rol tabanlÄ± yetkilendirme ile yapÄ±lÄ±r.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 76
```csharp
[HttpGet("instructor/courses")]
[Authorize(Roles = "Instructor,Admin")]
public async Task<IActionResult> GetInstructorCourses()
{
    var instructorId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var courses = await _context.Courses
        .Where(c => c.InstructorId == instructorId)
        .Include(c => c.Modules)
        .OrderByDescending(c => c.CreatedAt)
        .Select(c => new CourseListDto
        {
            Id = c.Id,
            Title = c.Title,
            Description = c.Description,
            IsPublished = c.IsPublished,
            StudentCount = c.Enrollments.Count,
            ModuleCount = c.Modules.Count,
            CreatedAt = c.CreatedAt
        })
        .ToListAsync();
    
    return Ok(courses);
}

[HttpPost("course")]
[Authorize(Roles = "Instructor,Admin")]
public async Task<IActionResult> CreateCourse(CreateCourseRequest request)
{
    var instructorId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var course = new Course
    {
        Title = request.Title,
        Description = request.Description,
        InstructorId = instructorId,
        IsPublished = false,
        CreatedAt = DateTime.UtcNow
    };
    
    _context.Courses.Add(course);
    await _context.SaveChangesAsync();
    
    return CreatedAtAction(nameof(GetCourse), new { id = course.Id }, course);
}

[HttpPut("course/{courseId}/content")]
[Authorize(Roles = "Instructor,Admin")]
public async Task<IActionResult> UpdateCourseContent(int courseId, UpdateCourseContentRequest request)
{
    var instructorId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var isAdmin = User.IsInRole("Admin");
    
    var course = await _context.Courses
        .Include(c => c.Modules)
        .ThenInclude(m => m.Lessons)
        .FirstOrDefaultAsync(c => c.Id == courseId);
    
    if (course == null) return NotFound();
    
    // Check ownership or admin privileges
    if (course.InstructorId != instructorId && !isAdmin)
        return Forbid();
    
    course.Title = request.Title;
    course.Description = request.Description;
    course.UpdatedAt = DateTime.UtcNow;
    
    await _context.SaveChangesAsync();
    
    return Ok(course);
}

[HttpPost("course/{courseId}/publish")]
[Authorize(Roles = "Instructor,Admin")]
public async Task<IActionResult> PublishCourse(int courseId)
{
    var instructorId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var course = await _context.Courses.FirstOrDefaultAsync(c => c.Id == courseId && c.InstructorId == instructorId);
    
    if (course == null) return NotFound();
    
    // Validate course has required content before publishing
    var hasContent = await _context.Modules
        .AnyAsync(m => m.CourseId == courseId && m.Lessons.Any());
    
    if (!hasContent)
        return BadRequest("Course must have at least one module with lessons before publishing");
    
    course.IsPublished = true;
    course.PublishedAt = DateTime.UtcNow;
    
    await _context.SaveChangesAsync();
    
    return Ok(new { message = "Course published successfully" });
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 89
```python
from functools import wraps
from models import Course, Module, Lesson, User, Enrollment

def require_instructor_role(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user_id = get_jwt_identity()
        user = User.query.get(user_id)
        
        if user.role not in ['instructor', 'admin']:
            return jsonify({'error': 'Instructor role required'}), 403
        
        return f(*args, **kwargs)
    return decorated_function

def check_course_ownership(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user_id = get_jwt_identity()
        course_id = kwargs.get('course_id') or request.view_args.get('course_id')
        
        user = User.query.get(user_id)
        course = Course.query.get(course_id)
        
        if not course:
            return jsonify({'error': 'Course not found'}), 404
        
        # Check ownership or admin privileges
        if course.instructor_id != user_id and user.role != 'admin':
            return jsonify({'error': 'Access denied'}), 403
        
        kwargs['course'] = course
        return f(*args, **kwargs)
    return decorated_function

@app.route('/instructor/courses', methods=['GET'])
@jwt_required()
@require_instructor_role
def get_instructor_courses():
    instructor_id = get_jwt_identity()
    
    courses = Course.query.filter_by(instructor_id=instructor_id)\
                    .order_by(Course.created_at.desc())\
                    .all()
    
    return jsonify([{
        'id': course.id,
        'title': course.title,
        'description': course.description,
        'is_published': course.is_published,
        'student_count': len(course.enrollments),
        'module_count': len(course.modules),
        'created_at': course.created_at.isoformat()
    } for course in courses])

@app.route('/course', methods=['POST'])
@jwt_required()
@require_instructor_role
def create_course():
    instructor_id = get_jwt_identity()
    data = request.get_json()
    
    course = Course(
        title=data['title'],
        description=data['description'],
        instructor_id=instructor_id,
        is_published=False
    )
    
    db.session.add(course)
    db.session.commit()
    
    return jsonify({
        'id': course.id,
        'message': 'Course created successfully'
    }), 201

@app.route('/course/<int:course_id>/content', methods=['PUT'])
@jwt_required()
@require_instructor_role
@check_course_ownership
def update_course_content(course_id, course):
    data = request.get_json()
    
    course.title = data.get('title', course.title)
    course.description = data.get('description', course.description)
    course.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    return jsonify({'message': 'Course content updated successfully'})

@app.route('/course/<int:course_id>/publish', methods=['POST'])
@jwt_required()
@require_instructor_role
@check_course_ownership
def publish_course(course_id, course):
    # Validate course has required content
    has_content = Module.query.filter_by(course_id=course_id)\
                        .join(Lesson)\
                        .first() is not None
    
    if not has_content:
        return jsonify({
            'error': 'Course must have at least one module with lessons'
        }), 400
    
    course.is_published = True
    course.published_at = datetime.utcnow()
    db.session.commit()
    
    return jsonify({'message': 'Course published successfully'})
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 111
```typescript
import { CourseService } from '../services/CourseService';
import { ModuleService } from '../services/ModuleService';

type UserRole = 'student' | 'instructor' | 'admin';

interface CreateCourseRequest {
    title: string;
    description: string;
}

interface UpdateCourseContentRequest {
    title?: string;
    description?: string;
}

const requireInstructorRole = (req: AuthRequest, res: Response, next: NextFunction) => {
    const userRole = req.userRole as UserRole;
    
    if (!['instructor', 'admin'].includes(userRole)) {
        return res.status(403).json({ error: 'Instructor role required' });
    }
    
    next();
};

const checkCourseOwnership = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const userId = req.userId!;
        const userRole = req.userRole as UserRole;
        const courseId = req.params.courseId;
        
        const course = await CourseService.getCourseById(courseId);
        
        if (!course) {
            return res.status(404).json({ error: 'Course not found' });
        }
        
        // Check ownership or admin privileges
        if (course.instructorId !== userId && userRole !== 'admin') {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        req.course = course;
        next();
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const getInstructorCourses = [
    requireInstructorRole,
    async (req: AuthRequest, res: Response) => {
        try {
            const instructorId = req.userId!;
            const courses = await CourseService.getCoursesByInstructor(instructorId);
            
            res.json(courses.map(course => ({
                id: course.id,
                title: course.title,
                description: course.description,
                isPublished: course.isPublished,
                studentCount: course.enrollments.length,
                moduleCount: course.modules.length,
                createdAt: course.createdAt
            })));
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];

export const createCourse = [
    requireInstructorRole,
    async (req: AuthRequest, res: Response) => {
        try {
            const instructorId = req.userId!;
            const courseData = req.body as CreateCourseRequest;
            
            const course = await CourseService.createCourse({
                ...courseData,
                instructorId,
                isPublished: false
            });
            
            res.status(201).json({
                id: course.id,
                message: 'Course created successfully'
            });
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];

export const updateCourseContent = [
    requireInstructorRole,
    checkCourseOwnership,
    async (req: AuthRequest, res: Response) => {
        try {
            const courseId = req.params.courseId;
            const updateData = req.body as UpdateCourseContentRequest;
            
            const updatedCourse = await CourseService.updateCourse(courseId, updateData);
            
            res.json(updatedCourse);
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];

export const publishCourse = [
    requireInstructorRole,
    checkCourseOwnership,
    async (req: AuthRequest, res: Response) => {
        try {
            const courseId = req.params.courseId;
            
            // Validate course has required content
            const hasContent = await ModuleService.courseHasContent(courseId);
            
            if (!hasContent) {
                return res.status(400).json({
                    error: 'Course must have at least one module with lessons'
                });
            }
            
            await CourseService.publishCourse(courseId);
            
            res.json({ message: 'Course published successfully' });
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];
```

### ğŸ§ª Senaryo 8: Bir muhasebe uygulamasÄ±nda kullanÄ±cÄ±lar finansal kayÄ±tlarÄ±nÄ± gÃ¶rÃ¼ntÃ¼ler. Sistem kullanÄ±cÄ± hesaplarÄ± ile finansal verileri iliÅŸkilendirir. Her kullanÄ±cÄ± kendi mali bilgilerine eriÅŸim saÄŸlar. Finansal raporlar kullanÄ±cÄ± bazÄ±nda oluÅŸturulur.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 70
```csharp
[HttpGet("financial-records")]
[Authorize]
public async Task<IActionResult> GetFinancialRecords([FromQuery] DateTime? startDate, [FromQuery] DateTime? endDate)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var query = _context.FinancialRecords.Where(fr => fr.UserId == userId);
    
    if (startDate.HasValue)
        query = query.Where(fr => fr.Date >= startDate.Value);
    
    if (endDate.HasValue)
        query = query.Where(fr => fr.Date <= endDate.Value);
    
    var records = await query
        .OrderByDescending(fr => fr.Date)
        .Select(fr => new FinancialRecordDto
        {
            Id = fr.Id,
            Date = fr.Date,
            Description = fr.Description,
            Amount = fr.Amount,
            Type = fr.Type, // Income, Expense, Transfer
            Category = fr.Category
        })
        .ToListAsync();
    
    return Ok(records);
}

[HttpGet("financial-summary")]
[Authorize]
public async Task<IActionResult> GetFinancialSummary([FromQuery] int year = 0, [FromQuery] int month = 0)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var currentYear = year == 0 ? DateTime.Now.Year : year;
    
    var query = _context.FinancialRecords
        .Where(fr => fr.UserId == userId && fr.Date.Year == currentYear);
    
    if (month > 0)
        query = query.Where(fr => fr.Date.Month == month);
    
    var records = await query.ToListAsync();
    
    var summary = new FinancialSummaryDto
    {
        TotalIncome = records.Where(r => r.Type == "Income").Sum(r => r.Amount),
        TotalExpense = records.Where(r => r.Type == "Expense").Sum(r => r.Amount),
        NetAmount = records.Where(r => r.Type == "Income").Sum(r => r.Amount) - 
                   records.Where(r => r.Type == "Expense").Sum(r => r.Amount),
        ExpensesByCategory = records
            .Where(r => r.Type == "Expense")
            .GroupBy(r => r.Category)
            .ToDictionary(g => g.Key, g => g.Sum(r => r.Amount))
    };
    
    return Ok(summary);
}

[HttpPost("financial-record")]
[Authorize]
public async Task<IActionResult> CreateFinancialRecord(CreateFinancialRecordRequest request)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var record = new FinancialRecord
    {
        UserId = userId,
        Date = request.Date,
        Description = request.Description,
        Amount = request.Amount,
        Type = request.Type,
        Category = request.Category,
        CreatedAt = DateTime.UtcNow
    };
    
    _context.FinancialRecords.Add(record);
    await _context.SaveChangesAsync();
    
    // Log financial transaction for audit
    _logger.LogInformation("User {UserId} created financial record: {Type} {Amount}", 
        userId, record.Type, record.Amount);
    
    return CreatedAtAction(nameof(GetFinancialRecord), new { id = record.Id }, record);
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 96
```python
from datetime import datetime, timedelta
from sqlalchemy import extract, func
from models import FinancialRecord

@app.route('/financial-records', methods=['GET'])
@jwt_required()
def get_financial_records():
    user_id = get_jwt_identity()
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    
    query = FinancialRecord.query.filter_by(user_id=user_id)
    
    if start_date:
        start_date = datetime.fromisoformat(start_date)
        query = query.filter(FinancialRecord.date >= start_date)
    
    if end_date:
        end_date = datetime.fromisoformat(end_date)
        query = query.filter(FinancialRecord.date <= end_date)
    
    records = query.order_by(FinancialRecord.date.desc()).all()
    
    return jsonify([{
        'id': record.id,
        'date': record.date.isoformat(),
        'description': record.description,
        'amount': float(record.amount),
        'type': record.type,  # income, expense, transfer
        'category': record.category
    } for record in records])

@app.route('/financial-summary', methods=['GET'])
@jwt_required()
def get_financial_summary():
    user_id = get_jwt_identity()
    year = request.args.get('year', datetime.now().year, type=int)
    month = request.args.get('month', type=int)
    
    query = FinancialRecord.query.filter_by(user_id=user_id)\
                                 .filter(extract('year', FinancialRecord.date) == year)
    
    if month:
        query = query.filter(extract('month', FinancialRecord.date) == month)
    
    records = query.all()
    
    # Calculate summary
    total_income = sum(r.amount for r in records if r.type == 'income')
    total_expense = sum(r.amount for r in records if r.type == 'expense')
    
    # Group expenses by category
    expenses_by_category = {}
    for record in records:
        if record.type == 'expense':
            category = record.category or 'Uncategorized'
            expenses_by_category[category] = expenses_by_category.get(category, 0) + float(record.amount)
    
    return jsonify({
        'total_income': float(total_income),
        'total_expense': float(total_expense),
        'net_amount': float(total_income - total_expense),
        'expenses_by_category': expenses_by_category,
        'period': f"{year}-{month:02d}" if month else str(year)
    })

@app.route('/financial-record', methods=['POST'])
@jwt_required()
def create_financial_record():
    user_id = get_jwt_identity()
    data = request.get_json()
    
    # Validate amount is positive
    if data['amount'] <= 0:
        return jsonify({'error': 'Amount must be positive'}), 400
    
    record = FinancialRecord(
        user_id=user_id,
        date=datetime.fromisoformat(data['date']),
        description=data['description'],
        amount=data['amount'],
        type=data['type'],
        category=data.get('category')
    )
    
    db.session.add(record)
    db.session.commit()
    
    # Log for audit trail
    app.logger.info(f'User {user_id} created financial record: {record.type} {record.amount}')
    
    return jsonify({
        'id': record.id,
        'message': 'Financial record created successfully'
    }), 201

@app.route('/financial-report', methods=['GET'])
@jwt_required()
def generate_financial_report():
    user_id = get_jwt_identity()
    report_type = request.args.get('type', 'monthly')  # monthly, yearly
    
    if report_type == 'monthly':
        # Generate monthly report for last 12 months
        monthly_data = db.session.query(
            extract('year', FinancialRecord.date).label('year'),
            extract('month', FinancialRecord.date).label('month'),
            func.sum(FinancialRecord.amount).label('total')
        ).filter_by(user_id=user_id)\
         .filter(FinancialRecord.date >= datetime.now() - timedelta(days=365))\
         .group_by('year', 'month')\
         .all()
        
        return jsonify([{
            'period': f"{int(data.year)}-{int(data.month):02d}",
            'total': float(data.total)
        } for data in monthly_data])
    
    return jsonify({'error': 'Invalid report type'}), 400
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 110
```typescript
import { FinancialRecordService } from '../services/FinancialRecordService';
import { ReportService } from '../services/ReportService';

interface FinancialRecordQuery {
    startDate?: string;
    endDate?: string;
    category?: string;
    type?: 'income' | 'expense' | 'transfer';
}

interface CreateFinancialRecordRequest {
    date: string;
    description: string;
    amount: number;
    type: 'income' | 'expense' | 'transfer';
    category?: string;
}

interface FinancialSummaryQuery {
    year?: number;
    month?: number;
}

export const getFinancialRecords = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const { startDate, endDate, category, type } = req.query as FinancialRecordQuery;
        
        const records = await FinancialRecordService.getUserRecords(userId, {
            startDate: startDate ? new Date(startDate) : undefined,
            endDate: endDate ? new Date(endDate) : undefined,
            category,
            type
        });
        
        res.json(records.map(record => ({
            id: record.id,
            date: record.date.toISOString(),
            description: record.description,
            amount: record.amount,
            type: record.type,
            category: record.category
        })));
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const getFinancialSummary = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const { year = new Date().getFullYear(), month } = req.query as FinancialSummaryQuery;
        
        const summary = await FinancialRecordService.generateSummary(userId, {
            year: Number(year),
            month: month ? Number(month) : undefined
        });
        
        res.json({
            totalIncome: summary.totalIncome,
            totalExpense: summary.totalExpense,
            netAmount: summary.netAmount,
            expensesByCategory: summary.expensesByCategory,
            period: month ? `${year}-${month.toString().padStart(2, '0')}` : year.toString()
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const createFinancialRecord = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const recordData = req.body as CreateFinancialRecordRequest;
        
        // Validate amount is positive
        if (recordData.amount <= 0) {
            return res.status(400).json({ error: 'Amount must be positive' });
        }
        
        const record = await FinancialRecordService.createRecord({
            ...recordData,
            userId,
            date: new Date(recordData.date)
        });
        
        // Log for audit trail
        console.log(`User ${userId} created financial record: ${record.type} ${record.amount}`);
        
        res.status(201).json({
            id: record.id,
            message: 'Financial record created successfully'
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const generateFinancialReport = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const { reportType = 'monthly' } = req.query as { reportType?: string };
        
        let reportData;
        
        switch (reportType) {
            case 'monthly':
                reportData = await ReportService.generateMonthlyReport(userId);
                break;
            case 'yearly':
                reportData = await ReportService.generateYearlyReport(userId);
                break;
            case 'category':
                reportData = await ReportService.generateCategoryReport(userId);
                break;
            default:
                return res.status(400).json({ error: 'Invalid report type' });
        }
        
        res.json({
            reportType,
            data: reportData,
            generatedAt: new Date().toISOString()
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};
```

### ğŸ§ª Senaryo 9: Bir takÄ±m Ã§alÄ±ÅŸmasÄ± uygulamasÄ±nda Ã¼yeler proje dosyalarÄ±nÄ± paylaÅŸÄ±r. Sistem proje Ã¼yeliÄŸi ve dosya eriÅŸim haklarÄ±nÄ± yÃ¶netir. Her Ã¼ye projeye katkÄ± saÄŸlayabilir. Dosya paylaÅŸÄ±mÄ± proje kapsamÄ±nda kontrol edilir.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 76
```csharp
[HttpGet("project/{projectId}/files")]
[Authorize]
public async Task<IActionResult> GetProjectFiles(int projectId)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    // Check if user is a member of the project
    var membership = await _context.ProjectMembers
        .FirstOrDefaultAsync(pm => pm.ProjectId == projectId && pm.UserId == userId);
    
    if (membership == null) return Forbid();
    
    var files = await _context.ProjectFiles
        .Where(pf => pf.ProjectId == projectId)
        .Include(pf => pf.UploadedByUser)
        .OrderByDescending(pf => pf.UploadedAt)
        .Select(pf => new ProjectFileDto
        {
            Id = pf.Id,
            FileName = pf.FileName,
            FileSize = pf.FileSize,
            UploadedBy = pf.UploadedByUser.Name,
            UploadedAt = pf.UploadedAt,
            CanDelete = pf.UploadedById == userId || membership.Role == "Admin"
        })
        .ToListAsync();
    
    return Ok(files);
}

[HttpPost("project/{projectId}/upload")]
[Authorize]
public async Task<IActionResult> UploadProjectFile(int projectId, IFormFile file)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var membership = await _context.ProjectMembers
        .FirstOrDefaultAsync(pm => pm.ProjectId == projectId && pm.UserId == userId);
    
    if (membership == null) return Forbid();
    
    if (file == null || file.Length == 0)
        return BadRequest("No file uploaded");
    
    if (file.Length > 100 * 1024 * 1024) // 100MB limit
        return BadRequest("File too large");
    
    var fileExtension = Path.GetExtension(file.FileName);
    var allowedExtensions = new[] { ".pdf", ".docx", ".xlsx", ".pptx", ".txt", ".jpg", ".png" };
    
    if (!allowedExtensions.Contains(fileExtension.ToLower()))
        return BadRequest("File type not allowed");
    
    var fileUrl = await _fileService.UploadProjectFileAsync(projectId, file);
    
    var projectFile = new ProjectFile
    {
        ProjectId = projectId,
        FileName = file.FileName,
        FileSize = file.Length,
        FileUrl = fileUrl,
        UploadedById = userId,
        UploadedAt = DateTime.UtcNow
    };
    
    _context.ProjectFiles.Add(projectFile);
    await _context.SaveChangesAsync();
    
    return CreatedAtAction(nameof(GetProjectFile), new { id = projectFile.Id }, projectFile);
}

[HttpDelete("project/file/{fileId}")]
[Authorize]
public async Task<IActionResult> DeleteProjectFile(int fileId)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var file = await _context.ProjectFiles
        .Include(pf => pf.Project)
        .ThenInclude(p => p.ProjectMembers)
        .FirstOrDefaultAsync(pf => pf.Id == fileId);
    
    if (file == null) return NotFound();
    
    var userMembership = file.Project.ProjectMembers
        .FirstOrDefault(pm => pm.UserId == userId);
    
    if (userMembership == null) return Forbid();
    
    // Users can delete their own files or admins can delete any file
    if (file.UploadedById != userId && userMembership.Role != "Admin")
        return Forbid();
    
    await _fileService.DeleteFileAsync(file.FileUrl);
    _context.ProjectFiles.Remove(file);
    await _context.SaveChangesAsync();
    
    return NoContent();
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 101
```python
import os
from werkzeug.utils import secure_filename
from models import ProjectFile, ProjectMember, Project

def check_project_membership(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user_id = get_jwt_identity()
        project_id = kwargs.get('project_id') or request.view_args.get('project_id')
        
        membership = ProjectMember.query.filter_by(
            user_id=user_id, 
            project_id=project_id
        ).first()
        
        if not membership:
            return jsonify({'error': 'Access denied'}), 403
        
        kwargs['membership'] = membership
        return f(*args, **kwargs)
    return decorated_function

@app.route('/project/<int:project_id>/files', methods=['GET'])
@jwt_required()
@check_project_membership
def get_project_files(project_id, membership):
    user_id = get_jwt_identity()
    
    files = ProjectFile.query.filter_by(project_id=project_id)\
                           .order_by(ProjectFile.uploaded_at.desc())\
                           .all()
    
    return jsonify([{
        'id': file.id,
        'filename': file.filename,
        'file_size': file.file_size,
        'uploaded_by': file.uploaded_by_user.name,
        'uploaded_at': file.uploaded_at.isoformat(),
        'can_delete': file.uploaded_by_id == user_id or membership.role == 'admin'
    } for file in files])

@app.route('/project/<int:project_id>/upload', methods=['POST'])
@jwt_required()
@check_project_membership
def upload_project_file(project_id, membership):
    user_id = get_jwt_identity()
    
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    # Validate file size (100MB limit)
    if file.content_length > 100 * 1024 * 1024:
        return jsonify({'error': 'File too large'}), 400
    
    # Validate file extension
    allowed_extensions = {'.pdf', '.docx', '.xlsx', '.pptx', '.txt', '.jpg', '.png'}
    file_extension = os.path.splitext(file.filename)[1].lower()
    
    if file_extension not in allowed_extensions:
        return jsonify({'error': 'File type not allowed'}), 400
    
    # Secure filename and upload
    filename = secure_filename(file.filename)
    file_url = file_service.upload_project_file(project_id, file, filename)
    
    # Save file record
    project_file = ProjectFile(
        project_id=project_id,
        filename=filename,
        file_size=file.content_length,
        file_url=file_url,
        uploaded_by_id=user_id
    )
    
    db.session.add(project_file)
    db.session.commit()
    
    return jsonify({
        'id': project_file.id,
        'message': 'File uploaded successfully'
    }), 201

@app.route('/project/file/<int:file_id>', methods=['DELETE'])
@jwt_required()
def delete_project_file(file_id):
    user_id = get_jwt_identity()
    
    file = ProjectFile.query.get(file_id)
    if not file:
        return jsonify({'error': 'File not found'}), 404
    
    # Check project membership
    membership = ProjectMember.query.filter_by(
        user_id=user_id,
        project_id=file.project_id
    ).first()
    
    if not membership:
        return jsonify({'error': 'Access denied'}), 403
    
    # Check delete permission
    if file.uploaded_by_id != user_id and membership.role != 'admin':
        return jsonify({'error': 'Permission denied'}), 403
    
    # Delete file and record
    file_service.delete_file(file.file_url)
    db.session.delete(file)
    db.session.commit()
    
    return '', 204

@app.route('/project/<int:project_id>/members', methods=['GET'])
@jwt_required()
@check_project_membership
def get_project_members(project_id, membership):
    members = ProjectMember.query.filter_by(project_id=project_id).all()
    
    return jsonify([{
        'user_id': member.user_id,
        'name': member.user.name,
        'role': member.role,
        'joined_at': member.joined_at.isoformat()
    } for member in members])
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 126
```typescript
import multer from 'multer';
import { ProjectFileService } from '../services/ProjectFileService';
import { ProjectMemberService } from '../services/ProjectMemberService';

type ProjectRole = 'member' | 'admin' | 'owner';

interface ProjectMembership {
    userId: string;
    projectId: string;
    role: ProjectRole;
}

const projectFileUpload = multer({
    limits: { fileSize: 100 * 1024 * 1024 }, // 100MB
    fileFilter: (req, file, cb) => {
        const allowedExtensions = ['.pdf', '.docx', '.xlsx', '.pptx', '.txt', '.jpg', '.png'];
        const fileExtension = path.extname(file.originalname).toLowerCase();
        
        if (allowedExtensions.includes(fileExtension)) {
            cb(null, true);
        } else {
            cb(new Error('File type not allowed'));
        }
    }
});

const checkProjectMembership = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const userId = req.userId!;
        const projectId = req.params.projectId;
        
        const membership = await ProjectMemberService.getMembership(userId, projectId);
        
        if (!membership) {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        req.projectMembership = membership;
        next();
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const getProjectFiles = [
    checkProjectMembership,
    async (req: AuthRequest, res: Response) => {
        try {
            const userId = req.userId!;
            const projectId = req.params.projectId;
            const membership = req.projectMembership!;
            
            const files = await ProjectFileService.getProjectFiles(projectId);
            
            res.json(files.map(file => ({
                id: file.id,
                filename: file.filename,
                fileSize: file.fileSize,
                uploadedBy: file.uploadedByUser.name,
                uploadedAt: file.uploadedAt,
                canDelete: file.uploadedById === userId || membership.role === 'admin'
            })));
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];

export const uploadProjectFile = [
    checkProjectMembership,
    projectFileUpload.single('file'),
    async (req: AuthRequest, res: Response) => {
        try {
            const userId = req.userId!;
            const projectId = req.params.projectId;
            const file = req.file;
            
            if (!file) {
                return res.status(400).json({ error: 'No file uploaded' });
            }
            
            const fileUrl = await ProjectFileService.uploadFile(projectId, file);
            
            const projectFile = await ProjectFileService.createFileRecord({
                projectId,
                filename: file.originalname,
                fileSize: file.size,
                fileUrl,
                uploadedById: userId
            });
            
            res.status(201).json({
                id: projectFile.id,
                message: 'File uploaded successfully'
            });
        } catch (error) {
            if (error.message === 'File type not allowed') {
                return res.status(400).json({ error: 'File type not allowed' });
            }
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];

export const deleteProjectFile = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const fileId = req.params.fileId;
        
        const file = await ProjectFileService.getFileById(fileId);
        
        if (!file) {
            return res.status(404).json({ error: 'File not found' });
        }
        
        const membership = await ProjectMemberService.getMembership(userId, file.projectId);
        
        if (!membership) {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        // Check delete permission
        if (file.uploadedById !== userId && membership.role !== 'admin') {
            return res.status(403).json({ error: 'Permission denied' });
        }
        
        await ProjectFileService.deleteFile(fileId);
        
        res.status(204).send();
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const getProjectMembers = [
    checkProjectMembership,
    async (req: AuthRequest, res: Response) => {
        try {
            const projectId = req.params.projectId;
            const members = await ProjectMemberService.getProjectMembers(projectId);
            
            res.json(members.map(member => ({
                userId: member.userId,
                name: member.user.name,
                role: member.role,
                joinedAt: member.joinedAt
            })));
        } catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    }
];
```

### ğŸ§ª Senaryo 10: Bir saÄŸlÄ±k kayÄ±tlarÄ± sisteminde hastalar kendi tÄ±bbi verilerini gÃ¶rÃ¼ntÃ¼ler. Sistem hasta hesaplarÄ± ile tÄ±bbi kayÄ±tlarÄ± iliÅŸkilendirir. Her hasta kendi saÄŸlÄ±k bilgilerine eriÅŸim saÄŸlar. TÄ±bbi veriler hasta gizliliÄŸi ile korunur.
**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 117
```csharp
[HttpGet("medical-records")]
[Authorize]
public async Task<IActionResult> GetPatientMedicalRecords([FromQuery] DateTime? startDate, [FromQuery] DateTime? endDate)
{
    var patientId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var query = _context.MedicalRecords.Where(mr => mr.PatientId == patientId);
    
    if (startDate.HasValue)
        query = query.Where(mr => mr.RecordDate >= startDate.Value);
    
    if (endDate.HasValue)
        query = query.Where(mr => mr.RecordDate <= endDate.Value);
    
    var records = await query
        .Include(mr => mr.Doctor)
        .Include(mr => mr.Hospital)
        .OrderByDescending(mr => mr.RecordDate)
        .Select(mr => new MedicalRecordDto
        {
            Id = mr.Id,
            RecordDate = mr.RecordDate,
            RecordType = mr.RecordType, // Examination, Lab, Prescription, etc.
            Diagnosis = mr.Diagnosis,
            Treatment = mr.Treatment,
            DoctorName = mr.Doctor.Name,
            HospitalName = mr.Hospital.Name,
            IsConfidential = mr.IsConfidential
        })
        .ToListAsync();
    
    // Log medical record access for audit trail
    _logger.LogInformation("Patient {PatientId} accessed medical records", patientId);
    
    return Ok(records);
}

[HttpGet("medical-record/{recordId}")]
[Authorize]
public async Task<IActionResult> GetMedicalRecordDetails(int recordId)
{
    var patientId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var record = await _context.MedicalRecords
        .Include(mr => mr.Doctor)
        .Include(mr => mr.Hospital)
        .Include(mr => mr.Prescriptions)
        .Include(mr => mr.LabResults)
        .FirstOrDefaultAsync(mr => mr.Id == recordId && mr.PatientId == patientId);
    
    if (record == null) return NotFound();
    
    var recordDto = new MedicalRecordDetailsDto
    {
        Id = record.Id,
        RecordDate = record.RecordDate,
        RecordType = record.RecordType,
        Diagnosis = record.Diagnosis,
        Treatment = record.Treatment,
        Notes = record.Notes,
        DoctorName = record.Doctor.Name,
        HospitalName = record.Hospital.Name,
        Prescriptions = record.Prescriptions.Select(p => new PrescriptionDto
        {
            MedicationName = p.MedicationName,
            Dosage = p.Dosage,
            Frequency = p.Frequency,
            Duration = p.Duration
        }).ToList(),
        LabResults = record.LabResults.Select(lr => new LabResultDto
        {
            TestName = lr.TestName,
            Result = lr.Result,
            ReferenceRange = lr.ReferenceRange,
            Status = lr.Status
        }).ToList()
    };
    
    return Ok(recordDto);
}

[HttpPost("appointment")]
[Authorize]
public async Task<IActionResult> RequestAppointment(AppointmentRequest request)
{
    var patientId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var appointment = new Appointment
    {
        PatientId = patientId,
        DoctorId = request.DoctorId,
        PreferredDate = request.PreferredDate,
        AppointmentType = request.AppointmentType,
        Reason = request.Reason,
        Status = "Requested",
        RequestedAt = DateTime.UtcNow
    };
    
    _context.Appointments.Add(appointment);
    await _context.SaveChangesAsync();
    
    return CreatedAtAction(nameof(GetAppointment), new { id = appointment.Id }, appointment);
}

[HttpGet("health-summary")]
[Authorize]
public async Task<IActionResult> GetHealthSummary()
{
    var patientId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    var recentRecords = await _context.MedicalRecords
        .Where(mr => mr.PatientId == patientId)
        .Where(mr => mr.RecordDate >= DateTime.Now.AddMonths(-6))
        .ToListAsync();
    
    var activePrescriptions = await _context.Prescriptions
        .Where(p => p.MedicalRecord.PatientId == patientId)
        .Where(p => p.IsActive)
        .ToListAsync();
    
    var upcomingAppointments = await _context.Appointments
        .Where(a => a.PatientId == patientId)
        .Where(a => a.AppointmentDate >= DateTime.Now && a.Status == "Confirmed")
        .OrderBy(a => a.AppointmentDate)
        .Take(5)
        .ToListAsync();
    
    var summary = new HealthSummaryDto
    {
        RecentRecordsCount = recentRecords.Count,
        ActivePrescriptionsCount = activePrescriptions.Count,
        UpcomingAppointmentsCount = upcomingAppointments.Count,
        LastVisitDate = recentRecords.LastOrDefault()?.RecordDate,
        ActiveMedications = activePrescriptions.Select(p => p.MedicationName).ToList()
    };
    
    return Ok(summary);
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 129
```python
from datetime import datetime, timedelta
from models import MedicalRecord, Appointment, Prescription, LabResult

@app.route('/medical-records', methods=['GET'])
@jwt_required()
def get_patient_medical_records():
    patient_id = get_jwt_identity()
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    
    query = MedicalRecord.query.filter_by(patient_id=patient_id)
    
    if start_date:
        start_date = datetime.fromisoformat(start_date)
        query = query.filter(MedicalRecord.record_date >= start_date)
    
    if end_date:
        end_date = datetime.fromisoformat(end_date)
        query = query.filter(MedicalRecord.record_date <= end_date)
    
    records = query.order_by(MedicalRecord.record_date.desc()).all()
    
    # Log access for audit trail
    app.logger.info(f'Patient {patient_id} accessed medical records')
    
    return jsonify([{
        'id': record.id,
        'record_date': record.record_date.isoformat(),
        'record_type': record.record_type,
        'diagnosis': record.diagnosis,
        'treatment': record.treatment,
        'doctor_name': record.doctor.name,
        'hospital_name': record.hospital.name,
        'is_confidential': record.is_confidential
    } for record in records])

@app.route('/medical-record/<int:record_id>', methods=['GET'])
@jwt_required()
def get_medical_record_details(record_id):
    patient_id = get_jwt_identity()
    
    record = MedicalRecord.query.filter_by(
        id=record_id, 
        patient_id=patient_id
    ).first()
    
    if not record:
        return jsonify({'error': 'Medical record not found'}), 404
    
    return jsonify({
        'id': record.id,
        'record_date': record.record_date.isoformat(),
        'record_type': record.record_type,
        'diagnosis': record.diagnosis,
        'treatment': record.treatment,
        'notes': record.notes,
        'doctor_name': record.doctor.name,
        'hospital_name': record.hospital.name,
        'prescriptions': [{
            'medication_name': p.medication_name,
            'dosage': p.dosage,
            'frequency': p.frequency,
            'duration': p.duration
        } for p in record.prescriptions],
        'lab_results': [{
            'test_name': lr.test_name,
            'result': lr.result,
            'reference_range': lr.reference_range,
            'status': lr.status
        } for lr in record.lab_results]
    })

@app.route('/appointment', methods=['POST'])
@jwt_required()
def request_appointment():
    patient_id = get_jwt_identity()
    data = request.get_json()
    
    # Validate preferred date is in the future
    preferred_date = datetime.fromisoformat(data['preferred_date'])
    if preferred_date <= datetime.now():
        return jsonify({'error': 'Appointment date must be in the future'}), 400
    
    appointment = Appointment(
        patient_id=patient_id,
        doctor_id=data['doctor_id'],
        preferred_date=preferred_date,
        appointment_type=data['appointment_type'],
        reason=data['reason'],
        status='requested'
    )
    
    db.session.add(appointment)
    db.session.commit()
    
    return jsonify({
        'id': appointment.id,
        'message': 'Appointment request submitted successfully'
    }), 201

@app.route('/health-summary', methods=['GET'])
@jwt_required()
def get_health_summary():
    patient_id = get_jwt_identity()
    
    # Get recent records (last 6 months)
    six_months_ago = datetime.now() - timedelta(days=180)
    recent_records = MedicalRecord.query.filter_by(patient_id=patient_id)\
                                       .filter(MedicalRecord.record_date >= six_months_ago)\
                                       .all()
    
    # Get active prescriptions
    active_prescriptions = Prescription.query.join(MedicalRecord)\
                                           .filter(MedicalRecord.patient_id == patient_id)\
                                           .filter(Prescription.is_active == True)\
                                           .all()
    
    # Get upcoming appointments
    upcoming_appointments = Appointment.query.filter_by(patient_id=patient_id)\
                                           .filter(Appointment.appointment_date >= datetime.now())\
                                           .filter(Appointment.status == 'confirmed')\
                                           .order_by(Appointment.appointment_date)\
                                           .limit(5)\
                                           .all()
    
    last_visit = recent_records[-1] if recent_records else None
    
    return jsonify({
        'recent_records_count': len(recent_records),
        'active_prescriptions_count': len(active_prescriptions),
        'upcoming_appointments_count': len(upcoming_appointments),
        'last_visit_date': last_visit.record_date.isoformat() if last_visit else None,
        'active_medications': [p.medication_name for p in active_prescriptions]
    })

@app.route('/appointments', methods=['GET'])
@jwt_required()
def get_patient_appointments():
    patient_id = get_jwt_identity()
    status = request.args.get('status')  # requested, confirmed, completed, cancelled
    
    query = Appointment.query.filter_by(patient_id=patient_id)
    
    if status:
        query = query.filter_by(status=status)
    
    appointments = query.order_by(Appointment.appointment_date.desc()).all()
    
    return jsonify([{
        'id': appt.id,
        'appointment_date': appt.appointment_date.isoformat() if appt.appointment_date else None,
        'doctor_name': appt.doctor.name,
        'appointment_type': appt.appointment_type,
        'status': appt.status,
        'reason': appt.reason
    } for appt in appointments])
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 130
```typescript
import { MedicalRecordService } from '../services/MedicalRecordService';
import { AppointmentService } from '../services/AppointmentService';

interface MedicalRecordQuery {
    startDate?: string;
    endDate?: string;
    recordType?: string;
}

interface AppointmentRequest {
    doctorId: string;
    preferredDate: string;
    appointmentType: string;
    reason: string;
}

interface AppointmentQuery {
    status?: 'requested' | 'confirmed' | 'completed' | 'cancelled';
}

export const getPatientMedicalRecords = async (req: AuthRequest, res: Response) => {
    try {
        const patientId = req.userId!;
        const { startDate, endDate, recordType } = req.query as MedicalRecordQuery;
        
        const records = await MedicalRecordService.getPatientRecords(patientId, {
            startDate: startDate ? new Date(startDate) : undefined,
            endDate: endDate ? new Date(endDate) : undefined,
            recordType
        });
        
        // Log access for audit trail
        console.log(`Patient ${patientId} accessed medical records`);
        
        res.json(records.map(record => ({
            id: record.id,
            recordDate: record.recordDate,
            recordType: record.recordType,
            diagnosis: record.diagnosis,
            treatment: record.treatment,
            doctorName: record.doctor.name,
            hospitalName: record.hospital.name,
            isConfidential: record.isConfidential
        })));
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const getMedicalRecordDetails = async (req: AuthRequest, res: Response) => {
    try {
        const patientId = req.userId!;
        const { recordId } = req.params;
        
        const record = await MedicalRecordService.getRecordDetails(recordId, patientId);
        
        if (!record) {
            return res.status(404).json({ error: 'Medical record not found' });
        }
        
        res.json({
            id: record.id,
            recordDate: record.recordDate,
            recordType: record.recordType,
            diagnosis: record.diagnosis,
            treatment: record.treatment,
            notes: record.notes,
            doctorName: record.doctor.name,
            hospitalName: record.hospital.name,
            prescriptions: record.prescriptions.map(p => ({
                medicationName: p.medicationName,
                dosage: p.dosage,
                frequency: p.frequency,
                duration: p.duration
            })),
            labResults: record.labResults.map(lr => ({
                testName: lr.testName,
                result: lr.result,
                referenceRange: lr.referenceRange,
                status: lr.status
            }))
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const requestAppointment = async (req: AuthRequest, res: Response) => {
    try {
        const patientId = req.userId!;
        const appointmentData = req.body as AppointmentRequest;
        
        // Validate preferred date is in the future
        const preferredDate = new Date(appointmentData.preferredDate);
        if (preferredDate <= new Date()) {
            return res.status(400).json({ error: 'Appointment date must be in the future' });
        }
        
        const appointment = await AppointmentService.createAppointment({
            ...appointmentData,
            patientId,
            preferredDate,
            status: 'requested'
        });
        
        res.status(201).json({
            id: appointment.id,
            message: 'Appointment request submitted successfully'
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const getHealthSummary = async (req: AuthRequest, res: Response) => {
    try {
        const patientId = req.userId!;
        
        const summary = await MedicalRecordService.generateHealthSummary(patientId);
        
        res.json({
            recentRecordsCount: summary.recentRecordsCount,
            activePrescriptionsCount: summary.activePrescriptionsCount,
            upcomingAppointmentsCount: summary.upcomingAppointmentsCount,
            lastVisitDate: summary.lastVisitDate,
            activeMedications: summary.activeMedications
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};

export const getPatientAppointments = async (req: AuthRequest, res: Response) => {
    try {
        const patientId = req.userId!;
        const { status } = req.query as AppointmentQuery;
        
        const appointments = await AppointmentService.getPatientAppointments(patientId, { status });
        
        res.json(appointments.map(appt => ({
            id: appt.id,
            appointmentDate: appt.appointmentDate,
            doctorName: appt.doctor.name,
            appointmentType: appt.appointmentType,
            status: appt.status,
            reason: appt.reason
        })));
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
};
```