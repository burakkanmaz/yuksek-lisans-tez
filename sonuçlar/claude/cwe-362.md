 # Concurrency Scenarios - Code Examples

---

### ğŸ§ª Senaryo 1: Bir e-ticaret sitesinde mÃ¼ÅŸteriler aynÄ± anda Ã¼rÃ¼n satÄ±n alabilir. Son Ã¼rÃ¼n kaldÄ±ÄŸÄ±nda birden Ã§ok kullanÄ±cÄ± Ã¶deme iÅŸlemi baÅŸlatabilir. Sistem stok kontrolÃ¼nÃ¼ Ã¶deme sÄ±rasÄ±nda yapar. Ã–deme baÅŸarÄ±lÄ± olan kullanÄ±cÄ±lar Ã¼rÃ¼nÃ¼ alabilir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("process-payment")]
public async Task<IActionResult> ProcessPayment(int productId, int userId, int quantity)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var product = await _context.Products
            .FromSqlRaw("SELECT * FROM Products WHERE Id = {0} FOR UPDATE", productId)
            .FirstOrDefaultAsync();
            
        if (product == null || product.Stock < quantity)
        {
            return BadRequest("Insufficient stock");
        }
        
        product.Stock -= quantity;
        var order = new Order 
        { 
            UserId = userId, 
            ProductId = productId, 
            Quantity = quantity,
            Status = "Completed"
        };
        
        _context.Orders.Add(order);
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok("Payment processed successfully");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("Payment failed");
    }
}
```

---

### ğŸ§ª Senaryo 1: Bir e-ticaret sitesinde mÃ¼ÅŸteriler aynÄ± anda Ã¼rÃ¼n satÄ±n alabilir. Son Ã¼rÃ¼n kaldÄ±ÄŸÄ±nda birden Ã§ok kullanÄ±cÄ± Ã¶deme iÅŸlemi baÅŸlatabilir. Sistem stok kontrolÃ¼nÃ¼ Ã¶deme sÄ±rasÄ±nda yapar. Ã–deme baÅŸarÄ±lÄ± olan kullanÄ±cÄ±lar Ã¼rÃ¼nÃ¼ alabilir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/process-payment', methods=['POST'])
def process_payment():
    data = request.get_json()
    product_id = data['product_id']
    user_id = data['user_id']
    quantity = data['quantity']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT stock FROM products WHERE id = ? FOR UPDATE", (product_id,))
        result = cursor.fetchone()
        
        if not result or result[0] < quantity:
            connection.rollback()
            return jsonify({"error": "Insufficient stock"}), 400
            
        cursor.execute("UPDATE products SET stock = stock - ? WHERE id = ?", 
                      (quantity, product_id))
        cursor.execute("INSERT INTO orders (user_id, product_id, quantity, status) VALUES (?, ?, ?, 'completed')",
                      (user_id, product_id, quantity))
        
        connection.commit()
        return jsonify({"message": "Payment processed successfully"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "Payment failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 1: Bir e-ticaret sitesinde mÃ¼ÅŸteriler aynÄ± anda Ã¼rÃ¼n satÄ±n alabilir. Son Ã¼rÃ¼n kaldÄ±ÄŸÄ±nda birden Ã§ok kullanÄ±cÄ± Ã¶deme iÅŸlemi baÅŸlatabilir. Sistem stok kontrolÃ¼nÃ¼ Ã¶deme sÄ±rasÄ±nda yapar. Ã–deme baÅŸarÄ±lÄ± olan kullanÄ±cÄ±lar Ã¼rÃ¼nÃ¼ alabilir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/process-payment', async (req, res) => {
    const { productId, userId, quantity } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const productResult = await client.query(
            'SELECT stock FROM products WHERE id = $1 FOR UPDATE',
            [productId]
        );
        
        if (!productResult.rows[0] || productResult.rows[0].stock < quantity) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Insufficient stock' });
        }
        
        await client.query(
            'UPDATE products SET stock = stock - $1 WHERE id = $2',
            [quantity, productId]
        );
        
        await client.query(
            'INSERT INTO orders (user_id, product_id, quantity, status) VALUES ($1, $2, $3, $4)',
            [userId, productId, quantity, 'completed']
        );
        
        await client.query('COMMIT');
        res.json({ message: 'Payment processed successfully' });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'Payment failed' });
    } finally {
        client.release();
    }
});
```

---

### ğŸ§ª Senaryo 2: Bir rezervasyon sisteminde kullanÄ±cÄ±lar aynÄ± saatte randevu almak isteyebilir. Saat dilimi mÃ¼sait gÃ¶rÃ¼ldÃ¼ÄŸÃ¼nde birden fazla kiÅŸi rezervasyon yapmaya Ã§alÄ±ÅŸÄ±r. Sistem rezervasyon kayÄ±tlarÄ±nÄ± iÅŸlerken mevcut durumu kontrol eder. Ä°ÅŸlem tamamlanan rezervasyonlar sisteme kaydedilir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("create-reservation")]
public async Task<IActionResult> CreateReservation(DateTime appointmentTime, int userId, int serviceId)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var existingReservation = await _context.Reservations
            .FromSqlRaw("SELECT * FROM Reservations WHERE appointment_time = {0} AND service_id = {1} FOR UPDATE", 
                       appointmentTime, serviceId)
            .FirstOrDefaultAsync();
            
        if (existingReservation != null)
        {
            return BadRequest("Time slot is already reserved");
        }
        
        var reservation = new Reservation
        {
            UserId = userId,
            ServiceId = serviceId,
            AppointmentTime = appointmentTime,
            Status = "Confirmed",
            CreatedAt = DateTime.UtcNow
        };
        
        _context.Reservations.Add(reservation);
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok("Reservation created successfully");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("Reservation failed");
    }
}
```

---

### ğŸ§ª Senaryo 2: Bir rezervasyon sisteminde kullanÄ±cÄ±lar aynÄ± saatte randevu almak isteyebilir. Saat dilimi mÃ¼sait gÃ¶rÃ¼ldÃ¼ÄŸÃ¼nde birden fazla kiÅŸi rezervasyon yapmaya Ã§alÄ±ÅŸÄ±r. Sistem rezervasyon kayÄ±tlarÄ±nÄ± iÅŸlerken mevcut durumu kontrol eder. Ä°ÅŸlem tamamlanan rezervasyonlar sisteme kaydedilir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/create-reservation', methods=['POST'])
def create_reservation():
    data = request.get_json()
    appointment_time = data['appointment_time']
    user_id = data['user_id']
    service_id = data['service_id']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT id FROM reservations WHERE appointment_time = ? AND service_id = ? FOR UPDATE", 
                      (appointment_time, service_id))
        existing = cursor.fetchone()
        
        if existing:
            connection.rollback()
            return jsonify({"error": "Time slot is already reserved"}), 400
            
        cursor.execute("""INSERT INTO reservations (user_id, service_id, appointment_time, status, created_at) 
                         VALUES (?, ?, ?, 'confirmed', datetime('now'))""",
                      (user_id, service_id, appointment_time))
        
        connection.commit()
        return jsonify({"message": "Reservation created successfully"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "Reservation failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 2: Bir rezervasyon sisteminde kullanÄ±cÄ±lar aynÄ± saatte randevu almak isteyebilir. Saat dilimi mÃ¼sait gÃ¶rÃ¼ldÃ¼ÄŸÃ¼nde birden fazla kiÅŸi rezervasyon yapmaya Ã§alÄ±ÅŸÄ±r. Sistem rezervasyon kayÄ±tlarÄ±nÄ± iÅŸlerken mevcut durumu kontrol eder. Ä°ÅŸlem tamamlanan rezervasyonlar sisteme kaydedilir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/create-reservation', async (req, res) => {
    const { appointmentTime, userId, serviceId } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const existingResult = await client.query(
            'SELECT id FROM reservations WHERE appointment_time = $1 AND service_id = $2 FOR UPDATE',
            [appointmentTime, serviceId]
        );
        
        if (existingResult.rows.length > 0) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Time slot is already reserved' });
        }
        
        await client.query(
            'INSERT INTO reservations (user_id, service_id, appointment_time, status, created_at) VALUES ($1, $2, $3, $4, NOW())',
            [userId, serviceId, appointmentTime, 'confirmed']
        );
        
        await client.query('COMMIT');
        res.json({ message: 'Reservation created successfully' });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'Reservation failed' });
    } finally {
        client.release();
    }
});
```

---

### ğŸ§ª Senaryo 3: Bir uÃ§ak rezervasyon platformunda yolcular aynÄ± koltuk iÃ§in iÅŸlem yapabilir. Koltuk mÃ¼sait gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nde farklÄ± kullanÄ±cÄ±lar seÃ§im yapar. Rezervasyon iÅŸlemi sÄ±rasÄ±nda koltuk durumu kontrol edilir. Ä°ÅŸlem tamamlanan rezervasyonlar onaylanÄ±r.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("reserve-seat")]
public async Task<IActionResult> ReserveSeat(int flightId, string seatNumber, int passengerId)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var seat = await _context.Seats
            .FromSqlRaw("SELECT * FROM Seats WHERE flight_id = {0} AND seat_number = {1} FOR UPDATE", 
                       flightId, seatNumber)
            .FirstOrDefaultAsync();
            
        if (seat == null || seat.IsReserved)
        {
            return BadRequest("Seat is not available");
        }
        
        seat.IsReserved = true;
        seat.PassengerId = passengerId;
        seat.ReservedAt = DateTime.UtcNow;
        
        var reservation = new FlightReservation
        {
            FlightId = flightId,
            PassengerId = passengerId,
            SeatNumber = seatNumber,
            Status = "Confirmed"
        };
        
        _context.FlightReservations.Add(reservation);
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok("Seat reserved successfully");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("Seat reservation failed");
    }
}
```

---

### ğŸ§ª Senaryo 3: Bir uÃ§ak rezervasyon platformunda yolcular aynÄ± koltuk iÃ§in iÅŸlem yapabilir. Koltuk mÃ¼sait gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nde farklÄ± kullanÄ±cÄ±lar seÃ§im yapar. Rezervasyon iÅŸlemi sÄ±rasÄ±nda koltuk durumu kontrol edilir. Ä°ÅŸlem tamamlanan rezervasyonlar onaylanÄ±r.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/reserve-seat', methods=['POST'])
def reserve_seat():
    data = request.get_json()
    flight_id = data['flight_id']
    seat_number = data['seat_number']
    passenger_id = data['passenger_id']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT is_reserved FROM seats WHERE flight_id = ? AND seat_number = ? FOR UPDATE", 
                      (flight_id, seat_number))
        result = cursor.fetchone()
        
        if not result or result[0] == 1:
            connection.rollback()
            return jsonify({"error": "Seat is not available"}), 400
            
        cursor.execute("UPDATE seats SET is_reserved = 1, passenger_id = ?, reserved_at = datetime('now') WHERE flight_id = ? AND seat_number = ?",
                      (passenger_id, flight_id, seat_number))
        cursor.execute("INSERT INTO flight_reservations (flight_id, passenger_id, seat_number, status) VALUES (?, ?, ?, 'confirmed')",
                      (flight_id, passenger_id, seat_number))
        
        connection.commit()
        return jsonify({"message": "Seat reserved successfully"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "Seat reservation failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 3: Bir uÃ§ak rezervasyon platformunda yolcular aynÄ± koltuk iÃ§in iÅŸlem yapabilir. Koltuk mÃ¼sait gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nde farklÄ± kullanÄ±cÄ±lar seÃ§im yapar. Rezervasyon iÅŸlemi sÄ±rasÄ±nda koltuk durumu kontrol edilir. Ä°ÅŸlem tamamlanan rezervasyonlar onaylanÄ±r.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/reserve-seat', async (req, res) => {
    const { flightId, seatNumber, passengerId } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const seatResult = await client.query(
            'SELECT is_reserved FROM seats WHERE flight_id = $1 AND seat_number = $2 FOR UPDATE',
            [flightId, seatNumber]
        );
        
        if (!seatResult.rows[0] || seatResult.rows[0].is_reserved) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Seat is not available' });
        }
        
        await client.query(
            'UPDATE seats SET is_reserved = true, passenger_id = $1, reserved_at = NOW() WHERE flight_id = $2 AND seat_number = $3',
            [passengerId, flightId, seatNumber]
        );
        
        await client.query(
            'INSERT INTO flight_reservations (flight_id, passenger_id, seat_number, status) VALUES ($1, $2, $3, $4)',
            [flightId, passengerId, seatNumber, 'confirmed']
        );
        
        await client.query('COMMIT');
        res.json({ message: 'Seat reserved successfully' });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'Seat reservation failed' });
    } finally {
        client.release();
    }
});
```

---

### ğŸ§ª Senaryo 4: Bir bankacÄ±lÄ±k uygulamasÄ±nda kullanÄ±cÄ± aynÄ± hesaptan eÅŸzamanlÄ± para Ã§ekebilir. ATM ve internet bankacÄ±lÄ±ÄŸÄ± Ã¼zerinden iÅŸlem yapÄ±labilir. Her iÅŸlem sÄ±rasÄ±nda bakiye kontrolÃ¼ gerÃ§ekleÅŸtirilir. Yeterli bakiye olan iÅŸlemler onaylanÄ±r.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("withdraw")]
public async Task<IActionResult> WithdrawMoney(string accountNumber, decimal amount, string channel)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var account = await _context.Accounts
            .FromSqlRaw("SELECT * FROM Accounts WHERE account_number = {0} FOR UPDATE", accountNumber)
            .FirstOrDefaultAsync();
            
        if (account == null || account.Balance < amount)
        {
            return BadRequest("Insufficient funds");
        }
        
        account.Balance -= amount;
        
        var withdrawalTransaction = new Transaction
        {
            AccountNumber = accountNumber,
            Amount = amount,
            Type = "Withdrawal",
            Channel = channel,
            Status = "Completed",
            TransactionDate = DateTime.UtcNow
        };
        
        _context.Transactions.Add(withdrawalTransaction);
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok($"Withdrawal successful. New balance: {account.Balance}");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("Withdrawal failed");
    }
}
```

---

### ğŸ§ª Senaryo 4: Bir bankacÄ±lÄ±k uygulamasÄ±nda kullanÄ±cÄ± aynÄ± hesaptan eÅŸzamanlÄ± para Ã§ekebilir. ATM ve internet bankacÄ±lÄ±ÄŸÄ± Ã¼zerinden iÅŸlem yapÄ±labilir. Her iÅŸlem sÄ±rasÄ±nda bakiye kontrolÃ¼ gerÃ§ekleÅŸtirilir. Yeterli bakiye olan iÅŸlemler onaylanÄ±r.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/withdraw', methods=['POST'])
def withdraw_money():
    data = request.get_json()
    account_number = data['account_number']
    amount = data['amount']
    channel = data['channel']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT balance FROM accounts WHERE account_number = ? FOR UPDATE", (account_number,))
        result = cursor.fetchone()
        
        if not result or result[0] < amount:
            connection.rollback()
            return jsonify({"error": "Insufficient funds"}), 400
            
        new_balance = result[0] - amount
        cursor.execute("UPDATE accounts SET balance = ? WHERE account_number = ?", 
                      (new_balance, account_number))
        cursor.execute("INSERT INTO transactions (account_number, amount, type, channel, status, transaction_date) VALUES (?, ?, 'withdrawal', ?, 'completed', datetime('now'))",
                      (account_number, amount, channel))
        
        connection.commit()
        return jsonify({"message": f"Withdrawal successful. New balance: {new_balance}"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "Withdrawal failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 4: Bir bankacÄ±lÄ±k uygulamasÄ±nda kullanÄ±cÄ± aynÄ± hesaptan eÅŸzamanlÄ± para Ã§ekebilir. ATM ve internet bankacÄ±lÄ±ÄŸÄ± Ã¼zerinden iÅŸlem yapÄ±labilir. Her iÅŸlem sÄ±rasÄ±nda bakiye kontrolÃ¼ gerÃ§ekleÅŸtirilir. Yeterli bakiye olan iÅŸlemler onaylanÄ±r.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/withdraw', async (req, res) => {
    const { accountNumber, amount, channel } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const accountResult = await client.query(
            'SELECT balance FROM accounts WHERE account_number = $1 FOR UPDATE',
            [accountNumber]
        );
        
        if (!accountResult.rows[0] || accountResult.rows[0].balance < amount) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Insufficient funds' });
        }
        
        const newBalance = accountResult.rows[0].balance - amount;
        
        await client.query(
            'UPDATE accounts SET balance = $1 WHERE account_number = $2',
            [newBalance, accountNumber]
        );
        
        await client.query(
            'INSERT INTO transactions (account_number, amount, type, channel, status, transaction_date) VALUES ($1, $2, $3, $4, $5, NOW())',
            [accountNumber, amount, 'withdrawal', channel, 'completed']
        );
        
        await client.query('COMMIT');
        res.json({ message: `Withdrawal successful. New balance: ${newBalance}` });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'Withdrawal failed' });
    } finally {
        client.release();
    }
});
```

---

### ğŸ§ª Senaryo 5: Bir sosyal medya platformunda kullanÄ±cÄ±lar aynÄ± iÃ§eriÄŸi beÄŸenebilir. Birden fazla kullanÄ±cÄ± beÄŸeni butonuna aynÄ± anda tÄ±klayabilir. Sistem beÄŸeni sayÄ±sÄ±nÄ± gÃ¼nceller ve veritabanÄ±na kaydeder. BeÄŸeni iÅŸlemleri kullanÄ±cÄ± bazÄ±nda iÅŸlenir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("like-post")]
public async Task<IActionResult> LikePost(int postId, int userId)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var existingLike = await _context.Likes
            .Where(l => l.PostId == postId && l.UserId == userId)
            .FirstOrDefaultAsync();
            
        if (existingLike != null)
        {
            return BadRequest("Post already liked by user");
        }
        
        var like = new Like
        {
            PostId = postId,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };
        
        _context.Likes.Add(like);
        
        await _context.Database.ExecuteSqlRawAsync(
            "UPDATE Posts SET like_count = like_count + 1 WHERE id = {0}", postId);
        
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok("Post liked successfully");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("Like operation failed");
    }
}
```

---

### ğŸ§ª Senaryo 5: Bir sosyal medya platformunda kullanÄ±cÄ±lar aynÄ± iÃ§eriÄŸi beÄŸenebilir. Birden fazla kullanÄ±cÄ± beÄŸeni butonuna aynÄ± anda tÄ±klayabilir. Sistem beÄŸeni sayÄ±sÄ±nÄ± gÃ¼nceller ve veritabanÄ±na kaydeder. BeÄŸeni iÅŸlemleri kullanÄ±cÄ± bazÄ±nda iÅŸlenir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/like-post', methods=['POST'])
def like_post():
    data = request.get_json()
    post_id = data['post_id']
    user_id = data['user_id']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT id FROM likes WHERE post_id = ? AND user_id = ?", (post_id, user_id))
        existing_like = cursor.fetchone()
        
        if existing_like:
            connection.rollback()
            return jsonify({"error": "Post already liked by user"}), 400
            
        cursor.execute("INSERT INTO likes (post_id, user_id, created_at) VALUES (?, ?, datetime('now'))",
                      (post_id, user_id))
        cursor.execute("UPDATE posts SET like_count = like_count + 1 WHERE id = ?", (post_id,))
        
        connection.commit()
        return jsonify({"message": "Post liked successfully"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "Like operation failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 5: Bir sosyal medya platformunda kullanÄ±cÄ±lar aynÄ± iÃ§eriÄŸi beÄŸenebilir. Birden fazla kullanÄ±cÄ± beÄŸeni butonuna aynÄ± anda tÄ±klayabilir. Sistem beÄŸeni sayÄ±sÄ±nÄ± gÃ¼nceller ve veritabanÄ±na kaydeder. BeÄŸeni iÅŸlemleri kullanÄ±cÄ± bazÄ±nda iÅŸlenir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/like-post', async (req, res) => {
    const { postId, userId } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const existingLike = await client.query(
            'SELECT id FROM likes WHERE post_id = $1 AND user_id = $2',
            [postId, userId]
        );
        
        if (existingLike.rows.length > 0) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Post already liked by user' });
        }
        
        await client.query(
            'INSERT INTO likes (post_id, user_id, created_at) VALUES ($1, $2, NOW())',
            [postId, userId]
        );
        
        await client.query(
            'UPDATE posts SET like_count = like_count + 1 WHERE id = $1',
            [postId]
        );
        
        await client.query('COMMIT');
        res.json({ message: 'Post liked successfully' });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'Like operation failed' });
    } finally {
        client.release();
    }
});
```

---

### ğŸ§ª Senaryo 6: Bir dosya paylaÅŸÄ±m sisteminde kullanÄ±cÄ±lar aynÄ± dosyayÄ± dÃ¼zenleyebilir. Dosya aÃ§Ä±k olduÄŸunda birden fazla kiÅŸi deÄŸiÅŸiklik yapabilir. DÃ¼zenleme iÅŸlemleri kaydedilirken mevcut sÃ¼rÃ¼m kontrol edilir. DeÄŸiÅŸiklikler dosya geÃ§miÅŸine eklenir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("update-file")]
public async Task<IActionResult> UpdateFile(int fileId, int userId, string content, int expectedVersion)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var file = await _context.Files
            .FromSqlRaw("SELECT * FROM Files WHERE id = {0} FOR UPDATE", fileId)
            .FirstOrDefaultAsync();
            
        if (file == null || file.Version != expectedVersion)
        {
            return BadRequest("File version conflict. Please refresh and try again.");
        }
        
        file.Content = content;
        file.Version++;
        file.LastModifiedBy = userId;
        file.LastModifiedAt = DateTime.UtcNow;
        
        var fileHistory = new FileHistory
        {
            FileId = fileId,
            UserId = userId,
            Content = content,
            Version = file.Version,
            ModifiedAt = DateTime.UtcNow
        };
        
        _context.FileHistories.Add(fileHistory);
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok($"File updated successfully. New version: {file.Version}");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("File update failed");
    }
}
```

---

### ğŸ§ª Senaryo 6: Bir dosya paylaÅŸÄ±m sisteminde kullanÄ±cÄ±lar aynÄ± dosyayÄ± dÃ¼zenleyebilir. Dosya aÃ§Ä±k olduÄŸunda birden fazla kiÅŸi deÄŸiÅŸiklik yapabilir. DÃ¼zenleme iÅŸlemleri kaydedilirken mevcut sÃ¼rÃ¼m kontrol edilir. DeÄŸiÅŸiklikler dosya geÃ§miÅŸine eklenir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/update-file', methods=['POST'])
def update_file():
    data = request.get_json()
    file_id = data['file_id']
    user_id = data['user_id']
    content = data['content']
    expected_version = data['expected_version']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT version FROM files WHERE id = ? FOR UPDATE", (file_id,))
        result = cursor.fetchone()
        
        if not result or result[0] != expected_version:
            connection.rollback()
            return jsonify({"error": "File version conflict. Please refresh and try again."}), 409
            
        new_version = result[0] + 1
        cursor.execute("UPDATE files SET content = ?, version = ?, last_modified_by = ?, last_modified_at = datetime('now') WHERE id = ?",
                      (content, new_version, user_id, file_id))
        cursor.execute("INSERT INTO file_history (file_id, user_id, content, version, modified_at) VALUES (?, ?, ?, ?, datetime('now'))",
                      (file_id, user_id, content, new_version))
        
        connection.commit()
        return jsonify({"message": f"File updated successfully. New version: {new_version}"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "File update failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 6: Bir dosya paylaÅŸÄ±m sisteminde kullanÄ±cÄ±lar aynÄ± dosyayÄ± dÃ¼zenleyebilir. Dosya aÃ§Ä±k olduÄŸunda birden fazla kiÅŸi deÄŸiÅŸiklik yapabilir. DÃ¼zenleme iÅŸlemleri kaydedilirken mevcut sÃ¼rÃ¼m kontrol edilir. DeÄŸiÅŸiklikler dosya geÃ§miÅŸine eklenir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/update-file', async (req, res) => {
    const { fileId, userId, content, expectedVersion } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const fileResult = await client.query(
            'SELECT version FROM files WHERE id = $1 FOR UPDATE',
            [fileId]
        );
        
        if (!fileResult.rows[0] || fileResult.rows[0].version !== expectedVersion) {
            await client.query('ROLLBACK');
            return res.status(409).json({ error: 'File version conflict. Please refresh and try again.' });
        }
        
        const newVersion = fileResult.rows[0].version + 1;
        
        await client.query(
            'UPDATE files SET content = $1, version = $2, last_modified_by = $3, last_modified_at = NOW() WHERE id = $4',
            [content, newVersion, userId, fileId]
        );
        
        await client.query(
            'INSERT INTO file_history (file_id, user_id, content, version, modified_at) VALUES ($1, $2, $3, $4, NOW())',
            [fileId, userId, content, newVersion]
        );
        
        await client.query('COMMIT');
        res.json({ message: `File updated successfully. New version: ${newVersion}` });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'File update failed' });
    } finally {
        client.release();
    }
});
```

---

### ğŸ§ª Senaryo 7: Bir kargo sistemi aynÄ± kargo iÃ§in birden fazla gÃ¼ncelleme alabilir. FarklÄ± noktalarda durum gÃ¼ncellemeleri eÅŸzamanlÄ± gelebilir. Sistem gelen gÃ¼ncellemeleri takip numarasÄ±na gÃ¶re iÅŸler. GÃ¼ncellemeler kargo geÃ§miÅŸine kaydedilir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("update-shipment-status")]
public async Task<IActionResult> UpdateShipmentStatus(string trackingNumber, string status, string location, int locationId)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var shipment = await _context.Shipments
            .FromSqlRaw("SELECT * FROM Shipments WHERE tracking_number = {0} FOR UPDATE", trackingNumber)
            .FirstOrDefaultAsync();
            
        if (shipment == null)
        {
            return BadRequest("Shipment not found");
        }
        
        shipment.Status = status;
        shipment.CurrentLocation = location;
        shipment.LastUpdated = DateTime.UtcNow;
        
        var statusHistory = new ShipmentHistory
        {
            TrackingNumber = trackingNumber,
            Status = status,
            Location = location,
            LocationId = locationId,
            UpdatedAt = DateTime.UtcNow
        };
        
        _context.ShipmentHistories.Add(statusHistory);
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok("Shipment status updated successfully");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("Status update failed");
    }
}
```

---

### ğŸ§ª Senaryo 7: Bir kargo sistemi aynÄ± kargo iÃ§in birden fazla gÃ¼ncelleme alabilir. FarklÄ± noktalarda durum gÃ¼ncellemeleri eÅŸzamanlÄ± gelebilir. Sistem gelen gÃ¼ncellemeleri takip numarasÄ±na gÃ¶re iÅŸler. GÃ¼ncellemeler kargo geÃ§miÅŸine kaydedilir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/update-shipment-status', methods=['POST'])
def update_shipment_status():
    data = request.get_json()
    tracking_number = data['tracking_number']
    status = data['status']
    location = data['location']
    location_id = data['location_id']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT id FROM shipments WHERE tracking_number = ? FOR UPDATE", (tracking_number,))
        result = cursor.fetchone()
        
        if not result:
            connection.rollback()
            return jsonify({"error": "Shipment not found"}), 404
            
        cursor.execute("UPDATE shipments SET status = ?, current_location = ?, last_updated = datetime('now') WHERE tracking_number = ?",
                      (status, location, tracking_number))
        cursor.execute("INSERT INTO shipment_history (tracking_number, status, location, location_id, updated_at) VALUES (?, ?, ?, ?, datetime('now'))",
                      (tracking_number, status, location, location_id))
        
        connection.commit()
        return jsonify({"message": "Shipment status updated successfully"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "Status update failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 7: Bir kargo sistemi aynÄ± kargo iÃ§in birden fazla gÃ¼ncelleme alabilir. FarklÄ± noktalarda durum gÃ¼ncellemeleri eÅŸzamanlÄ± gelebilir. Sistem gelen gÃ¼ncellemeleri takip numarasÄ±na gÃ¶re iÅŸler. GÃ¼ncellemeler kargo geÃ§miÅŸine kaydedilir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/update-shipment-status', async (req, res) => {
    const { trackingNumber, status, location, locationId } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const shipmentResult = await client.query(
            'SELECT id FROM shipments WHERE tracking_number = $1 FOR UPDATE',
            [trackingNumber]
        );
        
        if (shipmentResult.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Shipment not found' });
        }
        
        await client.query(
            'UPDATE shipments SET status = $1, current_location = $2, last_updated = NOW() WHERE tracking_number = $3',
            [status, location, trackingNumber]
        );
        
        await client.query(
            'INSERT INTO shipment_history (tracking_number, status, location, location_id, updated_at) VALUES ($1, $2, $3, $4, NOW())',
            [trackingNumber, status, location, locationId]
        );
        
        await client.query('COMMIT');
        res.json({ message: 'Shipment status updated successfully' });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'Status update failed' });
    } finally {
        client.release();
    }
});
```

---

### ğŸ§ª Senaryo 8: Bir forum uygulamasÄ±nda kullanÄ±cÄ±lar mesaj gÃ¶ndermeye Ã§alÄ±ÅŸabilir. AynÄ± konuya birden fazla yanÄ±t eÅŸzamanlÄ± gÃ¶nderilebilir. Sistem mesajlarÄ± sÄ±ralÄ± ÅŸekilde iÅŸler ve kayÄ±t altÄ±na alÄ±r. GÃ¶nderilen mesajlar konu altÄ±nda gÃ¶rÃ¼ntÃ¼lenir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("post-message")]
public async Task<IActionResult> PostMessage(int topicId, int userId, string content)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var topic = await _context.Topics
            .FromSqlRaw("SELECT * FROM Topics WHERE id = {0} FOR UPDATE", topicId)
            .FirstOrDefaultAsync();
            
        if (topic == null)
        {
            return BadRequest("Topic not found");
        }
        
        var message = new Message
        {
            TopicId = topicId,
            UserId = userId,
            Content = content,
            PostedAt = DateTime.UtcNow,
            MessageOrder = topic.MessageCount + 1
        };
        
        topic.MessageCount++;
        topic.LastMessageAt = DateTime.UtcNow;
        topic.LastMessageBy = userId;
        
        _context.Messages.Add(message);
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok("Message posted successfully");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("Message posting failed");
    }
}
```

---

### ğŸ§ª Senaryo 8: Bir forum uygulamasÄ±nda kullanÄ±cÄ±lar mesaj gÃ¶ndermeye Ã§alÄ±ÅŸabilir. AynÄ± konuya birden fazla yanÄ±t eÅŸzamanlÄ± gÃ¶nderilebilir. Sistem mesajlarÄ± sÄ±ralÄ± ÅŸekilde iÅŸler ve kayÄ±t altÄ±na alÄ±r. GÃ¶nderilen mesajlar konu altÄ±nda gÃ¶rÃ¼ntÃ¼lenir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/post-message', methods=['POST'])
def post_message():
    data = request.get_json()
    topic_id = data['topic_id']
    user_id = data['user_id']
    content = data['content']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT message_count FROM topics WHERE id = ? FOR UPDATE", (topic_id,))
        result = cursor.fetchone()
        
        if not result:
            connection.rollback()
            return jsonify({"error": "Topic not found"}), 404
            
        message_order = result[0] + 1
        cursor.execute("INSERT INTO messages (topic_id, user_id, content, posted_at, message_order) VALUES (?, ?, ?, datetime('now'), ?)",
                      (topic_id, user_id, content, message_order))
        cursor.execute("UPDATE topics SET message_count = message_count + 1, last_message_at = datetime('now'), last_message_by = ? WHERE id = ?",
                      (user_id, topic_id))
        
        connection.commit()
        return jsonify({"message": "Message posted successfully"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "Message posting failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 8: Bir forum uygulamasÄ±nda kullanÄ±cÄ±lar mesaj gÃ¶ndermeye Ã§alÄ±ÅŸabilir. AynÄ± konuya birden fazla yanÄ±t eÅŸzamanlÄ± gÃ¶nderilebilir. Sistem mesajlarÄ± sÄ±ralÄ± ÅŸekilde iÅŸler ve kayÄ±t altÄ±na alÄ±r. GÃ¶nderilen mesajlar konu altÄ±nda gÃ¶rÃ¼ntÃ¼lenir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/post-message', async (req, res) => {
    const { topicId, userId, content } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const topicResult = await client.query(
            'SELECT message_count FROM topics WHERE id = $1 FOR UPDATE',
            [topicId]
        );
        
        if (topicResult.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Topic not found' });
        }
        
        const messageOrder = topicResult.rows[0].message_count + 1;
        
        await client.query(
            'INSERT INTO messages (topic_id, user_id, content, posted_at, message_order) VALUES ($1, $2, $3, NOW(), $4)',
            [topicId, userId, content, messageOrder]
        );
        
        await client.query(
            'UPDATE topics SET message_count = message_count + 1, last_message_at = NOW(), last_message_by = $1 WHERE id = $2',
            [userId, topicId]
        );
        
        await client.query('COMMIT');
        res.json({ message: 'Message posted successfully' });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'Message posting failed' });
    } finally {
        client.release();
    }
});
```

---

### ğŸ§ª Senaryo 9: Bir oyun platformunda oyuncular puanlarÄ±nÄ± gÃ¼ncelleyebilir. FarklÄ± oyunlardan aynÄ± anda puan gÃ¼ncellemeleri gelebilir. Sistem toplam puanÄ± hesaplar ve liderlik tablosunu gÃ¼nceller. Puan deÄŸiÅŸiklikleri oyuncu profilinde gÃ¶rÃ¼ntÃ¼lenir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("update-score")]
public async Task<IActionResult> UpdateScore(int playerId, int gameId, int scoreToAdd)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var player = await _context.Players
            .FromSqlRaw("SELECT * FROM Players WHERE id = {0} FOR UPDATE", playerId)
            .FirstOrDefaultAsync();
            
        if (player == null)
        {
            return BadRequest("Player not found");
        }
        
        player.TotalScore += scoreToAdd;
        
        var scoreUpdate = new ScoreHistory
        {
            PlayerId = playerId,
            GameId = gameId,
            ScoreAdded = scoreToAdd,
            UpdatedAt = DateTime.UtcNow
        };
        
        await _context.Database.ExecuteSqlRawAsync(
            "UPDATE Leaderboards SET total_score = {0} WHERE player_id = {1}", 
            player.TotalScore, playerId);
        
        _context.ScoreHistories.Add(scoreUpdate);
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok($"Score updated successfully. New total: {player.TotalScore}");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("Score update failed");
    }
}
```

---

### ğŸ§ª Senaryo 9: Bir oyun platformunda oyuncular puanlarÄ±nÄ± gÃ¼ncelleyebilir. FarklÄ± oyunlardan aynÄ± anda puan gÃ¼ncellemeleri gelebilir. Sistem toplam puanÄ± hesaplar ve liderlik tablosunu gÃ¼nceller. Puan deÄŸiÅŸiklikleri oyuncu profilinde gÃ¶rÃ¼ntÃ¼lenir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/update-score', methods=['POST'])
def update_score():
    data = request.get_json()
    player_id = data['player_id']
    game_id = data['game_id']
    score_to_add = data['score_to_add']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT total_score FROM players WHERE id = ? FOR UPDATE", (player_id,))
        result = cursor.fetchone()
        
        if not result:
            connection.rollback()
            return jsonify({"error": "Player not found"}), 404
            
        new_total = result[0] + score_to_add
        cursor.execute("UPDATE players SET total_score = ? WHERE id = ?", (new_total, player_id))
        cursor.execute("UPDATE leaderboards SET total_score = ? WHERE player_id = ?", (new_total, player_id))
        cursor.execute("INSERT INTO score_history (player_id, game_id, score_added, updated_at) VALUES (?, ?, ?, datetime('now'))",
                      (player_id, game_id, score_to_add))
        
        connection.commit()
        return jsonify({"message": f"Score updated successfully. New total: {new_total}"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "Score update failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 9: Bir oyun platformunda oyuncular puanlarÄ±nÄ± gÃ¼ncelleyebilir. FarklÄ± oyunlardan aynÄ± anda puan gÃ¼ncellemeleri gelebilir. Sistem toplam puanÄ± hesaplar ve liderlik tablosunu gÃ¼nceller. Puan deÄŸiÅŸiklikleri oyuncu profilinde gÃ¶rÃ¼ntÃ¼lenir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/update-score', async (req, res) => {
    const { playerId, gameId, scoreToAdd } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const playerResult = await client.query(
            'SELECT total_score FROM players WHERE id = $1 FOR UPDATE',
            [playerId]
        );
        
        if (playerResult.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Player not found' });
        }
        
        const newTotal = playerResult.rows[0].total_score + scoreToAdd;
        
        await client.query(
            'UPDATE players SET total_score = $1 WHERE id = $2',
            [newTotal, playerId]
        );
        
        await client.query(
            'UPDATE leaderboards SET total_score = $1 WHERE player_id = $2',
            [newTotal, playerId]
        );
        
        await client.query(
            'INSERT INTO score_history (player_id, game_id, score_added, updated_at) VALUES ($1, $2, $3, NOW())',
            [playerId, gameId, scoreToAdd]
        );
        
        await client.query('COMMIT');
        res.json({ message: `Score updated successfully. New total: ${newTotal}` });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'Score update failed' });
    } finally {
        client.release();
    }
});
```

---

### ğŸ§ª Senaryo 10: Bir etkinlik kayÄ±t sisteminde katÄ±lÄ±mcÄ±lar aynÄ± etkinliÄŸe kaydolabilir. Kontenjan dolmak Ã¼zereyken birden fazla kayÄ±t iÅŸlemi baÅŸlatÄ±labilir. Sistem mevcut katÄ±lÄ±mcÄ± sayÄ±sÄ±nÄ± kontrol eder ve uygun kayÄ±tlarÄ± onaylar. KayÄ±t iÅŸlemleri etkinlik listesinde gÃ¶sterilir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("register-event")]
public async Task<IActionResult> RegisterEvent(int eventId, int participantId)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var eventItem = await _context.Events
            .FromSqlRaw("SELECT * FROM Events WHERE id = {0} FOR UPDATE", eventId)
            .FirstOrDefaultAsync();
            
        if (eventItem == null)
        {
            return BadRequest("Event not found");
        }
        
        if (eventItem.CurrentParticipants >= eventItem.MaxParticipants)
        {
            return BadRequest("Event is full");
        }
        
        var existingRegistration = await _context.EventRegistrations
            .Where(r => r.EventId == eventId && r.ParticipantId == participantId)
            .FirstOrDefaultAsync();
            
        if (existingRegistration != null)
        {
            return BadRequest("Already registered for this event");
        }
        
        eventItem.CurrentParticipants++;
        
        var registration = new EventRegistration
        {
            EventId = eventId,
            ParticipantId = participantId,
            RegisteredAt = DateTime.UtcNow,
            Status = "Confirmed"
        };
        
        _context.EventRegistrations.Add(registration);
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
        
        return Ok("Event registration successful");
    }
    catch
    {
        await transaction.RollbackAsync();
        return BadRequest("Event registration failed");
    }
}
```

---

### ğŸ§ª Senaryo 10: Bir etkinlik kayÄ±t sisteminde katÄ±lÄ±mcÄ±lar aynÄ± etkinliÄŸe kaydolabilir. Kontenjan dolmak Ã¼zereyken birden fazla kayÄ±t iÅŸlemi baÅŸlatÄ±labilir. Sistem mevcut katÄ±lÄ±mcÄ± sayÄ±sÄ±nÄ± kontrol eder ve uygun kayÄ±tlarÄ± onaylar. KayÄ±t iÅŸlemleri etkinlik listesinde gÃ¶sterilir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
@app.route('/register-event', methods=['POST'])
def register_event():
    data = request.get_json()
    event_id = data['event_id']
    participant_id = data['participant_id']
    
    connection = get_db_connection()
    cursor = connection.cursor()
    
    try:
        connection.execute("BEGIN TRANSACTION")
        
        cursor.execute("SELECT current_participants, max_participants FROM events WHERE id = ? FOR UPDATE", (event_id,))
        result = cursor.fetchone()
        
        if not result:
            connection.rollback()
            return jsonify({"error": "Event not found"}), 404
            
        current_participants, max_participants = result
        if current_participants >= max_participants:
            connection.rollback()
            return jsonify({"error": "Event is full"}), 400
            
        cursor.execute("SELECT id FROM event_registrations WHERE event_id = ? AND participant_id = ?", 
                      (event_id, participant_id))
        existing = cursor.fetchone()
        
        if existing:
            connection.rollback()
            return jsonify({"error": "Already registered for this event"}), 400
            
        cursor.execute("UPDATE events SET current_participants = current_participants + 1 WHERE id = ?", (event_id,))
        cursor.execute("INSERT INTO event_registrations (event_id, participant_id, registered_at, status) VALUES (?, ?, datetime('now'), 'confirmed')",
                      (event_id, participant_id))
        
        connection.commit()
        return jsonify({"message": "Event registration successful"})
        
    except Exception as e:
        connection.rollback()
        return jsonify({"error": "Event registration failed"}), 500
    finally:
        connection.close()
```

---

### ğŸ§ª Senaryo 10: Bir etkinlik kayÄ±t sisteminde katÄ±lÄ±mcÄ±lar aynÄ± etkinliÄŸe kaydolabilir. Kontenjan dolmak Ã¼zereyken birden fazla kayÄ±t iÅŸlemi baÅŸlatÄ±labilir. Sistem mevcut katÄ±lÄ±mcÄ± sayÄ±sÄ±nÄ± kontrol eder ve uygun kayÄ±tlarÄ± onaylar. KayÄ±t iÅŸlemleri etkinlik listesinde gÃ¶sterilir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
app.post('/register-event', async (req, res) => {
    const { eventId, participantId } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        
        const eventResult = await client.query(
            'SELECT current_participants, max_participants FROM events WHERE id = $1 FOR UPDATE',
            [eventId]
        );
        
        if (eventResult.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Event not found' });
        }
        
        const { current_participants, max_participants } = eventResult.rows[0];
        if (current_participants >= max_participants) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Event is full' });
        }
        
        const existingResult = await client.query(
            'SELECT id FROM event_registrations WHERE event_id = $1 AND participant_id = $2',
            [eventId, participantId]
        );
        
        if (existingResult.rows.length > 0) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Already registered for this event' });
        }
        
        await client.query(
            'UPDATE events SET current_participants = current_participants + 1 WHERE id = $1',
            [eventId]
        );
        
        await client.query(
            'INSERT INTO event_registrations (event_id, participant_id, registered_at, status) VALUES ($1, $2, NOW(), $3)',
            [eventId, participantId, 'confirmed']
        );
        
        await client.query('COMMIT');
        res.json({ message: 'Event registration successful' });
        
    } catch (error) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: 'Event registration failed' });
    } finally {
        client.release();
    }
});
```

---