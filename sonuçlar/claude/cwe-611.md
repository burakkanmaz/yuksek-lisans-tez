 ### ğŸ§ª Senaryo 1: Bir dÃ¶kÃ¼man yÃ¶netim sisteminde kullanÄ±cÄ±lar XML dosyalarÄ±nÄ± yÃ¼kleyebiliyor. Sistem bu dosyalarÄ± okuyarak iÃ§erik verilerini Ã§Ä±karÄ±yor. XML dosyalarÄ± Ã§eÅŸitli yapÄ±larda olabilir ve sistem bunlarÄ± iÅŸleyebilir. YÃ¼klenen dÃ¶kÃ¼manlar sisteme entegre edilir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("upload-document")]
public async Task<IActionResult> UploadDocument(IFormFile xmlFile)
{
    if (xmlFile == null || !xmlFile.FileName.EndsWith(".xml"))
        return BadRequest("Invalid XML file");

    try
    {
        using var stream = xmlFile.OpenReadStream();
        var document = XDocument.Load(stream);
        
        var documentInfo = new DocumentInfo
        {
            Title = document.Root?.Element("title")?.Value ?? "Untitled",
            Content = document.Root?.Element("content")?.Value ?? "",
            Author = document.Root?.Element("author")?.Value ?? "Unknown",
            CreatedDate = DateTime.Now,
            FileSize = xmlFile.Length
        };

        await _documentRepository.SaveAsync(documentInfo);
        return Ok(new { Message = "Document uploaded successfully", Id = documentInfo.Id });
    }
    catch (XmlException ex)
    {
        return BadRequest($"Invalid XML format: {ex.Message}");
    }
}

public class DocumentInfo
{
    public int Id { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }
    public string Author { get; set; }
    public DateTime CreatedDate { get; set; }
    public long FileSize { get; set; }
}
```

----

### ğŸ§ª Senaryo 1: Bir dÃ¶kÃ¼man yÃ¶netim sisteminde kullanÄ±cÄ±lar XML dosyalarÄ±nÄ± yÃ¼kleyebiliyor. Sistem bu dosyalarÄ± okuyarak iÃ§erik verilerini Ã§Ä±karÄ±yor. XML dosyalarÄ± Ã§eÅŸitli yapÄ±larda olabilir ve sistem bunlarÄ± iÅŸleyebilir. YÃ¼klenen dÃ¶kÃ¼manlar sisteme entegre edilir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import xml.etree.ElementTree as ET
from datetime import datetime
from flask import Flask, request, jsonify
import sqlite3

app = Flask(__name__)

@app.route('/upload-document', methods=['POST'])
def upload_document():
    if 'xmlFile' not in request.files:
        return jsonify({'error': 'No XML file provided'}), 400
    
    xml_file = request.files['xmlFile']
    
    if not xml_file.filename.endswith('.xml'):
        return jsonify({'error': 'Invalid file format'}), 400
    
    try:
        # Parse XML content
        xml_content = xml_file.read().decode('utf-8')
        root = ET.fromstring(xml_content)
        
        # Extract document information
        title = root.find('title').text if root.find('title') is not None else 'Untitled'
        content = root.find('content').text if root.find('content') is not None else ''
        author = root.find('author').text if root.find('author') is not None else 'Unknown'
        
        # Save to database
        conn = sqlite3.connect('documents.db')
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO documents (title, content, author, created_date, file_size)
            VALUES (?, ?, ?, ?, ?)
        ''', (title, content, author, datetime.now(), len(xml_content)))
        
        document_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return jsonify({
            'message': 'Document uploaded successfully',
            'id': document_id
        }), 200
        
    except ET.ParseError as e:
        return jsonify({'error': f'Invalid XML format: {str(e)}'}), 400
```

----

### ğŸ§ª Senaryo 1: Bir dÃ¶kÃ¼man yÃ¶netim sisteminde kullanÄ±cÄ±lar XML dosyalarÄ±nÄ± yÃ¼kleyebiliyor. Sistem bu dosyalarÄ± okuyarak iÃ§erik verilerini Ã§Ä±karÄ±yor. XML dosyalarÄ± Ã§eÅŸitli yapÄ±larda olabilir ve sistem bunlarÄ± iÅŸleyebilir. YÃ¼klenen dÃ¶kÃ¼manlar sisteme entegre edilir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import multer from 'multer';
import { parseString } from 'xml2js';
import { Database } from 'sqlite3';

const app = express();
const upload = multer({ dest: 'uploads/' });
const db = new Database('documents.db');

interface DocumentInfo {
    title: string;
    content: string;
    author: string;
    createdDate: Date;
    fileSize: number;
}

app.post('/upload-document', upload.single('xmlFile'), (req, res) => {
    if (!req.file || !req.file.originalname.endsWith('.xml')) {
        return res.status(400).json({ error: 'Invalid XML file' });
    }

    const fs = require('fs');
    const xmlContent = fs.readFileSync(req.file.path, 'utf8');

    parseString(xmlContent, (err, result) => {
        if (err) {
            return res.status(400).json({ error: `Invalid XML format: ${err.message}` });
        }

        const documentInfo: DocumentInfo = {
            title: result.root?.title?.[0] || 'Untitled',
            content: result.root?.content?.[0] || '',
            author: result.root?.author?.[0] || 'Unknown',
            createdDate: new Date(),
            fileSize: xmlContent.length
        };

        db.run(
            'INSERT INTO documents (title, content, author, created_date, file_size) VALUES (?, ?, ?, ?, ?)',
            [documentInfo.title, documentInfo.content, documentInfo.author, documentInfo.createdDate, documentInfo.fileSize],
            function(err) {
                if (err) {
                    return res.status(500).json({ error: 'Database error' });
                }
                res.json({ message: 'Document uploaded successfully', id: this.lastID });
            }
        );
    });
});
```

----

### ğŸ§ª Senaryo 2: Bir yapÄ±landÄ±rma uygulamasÄ±nda ayar dosyalarÄ± XML formatÄ±nda tutulur. KullanÄ±cÄ±lar bu dosyalarÄ± dÃ¼zenleyip sisteme yÃ¼kleyebilir. Uygulama XML iÃ§eriÄŸini okuyarak ayarlarÄ± gÃ¼nceller. YapÄ±landÄ±rma verileri uygulamada aktif hale gelir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("update-config")]
public async Task<IActionResult> UpdateConfiguration(IFormFile configFile)
{
    try
    {
        using var stream = configFile.OpenReadStream();
        var configXml = XDocument.Load(stream);
        
        var settings = new Dictionary<string, string>();
        
        foreach (var setting in configXml.Root.Elements("setting"))
        {
            var key = setting.Attribute("key")?.Value;
            var value = setting.Attribute("value")?.Value;
            
            if (!string.IsNullOrEmpty(key) && value != null)
                settings[key] = value;
        }
        
        // Update application configuration
        await _configService.UpdateSettingsAsync(settings);
        
        // Apply configuration immediately
        _configService.ReloadConfiguration();
        
        return Ok(new { Message = "Configuration updated successfully", SettingsCount = settings.Count });
    }
    catch (Exception ex)
    {
        return BadRequest($"Configuration update failed: {ex.Message}");
    }
}

public class ConfigurationService
{
    public async Task UpdateSettingsAsync(Dictionary<string, string> settings)
    {
        foreach (var setting in settings)
        {
            await _settingsRepository.UpsertAsync(setting.Key, setting.Value);
        }
    }
    
    public void ReloadConfiguration()
    {
        // Trigger application configuration reload
        _configuration.Reload();
    }
}
```

----

### ğŸ§ª Senaryo 2: Bir yapÄ±landÄ±rma uygulamasÄ±nda ayar dosyalarÄ± XML formatÄ±nda tutulur. KullanÄ±cÄ±lar bu dosyalarÄ± dÃ¼zenleyip sisteme yÃ¼kleyebilir. Uygulama XML iÃ§eriÄŸini okuyarak ayarlarÄ± gÃ¼nceller. YapÄ±landÄ±rma verileri uygulamada aktif hale gelir.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import xml.etree.ElementTree as ET
import json
from flask import Flask, request, jsonify
import sqlite3

app = Flask(__name__)
current_config = {}

@app.route('/update-config', methods=['POST'])
def update_configuration():
    global current_config
    
    if 'configFile' not in request.files:
        return jsonify({'error': 'No configuration file provided'}), 400
    
    config_file = request.files['configFile']
    
    try:
        xml_content = config_file.read().decode('utf-8')
        root = ET.fromstring(xml_content)
        
        settings = {}
        
        for setting in root.findall('setting'):
            key = setting.get('key')
            value = setting.get('value')
            
            if key and value is not None:
                settings[key] = value
        
        # Update database
        conn = sqlite3.connect('config.db')
        cursor = conn.cursor()
        
        for key, value in settings.items():
            cursor.execute('''
                INSERT OR REPLACE INTO settings (key, value, updated_at)
                VALUES (?, ?, datetime('now'))
            ''', (key, value))
        
        conn.commit()
        conn.close()
        
        # Apply configuration immediately
        current_config.update(settings)
        
        return jsonify({
            'message': 'Configuration updated successfully',
            'settings_count': len(settings)
        }), 200
        
    except ET.ParseError as e:
        return jsonify({'error': f'Invalid XML format: {str(e)}'}), 400

def get_config_value(key, default=None):
    return current_config.get(key, default)
```

----

### ğŸ§ª Senaryo 2: Bir yapÄ±landÄ±rma uygulamasÄ±nda ayar dosyalarÄ± XML formatÄ±nda tutulur. KullanÄ±cÄ±lar bu dosyalarÄ± dÃ¼zenleyip sisteme yÃ¼kleyebilir. Uygulama XML iÃ§eriÄŸini okuyarak ayarlarÄ± gÃ¼nceller. YapÄ±landÄ±rma verileri uygulamada aktif hale gelir.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import multer from 'multer';
import { parseString } from 'xml2js';
import { Database } from 'sqlite3';

const app = express();
const upload = multer({ dest: 'uploads/' });
const db = new Database('config.db');

let currentConfig: { [key: string]: string } = {};

interface ConfigSetting {
    key: string;
    value: string;
}

app.post('/update-config', upload.single('configFile'), (req, res) => {
    if (!req.file) {
        return res.status(400).json({ error: 'No configuration file provided' });
    }

    const fs = require('fs');
    const xmlContent = fs.readFileSync(req.file.path, 'utf8');

    parseString(xmlContent, (err, result) => {
        if (err) {
            return res.status(400).json({ error: `Invalid XML format: ${err.message}` });
        }

        const settings: ConfigSetting[] = [];
        
        if (result.root && result.root.setting) {
            result.root.setting.forEach((setting: any) => {
                if (setting.$ && setting.$.key && setting.$.value !== undefined) {
                    settings.push({
                        key: setting.$.key,
                        value: setting.$.value
                    });
                }
            });
        }

        // Update database and current config
        settings.forEach(setting => {
            db.run(
                'INSERT OR REPLACE INTO settings (key, value, updated_at) VALUES (?, ?, datetime("now"))',
                [setting.key, setting.value]
            );
            currentConfig[setting.key] = setting.value;
        });

        res.json({
            message: 'Configuration updated successfully',
            settings_count: settings.length
        });
    });
});

export function getConfigValue(key: string, defaultValue?: string): string | undefined {
    return currentConfig[key] || defaultValue;
}
```

----

### ğŸ§ª Senaryo 3: Bir veri dÃ¶nÃ¼ÅŸtÃ¼rme servisi farklÄ± formatlarÄ± XML'e Ã§evirir. KullanÄ±cÄ±lar kaynak dosyalarÄ±nÄ± yÃ¼kleyerek dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi baÅŸlatÄ±r. Sistem XML Ã§Ä±ktÄ±sÄ±nÄ± oluÅŸturur ve iÅŸler. DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ veriler kullanÄ±cÄ±ya sunulur.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("convert-to-xml")]
public async Task<IActionResult> ConvertToXml(IFormFile sourceFile, string targetFormat = "xml")
{
    if (sourceFile == null)
        return BadRequest("No source file provided");

    try
    {
        string xmlContent = await ConvertFileToXml(sourceFile);
        
        var conversionResult = new ConversionResult
        {
            OriginalFileName = sourceFile.FileName,
            ConvertedFileName = Path.ChangeExtension(sourceFile.FileName, ".xml"),
            ConversionDate = DateTime.Now,
            XmlContent = xmlContent,
            Success = true
        };

        await _conversionRepository.SaveAsync(conversionResult);
        
        return Ok(new { 
            Message = "File converted successfully", 
            XmlContent = xmlContent,
            DownloadUrl = $"/download/{conversionResult.Id}" 
        });
    }
    catch (Exception ex)
    {
        return BadRequest($"Conversion failed: {ex.Message}");
    }
}

private async Task<string> ConvertFileToXml(IFormFile file)
{
    var extension = Path.GetExtension(file.FileName).ToLower();
    
    switch (extension)
    {
        case ".json":
            return await ConvertJsonToXml(file);
        case ".csv":
            return await ConvertCsvToXml(file);
        default:
            throw new NotSupportedException($"File format {extension} is not supported");
    }
}

private async Task<string> ConvertJsonToXml(IFormFile jsonFile)
{
    using var reader = new StreamReader(jsonFile.OpenReadStream());
    var jsonContent = await reader.ReadToEndAsync();
    var jsonDoc = JsonDocument.Parse(jsonContent);
    
    var xmlDoc = new XDocument(new XElement("root"));
    ConvertJsonElementToXml(jsonDoc.RootElement, xmlDoc.Root);
    
    return xmlDoc.ToString();
}
```

----

### ğŸ§ª Senaryo 3: Bir veri dÃ¶nÃ¼ÅŸtÃ¼rme servisi farklÄ± formatlarÄ± XML'e Ã§evirir. KullanÄ±cÄ±lar kaynak dosyalarÄ±nÄ± yÃ¼kleyerek dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi baÅŸlatÄ±r. Sistem XML Ã§Ä±ktÄ±sÄ±nÄ± oluÅŸturur ve iÅŸler. DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ veriler kullanÄ±cÄ±ya sunulur.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import json
import csv
import xml.etree.ElementTree as ET
from flask import Flask, request, jsonify
import sqlite3
from datetime import datetime

app = Flask(__name__)

@app.route('/convert-to-xml', methods=['POST'])
def convert_to_xml():
    if 'sourceFile' not in request.files:
        return jsonify({'error': 'No source file provided'}), 400
    
    source_file = request.files['sourceFile']
    file_extension = source_file.filename.split('.')[-1].lower()
    
    try:
        if file_extension == 'json':
            xml_content = convert_json_to_xml(source_file)
        elif file_extension == 'csv':
            xml_content = convert_csv_to_xml(source_file)
        else:
            return jsonify({'error': f'Unsupported file format: {file_extension}'}), 400
        
        # Save conversion result
        conn = sqlite3.connect('conversions.db')
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO conversions (original_filename, converted_filename, conversion_date, xml_content, success)
            VALUES (?, ?, ?, ?, ?)
        ''', (source_file.filename, source_file.filename.replace(f'.{file_extension}', '.xml'), 
              datetime.now(), xml_content, True))
        
        conversion_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return jsonify({
            'message': 'File converted successfully',
            'xml_content': xml_content,
            'download_url': f'/download/{conversion_id}'
        }), 200
        
    except Exception as e:
        return jsonify({'error': f'Conversion failed: {str(e)}'}), 500

def convert_json_to_xml(json_file):
    json_content = json_file.read().decode('utf-8')
    data = json.loads(json_content)
    
    root = ET.Element('root')
    
    def add_to_xml(element, data):
        if isinstance(data, dict):
            for key, value in data.items():
                child = ET.SubElement(element, key)
                add_to_xml(child, value)
        elif isinstance(data, list):
            for item in data:
                item_element = ET.SubElement(element, 'item')
                add_to_xml(item_element, item)
        else:
            element.text = str(data)
    
    add_to_xml(root, data)
    return ET.tostring(root, encoding='unicode')

def convert_csv_to_xml(csv_file):
    csv_content = csv_file.read().decode('utf-8')
    csv_reader = csv.DictReader(csv_content.splitlines())
    
    root = ET.Element('data')
    
    for row in csv_reader:
        row_element = ET.SubElement(root, 'row')
        for column, value in row.items():
            column_element = ET.SubElement(row_element, column.replace(' ', '_'))
            column_element.text = value
    
    return ET.tostring(root, encoding='unicode')
```

----

### ğŸ§ª Senaryo 3: Bir veri dÃ¶nÃ¼ÅŸtÃ¼rme servisi farklÄ± formatlarÄ± XML'e Ã§evirir. KullanÄ±cÄ±lar kaynak dosyalarÄ±nÄ± yÃ¼kleyerek dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi baÅŸlatÄ±r. Sistem XML Ã§Ä±ktÄ±sÄ±nÄ± oluÅŸturur ve iÅŸler. DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ veriler kullanÄ±cÄ±ya sunulur.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import multer from 'multer';
import { Database } from 'sqlite3';
import * as csv from 'csv-parser';
import { Builder } from 'xml2js';

const app = express();
const upload = multer({ dest: 'uploads/' });
const db = new Database('conversions.db');

interface ConversionResult {
    originalFileName: string;
    convertedFileName: string;
    conversionDate: Date;
    xmlContent: string;
    success: boolean;
}

app.post('/convert-to-xml', upload.single('sourceFile'), async (req, res) => {
    if (!req.file) {
        return res.status(400).json({ error: 'No source file provided' });
    }

    const fileExtension = req.file.originalname.split('.').pop()?.toLowerCase();
    
    try {
        let xmlContent: string;
        
        switch (fileExtension) {
            case 'json':
                xmlContent = await convertJsonToXml(req.file.path);
                break;
            case 'csv':
                xmlContent = await convertCsvToXml(req.file.path);
                break;
            default:
                return res.status(400).json({ error: `Unsupported file format: ${fileExtension}` });
        }

        const conversionResult: ConversionResult = {
            originalFileName: req.file.originalname,
            convertedFileName: req.file.originalname.replace(`.${fileExtension}`, '.xml'),
            conversionDate: new Date(),
            xmlContent,
            success: true
        };

        db.run(
            'INSERT INTO conversions (original_filename, converted_filename, conversion_date, xml_content, success) VALUES (?, ?, ?, ?, ?)',
            [conversionResult.originalFileName, conversionResult.convertedFileName, 
             conversionResult.conversionDate, conversionResult.xmlContent, conversionResult.success],
            function(err) {
                if (err) {
                    return res.status(500).json({ error: 'Database error' });
                }
                res.json({
                    message: 'File converted successfully',
                    xml_content: xmlContent,
                    download_url: `/download/${this.lastID}`
                });
            }
        );

    } catch (error) {
        res.status(500).json({ error: `Conversion failed: ${error.message}` });
    }
});

async function convertJsonToXml(filePath: string): Promise<string> {
    const fs = require('fs');
    const jsonContent = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    
    const builder = new Builder({ rootName: 'root' });
    return builder.buildObject(jsonContent);
}

async function convertCsvToXml(filePath: string): Promise<string> {
    const fs = require('fs');
    const results: any[] = [];
    
    return new Promise((resolve, reject) => {
        fs.createReadStream(filePath)
            .pipe(csv())
            .on('data', (data: any) => results.push(data))
            .on('end', () => {
                const builder = new Builder({ rootName: 'data', headless: true });
                const xmlContent = builder.buildObject({ row: results });
                resolve(xmlContent);
            })
            .on('error', reject);
    });
}
```

----

### ğŸ§ª Senaryo 4: Bir raporlama aracÄ±nda ÅŸablon dosyalarÄ± XML formatÄ±nda saklanÄ±r. KullanÄ±cÄ±lar Ã¶zel ÅŸablonlar oluÅŸturarak sisteme yÃ¼kleyebilir. Rapor Ã¼retimi sÄ±rasÄ±nda XML ÅŸablonlarÄ± iÅŸlenir. OluÅŸturulan raporlar ÅŸablon yapÄ±sÄ±na gÃ¶re formatlanÄ±r.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("upload-template")]
public async Task<IActionResult> UploadReportTemplate(IFormFile templateFile)
{
    try
    {
        using var stream = templateFile.OpenReadStream();
        var templateXml = XDocument.Load(stream);
        
        var template = new ReportTemplate
        {
            Name = templateXml.Root?.Attribute("name")?.Value ?? Path.GetFileNameWithoutExtension(templateFile.FileName),
            Category = templateXml.Root?.Attribute("category")?.Value ?? "General",
            XmlContent = templateXml.ToString(),
            CreatedDate = DateTime.Now,
            IsActive = true
        };

        await _templateRepository.SaveAsync(template);
        return Ok(new { Message = "Template uploaded successfully", TemplateId = template.Id });
    }
    catch (Exception ex)
    {
        return BadRequest($"Template upload failed: {ex.Message}");
    }
}

[HttpPost("generate-report")]
public async Task<IActionResult> GenerateReport(int templateId, [FromBody] Dictionary<string, object> data)
{
    try
    {
        var template = await _templateRepository.GetByIdAsync(templateId);
        var templateXml = XDocument.Parse(template.XmlContent);
        
        var reportXml = ProcessTemplate(templateXml, data);
        
        var report = new GeneratedReport
        {
            TemplateId = templateId,
            ReportData = reportXml.ToString(),
            GeneratedDate = DateTime.Now,
            DataHash = CalculateDataHash(data)
        };

        await _reportRepository.SaveAsync(report);
        return Ok(new { ReportXml = reportXml.ToString(), ReportId = report.Id });
    }
    catch (Exception ex)
    {
        return BadRequest($"Report generation failed: {ex.Message}");
    }
}

private XDocument ProcessTemplate(XDocument template, Dictionary<string, object> data)
{
    var result = new XDocument(template);
    
    foreach (var element in result.Descendants())
    {
        if (element.Value.Contains("${"))
        {
            foreach (var kvp in data)
            {
                element.Value = element.Value.Replace($"${{{kvp.Key}}}", kvp.Value?.ToString() ?? "");
            }
        }
    }
    
    return result;
}
```

----

### ğŸ§ª Senaryo 4: Bir raporlama aracÄ±nda ÅŸablon dosyalarÄ± XML formatÄ±nda saklanÄ±r. KullanÄ±cÄ±lar Ã¶zel ÅŸablonlar oluÅŸturarak sisteme yÃ¼kleyebilir. Rapor Ã¼retimi sÄ±rasÄ±nda XML ÅŸablonlarÄ± iÅŸlenir. OluÅŸturulan raporlar ÅŸablon yapÄ±sÄ±na gÃ¶re formatlanÄ±r.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import xml.etree.ElementTree as ET
import hashlib
import json
from flask import Flask, request, jsonify
import sqlite3
from datetime import datetime

app = Flask(__name__)

@app.route('/upload-template', methods=['POST'])
def upload_report_template():
    if 'templateFile' not in request.files:
        return jsonify({'error': 'No template file provided'}), 400
    
    template_file = request.files['templateFile']
    
    try:
        xml_content = template_file.read().decode('utf-8')
        root = ET.fromstring(xml_content)
        
        template_name = root.get('name', template_file.filename.split('.')[0])
        category = root.get('category', 'General')
        
        conn = sqlite3.connect('reports.db')
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO report_templates (name, category, xml_content, created_date, is_active)
            VALUES (?, ?, ?, ?, ?)
        ''', (template_name, category, xml_content, datetime.now(), True))
        
        template_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return jsonify({
            'message': 'Template uploaded successfully',
            'template_id': template_id
        }), 200
        
    except ET.ParseError as e:
        return jsonify({'error': f'Invalid XML template: {str(e)}'}), 400

@app.route('/generate-report', methods=['POST'])
def generate_report():
    data = request.json
    template_id = data.get('template_id')
    report_data = data.get('data', {})
    
    try:
        conn = sqlite3.connect('reports.db')
        cursor = conn.cursor()
        
        cursor.execute('SELECT xml_content FROM report_templates WHERE id = ?', (template_id,))
        template_row = cursor.fetchone()
        
        if not template_row:
            return jsonify({'error': 'Template not found'}), 404
        
        template_xml = template_row[0]
        processed_xml = process_template(template_xml, report_data)
        
        data_hash = hashlib.md5(json.dumps(report_data, sort_keys=True).encode()).hexdigest()
        
        cursor.execute('''
            INSERT INTO generated_reports (template_id, report_data, generated_date, data_hash)
            VALUES (?, ?, ?, ?)
        ''', (template_id, processed_xml, datetime.now(), data_hash))
        
        report_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return jsonify({
            'report_xml': processed_xml,
            'report_id': report_id
        }), 200
        
    except Exception as e:
        return jsonify({'error': f'Report generation failed: {str(e)}'}), 500

def process_template(template_xml, data):
    root = ET.fromstring(template_xml)
    
    def replace_placeholders(element):
        if element.text:
            for key, value in data.items():
                placeholder = f'${{{key}}}'
                if placeholder in element.text:
                    element.text = element.text.replace(placeholder, str(value))
        
        for child in element:
            replace_placeholders(child)
    
    replace_placeholders(root)
    return ET.tostring(root, encoding='unicode')
```

----

### ğŸ§ª Senaryo 4: Bir raporlama aracÄ±nda ÅŸablon dosyalarÄ± XML formatÄ±nda saklanÄ±r. KullanÄ±cÄ±lar Ã¶zel ÅŸablonlar oluÅŸturarak sisteme yÃ¼kleyebilir. Rapor Ã¼retimi sÄ±rasÄ±nda XML ÅŸablonlarÄ± iÅŸlenir. OluÅŸturulan raporlar ÅŸablon yapÄ±sÄ±na gÃ¶re formatlanÄ±r.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import multer from 'multer';
import { parseString, Builder } from 'xml2js';
import { Database } from 'sqlite3';
import * as crypto from 'crypto';

const app = express();
const upload = multer({ dest: 'uploads/' });
const db = new Database('reports.db');

interface ReportTemplate {
    id?: number;
    name: string;
    category: string;
    xmlContent: string;
    createdDate: Date;
    isActive: boolean;
}

interface GeneratedReport {
    id?: number;
    templateId: number;
    reportData: string;
    generatedDate: Date;
    dataHash: string;
}

app.post('/upload-template', upload.single('templateFile'), (req, res) => {
    if (!req.file) {
        return res.status(400).json({ error: 'No template file provided' });
    }

    const fs = require('fs');
    const xmlContent = fs.readFileSync(req.file.path, 'utf8');

    parseString(xmlContent, (err, result) => {
        if (err) {
            return res.status(400).json({ error: `Invalid XML template: ${err.message}` });
        }

        const templateName = result.root?.$?.name || req.file.originalname.split('.')[0];
        const category = result.root?.$?.category || 'General';

        const template: ReportTemplate = {
            name: templateName,
            category,
            xmlContent,
            createdDate: new Date(),
            isActive: true
        };

        db.run(
            'INSERT INTO report_templates (name, category, xml_content, created_date, is_active) VALUES (?, ?, ?, ?, ?)',
            [template.name, template.category, template.xmlContent, template.createdDate, template.isActive],
            function(err) {
                if (err) {
                    return res.status(500).json({ error: 'Database error' });
                }
                res.json({
                    message: 'Template uploaded successfully',
                    template_id: this.lastID
                });
            }
        );
    });
});

app.post('/generate-report', express.json(), (req, res) => {
    const { template_id, data } = req.body;

    db.get('SELECT xml_content FROM report_templates WHERE id = ?', [template_id], (err, row: any) => {
        if (err || !row) {
            return res.status(404).json({ error: 'Template not found' });
        }

        try {
            const processedXml = processTemplate(row.xml_content, data);
            const dataHash = crypto.createHash('md5').update(JSON.stringify(data)).digest('hex');

            const report: GeneratedReport = {
                templateId: template_id,
                reportData: processedXml,
                generatedDate: new Date(),
                dataHash
            };

            db.run(
                'INSERT INTO generated_reports (template_id, report_data, generated_date, data_hash) VALUES (?, ?, ?, ?)',
                [report.templateId, report.reportData, report.generatedDate, report.dataHash],
                function(err) {
                    if (err) {
                        return res.status(500).json({ error: 'Database error' });
                    }
                    res.json({
                        report_xml: processedXml,
                        report_id: this.lastID
                    });
                }
            );
        } catch (error) {
            res.status(500).json({ error: `Report generation failed: ${error.message}` });
        }
    });
});

function processTemplate(templateXml: string, data: { [key: string]: any }): string {
    let processedXml = templateXml;
    
    for (const [key, value] of Object.entries(data)) {
        const placeholder = `\${${key}}`;
        processedXml = processedXml.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), String(value));
    }
    
    return processedXml;
}
```

----

### ğŸ§ª Senaryo 5: Bir API entegrasyon platformu XML tabanlÄ± mesajlar alÄ±r. Ä°stemci uygulamalar XML formatÄ±nda veri gÃ¶nderir. Platform bu verileri iÅŸleyerek iÅŸ mantÄ±ÄŸÄ±nÄ± yÃ¼rÃ¼tÃ¼r. YanÄ±t mesajlarÄ± yine XML formatÄ±nda dÃ¶nÃ¼lÃ¼r.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("process-xml-message")]
[Consumes("application/xml")]
public async Task<IActionResult> ProcessXmlMessage([FromBody] XElement xmlMessage)
{
    try
    {
        var messageType = xmlMessage.Name.LocalName;
        var messageId = xmlMessage.Attribute("id")?.Value ?? Guid.NewGuid().ToString();
        
        var response = messageType switch
        {
            "OrderRequest" => await ProcessOrderRequest(xmlMessage),
            "PaymentRequest" => await ProcessPaymentRequest(xmlMessage),
            "StatusQuery" => await ProcessStatusQuery(xmlMessage),
            _ => CreateErrorResponse(messageId, "Unknown message type")
        };

        await LogMessageAsync(messageId, messageType, xmlMessage.ToString(), response.ToString());
        
        return Content(response.ToString(), "application/xml");
    }
    catch (Exception ex)
    {
        var errorResponse = CreateErrorResponse("unknown", ex.Message);
        return Content(errorResponse.ToString(), "application/xml");
    }
}

private async Task<XElement> ProcessOrderRequest(XElement orderRequest)
{
    var orderId = orderRequest.Element("orderId")?.Value;
    var customerId = orderRequest.Element("customerId")?.Value;
    var amount = decimal.Parse(orderRequest.Element("amount")?.Value ?? "0");
    
    var order = new Order
    {
        Id = orderId,
        CustomerId = customerId,
        Amount = amount,
        Status = "Processing",
        CreatedDate = DateTime.Now
    };

    await _orderService.CreateOrderAsync(order);
    
    return new XElement("OrderResponse",
        new XAttribute("id", orderId),
        new XElement("status", "Accepted"),
        new XElement("orderId", orderId),
        new XElement("estimatedDelivery", DateTime.Now.AddDays(3).ToString("yyyy-MM-dd")),
        new XElement("timestamp", DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss"))
    );
}

private XElement CreateErrorResponse(string messageId, string errorMessage)
{
    return new XElement("ErrorResponse",
        new XAttribute("id", messageId),
        new XElement("error", errorMessage),
        new XElement("timestamp", DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss"))
    );
}
```

----

### ğŸ§ª Senaryo 5: Bir API entegrasyon platformu XML tabanlÄ± mesajlar alÄ±r. Ä°stemci uygulamalar XML formatÄ±nda veri gÃ¶nderir. Platform bu verileri iÅŸleyerek iÅŸ mantÄ±ÄŸÄ±nÄ± yÃ¼rÃ¼tÃ¼r. YanÄ±t mesajlarÄ± yine XML formatÄ±nda dÃ¶nÃ¼lÃ¼r.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import xml.etree.ElementTree as ET
from flask import Flask, request, Response
import sqlite3
from datetime import datetime, timedelta
import uuid

app = Flask(__name__)

@app.route('/process-xml-message', methods=['POST'])
def process_xml_message():
    try:
        xml_content = request.data.decode('utf-8')
        root = ET.fromstring(xml_content)
        
        message_type = root.tag
        message_id = root.get('id', str(uuid.uuid4()))
        
        if message_type == 'OrderRequest':
            response = process_order_request(root)
        elif message_type == 'PaymentRequest':
            response = process_payment_request(root)
        elif message_type == 'StatusQuery':
            response = process_status_query(root)
        else:
            response = create_error_response(message_id, 'Unknown message type')
        
        log_message(message_id, message_type, xml_content, ET.tostring(response, encoding='unicode'))
        
        return Response(ET.tostring(response, encoding='unicode'), content_type='application/xml')
        
    except ET.ParseError as e:
        error_response = create_error_response('unknown', f'Invalid XML: {str(e)}')
        return Response(ET.tostring(error_response, encoding='unicode'), content_type='application/xml')
    except Exception as e:
        error_response = create_error_response('unknown', str(e))
        return Response(ET.tostring(error_response, encoding='unicode'), content_type='application/xml')

def process_order_request(order_request):
    order_id = order_request.find('orderId').text if order_request.find('orderId') is not None else None
    customer_id = order_request.find('customerId').text if order_request.find('customerId') is not None else None
    amount = float(order_request.find('amount').text) if order_request.find('amount') is not None else 0
    
    # Save order to database
    conn = sqlite3.connect('orders.db')
    cursor = conn.cursor()
    
    cursor.execute('''
        INSERT INTO orders (id, customer_id, amount, status, created_date)
        VALUES (?, ?, ?, ?, ?)
    ''', (order_id, customer_id, amount, 'Processing', datetime.now()))
    
    conn.commit()
    conn.close()
    
    # Create response XML
    response = ET.Element('OrderResponse')
    response.set('id', order_id)
    
    ET.SubElement(response, 'status').text = 'Accepted'
    ET.SubElement(response, 'orderId').text = order_id
    ET.SubElement(response, 'estimatedDelivery').text = (datetime.now() + timedelta(days=3)).strftime('%Y-%m-%d')
    ET.SubElement(response, 'timestamp').text = datetime.now().isoformat()
    
    return response

def process_payment_request(payment_request):
    payment_id = payment_request.find('paymentId').text
    amount = float(payment_request.find('amount').text)
    
    response = ET.Element('PaymentResponse')
    response.set('id', payment_id)
    
    ET.SubElement(response, 'status').text = 'Processed'
    ET.SubElement(response, 'transactionId').text = str(uuid.uuid4())
    ET.SubElement(response, 'timestamp').text = datetime.now().isoformat()
    
    return response

def process_status_query(status_query):
    query_id = status_query.find('queryId').text
    
    response = ET.Element('StatusResponse')
    response.set('id', query_id)
    
    ET.SubElement(response, 'status').text = 'Active'
    ET.SubElement(response, 'timestamp').text = datetime.now().isoformat()
    
    return response

def create_error_response(message_id, error_message):
    response = ET.Element('ErrorResponse')
    response.set('id', message_id)
    
    ET.SubElement(response, 'error').text = error_message
    ET.SubElement(response, 'timestamp').text = datetime.now().isoformat()
    
    return response

def log_message(message_id, message_type, request_xml, response_xml):
    conn = sqlite3.connect('messages.db')
    cursor = conn.cursor()
    
    cursor.execute('''
        INSERT INTO message_log (message_id, message_type, request_xml, response_xml, processed_date)
        VALUES (?, ?, ?, ?, ?)
    ''', (message_id, message_type, request_xml, response_xml, datetime.now()))
    
    conn.commit()
    conn.close()
```

----

### ğŸ§ª Senaryo 5: Bir API entegrasyon platformu XML tabanlÄ± mesajlar alÄ±r. Ä°stemci uygulamalar XML formatÄ±nda veri gÃ¶nderir. Platform bu verileri iÅŸleyerek iÅŸ mantÄ±ÄŸÄ±nÄ± yÃ¼rÃ¼tÃ¼r. YanÄ±t mesajlarÄ± yine XML formatÄ±nda dÃ¶nÃ¼lÃ¼r.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import { parseString, Builder } from 'xml2js';
import { Database } from 'sqlite3';
import { v4 as uuidv4 } from 'uuid';

const app = express();
const db = new Database('orders.db');

app.use(express.text({ type: 'application/xml' }));

interface OrderRequest {
    orderId: string;
    customerId: string;
    amount: number;
}

interface ApiResponse {
    id: string;
    status: string;
    timestamp: string;
    [key: string]: any;
}

app.post('/process-xml-message', (req, res) => {
    const xmlContent = req.body;

    parseString(xmlContent, (err, result) => {
        if (err) {
            const errorResponse = createErrorResponse('unknown', `Invalid XML: ${err.message}`);
            return res.set('Content-Type', 'application/xml').send(errorResponse);
        }

        try {
            const messageType = Object.keys(result)[0];
            const messageData = result[messageType];
            const messageId = messageData.$.id || uuidv4();

            let response: string;

            switch (messageType) {
                case 'OrderRequest':
                    response = processOrderRequest(messageData, messageId);
                    break;
                case 'PaymentRequest':
                    response = processPaymentRequest(messageData, messageId);
                    break;
                case 'StatusQuery':
                    response = processStatusQuery(messageData, messageId);
                    break;
                default:
                    response = createErrorResponse(messageId, 'Unknown message type');
            }

            logMessage(messageId, messageType, xmlContent, response);
            res.set('Content-Type', 'application/xml').send(response);

        } catch (error) {
            const errorResponse = createErrorResponse('unknown', error.message);
            res.set('Content-Type', 'application/xml').send(errorResponse);
        }
    });
});

function processOrderRequest(orderData: any, messageId: string): string {
    const orderRequest: OrderRequest = {
        orderId: orderData.orderId?.[0] || messageId,
        customerId: orderData.customerId?.[0] || '',
        amount: parseFloat(orderData.amount?.[0] || '0')
    };

    // Save order to database
    db.run(
        'INSERT INTO orders (id, customer_id, amount, status, created_date) VALUES (?, ?, ?, ?, ?)',
        [orderRequest.orderId, orderRequest.customerId, orderRequest.amount, 'Processing', new Date()]
    );

    const response: ApiResponse = {
        id: orderRequest.orderId,
        status: 'Accepted',
        orderId: orderRequest.orderId,
        estimatedDelivery: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        timestamp: new Date().toISOString()
    };

    return buildXmlResponse('OrderResponse', response);
}

function processPaymentRequest(paymentData: any, messageId: string): string {
    const response: ApiResponse = {
        id: messageId,
        status: 'Processed',
        transactionId: uuidv4(),
        timestamp: new Date().toISOString()
    };

    return buildXmlResponse('PaymentResponse', response);
}

function processStatusQuery(statusData: any, messageId: string): string {
    const response: ApiResponse = {
        id: messageId,
        status: 'Active',
        timestamp: new Date().toISOString()
    };

    return buildXmlResponse('StatusResponse', response);
}

function createErrorResponse(messageId: string, errorMessage: string): string {
    const response = {
        id: messageId,
        error: errorMessage,
        timestamp: new Date().toISOString()
    };

    return buildXmlResponse('ErrorResponse', response);
}

function buildXmlResponse(rootName: string, data: any): string {
    const builder = new Builder({ 
        rootName, 
        headless: true,
        renderOpts: { pretty: false }
    });
    return builder.buildObject(data);
}

function logMessage(messageId: string, messageType: string, requestXml: string, responseXml: string): void {
    db.run(
        'INSERT INTO message_log (message_id, message_type, request_xml, response_xml, processed_date) VALUES (?, ?, ?, ?, ?)',
        [messageId, messageType, requestXml, responseXml, new Date()]
    );
}
```

----

### ğŸ§ª Senaryo 6: Bir iÃ§erik editÃ¶rÃ¼ XML tabanlÄ± belgeleri dÃ¼zenler. KullanÄ±cÄ±lar yapÄ±landÄ±rÄ±lmÄ±ÅŸ belgeler oluÅŸturabilir. EditÃ¶r XML iÃ§eriÄŸini analiz ederek gÃ¶rsel arayÃ¼z sunar. Belge yapÄ±sÄ± XML ÅŸemasÄ±na gÃ¶re korunur.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("parse-document")]
public async Task<IActionResult> ParseDocument([FromBody] string xmlContent)
{
    try
    {
        var document = XDocument.Parse(xmlContent);
        var documentStructure = AnalyzeDocumentStructure(document);
        
        await _documentService.SaveDocumentAsync(xmlContent, documentStructure);
        
        return Ok(new { 
            Structure = documentStructure,
            EditableElements = GetEditableElements(document),
            ValidationResult = ValidateAgainstSchema(document)
        });
    }
    catch (Exception ex)
    {
        return BadRequest($"Document parsing failed: {ex.Message}");
    }
}

[HttpPut("update-element")]
public async Task<IActionResult> UpdateElement([FromBody] ElementUpdateRequest request)
{
    try
    {
        var document = await _documentService.GetDocumentAsync(request.DocumentId);
        var xmlDoc = XDocument.Parse(document.XmlContent);
        
        var element = FindElementByPath(xmlDoc, request.ElementPath);
        if (element == null)
            return NotFound("Element not found");
        
        element.Value = request.NewValue;
        
        var validationResult = ValidateAgainstSchema(xmlDoc);
        if (!validationResult.IsValid)
            return BadRequest(validationResult.Errors);
        
        await _documentService.UpdateDocumentAsync(request.DocumentId, xmlDoc.ToString());
        
        return Ok(new { Message = "Element updated successfully" });
    }
    catch (Exception ex)
    {
        return BadRequest($"Element update failed: {ex.Message}");
    }
}

private DocumentStructure AnalyzeDocumentStructure(XDocument document)
{
    var structure = new DocumentStructure
    {
        RootElement = document.Root.Name.LocalName,
        Elements = new List<ElementInfo>()
    };
    
    AnalyzeElement(document.Root, structure.Elements, "");
    return structure;
}

private void AnalyzeElement(XElement element, List<ElementInfo> elements, string path)
{
    var elementInfo = new ElementInfo
    {
        Name = element.Name.LocalName,
        Path = string.IsNullOrEmpty(path) ? element.Name.LocalName : $"{path}.{element.Name.LocalName}",
        Value = element.HasElements ? null : element.Value,
        Attributes = element.Attributes().ToDictionary(a => a.Name.LocalName, a => a.Value),
        IsEditable = !element.HasElements && !string.IsNullOrWhiteSpace(element.Value)
    };
    
    elements.Add(elementInfo);
    
    foreach (var child in element.Elements())
    {
        AnalyzeElement(child, elements, elementInfo.Path);
    }
}
```

----

### ğŸ§ª Senaryo 6: Bir iÃ§erik editÃ¶rÃ¼ XML tabanlÄ± belgeleri dÃ¼zenler. KullanÄ±cÄ±lar yapÄ±landÄ±rÄ±lmÄ±ÅŸ belgeler oluÅŸturabilir. EditÃ¶r XML iÃ§eriÄŸini analiz ederek gÃ¶rsel arayÃ¼z sunar. Belge yapÄ±sÄ± XML ÅŸemasÄ±na gÃ¶re korunur.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import xml.etree.ElementTree as ET
from flask import Flask, request, jsonify
import sqlite3
from datetime import datetime

app = Flask(__name__)

@app.route('/parse-document', methods=['POST'])
def parse_document():
    xml_content = request.json.get('xml_content')
    
    if not xml_content:
        return jsonify({'error': 'No XML content provided'}), 400
    
    try:
        root = ET.fromstring(xml_content)
        document_structure = analyze_document_structure(root)
        editable_elements = get_editable_elements(root)
        
        # Save document
        conn = sqlite3.connect('documents.db')
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO xml_documents (xml_content, structure, created_date)
            VALUES (?, ?, ?)
        ''', (xml_content, str(document_structure), datetime.now()))
        
        document_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return jsonify({
            'document_id': document_id,
            'structure': document_structure,
            'editable_elements': editable_elements,
            'validation_result': validate_document(root)
        }), 200
        
    except ET.ParseError as e:
        return jsonify({'error': f'Invalid XML: {str(e)}'}), 400

@app.route('/update-element', methods=['PUT'])
def update_element():
    data = request.json
    document_id = data.get('document_id')
    element_path = data.get('element_path')
    new_value = data.get('new_value')
    
    try:
        conn = sqlite3.connect('documents.db')
        cursor = conn.cursor()
        
        cursor.execute('SELECT xml_content FROM xml_documents WHERE id = ?', (document_id,))
        row = cursor.fetchone()
        
        if not row:
            return jsonify({'error': 'Document not found'}), 404
        
        root = ET.fromstring(row[0])
        element = find_element_by_path(root, element_path)
        
        if element is None:
            return jsonify({'error': 'Element not found'}), 404
        
        element.text = new_value
        
        validation_result = validate_document(root)
        if not validation_result['is_valid']:
            return jsonify({'error': 'Validation failed', 'errors': validation_result['errors']}), 400
        
        updated_xml = ET.tostring(root, encoding='unicode')
        
        cursor.execute(
            'UPDATE xml_documents SET xml_content = ?, updated_date = ? WHERE id = ?',
            (updated_xml, datetime.now(), document_id)
        )
        
        conn.commit()
        conn.close()
        
        return jsonify({'message': 'Element updated successfully'}), 200
        
    except Exception as e:
        return jsonify({'error': f'Update failed: {str(e)}'}), 500

def analyze_document_structure(element, path=''):
    structure = {
        'name': element.tag,
        'path': f"{path}.{element.tag}" if path else element.tag,
        'value': element.text if element.text and element.text.strip() else None,
        'attributes': dict(element.attrib),
        'children': [],
        'is_editable': len(element) == 0 and element.text and element.text.strip()
    }
    
    for child in element:
        child_structure = analyze_document_structure(child, structure['path'])
        structure['children'].append(child_structure)
    
    return structure

def get_editable_elements(element, path='', editable_list=None):
    if editable_list is None:
        editable_list = []
    
    current_path = f"{path}.{element.tag}" if path else element.tag
    
    if len(element) == 0 and element.text and element.text.strip():
        editable_list.append({
            'path': current_path,
            'name': element.tag,
            'current_value': element.text,
            'type': 'text'
        })
    
    for child in element:
        get_editable_elements(child, current_path, editable_list)
    
    return editable_list

def find_element_by_path(root, path):
    parts = path.split('.')
    current = root
    
    for part in parts[1:]:  # Skip root element
        found = False
        for child in current:
            if child.tag == part:
                current = child
                found = True
                break
        if not found:
            return None
    
    return current

def validate_document(root):
    # Basic validation - can be extended with XSD validation
    errors = []
    
    if not root.tag:
        errors.append("Document must have a root element")
    
    return {
        'is_valid': len(errors) == 0,
        'errors': errors
    }
```

----

### ğŸ§ª Senaryo 6: Bir iÃ§erik editÃ¶rÃ¼ XML tabanlÄ± belgeleri dÃ¼zenler. KullanÄ±cÄ±lar yapÄ±landÄ±rÄ±lmÄ±ÅŸ belgeler oluÅŸturabilir. EditÃ¶r XML iÃ§eriÄŸini analiz ederek gÃ¶rsel arayÃ¼z sunar. Belge yapÄ±sÄ± XML ÅŸemasÄ±na gÃ¶re korunur.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import { parseString, Builder } from 'xml2js';
import { Database } from 'sqlite3';

const app = express();
const db = new Database('documents.db');

app.use(express.json());

interface ElementInfo {
    name: string;
    path: string;
    value?: string;
    attributes: { [key: string]: string };
    children: ElementInfo[];
    isEditable: boolean;
}

interface DocumentStructure {
    rootElement: string;
    elements: ElementInfo[];
}

interface ElementUpdateRequest {
    documentId: number;
    elementPath: string;
    newValue: string;
}

app.post('/parse-document', (req, res) => {
    const { xml_content } = req.body;

    if (!xml_content) {
        return res.status(400).json({ error: 'No XML content provided' });
    }

    parseString(xml_content, (err, result) => {
        if (err) {
            return res.status(400).json({ error: `Invalid XML: ${err.message}` });
        }

        try {
            const documentStructure = analyzeDocumentStructure(result);
            const editableElements = getEditableElements(result);
            const validationResult = validateDocument(result);

            db.run(
                'INSERT INTO xml_documents (xml_content, structure, created_date) VALUES (?, ?, ?)',
                [xml_content, JSON.stringify(documentStructure), new Date()],
                function(err) {
                    if (err) {
                        return res.status(500).json({ error: 'Database error' });
                    }

                    res.json({
                        document_id: this.lastID,
                        structure: documentStructure,
                        editable_elements: editableElements,
                        validation_result: validationResult
                    });
                }
            );
        } catch (error) {
            res.status(500).json({ error: `Processing failed: ${error.message}` });
        }
    });
});

app.put('/update-element', (req, res) => {
    const { document_id, element_path, new_value }: ElementUpdateRequest = req.body;

    db.get('SELECT xml_content FROM xml_documents WHERE id = ?', [document_id], (err, row: any) => {
        if (err || !row) {
            return res.status(404).json({ error: 'Document not found' });
        }

        parseString(row.xml_content, (err, result) => {
            if (err) {
                return res.status(400).json({ error: 'Invalid XML in database' });
            }

            try {
                const updated = updateElementByPath(result, element_path, new_value);
                
                if (!updated) {
                    return res.status(404).json({ error: 'Element not found' });
                }

                const validationResult = validateDocument(result);
                if (!validationResult.isValid) {
                    return res.status(400).json({ 
                        error: 'Validation failed', 
                        errors: validationResult.errors 
                    });
                }

                const builder = new Builder();
                const updatedXml = builder.buildObject(result);

                db.run(
                    'UPDATE xml_documents SET xml_content = ?, updated_date = ? WHERE id = ?',
                    [updatedXml, new Date(), document_id],
                    (err) => {
                        if (err) {
                            return res.status(500).json({ error: 'Database update failed' });
                        }
                        res.json({ message: 'Element updated successfully' });
                    }
                );
            } catch (error) {
                res.status(500).json({ error: `Update failed: ${error.message}` });
            }
        });
    });
});

function analyzeDocumentStructure(xmlObject: any, path: string = ''): ElementInfo[] {
    const elements: ElementInfo[] = [];

    function analyzeElement(obj: any, currentPath: string): ElementInfo {
        const elementName = Object.keys(obj)[0];
        const elementData = obj[elementName];
        const fullPath = currentPath ? `${currentPath}.${elementName}` : elementName;

        const elementInfo: ElementInfo = {
            name: elementName,
            path: fullPath,
            attributes: elementData.$ || {},
            children: [],
            isEditable: false
        };

        if (typeof elementData === 'string') {
            elementInfo.value = elementData;
            elementInfo.isEditable = true;
        } else if (Array.isArray(elementData)) {
            elementData.forEach((item, index) => {
                if (typeof item === 'object') {
                    const childInfo = analyzeElement({ [elementName]: item }, fullPath);
                    elementInfo.children.push(childInfo);
                }
            });
        } else if (typeof elementData === 'object') {
            Object.keys(elementData).forEach(key => {
                if (key !== '$') {
                    const childInfo = analyzeElement({ [key]: elementData[key] }, fullPath);
                    elementInfo.children.push(childInfo);
                }
            });
        }

        return elementInfo;
    }

    const rootElement = analyzeElement(xmlObject, '');
    elements.push(rootElement);

    return elements;
}

function getEditableElements(xmlObject: any): any[] {
    const editableElements: any[] = [];

    function findEditableElements(obj: any, path: string = '') {
        Object.keys(obj).forEach(key => {
            const value = obj[key];
            const currentPath = path ? `${path}.${key}` : key;

            if (typeof value === 'string') {
                editableElements.push({
                    path: currentPath,
                    name: key,
                    current_value: value,
                    type: 'text'
                });
            } else if (typeof value === 'object' && value !== null) {
                findEditableElements(value, currentPath);
            }
        });
    }

    findEditableElements(xmlObject);
    return editableElements;
}

function updateElementByPath(xmlObject: any, path: string, newValue: string): boolean {
    const pathParts = path.split('.');
    let current = xmlObject;

    for (let i = 0; i < pathParts.length - 1; i++) {
        if (current[pathParts[i]]) {
            current = current[pathParts[i]];
        } else {
            return false;
        }
    }

    const lastKey = pathParts[pathParts.length - 1];
    if (current[lastKey] !== undefined) {
        current[lastKey] = newValue;
        return true;
    }

    return false;
}

function validateDocument(xmlObject: any): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!xmlObject || typeof xmlObject !== 'object') {
        errors.push('Invalid document structure');
    }

    return {
        isValid: errors.length === 0,
        errors
    };
}
```

----

### ğŸ§ª Senaryo 7: Bir veri aktarÄ±m sistemi XML formatÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. FarklÄ± sistemler arasÄ± veri transferi XML ile gerÃ§ekleÅŸir. AktarÄ±m sÄ±rasÄ±nda veriler iÅŸlenip hedefe yÃ¶nlendirilir. XML yapÄ±sÄ± veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ korur.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("transfer-data")]
public async Task<IActionResult> TransferData([FromBody] DataTransferRequest request)
{
    try
    {
        var sourceData = await _sourceService.GetDataAsync(request.SourceSystem, request.DataId);
        var xmlData = ConvertToXml(sourceData, request.TransferType);
        
        var transferLog = new DataTransferLog
        {
            SourceSystem = request.SourceSystem,
            TargetSystem = request.TargetSystem,
            DataId = request.DataId,
            TransferType = request.TransferType,
            XmlData = xmlData.ToString(),
            Status = "Processing",
            InitiatedDate = DateTime.Now
        };

        await _transferRepository.SaveAsync(transferLog);
        
        var validationResult = ValidateDataIntegrity(xmlData);
        if (!validationResult.IsValid)
        {
            transferLog.Status = "Failed";
            transferLog.ErrorMessage = string.Join(", ", validationResult.Errors);
            await _transferRepository.UpdateAsync(transferLog);
            return BadRequest(validationResult.Errors);
        }

        var transformedData = TransformForTarget(xmlData, request.TargetSystem);
        var transferResult = await _targetService.SendDataAsync(request.TargetSystem, transformedData);
        
        transferLog.Status = transferResult.Success ? "Completed" : "Failed";
        transferLog.CompletedDate = DateTime.Now;
        transferLog.ErrorMessage = transferResult.ErrorMessage;
        
        await _transferRepository.UpdateAsync(transferLog);
        
        return Ok(new { 
            TransferId = transferLog.Id,
            Status = transferLog.Status,
            Message = "Data transfer completed successfully"
        });
    }
    catch (Exception ex)
    {
        return BadRequest($"Data transfer failed: {ex.Message}");
    }
}

private XDocument ConvertToXml(object data, string transferType)
{
    var xmlDoc = new XDocument(new XElement("DataTransfer"));
    xmlDoc.Root.Add(new XAttribute("type", transferType));
    xmlDoc.Root.Add(new XAttribute("timestamp", DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss")));
    xmlDoc.Root.Add(new XAttribute("checksum", CalculateChecksum(data)));
    
    var dataElement = new XElement("Data");
    
    if (data is Dictionary<string, object> dict)
    {
        foreach (var kvp in dict)
        {
            dataElement.Add(new XElement(SanitizeElementName(kvp.Key), kvp.Value?.ToString()));
        }
    }
    
    xmlDoc.Root.Add(dataElement);
    return xmlDoc;
}

private XDocument TransformForTarget(XDocument sourceXml, string targetSystem)
{
    var transformer = _transformerFactory.GetTransformer(targetSystem);
    return transformer.Transform(sourceXml);
}
```

----

### ğŸ§ª Senaryo 7: Bir veri aktarÄ±m sistemi XML formatÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. FarklÄ± sistemler arasÄ± veri transferi XML ile gerÃ§ekleÅŸir. AktarÄ±m sÄ±rasÄ±nda veriler iÅŸlenip hedefe yÃ¶nlendirilir. XML yapÄ±sÄ± veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ korur.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import xml.etree.ElementTree as ET
import hashlib
import json
from flask import Flask, request, jsonify
import sqlite3
from datetime import datetime
import requests

app = Flask(__name__)

@app.route('/transfer-data', methods=['POST'])
def transfer_data():
    data = request.json
    source_system = data.get('source_system')
    target_system = data.get('target_system')
    data_id = data.get('data_id')
    transfer_type = data.get('transfer_type')
    
    try:
        # Get source data
        source_data = get_source_data(source_system, data_id)
        xml_data = convert_to_xml(source_data, transfer_type)
        
        # Log transfer
        conn = sqlite3.connect('transfers.db')
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO data_transfers (source_system, target_system, data_id, transfer_type, 
                                      xml_data, status, initiated_date)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (source_system, target_system, data_id, transfer_type, xml_data, 'Processing', datetime.now()))
        
        transfer_id = cursor.lastrowid
        conn.commit()
        
        # Validate data integrity
        validation_result = validate_data_integrity(xml_data)
        if not validation_result['is_valid']:
            cursor.execute(
                'UPDATE data_transfers SET status = ?, error_message = ? WHERE id = ?',
                ('Failed', ', '.join(validation_result['errors']), transfer_id)
            )
            conn.commit()
            conn.close()
            return jsonify({'error': 'Data validation failed', 'errors': validation_result['errors']}), 400
        
        # Transform for target system
        transformed_data = transform_for_target(xml_data, target_system)
        
        # Send to target system
        transfer_result = send_to_target(target_system, transformed_data)
        
        # Update transfer log
        status = 'Completed' if transfer_result['success'] else 'Failed'
        cursor.execute(
            'UPDATE data_transfers SET status = ?, completed_date = ?, error_message = ? WHERE id = ?',
            (status, datetime.now(), transfer_result.get('error_message'), transfer_id)
        )
        
        conn.commit()
        conn.close()
        
        return jsonify({
            'transfer_id': transfer_id,
            'status': status,
            'message': 'Data transfer completed successfully'
        }), 200
        
    except Exception as e:
        return jsonify({'error': f'Data transfer failed: {str(e)}'}), 500

def get_source_data(source_system, data_id):
    # Simulate getting data from source system
    return {
        'id': data_id,
        'name': 'Sample Data',
        'value': 12345,
        'timestamp': datetime.now().isoformat()
    }

def convert_to_xml(data, transfer_type):
    root = ET.Element('DataTransfer')
    root.set('type', transfer_type)
    root.set('timestamp', datetime.now().isoformat())
    root.set('checksum', calculate_checksum(data))
    
    data_element = ET.SubElement(root, 'Data')
    
    if isinstance(data, dict):
        for key, value in data.items():
            element = ET.SubElement(data_element, sanitize_element_name(key))
            element.text = str(value)
    
    return ET.tostring(root, encoding='unicode')

def validate_data_integrity(xml_data):
    errors = []
    
    try:
        root = ET.fromstring(xml_data)
        
        if not root.get('checksum'):
            errors.append('Missing checksum')
        
        if not root.get('timestamp'):
            errors.append('Missing timestamp')
        
        data_element = root.find('Data')
        if data_element is None or len(data_element) == 0:
            errors.append('No data elements found')
            
    except ET.ParseError as e:
        errors.append(f'Invalid XML: {str(e)}')
    
    return {
        'is_valid': len(errors) == 0,
        'errors': errors
    }

def transform_for_target(xml_data, target_system):
    # Apply target-specific transformations
    root = ET.fromstring(xml_data)
    
    if target_system == 'SystemB':
        # Add specific elements for SystemB
        metadata = ET.SubElement(root, 'Metadata')
        ET.SubElement(metadata, 'TargetSystem').text = target_system
        ET.SubElement(metadata, 'TransformVersion').text = '1.0'
    
    return ET.tostring(root, encoding='unicode')

def send_to_target(target_system, transformed_data):
    # Simulate sending to target system
    try:
        # In real implementation, this would be an HTTP request or other protocol
        print(f"Sending data to {target_system}: {transformed_data[:100]}...")
        return {'success': True}
    except Exception as e:
        return {'success': False, 'error_message': str(e)}

def calculate_checksum(data):
    data_str = json.dumps(data, sort_keys=True) if isinstance(data, dict) else str(data)
    return hashlib.md5(data_str.encode()).hexdigest()

def sanitize_element_name(name):
    return ''.join(c if c.isalnum() or c == '_' else '_' for c in str(name))
```

----

### ğŸ§ª Senaryo 7: Bir veri aktarÄ±m sistemi XML formatÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. FarklÄ± sistemler arasÄ± veri transferi XML ile gerÃ§ekleÅŸir. AktarÄ±m sÄ±rasÄ±nda veriler iÅŸlenip hedefe yÃ¶nlendirilir. XML yapÄ±sÄ± veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ korur.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import { Builder, parseString } from 'xml2js';
import { Database } from 'sqlite3';
import * as crypto from 'crypto';
import axios from 'axios';

const app = express();
const db = new Database('transfers.db');

app.use(express.json());

interface DataTransferRequest {
    sourceSystem: string;
    targetSystem: string;
    dataId: string;
    transferType: string;
}

interface DataTransferLog {
    id?: number;
    sourceSystem: string;
    targetSystem: string;
    dataId: string;
    transferType: string;
    xmlData: string;
    status: string;
    initiatedDate: Date;
    completedDate?: Date;
    errorMessage?: string;
}

interface ValidationResult {
    isValid: boolean;
    errors: string[];
}

app.post('/transfer-data', async (req, res) => {
    const { sourceSystem, targetSystem, dataId, transferType }: DataTransferRequest = req.body;

    try {
        // Get source data
        const sourceData = await getSourceData(sourceSystem, dataId);
        const xmlData = convertToXml(sourceData, transferType);

        // Log transfer
        const transferLog: DataTransferLog = {
            sourceSystem,
            targetSystem,
            dataId,
            transferType,
            xmlData,
            status: 'Processing',
            initiatedDate: new Date()
        };

        db.run(
            'INSERT INTO data_transfers (source_system, target_system, data_id, transfer_type, xml_data, status, initiated_date) VALUES (?, ?, ?, ?, ?, ?, ?)',
            [transferLog.sourceSystem, transferLog.targetSystem, transferLog.dataId, 
             transferLog.transferType, transferLog.xmlData, transferLog.status, transferLog.initiatedDate],
            async function(err) {
                if (err) {
                    return res.status(500).json({ error: 'Database error' });
                }

                const transferId = this.lastID;

                try {
                    // Validate data integrity
                    const validationResult = validateDataIntegrity(xmlData);
                    if (!validationResult.isValid) {
                        updateTransferStatus(transferId, 'Failed', validationResult.errors.join(', '));
                        return res.status(400).json({ 
                            error: 'Data validation failed', 
                            errors: validationResult.errors 
                        });
                    }

                    // Transform for target system
                    const transformedData = transformForTarget(xmlData, targetSystem);

                    // Send to target system
                    const transferResult = await sendToTarget(targetSystem, transformedData);

                    // Update transfer log
                    const status = transferResult.success ? 'Completed' : 'Failed';
                    updateTransferStatus(transferId, status, transferResult.errorMessage, new Date());

                    res.json({
                        transfer_id: transferId,
                        status,
                        message: 'Data transfer completed successfully'
                    });

                } catch (error) {
                    updateTransferStatus(transferId, 'Failed', error.message);
                    res.status(500).json({ error: `Transfer processing failed: ${error.message}` });
                }
            }
        );

    } catch (error) {
        res.status(500).json({ error: `Data transfer failed: ${error.message}` });
    }
});

async function getSourceData(sourceSystem: string, dataId: string): Promise<any> {
    // Simulate getting data from source system
    return {
        id: dataId,
        name: 'Sample Data',
        value: 12345,
        timestamp: new Date().toISOString()
    };
}

function convertToXml(data: any, transferType: string): string {
    const xmlObject = {
        DataTransfer: {
            $: {
                type: transferType,
                timestamp: new Date().toISOString(),
                checksum: calculateChecksum(data)
            },
            Data: data
        }
    };

    const builder = new Builder({ headless: true });
    return builder.buildObject(xmlObject);
}

function validateDataIntegrity(xmlData: string): ValidationResult {
    const errors: string[] = [];

    try {
        parseString(xmlData, (err, result) => {
            if (err) {
                errors.push(`Invalid XML: ${err.message}`);
                return;
            }

            const dataTransfer = result.DataTransfer;
            if (!dataTransfer) {
                errors.push('Missing DataTransfer root element');
                return;
            }

            if (!dataTransfer.$.checksum) {
                errors.push('Missing checksum');
            }

            if (!dataTransfer.$.timestamp) {
                errors.push('Missing timestamp');
            }

            if (!dataTransfer.Data || Object.keys(dataTransfer.Data).length === 0) {
                errors.push('No data elements found');
            }
        });
    } catch (error) {
        errors.push(`Validation error: ${error.message}`);
    }

    return {
        isValid: errors.length === 0,
        errors
    };
}

function transformForTarget(xmlData: string, targetSystem: string): string {
    let transformedXml = xmlData;

    if (targetSystem === 'SystemB') {
        // Add specific elements for SystemB
        parseString(xmlData, (err, result) => {
            if (!err && result.DataTransfer) {
                result.DataTransfer.Metadata = {
                    TargetSystem: targetSystem,
                    TransformVersion: '1.0'
                };

                const builder = new Builder({ headless: true });
                transformedXml = builder.buildObject(result);
            }
        });
    }

    return transformedXml;
}

async function sendToTarget(targetSystem: string, transformedData: string): Promise<{ success: boolean; errorMessage?: string }> {
    try {
        // Simulate sending to target system
        console.log(`Sending data to ${targetSystem}: ${transformedData.substring(0, 100)}...`);
        
        // In real implementation, this would be an HTTP request or other protocol
        // await axios.post(`https://${targetSystem}.api.com/receive-data`, { xmlData: transformedData });
        
        return { success: true };
    } catch (error) {
        return { success: false, errorMessage: error.message };
    }
}

function updateTransferStatus(transferId: number, status: string, errorMessage?: string, completedDate?: Date): void {
    db.run(
        'UPDATE data_transfers SET status = ?, completed_date = ?, error_message = ? WHERE id = ?',
        [status, completedDate, errorMessage, transferId]
    );
}

function calculateChecksum(data: any): string {
    const dataStr = typeof data === 'object' ? JSON.stringify(data) : String(data);
    return crypto.createHash('md5').update(dataStr).digest('hex');
}

function sanitizeElementName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
}
```

----

### ğŸ§ª Senaryo 8: Bir web servisi XML tabanlÄ± istekleri karÅŸÄ±lar. Ä°stemciler SOAP protokolÃ¼ ile XML mesajlarÄ± gÃ¶nderir. Servis bu mesajlarÄ± yorumlayarak uygun iÅŸlemleri yapar. YanÄ±tlar XML formatÄ±nda structurelanÄ±r.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("soap-endpoint")]
[Consumes("text/xml", "application/soap+xml")]
public async Task<IActionResult> HandleSoapRequest()
{
    try
    {
        using var reader = new StreamReader(Request.Body);
        var soapXml = await reader.ReadToEndAsync();
        
        var envelope = XDocument.Parse(soapXml);
        var soapBody = envelope.Descendants().FirstOrDefault(x => x.Name.LocalName == "Body");
        
        if (soapBody == null)
            return BadRequest(CreateSoapFault("Client", "Invalid SOAP envelope"));
        
        var operation = soapBody.Elements().FirstOrDefault();
        if (operation == null)
            return BadRequest(CreateSoapFault("Client", "No operation specified"));
        
        var response = operation.Name.LocalName switch
        {
            "GetUserInfo" => await ProcessGetUserInfo(operation),
            "UpdateUserInfo" => await ProcessUpdateUserInfo(operation),
            "DeleteUser" => await ProcessDeleteUser(operation),
            _ => CreateSoapFault("Client", "Unknown operation")
        };

        await LogSoapRequest(soapXml, response.ToString());
        
        return Content(response.ToString(), "text/xml");
    }
    catch (Exception ex)
    {
        var fault = CreateSoapFault("Server", ex.Message);
        return Content(fault.ToString(), "text/xml");
    }
}

private async Task<XDocument> ProcessGetUserInfo(XElement operation)
{
    var userId = operation.Element("userId")?.Value;
    if (string.IsNullOrEmpty(userId))
        return CreateSoapFault("Client", "UserId is required");
    
    var user = await _userService.GetUserAsync(userId);
    if (user == null)
        return CreateSoapFault("Client", "User not found");
    
    return CreateSoapResponse("GetUserInfoResponse", new XElement("user",
        new XElement("id", user.Id),
        new XElement("name", user.Name),
        new XElement("email", user.Email),
        new XElement("status", user.Status)
    ));
}

private async Task<XDocument> ProcessUpdateUserInfo(XElement operation)
{
    var userId = operation.Element("userId")?.Value;
    var name = operation.Element("name")?.Value;
    var email = operation.Element("email")?.Value;
    
    if (string.IsNullOrEmpty(userId))
        return CreateSoapFault("Client", "UserId is required");
    
    var updateResult = await _userService.UpdateUserAsync(userId, name, email);
    
    return CreateSoapResponse("UpdateUserInfoResponse", new XElement("result",
        new XElement("success", updateResult.Success),
        new XElement("message", updateResult.Message),
        new XElement("updatedFields", updateResult.UpdatedFields)
    ));
}

private XDocument CreateSoapResponse(string operationName, XElement responseData)
{
    return new XDocument(
        new XElement(XNamespace.Get("http://schemas.xmlsoap.org/soap/envelope/") + "Envelope",
            new XAttribute(XNamespace.Xmlns + "soap", "http://schemas.xmlsoap.org/soap/envelope/"),
            new XElement(XNamespace.Get("http://schemas.xmlsoap.org/soap/envelope/") + "Body",
                new XElement(operationName, responseData)
            )
        )
    );
}

private XDocument CreateSoapFault(string faultCode, string faultString)
{
    return new XDocument(
        new XElement(XNamespace.Get("http://schemas.xmlsoap.org/soap/envelope/") + "Envelope",
            new XAttribute(XNamespace.Xmlns + "soap", "http://schemas.xmlsoap.org/soap/envelope/"),
            new XElement(XNamespace.Get("http://schemas.xmlsoap.org/soap/envelope/") + "Body",
                new XElement(XNamespace.Get("http://schemas.xmlsoap.org/soap/envelope/") + "Fault",
                    new XElement("faultcode", faultCode),
                    new XElement("faultstring", faultString)
                )
            )
        )
    );
}
```

----

### ğŸ§ª Senaryo 8: Bir web servisi XML tabanlÄ± istekleri karÅŸÄ±lar. Ä°stemciler SOAP protokolÃ¼ ile XML mesajlarÄ± gÃ¶nderir. Servis bu mesajlarÄ± yorumlayarak uygun iÅŸlemleri yapar. YanÄ±tlar XML formatÄ±nda structurelanÄ±r.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import xml.etree.ElementTree as ET
from flask import Flask, request, Response
import sqlite3
from datetime import datetime

app = Flask(__name__)

@app.route('/soap-endpoint', methods=['POST'])
def handle_soap_request():
    try:
        soap_xml = request.data.decode('utf-8')
        envelope = ET.fromstring(soap_xml)
        
        # Find SOAP Body
        soap_body = None
        for elem in envelope.iter():
            if elem.tag.endswith('}Body') or elem.tag == 'Body':
                soap_body = elem
                break
        
        if soap_body is None:
            return Response(create_soap_fault('Client', 'Invalid SOAP envelope'), content_type='text/xml')
        
        # Get operation
        operation = None
        for child in soap_body:
            operation = child
            break
        
        if operation is None:
            return Response(create_soap_fault('Client', 'No operation specified'), content_type='text/xml')
        
        operation_name = operation.tag.split('}')[-1] if '}' in operation.tag else operation.tag
        
        if operation_name == 'GetUserInfo':
            response = process_get_user_info(operation)
        elif operation_name == 'UpdateUserInfo':
            response = process_update_user_info(operation)
        elif operation_name == 'DeleteUser':
            response = process_delete_user(operation)
        else:
            response = create_soap_fault('Client', 'Unknown operation')
        
        log_soap_request(soap_xml, response)
        
        return Response(response, content_type='text/xml')
        
    except ET.ParseError as e:
        fault = create_soap_fault('Client', f'Invalid XML: {str(e)}')
        return Response(fault, content_type='text/xml')
    except Exception as e:
        fault = create_soap_fault('Server', str(e))
        return Response(fault, content_type='text/xml')

def process_get_user_info(operation):
    user_id = None
    for child in operation:
        if child.tag.endswith('userId') or child.tag == 'userId':
            user_id = child.text
            break
    
    if not user_id:
        return create_soap_fault('Client', 'UserId is required')
    
    user = get_user_from_db(user_id)
    if not user:
        return create_soap_fault('Client', 'User not found')
    
    response_data = f'''
        <user>
            <id>{user['id']}</id>
            <name>{user['name']}</name>
            <email>{user['email']}</email>
            <status>{user['status']}</status>
        </user>
    '''
    
    return create_soap_response('GetUserInfoResponse', response_data)

def process_update_user_info(operation):
    user_id = None
    name = None
    email = None
    
    for child in operation:
        if child.tag.endswith('userId') or child.tag == 'userId':
            user_id = child.text
        elif child.tag.endswith('name') or child.tag == 'name':
            name = child.text
        elif child.tag.endswith('email') or child.tag == 'email':
            email = child.text
    
    if not user_id:
        return create_soap_fault('Client', 'UserId is required')
    
    update_result = update_user_in_db(user_id, name, email)
    
    response_data = f'''
        <result>
            <success>{str(update_result['success']).lower()}</success>
            <message>{update_result['message']}</message>
            <updatedFields>{update_result['updated_fields']}</updatedFields>
        </result>
    '''
    
    return create_soap_response('UpdateUserInfoResponse', response_data)

def process_delete_user(operation):
    user_id = None
    for child in operation:
        if child.tag.endswith('userId') or child.tag == 'userId':
            user_id = child.text
            break
    
    if not user_id:
        return create_soap_fault('Client', 'UserId is required')
    
    delete_result = delete_user_from_db(user_id)
    
    response_data = f'''
        <result>
            <success>{str(delete_result['success']).lower()}</success>
            <message>{delete_result['message']}</message>
        </result>
    '''
    
    return create_soap_response('DeleteUserResponse', response_data)

def create_soap_response(operation_name, response_data):
    return f'''<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <{operation_name}>
            {response_data}
        </{operation_name}>
    </soap:Body>
</soap:Envelope>'''

def create_soap_fault(fault_code, fault_string):
    return f'''<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <soap:Fault>
            <faultcode>{fault_code}</faultcode>
            <faultstring>{fault_string}</faultstring>
        </soap:Fault>
    </soap:Body>
</soap:Envelope>'''

def get_user_from_db(user_id):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    cursor.execute('SELECT id, name, email, status FROM users WHERE id = ?', (user_id,))
    row = cursor.fetchone()
    conn.close()
    
    if row:
        return {
            'id': row[0],
            'name': row[1],
            'email': row[2],
            'status': row[3]
        }
    return None

def update_user_in_db(user_id, name, email):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    updated_fields = []
    if name:
        cursor.execute('UPDATE users SET name = ? WHERE id = ?', (name, user_id))
        updated_fields.append('name')
    if email:
        cursor.execute('UPDATE users SET email = ? WHERE id = ?', (email, user_id))
        updated_fields.append('email')
    
    conn.commit()
    affected_rows = cursor.rowcount
    conn.close()
    
    return {
        'success': affected_rows > 0,
        'message': 'User updated successfully' if affected_rows > 0 else 'User not found',
        'updated_fields': ','.join(updated_fields)
    }

def delete_user_from_db(user_id):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    cursor.execute('DELETE FROM users WHERE id = ?', (user_id,))
    affected_rows = cursor.rowcount
    
    conn.commit()
    conn.close()
    
    return {
        'success': affected_rows > 0,
        'message': 'User deleted successfully' if affected_rows > 0 else 'User not found'
    }

def log_soap_request(request_xml, response_xml):
    conn = sqlite3.connect('soap_logs.db')
    cursor = conn.cursor()
    
    cursor.execute('''
        INSERT INTO soap_requests (request_xml, response_xml, processed_date)
        VALUES (?, ?, ?)
    ''', (request_xml, response_xml, datetime.now()))
    
    conn.commit()
    conn.close()

----

### ğŸ§ª Senaryo 8: Bir web servisi XML tabanlÄ± istekleri karÅŸÄ±lar. Ä°stemciler SOAP protokolÃ¼ ile XML mesajlarÄ± gÃ¶nderir. Servis bu mesajlarÄ± yorumlayarak uygun iÅŸlemleri yapar. YanÄ±tlar XML formatÄ±nda structurelanÄ±r.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import { parseString, Builder } from 'xml2js';
import { Database } from 'sqlite3';

const app = express();
const db = new Database('users.db');

app.use(express.text({ type: ['text/xml', 'application/soap+xml'] }));

interface User {
    id: string;
    name: string;
    email: string;
    status: string;
}

interface UpdateResult {
    success: boolean;
    message: string;
    updatedFields: string[];
}

app.post('/soap-endpoint', (req, res) => {
    const soapXml = req.body;

    parseString(soapXml, async (err, result) => {
        if (err) {
            const fault = createSoapFault('Client', `Invalid XML: ${err.message}`);
            return res.set('Content-Type', 'text/xml').send(fault);
        }

        try {
            const envelope = result['soap:Envelope'] || result.Envelope;
            const soapBody = envelope['soap:Body'] || envelope.Body;

            if (!soapBody || !soapBody[0]) {
                const fault = createSoapFault('Client', 'Invalid SOAP envelope');
                return res.set('Content-Type', 'text/xml').send(fault);
            }

            const operations = Object.keys(soapBody[0]);
            if (operations.length === 0) {
                const fault = createSoapFault('Client', 'No operation specified');
                return res.set('Content-Type', 'text/xml').send(fault);
            }

            const operationName = operations[0];
            const operationData = soapBody[0][operationName][0];

            let response: string;

            switch (operationName) {
                case 'GetUserInfo':
                    response = await processGetUserInfo(operationData);
                    break;
                case 'UpdateUserInfo':
                    response = await processUpdateUserInfo(operationData);
                    break;
                case 'DeleteUser':
                    response = await processDeleteUser(operationData);
                    break;
                default:
                    response = createSoapFault('Client', 'Unknown operation');
            }

            logSoapRequest(soapXml, response);
            res.set('Content-Type', 'text/xml').send(response);

        } catch (error) {
            const fault = createSoapFault('Server', error.message);
            res.set('Content-Type', 'text/xml').send(fault);
        }
    });
});

async function processGetUserInfo(operationData: any): Promise<string> {
    const userId = operationData.userId?.[0];

    if (!userId) {
        return createSoapFault('Client', 'UserId is required');
    }

    const user = await getUserFromDb(userId);
    if (!user) {
        return createSoapFault('Client', 'User not found');
    }

    const responseData = {
        user: {
            id: user.id,
            name: user.name,
            email: user.email,
            status: user.status
        }
    };

    return createSoapResponse('GetUserInfoResponse', responseData);
}

async function processUpdateUserInfo(operationData: any): Promise<string> {
    const userId = operationData.userId?.[0];
    const name = operationData.name?.[0];
    const email = operationData.email?.[0];

    if (!userId) {
        return createSoapFault('Client', 'UserId is required');
    }

    const updateResult = await updateUserInDb(userId, name, email);

    const responseData = {
        result: {
            success: updateResult.success,
            message: updateResult.message,
            updatedFields: updateResult.updatedFields.join(',')
        }
    };

    return createSoapResponse('UpdateUserInfoResponse', responseData);
}

async function processDeleteUser(operationData: any): Promise<string> {
    const userId = operationData.userId?.[0];

    if (!userId) {
        return createSoapFault('Client', 'UserId is required');
    }

    const deleteResult = await deleteUserFromDb(userId);

    const responseData = {
        result: {
            success: deleteResult.success,
            message: deleteResult.message
        }
    };

    return createSoapResponse('DeleteUserResponse', responseData);
}

function createSoapResponse(operationName: string, responseData: any): string {
    return `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <${operationName}>
            ${objectToXmlString(responseData)}
        </${operationName}>
    </soap:Body>
</soap:Envelope>`;
}

function createSoapFault(faultCode: string, faultString: string): string {
    return `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <soap:Fault>
            <faultcode>${faultCode}</faultcode>
            <faultstring>${faultString}</faultstring>
        </soap:Fault>
    </soap:Body>
</soap:Envelope>`;
}

function objectToXmlString(obj: any): string {
    let xml = '';
    for (const [key, value] of Object.entries(obj)) {
        if (typeof value === 'object') {
            xml += `<${key}>${objectToXmlString(value)}</${key}>`;
        } else {
            xml += `<${key}>${value}</${key}>`;
        }
    }
    return xml;
}

function getUserFromDb(userId: string): Promise<User | null> {
    return new Promise((resolve, reject) => {
        db.get('SELECT id, name, email, status FROM users WHERE id = ?', [userId], (err, row: any) => {
            if (err) {
                reject(err);
            } else if (row) {
                resolve({
                    id: row.id,
                    name: row.name,
                    email: row.email,
                    status: row.status
                });
            } else {
                resolve(null);
            }
        });
    });
}

function updateUserInDb(userId: string, name?: string, email?: string): Promise<UpdateResult> {
    return new Promise((resolve, reject) => {
        const updatedFields: string[] = [];
        let query = 'UPDATE users SET ';
        const params: any[] = [];

        if (name) {
            query += 'name = ?';
            params.push(name);
            updatedFields.push('name');
        }

        if (email) {
            if (params.length > 0) query += ', ';
            query += 'email = ?';
            params.push(email);
            updatedFields.push('email');
        }

        query += ' WHERE id = ?';
        params.push(userId);

        db.run(query, params, function(err) {
            if (err) {
                reject(err);
            } else {
                resolve({
                    success: this.changes > 0,
                    message: this.changes > 0 ? 'User updated successfully' : 'User not found',
                    updatedFields
                });
            }
        });
    });
}

function deleteUserFromDb(userId: string): Promise<{ success: boolean; message: string }> {
    return new Promise((resolve, reject) => {
        db.run('DELETE FROM users WHERE id = ?', [userId], function(err) {
            if (err) {
                reject(err);
            } else {
                resolve({
                    success: this.changes > 0,
                    message: this.changes > 0 ? 'User deleted successfully' : 'User not found'
                });
            }
        });
    });
}

function logSoapRequest(requestXml: string, responseXml: string): void {
    db.run(
        'INSERT INTO soap_requests (request_xml, response_xml, processed_date) VALUES (?, ?, ?)',
        [requestXml, responseXml, new Date()]
    );
}
```

----

### ğŸ§ª Senaryo 9: Bir katalog yÃ¶netim sistemi Ã¼rÃ¼n bilgilerini XML dosyalarÄ±ndan okur. TedarikÃ§iler Ã¼rÃ¼n veritabanlarÄ±nÄ± XML formatÄ±nda saÄŸlar. Sistem bu dosyalarÄ± iÅŸleyerek katalog gÃ¼nceller. ÃœrÃ¼n bilgileri XML yapÄ±sÄ±ndan Ã§Ä±karÄ±lÄ±r.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("import-catalog")]
public async Task<IActionResult> ImportCatalog(IFormFile catalogFile, string supplierId)
{
    try
    {
        using var stream = catalogFile.OpenReadStream();
        var catalogXml = XDocument.Load(stream);
        
        var products = ExtractProductsFromXml(catalogXml);
        var importResult = await ProcessCatalogImport(products, supplierId);
        
        var catalogImport = new CatalogImport
        {
            SupplierId = supplierId,
            FileName = catalogFile.FileName,
            ImportDate = DateTime.Now,
            ProductCount = products.Count,
            SuccessCount = importResult.SuccessCount,
            FailureCount = importResult.FailureCount,
            Status = "Completed"
        };

        await _catalogRepository.SaveImportAsync(catalogImport);
        
        return Ok(new { 
            Message = "Catalog imported successfully",
            ImportId = catalogImport.Id,
            ProductsProcessed = products.Count,
            SuccessCount = importResult.SuccessCount,
            FailureCount = importResult.FailureCount
        });
    }
    catch (Exception ex)
    {
        return BadRequest($"Catalog import failed: {ex.Message}");
    }
}

private List<Product> ExtractProductsFromXml(XDocument catalogXml)
{
    var products = new List<Product>();
    
    foreach (var productElement in catalogXml.Descendants("product"))
    {
        var product = new Product
        {
            ExternalId = productElement.Attribute("id")?.Value,
            Name = productElement.Element("name")?.Value,
            Description = productElement.Element("description")?.Value,
            Price = decimal.TryParse(productElement.Element("price")?.Value, out var price) ? price : 0,
            Currency = productElement.Element("currency")?.Value ?? "USD",
            Category = productElement.Element("category")?.Value,
            Brand = productElement.Element("brand")?.Value,
            Stock = int.TryParse(productElement.Element("stock")?.Value, out var stock) ? stock : 0,
            Images = ExtractImages(productElement.Element("images")),
            Specifications = ExtractSpecifications(productElement.Element("specifications"))
        };
        
        products.Add(product);
    }
    
    return products;
}

private async Task<ImportResult> ProcessCatalogImport(List<Product> products, string supplierId)
{
    var result = new ImportResult();
    
    foreach (var product in products)
    {
        try
        {
            var existingProduct = await _productRepository.GetByExternalIdAsync(product.ExternalId, supplierId);
            
            if (existingProduct != null)
            {
                existingProduct.UpdateFrom(product);
                await _productRepository.UpdateAsync(existingProduct);
            }
            else
            {
                product.SupplierId = supplierId;
                await _productRepository.CreateAsync(product);
            }
            
            result.SuccessCount++;
        }
        catch (Exception ex)
        {
            result.FailureCount++;
            await _logService.LogErrorAsync($"Failed to import product {product.ExternalId}: {ex.Message}");
        }
    }
    
    return result;
}

private List<string> ExtractImages(XElement imagesElement)
{
    if (imagesElement == null) return new List<string>();
    
    return imagesElement.Elements("image")
        .Select(img => img.Attribute("url")?.Value)
        .Where(url => !string.IsNullOrEmpty(url))
        .ToList();
}

private Dictionary<string, string> ExtractSpecifications(XElement specsElement)
{
    if (specsElement == null) return new Dictionary<string, string>();
    
    return specsElement.Elements("spec")
        .Where(spec => spec.Attribute("name") != null && spec.Attribute("value") != null)
        .ToDictionary(
            spec => spec.Attribute("name").Value,
            spec => spec.Attribute("value").Value
        );
}
```

----

### ğŸ§ª Senaryo 9: Bir katalog yÃ¶netim sistemi Ã¼rÃ¼n bilgilerini XML dosyalarÄ±ndan okur. TedarikÃ§iler Ã¼rÃ¼n veritabanlarÄ±nÄ± XML formatÄ±nda saÄŸlar. Sistem bu dosyalarÄ± iÅŸleyerek katalog gÃ¼nceller. ÃœrÃ¼n bilgileri XML yapÄ±sÄ±ndan Ã§Ä±karÄ±lÄ±r.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import xml.etree.ElementTree as ET
from flask import Flask, request, jsonify
import sqlite3
from datetime import datetime

app = Flask(__name__)

@app.route('/import-catalog', methods=['POST'])
def import_catalog():
    if 'catalogFile' not in request.files:
        return jsonify({'error': 'No catalog file provided'}), 400
    
    catalog_file = request.files['catalogFile']
    supplier_id = request.form.get('supplier_id')
    
    if not supplier_id:
        return jsonify({'error': 'Supplier ID is required'}), 400
    
    try:
        xml_content = catalog_file.read().decode('utf-8')
        catalog_xml = ET.fromstring(xml_content)
        
        products = extract_products_from_xml(catalog_xml)
        import_result = process_catalog_import(products, supplier_id)
        
        # Log import
        conn = sqlite3.connect('catalog.db')
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO catalog_imports (supplier_id, filename, import_date, product_count, 
                                       success_count, failure_count, status)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (supplier_id, catalog_file.filename, datetime.now(), len(products),
              import_result['success_count'], import_result['failure_count'], 'Completed'))
        
        import_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return jsonify({
            'message': 'Catalog imported successfully',
            'import_id': import_id,
            'products_processed': len(products),
            'success_count': import_result['success_count'],
            'failure_count': import_result['failure_count']
        }), 200
        
    except ET.ParseError as e:
        return jsonify({'error': f'Invalid XML: {str(e)}'}), 400
    except Exception as e:
        return jsonify({'error': f'Import failed: {str(e)}'}), 500

def extract_products_from_xml(catalog_xml):
    products = []
    
    for product_element in catalog_xml.findall('product'):
        product = {
            'external_id': product_element.get('id'),
            'name': product_element.find('name').text if product_element.find('name') is not None else '',
            'description': product_element.find('description').text if product_element.find('description') is not None else '',
            'price': float(product_element.find('price').text) if product_element.find('price') is not None else 0.0,
            'currency': product_element.find('currency').text if product_element.find('currency') is not None else 'USD',
            'category': product_element.find('category').text if product_element.find('category') is not None else '',
            'brand': product_element.find('brand').text if product_element.find('brand') is not None else '',
            'stock': int(product_element.find('stock').text) if product_element.find('stock') is not None else 0,
            'images': extract_images(product_element.find('images')),
            'specifications': extract_specifications(product_element.find('specifications'))
        }
        
        products.append(product)
    
    return products

def extract_images(images_element):
    if images_element is None:
        return []
    
    images = []
    for image in images_element.findall('image'):
        url = image.get('url')
        if url:
            images.append(url)
    
    return images

def extract_specifications(specs_element):
    if specs_element is None:
        return {}
    
    specifications = {}
    for spec in specs_element.findall('spec'):
        name = spec.get('name')
        value = spec.get('value')
        if name and value:
            specifications[name] = value
    
    return specifications

def process_catalog_import(products, supplier_id):
    conn = sqlite3.connect('catalog.db')
    cursor = conn.cursor()
    
    success_count = 0
    failure_count = 0
    
    for product in products:
        try:
            # Check if product exists
            cursor.execute(
                'SELECT id FROM products WHERE external_id = ? AND supplier_id = ?',
                (product['external_id'], supplier_id)
            )
            
            existing_product = cursor.fetchone()
            
            if existing_product:
                # Update existing product
                cursor.execute('''
                    UPDATE products SET name = ?, description = ?, price = ?, currency = ?,
                                      category = ?, brand = ?, stock = ?, updated_date = ?
                    WHERE external_id = ? AND supplier_id = ?
                ''', (product['name'], product['description'], product['price'], product['currency'],
                      product['category'], product['brand'], product['stock'], datetime.now(),
                      product['external_id'], supplier_id))
            else:
                # Create new product
                cursor.execute('''
                    INSERT INTO products (external_id, supplier_id, name, description, price, currency,
                                        category, brand, stock, created_date)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (product['external_id'], supplier_id, product['name'], product['description'],
                      product['price'], product['currency'], product['category'], product['brand'],
                      product['stock'], datetime.now()))
            
            success_count += 1
            
        except Exception as e:
            failure_count += 1
            print(f"Failed to import product {product['external_id']}: {str(e)}")
    
    conn.commit()
    conn.close()
    
    return {
        'success_count': success_count,
        'failure_count': failure_count
    }
```

----

### ğŸ§ª Senaryo 9: Bir katalog yÃ¶netim sistemi Ã¼rÃ¼n bilgilerini XML dosyalarÄ±ndan okur. TedarikÃ§iler Ã¼rÃ¼n veritabanlarÄ±nÄ± XML formatÄ±nda saÄŸlar. Sistem bu dosyalarÄ± iÅŸleyerek katalog gÃ¼nceller. ÃœrÃ¼n bilgileri XML yapÄ±sÄ±ndan Ã§Ä±karÄ±lÄ±r.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import multer from 'multer';
import { parseString } from 'xml2js';
import { Database } from 'sqlite3';

const app = express();
const upload = multer({ dest: 'uploads/' });
const db = new Database('catalog.db');

interface Product {
    externalId: string;
    name: string;
    description: string;
    price: number;
    currency: string;
    category: string;
    brand: string;
    stock: number;
    images: string[];
    specifications: { [key: string]: string };
}

interface ImportResult {
    successCount: number;
    failureCount: number;
}

app.post('/import-catalog', upload.single('catalogFile'), (req, res) => {
    if (!req.file) {
        return res.status(400).json({ error: 'No catalog file provided' });
    }

    const supplierId = req.body.supplier_id;
    if (!supplierId) {
        return res.status(400).json({ error: 'Supplier ID is required' });
    }

    const fs = require('fs');
    const xmlContent = fs.readFileSync(req.file.path, 'utf8');

    parseString(xmlContent, async (err, result) => {
        if (err) {
            return res.status(400).json({ error: `Invalid XML: ${err.message}` });
        }

        try {
            const products = extractProductsFromXml(result);
            const importResult = await processCatalogImport(products, supplierId);

            // Log import
            db.run(
                'INSERT INTO catalog_imports (supplier_id, filename, import_date, product_count, success_count, failure_count, status) VALUES (?, ?, ?, ?, ?, ?, ?)',
                [supplierId, req.file.originalname, new Date(), products.length, 
                 importResult.successCount, importResult.failureCount, 'Completed'],
                function(err) {
                    if (err) {
                        return res.status(500).json({ error: 'Failed to log import' });
                    }

                    res.json({
                        message: 'Catalog imported successfully',
                        import_id: this.lastID,
                        products_processed: products.length,
                        success_count: importResult.successCount,
                        failure_count: importResult.failureCount
                    });
                }
            );

        } catch (error) {
            res.status(500).json({ error: `Import failed: ${error.message}` });
        }
    });
});

function extractProductsFromXml(xmlObject: any): Product[] {
    const products: Product[] = [];

    const productList = xmlObject.catalog?.product || xmlObject.product || [];
    const productsArray = Array.isArray(productList) ? productList : [productList];

    productsArray.forEach((productData: any) => {
        const product: Product = {
            externalId: productData.$.id || '',
            name: productData.name?.[0] || '',
            description: productData.description?.[0] || '',
            price: parseFloat(productData.price?.[0]) || 0,
            currency: productData.currency?.[0] || 'USD',
            category: productData.category?.[0] || '',
            brand: productData.brand?.[0] || '',
            stock: parseInt(productData.stock?.[0]) || 0,
            images: extractImages(productData.images),
            specifications: extractSpecifications(productData.specifications)
        };

        products.push(product);
    });

    return products;
}

function extractImages(imagesData: any): string[] {
    if (!imagesData || !imagesData[0] || !imagesData[0].image) {
        return [];
    }

    const images: string[] = [];
    const imageList = Array.isArray(imagesData[0].image) ? imagesData[0].image : [imagesData[0].image];

    imageList.forEach((imageData: any) => {
        if (imageData.$.url) {
            images.push(imageData.$.url);
        }
    });

    return images;
}

function extractSpecifications(specsData: any): { [key: string]: string } {
    if (!specsData || !specsData[0] || !specsData[0].spec) {
        return {};
    }

    const specifications: { [key: string]: string } = {};
    const specList = Array.isArray(specsData[0].spec) ? specsData[0].spec : [specsData[0].spec];

    specList.forEach((specData: any) => {
        if (specData.$.name && specData.$.value) {
            specifications[specData.$.name] = specData.$.value;
        }
    });

    return specifications;
}

async function processCatalogImport(products: Product[], supplierId: string): Promise<ImportResult> {
    let successCount = 0;
    let failureCount = 0;

    for (const product of products) {
        try {
            await new Promise<void>((resolve, reject) => {
                // Check if product exists
                db.get(
                    'SELECT id FROM products WHERE external_id = ? AND supplier_id = ?',
                    [product.externalId, supplierId],
                    (err, row) => {
                        if (err) {
                            reject(err);
                            return;
                        }

                        if (row) {
                            // Update existing product
                            db.run(
                                'UPDATE products SET name = ?, description = ?, price = ?, currency = ?, category = ?, brand = ?, stock = ?, updated_date = ? WHERE external_id = ? AND supplier_id = ?',
                                [product.name, product.description, product.price, product.currency,
                                 product.category, product.brand, product.stock, new Date(),
                                 product.externalId, supplierId],
                                (updateErr) => {
                                    if (updateErr) reject(updateErr);
                                    else resolve();
                                }
                            );
                        } else {
                            // Create new product
                            db.run(
                                'INSERT INTO products (external_id, supplier_id, name, description, price, currency, category, brand, stock, created_date) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                                [product.externalId, supplierId, product.name, product.description,
                                 product.price, product.currency, product.category, product.brand,
                                 product.stock, new Date()],
                                (insertErr) => {
                                    if (insertErr) reject(insertErr);
                                    else resolve();
                                }
                            );
                        }
                    }
                );
            });

            successCount++;
        } catch (error) {
            failureCount++;
            console.error(`Failed to import product ${product.externalId}:`, error.message);
        }
    }

    return { successCount, failureCount };
}
```

----

### ğŸ§ª Senaryo 10: Bir iÅŸ akÄ±ÅŸÄ± motoru sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± XML dosyalarÄ±nda tutar. KullanÄ±cÄ±lar iÅŸ akÄ±ÅŸÄ± ÅŸemalarÄ±nÄ± XML olarak sisteme yÃ¼kler. Motor bu tanÄ±mlarÄ± iÅŸleyerek sÃ¼reÃ§leri baÅŸlatÄ±r. Ä°ÅŸ akÄ±ÅŸÄ± adÄ±mlarÄ± XML yapÄ±sÄ±ndan oluÅŸturulur.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Claude

```csharp
[HttpPost("upload-workflow")]
public async Task<IActionResult> UploadWorkflow(IFormFile workflowFile)
{
    try
    {
        using var stream = workflowFile.OpenReadStream();
        var workflowXml = XDocument.Load(stream);
        
        var workflow = ParseWorkflowDefinition(workflowXml);
        var validationResult = ValidateWorkflow(workflow);
        
        if (!validationResult.IsValid)
            return BadRequest(validationResult.Errors);
        
        await _workflowRepository.SaveAsync(workflow);
        
        return Ok(new { 
            Message = "Workflow uploaded successfully",
            WorkflowId = workflow.Id,
            StepCount = workflow.Steps.Count
        });
    }
    catch (Exception ex)
    {
        return BadRequest($"Workflow upload failed: {ex.Message}");
    }
}

[HttpPost("start-workflow")]
public async Task<IActionResult> StartWorkflow([FromBody] StartWorkflowRequest request)
{
    try
    {
        var workflow = await _workflowRepository.GetByIdAsync(request.WorkflowId);
        if (workflow == null)
            return NotFound("Workflow not found");
        
        var workflowInstance = new WorkflowInstance
        {
            WorkflowId = workflow.Id,
            InitiatedBy = request.UserId,
            Status = "Running",
            StartDate = DateTime.Now,
            CurrentStepId = workflow.Steps.First(s => s.IsStartStep).Id,
            Variables = request.InitialVariables ?? new Dictionary<string, object>()
        };
        
        await _workflowInstanceRepository.SaveAsync(workflowInstance);
        await ExecuteCurrentStep(workflowInstance);
        
        return Ok(new { 
            Message = "Workflow started successfully",
            InstanceId = workflowInstance.Id,
            CurrentStep = workflowInstance.CurrentStepId
        });
    }
    catch (Exception ex)
    {
        return BadRequest($"Workflow start failed: {ex.Message}");
    }
}

private WorkflowDefinition ParseWorkflowDefinition(XDocument workflowXml)
{
    var workflow = new WorkflowDefinition
    {
        Name = workflowXml.Root?.Attribute("name")?.Value ?? "Unnamed Workflow",
        Version = workflowXml.Root?.Attribute("version")?.Value ?? "1.0",
        Description = workflowXml.Root?.Element("description")?.Value,
        Steps = new List<WorkflowStep>(),
        Transitions = new List<WorkflowTransition>()
    };
    
    // Parse steps
    foreach (var stepElement in workflowXml.Descendants("step"))
    {
        var step = new WorkflowStep
        {
            Id = stepElement.Attribute("id")?.Value,
            Name = stepElement.Attribute("name")?.Value,
            Type = stepElement.Attribute("type")?.Value,
            IsStartStep = bool.Parse(stepElement.Attribute("isStart")?.Value ?? "false"),
            IsEndStep = bool.Parse(stepElement.Attribute("isEnd")?.Value ?? "false"),
            Actions = ParseStepActions(stepElement.Element("actions")),
            Conditions = ParseStepConditions(stepElement.Element("conditions"))
        };
        
        workflow.Steps.Add(step);
    }
    
    // Parse transitions
    foreach (var transitionElement in workflowXml.Descendants("transition"))
    {
        var transition = new WorkflowTransition
        {
            From = transitionElement.Attribute("from")?.Value,
            To = transitionElement.Attribute("to")?.Value,
            Condition = transitionElement.Attribute("condition")?.Value,
            Label = transitionElement.Attribute("label")?.Value
        };
        
        workflow.Transitions.Add(transition);
    }
    
    return workflow;
}

private async Task ExecuteCurrentStep(WorkflowInstance instance)
{
    var workflow = await _workflowRepository.GetByIdAsync(instance.WorkflowId);
    var currentStep = workflow.Steps.FirstOrDefault(s => s.Id == instance.CurrentStepId);
    
    if (currentStep == null) return;
    
    foreach (var action in currentStep.Actions)
    {
        await _actionExecutor.ExecuteAsync(action, instance);
    }
    
    var nextStep = DetermineNextStep(currentStep, workflow.Transitions, instance);
    if (nextStep != null)
    {
        instance.CurrentStepId = nextStep.Id;
        if (nextStep.IsEndStep)
        {
            instance.Status = "Completed";
            instance.EndDate = DateTime.Now;
        }
        await _workflowInstanceRepository.UpdateAsync(instance);
    }
}
```

----

### ğŸ§ª Senaryo 10: Bir iÅŸ akÄ±ÅŸÄ± motoru sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± XML dosyalarÄ±nda tutar. KullanÄ±cÄ±lar iÅŸ akÄ±ÅŸÄ± ÅŸemalarÄ±nÄ± XML olarak sisteme yÃ¼kler. Motor bu tanÄ±mlarÄ± iÅŸleyerek sÃ¼reÃ§leri baÅŸlatÄ±r. Ä°ÅŸ akÄ±ÅŸÄ± adÄ±mlarÄ± XML yapÄ±sÄ±ndan oluÅŸturulur.
**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** Claude

```python
import xml.etree.ElementTree as ET
from flask import Flask, request, jsonify
import sqlite3
from datetime import datetime
import json

app = Flask(__name__)

@app.route('/upload-workflow', methods=['POST'])
def upload_workflow():
    if 'workflowFile' not in request.files:
        return jsonify({'error': 'No workflow file provided'}), 400
    
    workflow_file = request.files['workflowFile']
    
    try:
        xml_content = workflow_file.read().decode('utf-8')
        workflow_xml = ET.fromstring(xml_content)
        
        workflow = parse_workflow_definition(workflow_xml)
        validation_result = validate_workflow(workflow)
        
        if not validation_result['is_valid']:
            return jsonify({'error': 'Workflow validation failed', 'errors': validation_result['errors']}), 400
        
        # Save workflow
        conn = sqlite3.connect('workflows.db')
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO workflow_definitions (name, version, description, steps, transitions, created_date)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (workflow['name'], workflow['version'], workflow['description'],
              json.dumps(workflow['steps']), json.dumps(workflow['transitions']), datetime.now()))
        
        workflow_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return jsonify({
            'message': 'Workflow uploaded successfully',
            'workflow_id': workflow_id,
            'step_count': len(workflow['steps'])
        }), 200
        
    except ET.ParseError as e:
        return jsonify({'error': f'Invalid XML: {str(e)}'}), 400
    except Exception as e:
        return jsonify({'error': f'Upload failed: {str(e)}'}), 500

@app.route('/start-workflow', methods=['POST'])
def start_workflow():
    data = request.json
    workflow_id = data.get('workflow_id')
    user_id = data.get('user_id')
    initial_variables = data.get('initial_variables', {})
    
    try:
        # Get workflow definition
        conn = sqlite3.connect('workflows.db')
        cursor = conn.cursor()
        
        cursor.execute('SELECT name, steps, transitions FROM workflow_definitions WHERE id = ?', (workflow_id,))
        workflow_row = cursor.fetchone()
        
        if not workflow_row:
            return jsonify({'error': 'Workflow not found'}), 404
        
        workflow_name, steps_json, transitions_json = workflow_row
        steps = json.loads(steps_json)
        
        # Find start step
        start_step = next((step for step in steps if step.get('is_start_step', False)), None)
        if not start_step:
            return jsonify({'error': 'No start step found in workflow'}), 400
        
        # Create workflow instance
        cursor.execute('''
            INSERT INTO workflow_instances (workflow_id, initiated_by, status, start_date, 
                                          current_step_id, variables)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (workflow_id, user_id, 'Running', datetime.now(), start_step['id'], 
              json.dumps(initial_variables)))
        
        instance_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        # Execute current step
        execute_current_step(instance_id)
        
        return jsonify({
            'message': 'Workflow started successfully',
            'instance_id': instance_id,
            'current_step': start_step['id']
        }), 200
        
    except Exception as e:
        return jsonify({'error': f'Workflow start failed: {str(e)}'}), 500

def parse_workflow_definition(workflow_xml):
    workflow = {
        'name': workflow_xml.get('name', 'Unnamed Workflow'),
        'version': workflow_xml.get('version', '1.0'),
        'description': workflow_xml.find('description').text if workflow_xml.find('description') is not None else '',
        'steps': [],
        'transitions': []
    }
    
    # Parse steps
    for step_element in workflow_xml.findall('step'):
        step = {
            'id': step_element.get('id'),
            'name': step_element.get('name'),
            'type': step_element.get('type'),
            'is_start_step': step_element.get('isStart', 'false').lower() == 'true',
            'is_end_step': step_element.get('isEnd', 'false').lower() == 'true',
            'actions': parse_step_actions(step_element.find('actions')),
            'conditions': parse_step_conditions(step_element.find('conditions'))
        }
        workflow['steps'].append(step)
    
    # Parse transitions
    for transition_element in workflow_xml.findall('transition'):
        transition = {
            'from': transition_element.get('from'),
            'to': transition_element.get('to'),
            'condition': transition_element.get('condition'),
            'label': transition_element.get('label')
        }
        workflow['transitions'].append(transition)
    
    return workflow

def parse_step_actions(actions_element):
    if actions_element is None:
        return []
    
    actions = []
    for action in actions_element.findall('action'):
        actions.append({
            'type': action.get('type'),
            'parameters': dict(action.attrib)
        })
    
    return actions

def parse_step_conditions(conditions_element):
    if conditions_element is None:
        return []
    
    conditions = []
    for condition in conditions_element.findall('condition'):
        conditions.append({
            'expression': condition.text,
            'type': condition.get('type')
        })
    
    return conditions

def validate_workflow(workflow):
    errors = []
    
    if not workflow['name']:
        errors.append('Workflow name is required')
    
    if not workflow['steps']:
        errors.append('Workflow must have at least one step')
    
    start_steps = [step for step in workflow['steps'] if step['is_start_step']]
    if len(start_steps) != 1:
        errors.append('Workflow must have exactly one start step')
    
    step_ids = [step['id'] for step in workflow['steps']]
    for transition in workflow['transitions']:
        if transition['from'] not in step_ids:
            errors.append(f"Transition from unknown step: {transition['from']}")
        if transition['to'] not in step_ids:
            errors.append(f"Transition to unknown step: {transition['to']}")
    
    return {
        'is_valid': len(errors) == 0,
        'errors': errors
    }

def execute_current_step(instance_id):
    conn = sqlite3.connect('workflows.db')
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT wi.workflow_id, wi.current_step_id, wi.variables, wd.steps, wd.transitions
        FROM workflow_instances wi
        JOIN workflow_definitions wd ON wi.workflow_id = wd.id
        WHERE wi.id = ?
    ''', (instance_id,))
    
    row = cursor.fetchone()
    if not row:
        return
    
    workflow_id, current_step_id, variables_json, steps_json, transitions_json = row
    variables = json.loads(variables_json)
    steps = json.loads(steps_json)
    transitions = json.loads(transitions_json)
    
    current_step = next((step for step in steps if step['id'] == current_step_id), None)
    if not current_step:
        return
    
    # Execute step actions
    for action in current_step['actions']:
        execute_action(action, variables)
    
    # Determine next step
    next_step = determine_next_step(current_step, transitions, variables, steps)
    
    if next_step:
        status = 'Completed' if next_step.get('is_end_step', False) else 'Running'
        end_date = datetime.now() if status == 'Completed' else None
        
        cursor.execute('''
            UPDATE workflow_instances 
            SET current_step_id = ?, status = ?, end_date = ?, variables = ?
            WHERE id = ?
        ''', (next_step['id'], status, end_date, json.dumps(variables), instance_id))
    
    conn.commit()
    conn.close()

def execute_action(action, variables):
    # Simulate action execution
    print(f"Executing action: {action['type']} with parameters: {action['parameters']}")

def determine_next_step(current_step, transitions, variables, steps):
    for transition in transitions:
        if transition['from'] == current_step['id']:
            # In a real implementation, evaluate transition conditions here
            return next((step for step in steps if step['id'] == transition['to']), None)
    
    return None
```

----

### ğŸ§ª Senaryo 10: Bir iÅŸ akÄ±ÅŸÄ± motoru sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± XML dosyalarÄ±nda tutar. KullanÄ±cÄ±lar iÅŸ akÄ±ÅŸÄ± ÅŸemalarÄ±nÄ± XML olarak sisteme yÃ¼kler. Motor bu tanÄ±mlarÄ± iÅŸleyerek sÃ¼reÃ§leri baÅŸlatÄ±r. Ä°ÅŸ akÄ±ÅŸÄ± adÄ±mlarÄ± XML yapÄ±sÄ±ndan oluÅŸturulur.
**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** Claude

```typescript
import express from 'express';
import multer from 'multer';
import { parseString } from 'xml2js';
import { Database } from 'sqlite3';

const app = express();
const upload = multer({ dest: 'uploads/' });
const db = new Database('workflows.db');

app.use(express.json());

interface WorkflowStep {
    id: string;
    name: string;
    type: string;
    isStartStep: boolean;
    isEndStep: boolean;
    actions: WorkflowAction[];
    conditions: WorkflowCondition[];
}

interface WorkflowAction {
    type: string;
    parameters: { [key: string]: string };
}

interface WorkflowCondition {
    expression: string;
    type: string;
}

interface WorkflowTransition {
    from: string;
    to: string;
    condition?: string;
    label?: string;
}

interface WorkflowDefinition {
    name: string;
    version: string;
    description: string;
    steps: WorkflowStep[];
    transitions: WorkflowTransition[];
}

interface WorkflowInstance {
    id?: number;
    workflowId: number;
    initiatedBy: string;
    status: string;
    startDate: Date;
    endDate?: Date;
    currentStepId: string;
    variables: { [key: string]: any };
}

app.post('/upload-workflow', upload.single('workflowFile'), (req, res) => {
    if (!req.file) {
        return res.status(400).json({ error: 'No workflow file provided' });
    }

    const fs = require('fs');
    const xmlContent = fs.readFileSync(req.file.path, 'utf8');

    parseString(xmlContent, (err, result) => {
        if (err) {
            return res.status(400).json({ error: `Invalid XML: ${err.message}` });
        }

        try {
            const workflow = parseWorkflowDefinition(result);
            const validationResult = validateWorkflow(workflow);

            if (!validationResult.isValid) {
                return res.status(400).json({ 
                    error: 'Workflow validation failed', 
                    errors: validationResult.errors 
                });
            }

            // Save workflow
            db.run(
                'INSERT INTO workflow_definitions (name, version, description, steps, transitions, created_date) VALUES (?, ?, ?, ?, ?, ?)',
                [workflow.name, workflow.version, workflow.description, 
                 JSON.stringify(workflow.steps), JSON.stringify(workflow.transitions), new Date()],
                function(err) {
                    if (err) {
                        return res.status(500).json({ error: 'Database error' });
                    }

                    res.json({
                        message: 'Workflow uploaded successfully',
                        workflow_id: this.lastID,
                        step_count: workflow.steps.length
                    });
                }
            );

        } catch (error) {
            res.status(500).json({ error: `Upload failed: ${error.message}` });
        }
    });
});

app.post('/start-workflow', (req, res) => {
    const { workflow_id, user_id, initial_variables = {} } = req.body;

    // Get workflow definition
    db.get('SELECT name, steps, transitions FROM workflow_definitions WHERE id = ?', [workflow_id], (err, row: any) => {
        if (err || !row) {
            return res.status(404).json({ error: 'Workflow not found' });
        }

        try {
            const steps: WorkflowStep[] = JSON.parse(row.steps);
            const startStep = steps.find(step => step.isStartStep);

            if (!startStep) {
                return res.status(400).json({ error: 'No start step found in workflow' });
            }

            // Create workflow instance
            const workflowInstance: WorkflowInstance = {
                workflowId: workflow_id,
                initiatedBy: user_id,
                status: 'Running',
                startDate: new Date(),
                currentStepId: startStep.id,
                variables: initial_variables
            };

            db.run(
                'INSERT INTO workflow_instances (workflow_id, initiated_by, status, start_date, current_step_id, variables) VALUES (?, ?, ?, ?, ?, ?)',
                [workflowInstance.workflowId, workflowInstance.initiatedBy, workflowInstance.status,
                 workflowInstance.startDate, workflowInstance.currentStepId, JSON.stringify(workflowInstance.variables)],
                function(err) {
                    if (err) {
                        return res.status(500).json({ error: 'Database error' });
                    }

                    const instanceId = this.lastID;
                    executeCurrentStep(instanceId);

                    res.json({
                        message: 'Workflow started successfully',
                        instance_id: instanceId,
                        current_step: workflowInstance.currentStepId
                    });
                }
            );

        } catch (error) {
            res.status(500).json({ error: `Workflow start failed: ${error.message}` });
        }
    });
});

function parseWorkflowDefinition(xmlObject: any): WorkflowDefinition {
    const root = xmlObject.workflow || xmlObject;
    
    const workflow: WorkflowDefinition = {
        name: root.$.name || 'Unnamed Workflow',
        version: root.$.version || '1.0',
        description: root.description?.[0] || '',
        steps: [],
        transitions: []
    };

    // Parse steps
    if (root.step) {
        const stepList = Array.isArray(root.step) ? root.step : [root.step];
        
        stepList.forEach((stepData: any) => {
            const step: WorkflowStep = {
                id: stepData.$.id,
                name: stepData.$.name,
                type: stepData.$.type,
                isStartStep: stepData.$.isStart === 'true',
                isEndStep: stepData.$.isEnd === 'true',
                actions: parseStepActions(stepData.actions),
                conditions: parseStepConditions(stepData.conditions)
            };
            
            workflow.steps.push(step);
        });
    }

    // Parse transitions
    if (root.transition) {
        const transitionList = Array.isArray(root.transition) ? root.transition : [root.transition];
        
        transitionList.forEach((transitionData: any) => {
            const transition: WorkflowTransition = {
                from: transitionData.$.from,
                to: transitionData.$.to,
                condition: transitionData.$.condition,
                label: transitionData.$.label
            };
            
            workflow.transitions.push(transition);
        });
    }

    return workflow;
}

function parseStepActions(actionsData: any): WorkflowAction[] {
    if (!actionsData || !actionsData[0] || !actionsData[0].action) {
        return [];
    }

    const actions: WorkflowAction[] = [];
    const actionList = Array.isArray(actionsData[0].action) ? actionsData[0].action : [actionsData[0].action];

    actionList.forEach((actionData: any) => {
        actions.push({
            type: actionData.$.type,
            parameters: actionData.$ || {}
        });
    });

    return actions;
}

function parseStepConditions(conditionsData: any): WorkflowCondition[] {
    if (!conditionsData || !conditionsData[0] || !conditionsData[0].condition) {
        return [];
    }

    const conditions: WorkflowCondition[] = [];
    const conditionList = Array.isArray(conditionsData[0].condition) ? conditionsData[0].condition : [conditionsData[0].condition];

    conditionList.forEach((conditionData: any) => {
        conditions.push({
            expression: conditionData._,
            type: conditionData.$.type
        });
    });

    return conditions;
}

function validateWorkflow(workflow: WorkflowDefinition): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!workflow.name) {
        errors.push('Workflow name is required');
    }

    if (!workflow.steps || workflow.steps.length === 0) {
        errors.push('Workflow must have at least one step');
    }

    const startSteps = workflow.steps.filter(step => step.isStartStep);
    if (startSteps.length !== 1) {
        errors.push('Workflow must have exactly one start step');
    }

    const stepIds = workflow.steps.map(step => step.id);
    workflow.transitions.forEach(transition => {
        if (!stepIds.includes(transition.from)) {
            errors.push(`Transition from unknown step: ${transition.from}`);
        }
        if (!stepIds.includes(transition.to)) {
            errors.push(`Transition to unknown step: ${transition.to}`);
        }
    });

    return {
        isValid: errors.length === 0,
        errors
    };
}

function executeCurrentStep(instanceId: number): void {
    db.get(`
        SELECT wi.workflow_id, wi.current_step_id, wi.variables, wd.steps, wd.transitions
        FROM workflow_instances wi
        JOIN workflow_definitions wd ON wi.workflow_id = wd.id
        WHERE wi.id = ?
    `, [instanceId], (err, row: any) => {
        if (err || !row) return;

        const variables = JSON.parse(row.variables);
        const steps: WorkflowStep[] = JSON.parse(row.steps);
        const transitions: WorkflowTransition[] = JSON.parse(row.transitions);

        const currentStep = steps.find(step => step.id === row.current_step_id);
        if (!currentStep) return;

        // Execute step actions
        currentStep.actions.forEach(action => {
            executeAction(action, variables);
        });

        // Determine next step
        const nextStep = determineNextStep(currentStep, transitions, variables, steps);

        if (nextStep) {
            const status = nextStep.isEndStep ? 'Completed' : 'Running';
            const endDate = nextStep.isEndStep ? new Date() : null;

            db.run(
                'UPDATE workflow_instances SET current_step_id = ?, status = ?, end_date = ?, variables = ? WHERE id = ?',
                [nextStep.id, status, endDate, JSON.stringify(variables), instanceId]
            );
        }
    });
}

function executeAction(action: WorkflowAction, variables: { [key: string]: any }): void {
    // Simulate action execution
    console.log(`Executing action: ${action.type} with parameters:`, action.parameters);
}

function determineNextStep(currentStep: WorkflowStep, transitions: WorkflowTransition[], variables: { [key: string]: any }, steps: WorkflowStep[]): WorkflowStep | null {
    const transition = transitions.find(t => t.from === currentStep.id);
    if (transition) {
        // In a real implementation, evaluate transition conditions here
        return steps.find(step => step.id === transition.to) || null;
    }
    return null;
}
```