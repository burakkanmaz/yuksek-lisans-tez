# Dosya Yükleme Senaryoları - Kod Örnekleri

## ✏️ Senaryo 1
Bir belge paylaşım platformunda kullanıcılar dosyalarını yükleyebiliyor. Platform farklı dosya türlerini destekler. Kullanıcılar çeşitli uzantılarda dosyalar yükleyebilir. Yüklenen dosyalar sistem üzerinde saklanır.

### 🧪 Senaryo 1: Belge Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 27
```csharp
[HttpPost("upload-document")]
public async Task<IActionResult> UploadDocument(IFormFile file, int userId)
{
    if (file == null || file.Length == 0)
        return BadRequest("File is required");

    var allowedExtensions = new[] { ".pdf", ".doc", ".docx", ".txt", ".xlsx" };
    var extension = Path.GetExtension(file.FileName).ToLower();
    
    if (!allowedExtensions.Contains(extension))
        return BadRequest("File type not supported");

    var fileName = $"{Guid.NewGuid()}{extension}";
    var filePath = Path.Combine("uploads/documents", fileName);
    
    using (var stream = new FileStream(filePath, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }

    var document = new Document
    {
        UserId = userId,
        FileName = file.FileName,
        FilePath = filePath,
        FileSize = file.Length,
        UploadDate = DateTime.UtcNow
    };

    _context.Documents.Add(document);
    await _context.SaveChangesAsync();
    
    return Ok(new { Message = "Document uploaded successfully", DocumentId = document.Id });
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 39
```python
from flask import Flask, request, jsonify
import os
import uuid
from datetime import datetime
from werkzeug.utils import secure_filename

app = Flask(__name__)

ALLOWED_EXTENSIONS = {'.pdf', '.doc', '.docx', '.txt', '.xlsx'}
UPLOAD_FOLDER = 'uploads/documents'

@app.route('/upload-document', methods=['POST'])
def upload_document():
    if 'file' not in request.files:
        return jsonify({'error': 'File is required'}), 400
    
    file = request.files['file']
    user_id = request.form.get('user_id')
    
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    filename = secure_filename(file.filename)
    _, extension = os.path.splitext(filename)
    
    if extension.lower() not in ALLOWED_EXTENSIONS:
        return jsonify({'error': 'File type not supported'}), 400
    
    # Generate unique filename
    unique_filename = f"{uuid.uuid4()}{extension}"
    file_path = os.path.join(UPLOAD_FOLDER, unique_filename)
    
    # Save file
    file.save(file_path)
    
    # Save to database
    document_data = {
        'user_id': user_id,
        'original_name': filename,
        'file_path': file_path,
        'file_size': os.path.getsize(file_path),
        'upload_date': datetime.utcnow()
    }
    
    # Database save logic here
    document_id = save_document_to_db(document_data)
    
    return jsonify({
        'message': 'Document uploaded successfully',
        'document_id': document_id
    }), 200
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 46
```typescript
import express from 'express';
import multer from 'multer';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';

const router = express.Router();

const allowedExtensions = ['.pdf', '.doc', '.docx', '.txt', '.xlsx'];

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/documents/');
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    cb(null, `${uuidv4()}${extension}`);
  }
});

const fileFilter = (req: any, file: Express.Multer.File, cb: any) => {
  const extension = path.extname(file.originalname).toLowerCase();
  if (allowedExtensions.includes(extension)) {
    cb(null, true);
  } else {
    cb(new Error('File type not supported'), false);
  }
};

const upload = multer({ storage, fileFilter });

router.post('/upload-document', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'File is required' });
    }

    const documentData = {
      userId: req.body.userId,
      fileName: req.file.originalname,
      filePath: req.file.path,
      fileSize: req.file.size,
      uploadDate: new Date()
    };

    // Save to database
    const documentId = await saveDocumentToDatabase(documentData);

    res.json({
      message: 'Document uploaded successfully',
      documentId
    });
  } catch (error) {
    res.status(500).json({ error: 'Upload failed' });
  }
});
```

## ✏️ Senaryo 2
Bir portfolio web sitesinde kullanıcılar çalışmalarını yükleyebiliyor. Site farklı dosya formatlarını kabul eder. Kullanıcılar resim, video ve dokuman dosyaları yükleyebilir. Yüklenen içerikler kullanıcı galilerinde görüntülenir.

### 🧪 Senaryo 2: Portfolio Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 48
```csharp
[HttpPost("upload-portfolio-item")]
public async Task<IActionResult> UploadPortfolioItem(IFormFile file, string title, string description, int userId)
{
    var imageExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif" };
    var videoExtensions = new[] { ".mp4", ".avi", ".mov" };
    var docExtensions = new[] { ".pdf", ".doc", ".docx" };
    
    var extension = Path.GetExtension(file.FileName).ToLower();
    string fileType = "unknown";
    string uploadPath = "";
    
    if (imageExtensions.Contains(extension))
    {
        fileType = "image";
        uploadPath = "uploads/portfolio/images";
    }
    else if (videoExtensions.Contains(extension))
    {
        fileType = "video";
        uploadPath = "uploads/portfolio/videos";
    }
    else if (docExtensions.Contains(extension))
    {
        fileType = "document";
        uploadPath = "uploads/portfolio/documents";
    }
    else
    {
        return BadRequest("Unsupported file format");
    }

    var fileName = $"{Guid.NewGuid()}{extension}";
    var filePath = Path.Combine(uploadPath, fileName);
    
    using (var stream = new FileStream(filePath, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }

    var portfolioItem = new PortfolioItem
    {
        UserId = userId,
        Title = title,
        Description = description,
        FileName = file.FileName,
        FilePath = filePath,
        FileType = fileType,
        UploadDate = DateTime.UtcNow
    };

    _context.PortfolioItems.Add(portfolioItem);
    await _context.SaveChangesAsync();
    
    return Ok(new { Message = "Portfolio item uploaded successfully" });
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 40
```python
@app.route('/upload-portfolio-item', methods=['POST'])
def upload_portfolio_item():
    file = request.files['file']
    title = request.form.get('title')
    description = request.form.get('description')
    user_id = request.form.get('user_id')
    
    if not file or file.filename == '':
        return jsonify({'error': 'File is required'}), 400
    
    filename = secure_filename(file.filename)
    _, extension = os.path.splitext(filename)
    
    image_extensions = {'.jpg', '.jpeg', '.png', '.gif'}
    video_extensions = {'.mp4', '.avi', '.mov'}
    doc_extensions = {'.pdf', '.doc', '.docx'}
    
    file_type = 'unknown'
    upload_folder = ''
    
    if extension.lower() in image_extensions:
        file_type = 'image'
        upload_folder = 'uploads/portfolio/images'
    elif extension.lower() in video_extensions:
        file_type = 'video'
        upload_folder = 'uploads/portfolio/videos'
    elif extension.lower() in doc_extensions:
        file_type = 'document'
        upload_folder = 'uploads/portfolio/documents'
    else:
        return jsonify({'error': 'Unsupported file format'}), 400
        
    unique_filename = f"{uuid.uuid4()}{extension}"
    file_path = os.path.join(upload_folder, unique_filename)
    
    file.save(file_path)
    
    portfolio_item_data = {
        'user_id': user_id,
        'title': title,
        'description': description,
        'original_name': filename,
        'file_path': file_path,
        'file_type': file_type,
        'upload_date': datetime.utcnow()
    }
    
    save_portfolio_item_to_db(portfolio_item_data)
    
    return jsonify({'message': 'Portfolio item uploaded successfully'}), 200
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 42
```typescript
import multer from 'multer';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';

const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif'];
const videoExtensions = ['.mp4', '.avi', '.mov'];
const docExtensions = ['.pdf', '.doc', '.docx'];

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    let uploadPath = 'uploads/portfolio/misc';

    if (imageExtensions.includes(extension)) {
      uploadPath = 'uploads/portfolio/images';
    } else if (videoExtensions.includes(extension)) {
      uploadPath = 'uploads/portfolio/videos';
    } else if (docExtensions.includes(extension)) {
      uploadPath = 'uploads/portfolio/documents';
    }
    
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    cb(null, `${uuidv4()}${extension}`);
  }
});

const fileFilter = (req: any, file: Express.Multer.File, cb: any) => {
  const extension = path.extname(file.originalname).toLowerCase();
  const allowedExtensions = [...imageExtensions, ...videoExtensions, ...docExtensions];
  
  if (allowedExtensions.includes(extension)) {
    cb(null, true);
  } else {
    cb(new Error('Unsupported file format'), false);
  }
};

const uploadPortfolio = multer({ storage, fileFilter });

router.post('/upload-portfolio-item', uploadPortfolio.single('file'), async (req, res) => {
    try {
        // ... (save to database logic similar to document upload)
        res.json({ message: 'Portfolio item uploaded' });
    } catch(error) {
        res.status(500).json({ error: 'Upload failed' });
    }
});
```

## ✏️ Senaryo 3
Bir müzik paylaşım sitesinde sanatçılar eserlerini yükleyebiliyor. Platform ses dosyaları ve albüm kapakları için dosya yüklemeyi destekler. Farklı ses formatları sisteme yüklenebilir. Yüklenen dosyalar katalogda yer alır.

### 🧪 Senaryo 3: Müzik Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 44
```csharp
[HttpPost("upload-music")]
public async Task<IActionResult> UploadMusic(IFormFile audioFile, IFormFile? coverImage, 
    string title, string artist, string album, int artistId)
{
    var audioExtensions = new[] { ".mp3", ".wav", ".flac", ".aac" };
    var imageExtensions = new[] { ".jpg", ".jpeg", ".png" };
    
    var audioExtension = Path.GetExtension(audioFile.FileName).ToLower();
    if (!audioExtensions.Contains(audioExtension))
        return BadRequest("Audio format not supported");

    var audioFileName = $"{Guid.NewGuid()}{audioExtension}";
    var audioPath = Path.Combine("uploads/music/audio", audioFileName);
    
    using (var stream = new FileStream(audioPath, FileMode.Create))
    {
        await audioFile.CopyToAsync(stream);
    }

    string? coverImagePath = null;
    if (coverImage != null)
    {
        var imageExtension = Path.GetExtension(coverImage.FileName).ToLower();
        if (imageExtensions.Contains(imageExtension))
        {
            var coverFileName = $"{Guid.NewGuid()}{imageExtension}";
            coverImagePath = Path.Combine("uploads/music/covers", coverFileName);
            
            using (var stream = new FileStream(coverImagePath, FileMode.Create))
            {
                await coverImage.CopyToAsync(stream);
            }
        }
    }

    var musicTrack = new MusicTrack
    {
        ArtistId = artistId,
        Title = title,
        Artist = artist,
        Album = album,
        AudioFilePath = audioPath,
        CoverImagePath = coverImagePath,
        Duration = GetAudioDuration(audioPath),
        UploadDate = DateTime.UtcNow
    };

    _context.MusicTracks.Add(musicTrack);
    await _context.SaveChangesAsync();
    
    return Ok(new { Message = "Music uploaded successfully", TrackId = musicTrack.Id });
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 48
```python
@app.route('/upload-music', methods=['POST'])
def upload_music():
    audio_file = request.files.get('audio_file')
    cover_image = request.files.get('cover_image')
    title = request.form.get('title')
    artist = request.form.get('artist')
    album = request.form.get('album')
    artist_id = request.form.get('artist_id')
    
    if not audio_file:
        return jsonify({'error': 'Audio file is required'}), 400
    
    # Validate audio file
    audio_extensions = {'.mp3', '.wav', '.flac', '.aac'}
    audio_filename = secure_filename(audio_file.filename)
    _, audio_extension = os.path.splitext(audio_filename)
    
    if audio_extension.lower() not in audio_extensions:
        return jsonify({'error': 'Audio format not supported'}), 400
    
    # Save audio file
    audio_unique_name = f"{uuid.uuid4()}{audio_extension}"
    audio_path = os.path.join('uploads/music/audio', audio_unique_name)
    audio_file.save(audio_path)
    
    # Handle cover image if provided
    cover_image_path = None
    if cover_image and cover_image.filename:
        image_extensions = {'.jpg', '.jpeg', '.png'}
        cover_filename = secure_filename(cover_image.filename)
        _, cover_extension = os.path.splitext(cover_filename)
        
        if cover_extension.lower() in image_extensions:
            cover_unique_name = f"{uuid.uuid4()}{cover_extension}"
            cover_image_path = os.path.join('uploads/music/covers', cover_unique_name)
            cover_image.save(cover_image_path)
    
    # Get audio duration (simplified)
    duration = get_audio_duration(audio_path)
    
    # Save to database
    music_data = {
        'artist_id': artist_id,
        'title': title,
        'artist': artist,
        'album': album,
        'audio_file_path': audio_path,
        'cover_image_path': cover_image_path,
        'duration': duration,
        'upload_date': datetime.utcnow()
    }
    
    track_id = save_music_track_to_db(music_data)
    
    return jsonify({
        'message': 'Music uploaded successfully',
        'track_id': track_id
    }), 200
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 57
```typescript
const audioExtensions = ['.mp3', '.wav', '.flac', '.aac'];
const imageExtensions = ['.jpg', '.jpeg', '.png'];

const musicStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    
    if (audioExtensions.includes(extension)) {
      cb(null, 'uploads/music/audio/');
    } else if (imageExtensions.includes(extension)) {
      cb(null, 'uploads/music/covers/');
    } else {
      cb(new Error('Unsupported file format'), '');
    }
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    cb(null, `${uuidv4()}${extension}`);
  }
});

const musicUpload = multer({ storage: musicStorage });

router.post('/upload-music', 
  musicUpload.fields([
    { name: 'audioFile', maxCount: 1 },
    { name: 'coverImage', maxCount: 1 }
  ]), 
  async (req, res) => {
    try {
      const files = req.files as { [fieldname: string]: Express.Multer.File[] };
      
      if (!files.audioFile || files.audioFile.length === 0) {
        return res.status(400).json({ error: 'Audio file is required' });
      }

      const audioFile = files.audioFile[0];
      const coverFile = files.coverImage?.[0];

      // Validate audio file extension
      const audioExtension = path.extname(audioFile.originalname).toLowerCase();
      if (!audioExtensions.includes(audioExtension)) {
        return res.status(400).json({ error: 'Audio format not supported' });
      }

      const musicData = {
        artistId: req.body.artistId,
        title: req.body.title,
        artist: req.body.artist,
        album: req.body.album,
        audioFilePath: audioFile.path,
        coverImagePath: coverFile?.path || null,
        duration: await getAudioDuration(audioFile.path),
        uploadDate: new Date()
      };

      const trackId = await saveMusicTrackToDatabase(musicData);

      res.json({
        message: 'Music uploaded successfully',
        trackId
      });
    } catch (error) {
      res.status(500).json({ error: 'Upload failed' });
    }
  }
);
```

## ✏️ Senaryo 4
Bir e-öğrenme platformunda eğitmenler ders materyallerini yükleyebiliyor. Sistem sunum, dokuman ve video dosyalarını kabul eder. Çeşitli eğitim içerikleri platforma yüklenebilir. Materyaller öğrencilere sunulur.

### 🧪 Senaryo 4: Ders Materyali Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 52
```csharp
[HttpPost("upload-course-material")]
public async Task<IActionResult> UploadCourseMaterial(IFormFile file, int courseId, 
    string materialTitle, string description, int instructorId)
{
    var presentationExtensions = new[] { ".ppt", ".pptx", ".pdf" };
    var documentExtensions = new[] { ".pdf", ".doc", ".docx", ".txt" };
    var videoExtensions = new[] { ".mp4", ".avi", ".mov", ".wmv" };
    
    var extension = Path.GetExtension(file.FileName).ToLower();
    string materialType = "";
    string uploadFolder = "";
    
    if (presentationExtensions.Contains(extension))
    {
        materialType = "presentation";
        uploadFolder = "uploads/courses/presentations";
    }
    else if (documentExtensions.Contains(extension))
    {
        materialType = "document";
        uploadFolder = "uploads/courses/documents";
    }
    else if (videoExtensions.Contains(extension))
    {
        materialType = "video";
        uploadFolder = "uploads/courses/videos";
    }
    else
    {
        return BadRequest("File format not supported for course materials");
    }

    var fileName = $"{Guid.NewGuid()}{extension}";
    var filePath = Path.Combine(uploadFolder, fileName);
    
    using (var stream = new FileStream(filePath, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }

    var courseMaterial = new CourseMaterial
    {
        CourseId = courseId,
        InstructorId = instructorId,
        Title = materialTitle,
        Description = description,
        FileName = file.FileName,
        FilePath = filePath,
        MaterialType = materialType,
        FileSize = file.Length,
        UploadDate = DateTime.UtcNow,
        IsActive = true
    };

    _context.CourseMaterials.Add(courseMaterial);
    await _context.SaveChangesAsync();
    
    return Ok(new { Message = "Course material uploaded successfully", MaterialId = courseMaterial.Id });
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 49
```python
@app.route('/upload-course-material', methods=['POST'])
def upload_course_material():
    file = request.files['file']
    course_id = request.form.get('course_id')
    material_title = request.form.get('material_title')
    description = request.form.get('description')
    instructor_id = request.form.get('instructor_id')
    
    if not file or file.filename == '':
        return jsonify({'error': 'File is required'}), 400
    
    filename = secure_filename(file.filename)
    _, extension = os.path.splitext(filename)
    extension = extension.lower()
    
    # Define material types and paths
    presentation_extensions = {'.ppt', '.pptx', '.pdf'}
    document_extensions = {'.pdf', '.doc', '.docx', '.txt'}
    video_extensions = {'.mp4', '.avi', '.mov', '.wmv'}
    
    if extension in presentation_extensions:
        material_type = 'presentation'
        upload_folder = 'uploads/courses/presentations'
    elif extension in document_extensions:
        material_type = 'document'
        upload_folder = 'uploads/courses/documents'
    elif extension in video_extensions:
        material_type = 'video'
        upload_folder = 'uploads/courses/videos'
    else:
        return jsonify({'error': 'File format not supported for course materials'}), 400
    
    # Save file
    unique_filename = f"{uuid.uuid4()}{extension}"
    file_path = os.path.join(upload_folder, unique_filename)
    file.save(file_path)
    
    # Save course material to database
    material_data = {
        'course_id': course_id,
        'instructor_id': instructor_id,
        'title': material_title,
        'description': description,
        'file_name': filename,
        'file_path': file_path,
        'material_type': material_type,
        'file_size': os.path.getsize(file_path),
        'upload_date': datetime.utcnow(),
        'is_active': True
    }
    
    material_id = save_course_material_to_db(material_data)
    
    return jsonify({
        'message': 'Course material uploaded successfully',
        'material_id': material_id
    }), 200
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 58
```typescript
interface MaterialTypeConfig {
  extensions: string[];
  type: string;
  uploadPath: string;
}

const materialConfigs: MaterialTypeConfig[] = [
  { extensions: ['.ppt', '.pptx'], type: 'presentation', uploadPath: 'uploads/courses/presentations' },
  { extensions: ['.pdf', '.doc', '.docx', '.txt'], type: 'document', uploadPath: 'uploads/courses/documents' },
  { extensions: ['.mp4', '.avi', '.mov', '.wmv'], type: 'video', uploadPath: 'uploads/courses/videos' }
];

const courseStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    const config = materialConfigs.find(config => 
      config.extensions.includes(extension)
    );
    
    if (config) {
      cb(null, config.uploadPath);
    } else {
      cb(new Error('File format not supported for course materials'), '');
    }
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    cb(null, `${uuidv4()}${extension}`);
  }
});

const courseUpload = multer({ storage: courseStorage });

router.post('/upload-course-material', courseUpload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'File is required' });
    }

    const extension = path.extname(req.file.originalname).toLowerCase();
    const config = materialConfigs.find(config => 
      config.extensions.includes(extension)
    );

    const materialData = {
      courseId: req.body.courseId,
      instructorId: req.body.instructorId,
      title: req.body.materialTitle,
      description: req.body.description,
      fileName: req.file.originalname,
      filePath: req.file.path,
      materialType: config?.type,
      fileSize: req.file.size,
      uploadDate: new Date(),
      isActive: true
    };

    const materialId = await saveCourseMaterialToDatabase(materialData);

    res.json({
      message: 'Course material uploaded successfully',
      materialId
    });
  } catch (error) {
    res.status(500).json({ error: 'Upload failed' });
  }
});
```

## ✏️ Senaryo 5
Bir proje yönetim aracında ekip üyeleri dosya paylaşımı yapabiliyor. Araç farklı türde proje dosyalarını destekler. Kullanıcılar tasarım, kod ve dokuman dosyaları yükleyebilir. Paylaşılan dosyalar proje klasörlerinde saklanır.

### 🧪 Senaryo 5: Proje Dosyası Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 44
```csharp
[HttpPost("upload-project-file")]
public async Task<IActionResult> UploadProjectFile(IFormFile file, int projectId, 
    int userId, string fileCategory, string description)
{
    var designExtensions = new[] { ".psd", ".ai", ".sketch", ".fig", ".png", ".jpg" };
    var codeExtensions = new[] { ".cs", ".js", ".ts", ".html", ".css", ".py", ".java" };
    var documentExtensions = new[] { ".pdf", ".doc", ".docx", ".txt", ".md" };
    
    var extension = Path.GetExtension(file.FileName).ToLower();
    string fileType = "";
    
    if (designExtensions.Contains(extension))
        fileType = "design";
    else if (codeExtensions.Contains(extension))
        fileType = "code";
    else if (documentExtensions.Contains(extension))
        fileType = "document";
    else
        return BadRequest("File type not supported for project files");

    var fileName = $"{Guid.NewGuid()}{extension}";
    var projectFolder = $"uploads/projects/{projectId}";
    var categoryFolder = Path.Combine(projectFolder, fileType);
    
    // Ensure directory exists
    Directory.CreateDirectory(categoryFolder);
    
    var filePath = Path.Combine(categoryFolder, fileName);
    
    using (var stream = new FileStream(filePath, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }

    var projectFile = new ProjectFile
    {
        ProjectId = projectId,
        UserId = userId,
        FileName = file.FileName,
        FilePath = filePath,
        FileType = fileType,
        FileCategory = fileCategory,
        Description = description,
        FileSize = file.Length,
        UploadDate = DateTime.UtcNow,
        Version = 1
    };

    _context.ProjectFiles.Add(projectFile);
    await _context.SaveChangesAsync();
    
    return Ok(new { Message = "Project file uploaded successfully", FileId = projectFile.Id });
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 50
```python
@app.route('/upload-project-file', methods=['POST'])
def upload_project_file():
    file = request.files['file']
    project_id = request.form.get('project_id')
    user_id = request.form.get('user_id')
    file_category = request.form.get('file_category')
    description = request.form.get('description')
    
    if not file or file.filename == '':
        return jsonify({'error': 'File is required'}), 400
    
    filename = secure_filename(file.filename)
    _, extension = os.path.splitext(filename)
    extension = extension.lower()
    
    # Define file types
    design_extensions = {'.psd', '.ai', '.sketch', '.fig', '.png', '.jpg'}
    code_extensions = {'.cs', '.js', '.ts', '.html', '.css', '.py', '.java'}
    document_extensions = {'.pdf', '.doc', '.docx', '.txt', '.md'}
    
    if extension in design_extensions:
        file_type = 'design'
    elif extension in code_extensions:
        file_type = 'code'
    elif extension in document_extensions:
        file_type = 'document'
    else:
        return jsonify({'error': 'File type not supported for project files'}), 400
    
    # Create project folder structure
    project_folder = f'uploads/projects/{project_id}'
    category_folder = os.path.join(project_folder, file_type)
    os.makedirs(category_folder, exist_ok=True)
    
    # Save file
    unique_filename = f"{uuid.uuid4()}{extension}"
    file_path = os.path.join(category_folder, unique_filename)
    file.save(file_path)
    
    # Save project file to database
    project_file_data = {
        'project_id': project_id,
        'user_id': user_id,
        'file_name': filename,
        'file_path': file_path,
        'file_type': file_type,
        'file_category': file_category,
        'description': description,
        'file_size': os.path.getsize(file_path),
        'upload_date': datetime.utcnow(),
        'version': 1
    }
    
    file_id = save_project_file_to_db(project_file_data)
    
    return jsonify({
        'message': 'Project file uploaded successfully',
        'file_id': file_id
    }), 200
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 57
```typescript
const projectFileConfigs = [
  { extensions: ['.psd', '.ai', '.sketch', '.fig', '.png', '.jpg'], type: 'design' },
  { extensions: ['.cs', '.js', '.ts', '.html', '.css', '.py', '.java'], type: 'code' },
  { extensions: ['.pdf', '.doc', '.docx', '.txt', '.md'], type: 'document' }
];

const projectStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    const config = projectFileConfigs.find(config => 
      config.extensions.includes(extension)
    );
    
    if (config) {
      const projectId = req.body.projectId;
      const folderPath = `uploads/projects/${projectId}/${config.type}`;
      
      // Ensure directory exists
      fs.mkdirSync(folderPath, { recursive: true });
      cb(null, folderPath);
    } else {
      cb(new Error('File type not supported for project files'), '');
    }
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    cb(null, `${uuidv4()}${extension}`);
  }
});

const projectUpload = multer({ storage: projectStorage });

router.post('/upload-project-file', projectUpload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'File is required' });
    }

    const extension = path.extname(req.file.originalname).toLowerCase();
    const config = projectFileConfigs.find(config => 
      config.extensions.includes(extension)
    );

    const projectFileData = {
      projectId: req.body.projectId,
      userId: req.body.userId,
      fileName: req.file.originalname,
      filePath: req.file.path,
      fileType: config?.type,
      fileCategory: req.body.fileCategory,
      description: req.body.description,
      fileSize: req.file.size,
      uploadDate: new Date(),
      version: 1
    };

    const fileId = await saveProjectFileToDatabase(projectFileData);

    res.json({
      message: 'Project file uploaded successfully',
      fileId
    });
  } catch (error) {
    res.status(500).json({ error: 'Upload failed' });
  }
});
```

## ✏️ Senaryo 6
Bir sosyal medya platformunda kullanıcılar içerik paylaşabiliyor. Platform resim, video ve GIF dosyalarını destekler. Kullanıcılar farklı medya türleri yükleyebilir. Paylaşılan içerikler akışta görüntülenir.

### 🧪 Senaryo 6: İçerik Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 52
```csharp
[HttpPost("upload-social-media-content")]
public async Task<IActionResult> UploadSocialMediaContent(IFormFile file, int userId, 
    string caption, List<string> hashtags)
{
    var imageExtensions = new[] { ".jpg", ".jpeg", ".png" };
    var videoExtensions = new[] { ".mp4", ".mov", ".avi" };
    var gifExtensions = new[] { ".gif" };
    
    var extension = Path.GetExtension(file.FileName).ToLower();
    string contentType = "";
    string uploadFolder = "";
    
    if (imageExtensions.Contains(extension))
    {
        contentType = "image";
        uploadFolder = "uploads/social/images";
    }
    else if (videoExtensions.Contains(extension))
    {
        contentType = "video";
        uploadFolder = "uploads/social/videos";
    }
    else if (gifExtensions.Contains(extension))
    {
        contentType = "gif";
        uploadFolder = "uploads/social/gifs";
    }
    else
    {
        return BadRequest("Media type not supported");
    }

    var fileName = $"{Guid.NewGuid()}{extension}";
    var filePath = Path.Combine(uploadFolder, fileName);
    
    using (var stream = new FileStream(filePath, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }

    var socialPost = new SocialPost
    {
        UserId = userId,
        Caption = caption,
        MediaFilePath = filePath,
        MediaType = contentType,
        Hashtags = string.Join(",", hashtags),
        FileSize = file.Length,
        PostDate = DateTime.UtcNow,
        IsActive = true,
        LikeCount = 0,
        CommentCount = 0
    };

    _context.SocialPosts.Add(socialPost);
    await _context.SaveChangesAsync();
    
    return Ok(new { Message = "Content uploaded successfully", PostId = socialPost.Id });
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 48
```python
@app.route('/upload-social-media-content', methods=['POST'])
def upload_social_media_content():
    file = request.files['file']
    user_id = request.form.get('user_id')
    caption = request.form.get('caption')
    hashtags = request.form.get('hashtags', '').split(',')
    
    if not file or file.filename == '':
        return jsonify({'error': 'Media file is required'}), 400
    
    filename = secure_filename(file.filename)
    _, extension = os.path.splitext(filename)
    extension = extension.lower()
    
    # Define media types
    image_extensions = {'.jpg', '.jpeg', '.png'}
    video_extensions = {'.mp4', '.mov', '.avi'}
    gif_extensions = {'.gif'}
    
    if extension in image_extensions:
        content_type = 'image'
        upload_folder = 'uploads/social/images'
    elif extension in video_extensions:
        content_type = 'video'
        upload_folder = 'uploads/social/videos'
    elif extension in gif_extensions:
        content_type = 'gif'
        upload_folder = 'uploads/social/gifs'
    else:
        return jsonify({'error': 'Media type not supported'}), 400
    
    # Save file
    unique_filename = f"{uuid.uuid4()}{extension}"
    file_path = os.path.join(upload_folder, unique_filename)
    file.save(file_path)
    
    # Save social post to database
    social_post_data = {
        'user_id': user_id,
        'caption': caption,
        'media_file_path': file_path,
        'media_type': content_type,
        'hashtags': ','.join(hashtags),
        'file_size': os.path.getsize(file_path),
        'post_date': datetime.utcnow(),
        'is_active': True,
        'like_count': 0,
        'comment_count': 0
    }
    
    post_id = save_social_post_to_db(social_post_data)
    
    return jsonify({
        'message': 'Content uploaded successfully',
        'post_id': post_id
    }), 200
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 54
```typescript
const socialMediaConfigs = [
  { extensions: ['.jpg', '.jpeg', '.png'], type: 'image', uploadPath: 'uploads/social/images' },
  { extensions: ['.mp4', '.mov', '.avi'], type: 'video', uploadPath: 'uploads/social/videos' },
  { extensions: ['.gif'], type: 'gif', uploadPath: 'uploads/social/gifs' }
];

const socialStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    const config = socialMediaConfigs.find(config => 
      config.extensions.includes(extension)
    );
    
    if (config) {
      cb(null, config.uploadPath);
    } else {
      cb(new Error('Media type not supported'), '');
    }
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    cb(null, `${uuidv4()}${extension}`);
  }
});

const socialUpload = multer({ storage: socialStorage });

router.post('/upload-social-media-content', socialUpload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Media file is required' });
    }

    const extension = path.extname(req.file.originalname).toLowerCase();
    const config = socialMediaConfigs.find(config => 
      config.extensions.includes(extension)
    );

    const hashtags = req.body.hashtags ? req.body.hashtags.split(',') : [];

    const socialPostData = {
      userId: req.body.userId,
      caption: req.body.caption,
      mediaFilePath: req.file.path,
      mediaType: config?.type,
      hashtags: hashtags.join(','),
      fileSize: req.file.size,
      postDate: new Date(),
      isActive: true,
      likeCount: 0,
      commentCount: 0
    };

    const postId = await saveSocialPostToDatabase(socialPostData);

    res.json({
      message: 'Content uploaded successfully',
      postId
    });
  } catch (error) {
    res.status(500).json({ error: 'Upload failed' });
  }
});
```

## ✏️ Senaryo 7
Bir bulut depolama servisinde kullanıcılar kişisel dosyalarını yedekleyebiliyor. Servis her türlü dosya formatını kabul eder. Kullanıcılar belgeler, fotoğraflar ve arşiv dosyaları yükleyebilir. Dosyalar kullanıcı hesabında saklanır.

### 🧪 Senaryo 7: Dosya Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 49
```csharp
[HttpPost("upload-to-cloud")]
public async Task<IActionResult> UploadToCloud(IFormFile file, int userId, string folderPath = "")
{
    if (file == null || file.Length == 0)
        return BadRequest("File is required");

    // Check file size limit (e.g., 100MB)
    if (file.Length > 100 * 1024 * 1024)
        return BadRequest("File size exceeds limit");

    // Determine file category
    var extension = Path.GetExtension(file.FileName).ToLower();
    string fileCategory = DetermineFileCategory(extension);
    
    // Create user directory structure
    var userDirectory = Path.Combine("uploads/cloud", userId.ToString());
    if (!string.IsNullOrEmpty(folderPath))
        userDirectory = Path.Combine(userDirectory, folderPath);
    
    Directory.CreateDirectory(userDirectory);
    
    var fileName = $"{Guid.NewGuid()}{extension}";
    var filePath = Path.Combine(userDirectory, fileName);
    
    using (var stream = new FileStream(filePath, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }

    var cloudFile = new CloudFile
    {
        UserId = userId,
        OriginalFileName = file.FileName,
        StoredFileName = fileName,
        FilePath = filePath,
        FolderPath = folderPath,
        FileCategory = fileCategory,
        FileSize = file.Length,
        MimeType = file.ContentType,
        UploadDate = DateTime.UtcNow,
        IsDeleted = false
    };

    _context.CloudFiles.Add(cloudFile);
    await _context.SaveChangesAsync();
    
    return Ok(new { Message = "File uploaded to cloud successfully", FileId = cloudFile.Id });
}

private string DetermineFileCategory(string extension)
{
    var imageExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif", ".bmp" };
    var documentExtensions = new[] { ".pdf", ".doc", ".docx", ".txt", ".xlsx" };
    var archiveExtensions = new[] { ".zip", ".rar", ".7z", ".tar" };
    
    if (imageExtensions.Contains(extension)) return "image";
    if (documentExtensions.Contains(extension)) return "document";
    if (archiveExtensions.Contains(extension)) return "archive";
    return "other";
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 54
```python
@app.route('/upload-to-cloud', methods=['POST'])
def upload_to_cloud():
    file = request.files['file']
    user_id = request.form.get('user_id')
    folder_path = request.form.get('folder_path', '')
    
    if not file or file.filename == '':
        return jsonify({'error': 'File is required'}), 400
    
    # Check file size limit (100MB)
    if request.content_length > 100 * 1024 * 1024:
        return jsonify({'error': 'File size exceeds limit'}), 400
    
    filename = secure_filename(file.filename)
    _, extension = os.path.splitext(filename)
    extension = extension.lower()
    
    # Determine file category
    file_category = determine_file_category(extension)
    
    # Create user directory structure
    user_directory = os.path.join('uploads/cloud', str(user_id))
    if folder_path:
        user_directory = os.path.join(user_directory, folder_path)
    
    os.makedirs(user_directory, exist_ok=True)
    
    # Save file
    unique_filename = f"{uuid.uuid4()}{extension}"
    file_path = os.path.join(user_directory, unique_filename)
    file.save(file_path)
    
    # Save cloud file to database
    cloud_file_data = {
        'user_id': user_id,
        'original_file_name': filename,
        'stored_file_name': unique_filename,
        'file_path': file_path,
        'folder_path': folder_path,
        'file_category': file_category,
        'file_size': os.path.getsize(file_path),
        'mime_type': file.content_type,
        'upload_date': datetime.utcnow(),
        'is_deleted': False
    }
    
    file_id = save_cloud_file_to_db(cloud_file_data)
    
    return jsonify({
        'message': 'File uploaded to cloud successfully',
        'file_id': file_id
    }), 200

def determine_file_category(extension):
    image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp'}
    document_extensions = {'.pdf', '.doc', '.docx', '.txt', '.xlsx'}
    archive_extensions = {'.zip', '.rar', '.7z', '.tar'}
    
    if extension in image_extensions:
        return 'image'
    elif extension in document_extensions:
        return 'document'
    elif extension in archive_extensions:
        return 'archive'
    else:
        return 'other'
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 63
```typescript
// File size limit: 100MB
const FILE_SIZE_LIMIT = 100 * 1024 * 1024;

const cloudStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const userId = req.body.userId;
    const folderPath = req.body.folderPath || '';
    
    let userDirectory = `uploads/cloud/${userId}`;
    if (folderPath) {
      userDirectory = path.join(userDirectory, folderPath);
    }
    
    // Ensure directory exists
    fs.mkdirSync(userDirectory, { recursive: true });
    cb(null, userDirectory);
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    cb(null, `${uuidv4()}${extension}`);
  }
});

const cloudUpload = multer({ 
  storage: cloudStorage,
  limits: { fileSize: FILE_SIZE_LIMIT }
});

function determineFileCategory(extension: string): string {
  const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp'];
  const documentExtensions = ['.pdf', '.doc', '.docx', '.txt', '.xlsx'];
  const archiveExtensions = ['.zip', '.rar', '.7z', '.tar'];
  
  if (imageExtensions.includes(extension)) return 'image';
  if (documentExtensions.includes(extension)) return 'document';
  if (archiveExtensions.includes(extension)) return 'archive';
  return 'other';
}

router.post('/upload-to-cloud', cloudUpload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'File is required' });
    }

    const extension = path.extname(req.file.originalname).toLowerCase();
    const fileCategory = determineFileCategory(extension);

    const cloudFileData = {
      userId: req.body.userId,
      originalFileName: req.file.originalname,
      storedFileName: req.file.filename,
      filePath: req.file.path,
      folderPath: req.body.folderPath || '',
      fileCategory,
      fileSize: req.file.size,
      mimeType: req.file.mimetype,
      uploadDate: new Date(),
      isDeleted: false
    };

    const fileId = await saveCloudFileToDatabase(cloudFileData);

    res.json({
      message: 'File uploaded to cloud successfully',
      fileId
    });
  } catch (error) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ error: 'File size exceeds limit' });
    }
    res.status(500).json({ error: 'Upload failed' });
  }
});
```

## ✏️ Senaryo 8
Bir haber portalında editörler haber içerikleri yükleyebiliyor. Portal metin, resim ve video dosyalarını destekler. Editörler multimedya içerikleri sisteme yükleyebilir. Yüklenen materyaller haberlerde kullanılır.

### 🧪 Senaryo 8: Haber Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 47
```csharp
[HttpPost("upload-news-media")]
public async Task<IActionResult> UploadNewsMedia(IFormFile file, int editorId, 
    string mediaTitle, string altText, int? articleId)
{
    var imageExtensions = new[] { ".jpg", ".jpeg", ".png", ".webp" };
    var videoExtensions = new[] { ".mp4", ".mov", ".avi", ".webm" };
    
    var extension = Path.GetExtension(file.FileName).ToLower();
    string mediaType = "";
    string uploadFolder = "";
    
    if (imageExtensions.Contains(extension))
    {
        mediaType = "image";
        uploadFolder = "uploads/news/images";
    }
    else if (videoExtensions.Contains(extension))
    {
        mediaType = "video";
        uploadFolder = "uploads/news/videos";
    }
    else
    {
        return BadRequest("Media format not supported for news content");
    }

    var fileName = $"{DateTime.Now:yyyyMMdd}_{Guid.NewGuid()}{extension}";
    var filePath = Path.Combine(uploadFolder, fileName);
    
    using (var stream = new FileStream(filePath, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }

    var newsMedia = new NewsMedia
    {
        EditorId = editorId,
        ArticleId = articleId,
        Title = mediaTitle,
        AltText = altText,
        FileName = file.FileName,
        FilePath = filePath,
        MediaType = mediaType,
        FileSize = file.Length,
        UploadDate = DateTime.UtcNow,
        IsApproved = false,
        IsPublished = false
    };

    _context.NewsMedias.Add(newsMedia);
    await _context.SaveChangesAsync();
    
    return Ok(new { Message = "News media uploaded successfully", MediaId = newsMedia.Id });
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 47
```python
@app.route('/upload-news-media', methods=['POST'])
def upload_news_media():
    file = request.files['file']
    editor_id = request.form.get('editor_id')
    media_title = request.form.get('media_title')
    alt_text = request.form.get('alt_text')
    article_id = request.form.get('article_id')
    
    if not file or file.filename == '':
        return jsonify({'error': 'Media file is required'}), 400
    
    filename = secure_filename(file.filename)
    _, extension = os.path.splitext(filename)
    extension = extension.lower()
    
    # Define media types
    image_extensions = {'.jpg', '.jpeg', '.png', '.webp'}
    video_extensions = {'.mp4', '.mov', '.avi', '.webm'}
    
    if extension in image_extensions:
        media_type = 'image'
        upload_folder = 'uploads/news/images'
    elif extension in video_extensions:
        media_type = 'video'
        upload_folder = 'uploads/news/videos'
    else:
        return jsonify({'error': 'Media format not supported for news content'}), 400
    
    # Save file with date prefix
    date_prefix = datetime.now().strftime('%Y%m%d')
    unique_filename = f"{date_prefix}_{uuid.uuid4()}{extension}"
    file_path = os.path.join(upload_folder, unique_filename)
    file.save(file_path)
    
    # Save news media to database
    news_media_data = {
        'editor_id': editor_id,
        'article_id': article_id,
        'title': media_title,
        'alt_text': alt_text,
        'file_name': filename,
        'file_path': file_path,
        'media_type': media_type,
        'file_size': os.path.getsize(file_path),
        'upload_date': datetime.utcnow(),
        'is_approved': False,
        'is_published': False
    }
    
    media_id = save_news_media_to_db(news_media_data)
    
    return jsonify({
        'message': 'News media uploaded successfully',
        'media_id': media_id
    }), 200
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 54
```typescript
const newsMediaConfigs = [
  { extensions: ['.jpg', '.jpeg', '.png', '.webp'], type: 'image', uploadPath: 'uploads/news/images' },
  { extensions: ['.mp4', '.mov', '.avi', '.webm'], type: 'video', uploadPath: 'uploads/news/videos' }
];

const newsStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    const config = newsMediaConfigs.find(config => 
      config.extensions.includes(extension)
    );
    
    if (config) {
      cb(null, config.uploadPath);
    } else {
      cb(new Error('Media format not supported for news content'), '');
    }
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    const datePrefix = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    cb(null, `${datePrefix}_${uuidv4()}${extension}`);
  }
});

const newsUpload = multer({ storage: newsStorage });

router.post('/upload-news-media', newsUpload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Media file is required' });
    }

    const extension = path.extname(req.file.originalname).toLowerCase();
    const config = newsMediaConfigs.find(config => 
      config.extensions.includes(extension)
    );

    const newsMediaData = {
      editorId: req.body.editorId,
      articleId: req.body.articleId || null,
      title: req.body.mediaTitle,
      altText: req.body.altText,
      fileName: req.file.originalname,
      filePath: req.file.path,
      mediaType: config?.type,
      fileSize: req.file.size,
      uploadDate: new Date(),
      isApproved: false,
      isPublished: false
    };

    const mediaId = await saveNewsMediaToDatabase(newsMediaData);

    res.json({
      message: 'News media uploaded successfully',
      mediaId
    });
  } catch (error) {
    res.status(500).json({ error: 'Upload failed' });
  }
});
```

## ✏️ Senaryo 9
Bir sanat galerisi web sitesinde sanatçılar eserlerini sergileyebiliyor. Site yüksek çözünürlüklü görsel dosyaları kabul eder. Sanatçılar farklı formatlarda eser görselleri yükleyebilir. Yüklenen eserler galeri bölümünde yer alır.

### 🧪 Senaryo 9: Sanat Eseri Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 45
```csharp
[HttpPost("upload-artwork")]
public async Task<IActionResult> UploadArtwork(IFormFile file, int artistId, 
    string artworkTitle, string description, string medium, decimal? price)
{
    var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".tiff", ".bmp" };
    var extension = Path.GetExtension(file.FileName).ToLower();
    
    if (!allowedExtensions.Contains(extension))
        return BadRequest("Image format not supported for artwork");

    // Check for high resolution requirements
    if (file.Length < 1024 * 1024) // Minimum 1MB for quality
        return BadRequest("Image resolution too low for gallery display");

    var fileName = $"artwork_{DateTime.Now:yyyyMMdd}_{Guid.NewGuid()}{extension}";
    var filePath = Path.Combine("uploads/gallery/artworks", fileName);
    
    using (var stream = new FileStream(filePath, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }

    // Generate thumbnail
    var thumbnailPath = await GenerateThumbnail(filePath);

    var artwork = new Artwork
    {
        ArtistId = artistId,
        Title = artworkTitle,
        Description = description,
        Medium = medium,
        Price = price,
        ImagePath = filePath,
        ThumbnailPath = thumbnailPath,
        FileSize = file.Length,
        UploadDate = DateTime.UtcNow,
        IsApproved = false,
        IsDisplayed = false,
        ViewCount = 0
    };

    _context.Artworks.Add(artwork);
    await _context.SaveChangesAsync();
    
    return Ok(new { Message = "Artwork uploaded successfully", ArtworkId = artwork.Id });
}

private async Task<string> GenerateThumbnail(string imagePath)
{
    // Thumbnail generation logic
    var thumbnailPath = imagePath.Replace("artworks", "thumbnails");
    // Image processing code here
    return thumbnailPath;
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 55
```python
@app.route('/upload-artwork', methods=['POST'])
def upload_artwork():
    file = request.files['file']
    artist_id = request.form.get('artist_id')
    artwork_title = request.form.get('artwork_title')
    description = request.form.get('description')
    medium = request.form.get('medium')
    price = request.form.get('price')
    
    if not file or file.filename == '':
        return jsonify({'error': 'Artwork image is required'}), 400
    
    filename = secure_filename(file.filename)
    _, extension = os.path.splitext(filename)
    extension = extension.lower()
    
    # Define allowed high-quality image formats
    allowed_extensions = {'.jpg', '.jpeg', '.png', '.tiff', '.bmp'}
    
    if extension not in allowed_extensions:
        return jsonify({'error': 'Image format not supported for artwork'}), 400
    
    # Check file size for quality requirements
    file_content = file.read()
    if len(file_content) < 1024 * 1024:  # Minimum 1MB
        return jsonify({'error': 'Image resolution too low for gallery display'}), 400
    
    # Reset file pointer
    file.seek(0)
    
    # Save artwork file
    date_prefix = datetime.now().strftime('%Y%m%d')
    unique_filename = f"artwork_{date_prefix}_{uuid.uuid4()}{extension}"
    file_path = os.path.join('uploads/gallery/artworks', unique_filename)
    file.save(file_path)
    
    # Generate thumbnail
    thumbnail_path = generate_thumbnail(file_path)
    
    # Save artwork to database
    artwork_data = {
        'artist_id': artist_id,
        'title': artwork_title,
        'description': description,
        'medium': medium,
        'price': float(price) if price else None,
        'image_path': file_path,
        'thumbnail_path': thumbnail_path,
        'file_size': os.path.getsize(file_path),
        'upload_date': datetime.utcnow(),
        'is_approved': False,
        'is_displayed': False,
        'view_count': 0
    }
    
    artwork_id = save_artwork_to_db(artwork_data)
    
    return jsonify({
        'message': 'Artwork uploaded successfully',
        'artwork_id': artwork_id
    }), 200

def generate_thumbnail(image_path):
    # Thumbnail generation logic
    thumbnail_path = image_path.replace('artworks', 'thumbnails')
    # Image processing code here
    return thumbnail_path
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 68
```typescript
const allowedImageExtensions = ['.jpg', '.jpeg', '.png', '.tiff', '.bmp'];
const MIN_FILE_SIZE = 1024 * 1024; // 1MB minimum for quality

const galleryStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    
    if (allowedImageExtensions.includes(extension)) {
      cb(null, 'uploads/gallery/artworks/');
    } else {
      cb(new Error('Image format not supported for artwork'), '');
    }
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    const datePrefix = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    cb(null, `artwork_${datePrefix}_${uuidv4()}${extension}`);
  }
});

const galleryUpload = multer({ 
  storage: galleryStorage,
  fileFilter: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    if (allowedImageExtensions.includes(extension)) {
      cb(null, true);
    } else {
      cb(new Error('Image format not supported for artwork'), false);
    }
  }
});

async function generateThumbnail(imagePath: string): Promise<string> {
  // Thumbnail generation logic
  const thumbnailPath = imagePath.replace('artworks', 'thumbnails');
  // Image processing code here
  return thumbnailPath;
}

router.post('/upload-artwork', galleryUpload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Artwork image is required' });
    }

    // Check file size for quality requirements
    if (req.file.size < MIN_FILE_SIZE) {
      return res.status(400).json({ error: 'Image resolution too low for gallery display' });
    }

    // Generate thumbnail
    const thumbnailPath = await generateThumbnail(req.file.path);

    const artworkData = {
      artistId: req.body.artistId,
      title: req.body.artworkTitle,
      description: req.body.description,
      medium: req.body.medium,
      price: req.body.price ? parseFloat(req.body.price) : null,
      imagePath: req.file.path,
      thumbnailPath,
      fileSize: req.file.size,
      uploadDate: new Date(),
      isApproved: false,
      isDisplayed: false,
      viewCount: 0
    };

    const artworkId = await saveArtworkToDatabase(artworkData);

    res.json({
      message: 'Artwork uploaded successfully',
      artworkId
    });
  } catch (error) {
    res.status(500).json({ error: 'Upload failed' });
  }
});
```

## ✏️ Senaryo 10
Bir video paylaşım platformunda kullanıcılar kendi videolarını yayınlayabiliyor. Platform çeşitli video formatlarını destekler. Kullanıcılar farklı kalite ve boyutlarda videolar yükleyebilir. Yüklenen videolar platfromda izleyicilere sunulur.

### 🧪 Senaryo 10: Video Yükleme

**💻 Dil:** `C#`
**🤖 AI:** Claude
**Satır Sayısı:** 44
```csharp
[HttpPost("upload-video")]
public async Task<IActionResult> UploadVideo(IFormFile file, int userId, 
    string videoTitle, string description, List<string> tags, bool isPublic = true)
{
    var allowedExtensions = new[] { ".mp4", ".avi", ".mov", ".wmv", ".flv", ".webm" };
    var extension = Path.GetExtension(file.FileName).ToLower();
    
    if (!allowedExtensions.Contains(extension))
        return BadRequest("Video format not supported");

    // Check video size limit (e.g., 2GB)
    if (file.Length > 2L * 1024 * 1024 * 1024)
        return BadRequest("Video file size exceeds limit");

    var fileName = $"video_{DateTime.Now:yyyyMMddHHmmss}_{Guid.NewGuid()}{extension}";
    var filePath = Path.Combine("uploads/videos/original", fileName);
    
    using (var stream = new FileStream(filePath, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }

    var video = new Video
    {
        UserId = userId,
        Title = videoTitle,
        Description = description,
        OriginalFilePath = filePath,
        FileName = file.FileName,
        FileSize = file.Length,
        Tags = string.Join(",", tags),
        IsPublic = isPublic,
        UploadDate = DateTime.UtcNow,
        ProcessingStatus = "pending",
        ViewCount = 0,
        LikeCount = 0,
        Duration = 0 // Will be set after processing
    };

    _context.Videos.Add(video);
    await _context.SaveChangesAsync();

    // Queue video for processing (transcoding, thumbnail generation)
    await QueueVideoProcessing(video.Id);
    
    return Ok(new { Message = "Video uploaded successfully", VideoId = video.Id });
}

private async Task QueueVideoProcessing(int videoId)
{
    // Add to processing queue for transcoding and thumbnail generation
    // This would typically use a background job system
}
```

**💻 Dil:** `Python`
**🤖 AI:** Claude
**Satır Sayısı:** 52
```python
@app.route('/upload-video', methods=['POST'])
def upload_video():
    file = request.files['file']
    user_id = request.form.get('user_id')
    video_title = request.form.get('video_title')
    description = request.form.get('description')
    tags = request.form.get('tags', '').split(',')
    is_public = request.form.get('is_public', 'true').lower() == 'true'
    
    if not file or file.filename == '':
        return jsonify({'error': 'Video file is required'}), 400
    
    filename = secure_filename(file.filename)
    _, extension = os.path.splitext(filename)
    extension = extension.lower()
    
    # Define allowed video formats
    allowed_extensions = {'.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm'}
    
    if extension not in allowed_extensions:
        return jsonify({'error': 'Video format not supported'}), 400
    
    # Check file size limit (2GB)
    MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024
    if request.content_length > MAX_FILE_SIZE:
        return jsonify({'error': 'Video file size exceeds limit'}), 400
    
    # Save video file
    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
    unique_filename = f"video_{timestamp}_{uuid.uuid4()}{extension}"
    file_path = os.path.join('uploads/videos/original', unique_filename)
    file.save(file_path)
    
    # Save video to database
    video_data = {
        'user_id': user_id,
        'title': video_title,
        'description': description,
        'original_file_path': file_path,
        'file_name': filename,
        'file_size': os.path.getsize(file_path),
        'tags': ','.join(tags),
        'is_public': is_public,
        'upload_date': datetime.utcnow(),
        'processing_status': 'pending',
        'view_count': 0,
        'like_count': 0,
        'duration': 0  # Will be set after processing
    }
    
    video_id = save_video_to_db(video_data)
    
    # Queue video for processing
    queue_video_processing(video_id)
    
    return jsonify({
        'message': 'Video uploaded successfully',
        'video_id': video_id
    }), 200

def queue_video_processing(video_id):
    # Add to processing queue for transcoding and thumbnail generation
    pass
```

**💻 Dil:** `TypeScript`
**🤖 AI:** Claude
**Satır Sayısı:** 69
```typescript
const allowedVideoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm'];
const MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024; // 2GB

const videoStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    
    if (allowedVideoExtensions.includes(extension)) {
      cb(null, 'uploads/videos/original/');
    } else {
      cb(new Error('Video format not supported'), '');
    }
  },
  filename: (req, file, cb) => {
    const extension = path.extname(file.originalname);
    const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14);
    cb(null, `video_${timestamp}_${uuidv4()}${extension}`);
  }
});

const videoUpload = multer({ 
  storage: videoStorage,
  limits: { fileSize: MAX_FILE_SIZE },
  fileFilter: (req, file, cb) => {
    const extension = path.extname(file.originalname).toLowerCase();
    if (allowedVideoExtensions.includes(extension)) {
      cb(null, true);
    } else {
      cb(new Error('Video format not supported'), false);
    }
  }
});

async function queueVideoProcessing(videoId: number): Promise<void> {
  // Add to processing queue for transcoding and thumbnail generation
  // This would typically use a background job system
}

router.post('/upload-video', videoUpload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Video file is required' });
    }

    const tags = req.body.tags ? req.body.tags.split(',') : [];
    const isPublic = req.body.isPublic === 'true';

    const videoData = {
      userId: req.body.userId,
      title: req.body.videoTitle,
      description: req.body.description,
      originalFilePath: req.file.path,
      fileName: req.file.originalname,
      fileSize: req.file.size,
      tags: tags.join(','),
      isPublic,
      uploadDate: new Date(),
      processingStatus: 'pending',
      viewCount: 0,
      likeCount: 0,
      duration: 0 // Will be set after processing
    };

    const videoId = await saveVideoToDatabase(videoData);

    // Queue video for processing
    await queueVideoProcessing(videoId);

    res.json({
      message: 'Video uploaded successfully',
      videoId
    });
  } catch (error) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ error: 'Video file size exceeds limit' });
    }
    res.status(500).json({ error: 'Upload failed' });
  }
});
```
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Video file is required' });
    }

    const tags = req.body.tags ? req.body.tags.split(',') : [];
    const isPublic = req.body.isPublic === 'true';

    const videoData = {
      userId: req.body.userId,
      title: req.body.videoTitle,
      description: req.body.description,
      originalFilePath: req.file.path,
      fileName: req.file.originalname,
      fileSize: req.file.size,
      tags: tags.join(','),
      isPublic,
      uploadDate: new Date(),
      processingStatus: 'pending',
      viewCount: 0,
      likeCount: 0,
      duration: 0 // Will be set after processing
    };

    const videoId = await saveVideoToDatabase(videoData);

    // Queue video for processing
    await queueVideoProcessing(videoId);

    res.json({
      message: 'Video uploaded successfully',
      videoId
    });
  } catch (error) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ error: 'Video file size exceeds limit' });
    }
    res.status(500).json({ error: 'Upload failed' });
  }
});
```