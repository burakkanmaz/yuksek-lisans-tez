# Integer Overflow SenaryolarÄ±

## âœï¸ Senaryo 1
Bir fatura hesaplama uygulamasÄ±nda kullanÄ±cÄ± adet ve birim fiyat girerek toplam tutarÄ± gÃ¶rebiliyor. Hesaplama iÅŸlemi iki tam sayÄ± deÄŸerin Ã§arpÄ±mÄ±yla yapÄ±lÄ±yor. Uygulama girilen deÄŸerlerin sÄ±nÄ±rlarÄ±nÄ± deÄŸerlendiriyor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde sonuÃ§ hesaplanÄ±yor.

### ğŸ§ª Senaryo 1: Fatura Hesaplama

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 20
```csharp
[HttpPost("calculate-invoice")]
public IActionResult CalculateInvoice(int quantity, int unitPrice)
{
    try
    {
        checked
        {
            long total = (long)quantity * unitPrice;
            if (total > int.MaxValue)
            {
                return BadRequest($"Total amount exceeds maximum value: {total}");
            }
            return Ok(new { Total = (int)total });
        }
    }
    catch (OverflowException)
    {
        return BadRequest("Calculation overflow occurred");
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 10
```python
import sys

def calculate_invoice(quantity, unit_price):
    try:
        total = quantity * unit_price
        max_int = sys.maxsize
        
        if total > max_int:
            return {"error": f"Total amount exceeds maximum value: {total}"}
        
        return {"total": total}
    except OverflowError:
        return {"error": "Calculation overflow occurred"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 11
```typescript
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;

function calculateInvoice(quantity: number, unitPrice: number): {total?: number, error?: string} {
    const total = quantity * unitPrice;
    
    if (total > MAX_SAFE_INTEGER) {
        return { error: `Total amount exceeds maximum safe value: ${total}` };
    }
    
    if (!Number.isSafeInteger(total)) {
        return { error: "Calculation resulted in unsafe integer" };
    }
    
    return { total };
}
```

## âœï¸ Senaryo 2
Bir oyun uygulamasÄ±nda oyuncular topladÄ±klarÄ± puanlara gÃ¶re seviye atlÄ±yor. Puanlar her baÅŸarÄ±yla birlikte belirli miktarda artÄ±rÄ±lÄ±yor. Uygulama puan deÄŸiÅŸkeninin sÄ±nÄ±rlarÄ±nÄ± takip ediyor. Belirli eÅŸik aÅŸÄ±ldÄ±ÄŸÄ±nda puan sistemi yeniden baÅŸlatÄ±lÄ±yor.

### ğŸ§ª Senaryo 2: Oyun Puan Sistemi

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 29
```csharp
public class GameScoreManager
{
    private int currentScore;
    private const int RESET_THRESHOLD = int.MaxValue - 1000;

    public void AddScore(int points)
    {
        try
        {
            checked
            {
                if (currentScore > RESET_THRESHOLD)
                {
                    ResetScore();
                    return;
                }
                currentScore += points;
            }
        }
        catch (OverflowException)
        {
            ResetScore();
        }
    }

    private void ResetScore()
    {
        currentScore = 0;
        Console.WriteLine("Score reset due to overflow protection");
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 16
```python
import sys

class GameScoreManager:
    def __init__(self):
        self.current_score = 0
        self.reset_threshold = sys.maxsize - 1000

    def add_score(self, points):
        try:
            if self.current_score > self.reset_threshold:
                self._reset_score()
                return
            
            self.current_score += points
        except OverflowError:
            self._reset_score()

    def _reset_score(self):
        self.current_score = 0
        print("Score reset due to overflow protection")
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 20
```typescript
class GameScoreManager {
    private currentScore: number = 0;
    private readonly RESET_THRESHOLD = Number.MAX_SAFE_INTEGER - 1000;

    addScore(points: number): void {
        if (this.currentScore > this.RESET_THRESHOLD) {
            this.resetScore();
            return;
        }

        const newScore = this.currentScore + points;
        
        if (!Number.isSafeInteger(newScore)) {
            this.resetScore();
            return;
        }

        this.currentScore = newScore;
    }

    private resetScore(): void {
        this.currentScore = 0;
        console.log("Score reset due to overflow protection");
    }
}
```

## âœï¸ Senaryo 3
Bir bÃ¼tÃ§e planlama aracÄ±nda kullanÄ±cÄ±lar gelir ve giderleri belirterek hesaplama yapabiliyor. Verilen rakamlar toplanarak kalan bÃ¼tÃ§e hesaplanÄ±yor. Sistem toplam deÄŸerlerin veri tipine uygunluÄŸunu deÄŸerlendiriyor. BÃ¼yÃ¼k sayÄ±lar girildiÄŸinde hesaplama dÃ¶ngÃ¼sel olarak gerÃ§ekleÅŸiyor.

### ğŸ§ª Senaryo 3: BÃ¼tÃ§e Planlama

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 37
```csharp
public class BudgetCalculator
{
    public decimal CalculateRemainingBudget(int[] incomes, int[] expenses)
    {
        try
        {
            checked
            {
                long totalIncome = 0;
                long totalExpense = 0;

                foreach (int income in incomes)
                {
                    totalIncome += income;
                }

                foreach (int expense in expenses)
                {
                    totalExpense += expense;
                }

                return (decimal)(totalIncome - totalExpense);
            }
        }
        catch (OverflowException)
        {
            return CalculateInChunks(incomes, expenses);
        }
    }

    private decimal CalculateInChunks(int[] incomes, int[] expenses)
    {
        decimal result = 0;
        for (int i = 0; i < Math.Max(incomes.Length, expenses.Length); i++)
        {
            if (i < incomes.Length) result += incomes[i];
            if (i < expenses.Length) result -= expenses[i];
        }
        return result;
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 18
```python
from decimal import Decimal

class BudgetCalculator:
    def calculate_remaining_budget(self, incomes, expenses):
        try:
            total_income = sum(incomes)
            total_expense = sum(expenses)
            
            return Decimal(total_income - total_expense)
        except OverflowError:
            return self._calculate_in_chunks(incomes, expenses)

    def _calculate_in_chunks(self, incomes, expenses):
        result = Decimal(0)
        max_length = max(len(incomes), len(expenses))
        
        for i in range(max_length):
            if i < len(incomes):
                result += Decimal(incomes[i])
            if i < len(expenses):
                result -= Decimal(expenses[i])
        
        return result
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 29
```typescript
class BudgetCalculator {
    calculateRemainingBudget(incomes: number[], expenses: number[]): number {
        const totalIncome = this.safeSum(incomes);
        const totalExpense = this.safeSum(expenses);
        
        if (totalIncome === null || totalExpense === null) {
            return this.calculateInChunks(incomes, expenses);
        }
        
        return totalIncome - totalExpense;
    }

    private safeSum(numbers: number[]): number | null {
        let sum = 0;
        for (const num of numbers) {
            sum += num;
            if (!Number.isSafeInteger(sum)) {
                return null;
            }
        }
        return sum;
    }

    private calculateInChunks(incomes: number[], expenses: number[]): number {
        let result = 0;
        const maxLength = Math.max(incomes.length, expenses.length);
        
        for (let i = 0; i < maxLength; i++) {
            if (i < incomes.length) result += incomes[i];
            if (i < expenses.length) result -= expenses[i];
        }
        
        return result;
    }
}
```

## âœï¸ Senaryo 4
Bir tarih hesaplama uygulamasÄ±nda kullanÄ±cÄ±lar gÃ¼n sayÄ±sÄ± girerek gelecekteki tarihi Ã¶ÄŸrenebiliyor. Sistem mevcut tarihe bu gÃ¼n sayÄ±sÄ±nÄ± ekleyerek sonucu gÃ¶steriyor. BÃ¼yÃ¼k sayÄ± girildiÄŸinde yÄ±l deÄŸeri deÄŸiÅŸim gÃ¶steriyor. Uygulama bu durumda uygun sonuÃ§ Ã¼retiyor.

### ğŸ§ª Senaryo 4: Tarih Hesaplama

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 25
```csharp
public class DateCalculator
{
    public DateTime? AddDaysToDate(DateTime startDate, int daysToAdd)
    {
        try
        {
            checked
            {
                if (daysToAdd > (DateTime.MaxValue - startDate).Days)
                {
                    return DateTime.MaxValue;
                }
                
                return startDate.AddDays(daysToAdd);
            }
        }
        catch (ArgumentOutOfRangeException)
        {
            return DateTime.MaxValue;
        }
        catch (OverflowException)
        {
            return DateTime.MaxValue;
        }
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 12
```python
from datetime import datetime, timedelta, date

class DateCalculator:
    def add_days_to_date(self, start_date, days_to_add):
        try:
            max_date = datetime.max
            
            if days_to_add > (max_date - start_date).days:
                return max_date
            
            return start_date + timedelta(days=days_to_add)
        except OverflowError:
            return datetime.max
        except ValueError:
            return datetime.max
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 20
```typescript
class DateCalculator {
    addDaysToDate(startDate: Date, daysToAdd: number): Date {
        const millisecondsPerDay = 24 * 60 * 60 * 1000;
        const maxTimestamp = 8640000000000000; // JavaScript max date timestamp
        
        try {
            const startTimestamp = startDate.getTime();
            const addMilliseconds = daysToAdd * millisecondsPerDay;
            
            if (startTimestamp + addMilliseconds > maxTimestamp) {
                return new Date(maxTimestamp);
            }
            
            const resultDate = new Date(startTimestamp + addMilliseconds);
            
            if (isNaN(resultDate.getTime())) {
                return new Date(maxTimestamp);
            }
            
            return resultDate;
        } catch (error) {
            return new Date(maxTimestamp);
        }
    }
}
```

## âœï¸ Senaryo 5
Bir video dÃ¼zenleyici yazÄ±lÄ±mÄ± kare numarasÄ±na gÃ¶re zaman hesaplamasÄ± yapÄ±yor. KullanÄ±cÄ± kare deÄŸeri girdiÄŸinde sistem bunu sÃ¼reye Ã§eviriyor. Kare deÄŸeri bÃ¼yÃ¼kse hesaplanan sÃ¼re deÄŸiÅŸken deÄŸerlere dÃ¶nÃ¼ÅŸebiliyor. Uygulama bu durumu yÃ¶netiyor.

### ğŸ§ª Senaryo 5: Video Kare ZamanÄ±

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 27
```csharp
public class VideoTimeCalculator
{
    private const double DEFAULT_FPS = 30.0;

    public TimeSpan? FramesToTime(int frameNumber, double fps = DEFAULT_FPS)
    {
        try
        {
            checked
            {
                double totalSeconds = frameNumber / fps;
                
                if (totalSeconds > TimeSpan.MaxValue.TotalSeconds)
                {
                    return TimeSpan.MaxValue;
                }
                
                return TimeSpan.FromSeconds(totalSeconds);
            }
        }
        catch (OverflowException)
        {
            return TimeSpan.MaxValue;
        }
        catch (ArgumentOutOfRangeException)
        {
            return TimeSpan.MaxValue;
        }
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 14
```python
from datetime import timedelta

class VideoTimeCalculator:
    DEFAULT_FPS = 30.0

    def frames_to_time(self, frame_number, fps=DEFAULT_FPS):
        try:
            total_seconds = frame_number / fps
            max_seconds = timedelta.max.total_seconds()
            
            if total_seconds > max_seconds:
                return timedelta.max
            
            return timedelta(seconds=total_seconds)
        except OverflowError:
            return timedelta.max
        except ValueError:
            return timedelta.max
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** TypeScript
**SatÄ±r SayÄ±sÄ±:** 18
```typescript
class VideoTimeCalculator {
    private readonly DEFAULT_FPS = 30.0;

    framesToTime(frameNumber: number, fps: number = this.DEFAULT_FPS): {hours: number, minutes: number, seconds: number} | null {
        try {
            const totalSeconds = frameNumber / fps;
            const maxSeconds = Number.MAX_SAFE_INTEGER / 1000;
            
            if (totalSeconds > maxSeconds || !Number.isFinite(totalSeconds)) {
                return { hours: 999999, minutes: 59, seconds: 59 };
            }
            
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            
            return { hours, minutes, seconds };
        } catch (error) {
            return null;
        }
    }
}
```

## âœï¸ Senaryo 6
Bir sayaÃ§ uygulamasÄ±nda kullanÄ±cÄ±lar belirli iÅŸlemlerle sayacÄ± artÄ±rabiliyor. SayacÄ±n varsayÄ±lan veri tipi kÃ¼Ã§Ã¼k boyutlu tamsayÄ± olarak belirlenmiÅŸ. Uygulama artÄ±ÅŸ sÄ±rasÄ±nda sÄ±nÄ±r durumlarÄ±nÄ± denetliyor. SayacÄ±n deÄŸeri gerektiÄŸinde sÄ±fÄ±rlanÄ±yor.

### ğŸ§ª Senaryo 6: SayaÃ§ UygulamasÄ±

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 26
```csharp
public class CounterApplication
{
    private short counter = 0;

    public short IncrementCounter(short increment)
    {
        try
        {
            checked
            {
                counter += increment;
                return counter;
            }
        }
        catch (OverflowException)
        {
            ResetCounter();
            return counter;
        }
    }

    private void ResetCounter()
    {
        counter = 0;
        Console.WriteLine("Counter reset due to overflow");
    }

    public short GetCounter() => counter;
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 21
```python
class CounterApplication:
    def __init__(self):
        self.counter = 0
        self.max_value = 32767  # 16-bit signed integer max
        self.min_value = -32768  # 16-bit signed integer min

    def increment_counter(self, increment):
        try:
            new_value = self.counter + increment
            
            if new_value > self.max_value or new_value < self.min_value:
                self._reset_counter()
                return self.counter
            
            self.counter = new_value
            return self.counter
        except OverflowError:
            self._reset_counter()
            return self.counter

    def _reset_counter(self):
        self.counter = 0
        print("Counter reset due to overflow")

    def get_counter(self):
        return self.counter
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 21
```typescript
class CounterApplication {
    private counter: number = 0;
    private readonly MAX_VALUE = 32767;  // 16-bit signed integer max
    private readonly MIN_VALUE = -32768; // 16-bit signed integer min

    incrementCounter(increment: number): number {
        const newValue = this.counter + increment;
        
        if (newValue > this.MAX_VALUE || newValue < this.MIN_VALUE) {
            this.resetCounter();
            return this.counter;
        }
        
        this.counter = newValue;
        return this.counter;
    }

    private resetCounter(): void {
        this.counter = 0;
        console.log("Counter reset due to overflow");
    }

    getCounter(): number {
        return this.counter;
    }
}
```

## âœï¸ Senaryo 7
Bir taÅŸÄ±ma yÃ¶netim sisteminde kullanÄ±cÄ±lar taÅŸÄ±nan malzeme miktarÄ±nÄ± ve birim hacmini girerek toplam hacmi hesaplatÄ±yor. Bu hesaplama iki deÄŸerin Ã§arpÄ±lmasÄ±yla yapÄ±lÄ±yor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde toplam hacim deÄŸiÅŸken sayÄ±lara dÃ¶nÃ¼ÅŸebiliyor. Sistem bu deÄŸeri yÃ¶netiyor.

### ğŸ§ª Senaryo 7: TaÅŸÄ±ma Hacim Hesaplama

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 33
```csharp
public class TransportVolumeCalculator
{
    public decimal CalculateTotalVolume(int materialAmount, int unitVolume)
    {
        try
        {
            checked
            {
                long totalVolume = (long)materialAmount * unitVolume;
                
                if (totalVolume > (long)decimal.MaxValue)
                {
                    return decimal.MaxValue;
                }
                
                return (decimal)totalVolume;
            }
        }
        catch (OverflowException)
        {
            return CalculateWithDecimal(materialAmount, unitVolume);
        }
    }

    private decimal CalculateWithDecimal(int materialAmount, int unitVolume)
    {
        try
        {
            return (decimal)materialAmount * (decimal)unitVolume;
        }
        catch (OverflowException)
        {
            return decimal.MaxValue;
        }
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 19
```python
from decimal import Decimal, getcontext

class TransportVolumeCalculator:
    def __init__(self):
        getcontext().prec = 50  # Set high precision

    def calculate_total_volume(self, material_amount, unit_volume):
        try:
            total_volume = material_amount * unit_volume
            
            # Check if result is too large for safe handling
            if total_volume > 10**15:  # Arbitrary large number threshold
                return self._calculate_with_decimal(material_amount, unit_volume)
            
            return total_volume
        except OverflowError:
            return self._calculate_with_decimal(material_amount, unit_volume)

    def _calculate_with_decimal(self, material_amount, unit_volume):
        try:
            result = Decimal(material_amount) * Decimal(unit_volume)
            return float(result)
        except:
            return float('inf')
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 20
```typescript
class TransportVolumeCalculator {
    calculateTotalVolume(materialAmount: number, unitVolume: number): number {
        const result = materialAmount * unitVolume;
        
        if (!Number.isSafeInteger(result) || result > Number.MAX_SAFE_INTEGER) {
            return this.calculateWithBigInt(materialAmount, unitVolume);
        }
        
        return result;
    }

    private calculateWithBigInt(materialAmount: number, unitVolume: number): number {
        try {
            const bigResult = BigInt(materialAmount) * BigInt(unitVolume);
            
            if (bigResult > BigInt(Number.MAX_SAFE_INTEGER)) {
                return Number.MAX_SAFE_INTEGER;
            }
            
            return Number(bigResult);
        } catch (error) {
            return Number.MAX_SAFE_INTEGER;
        }
    }
}
```

## âœï¸ Senaryo 8
Bir envanter sistemi Ã¼rÃ¼nlerin stok sayÄ±sÄ±nÄ± sipariÅŸ adediyle toplayarak gÃ¼ncelliyor. SipariÅŸ deÄŸeri yÃ¼ksekse toplam stok sayÄ±sÄ± Ã¼st limiti geÃ§ebiliyor. SayÄ± tipi sabit olduÄŸundan taÅŸma meydana geliyor. Sistem bu durumu ele alÄ±yor.

### ğŸ§ª Senaryo 8: Envanter Stok GÃ¼ncelleme

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 28
```csharp
public class InventoryManager
{
    private int currentStock;

    public bool UpdateStock(int orderQuantity)
    {
        try
        {
            checked
            {
                int newStock = currentStock + orderQuantity;
                currentStock = newStock;
                return true;
            }
        }
        catch (OverflowException)
        {
            // Cap at maximum value instead of overflow
            currentStock = int.MaxValue;
            Console.WriteLine($"Stock capped at maximum value due to overflow");
            return false;
        }
    }

    public int GetCurrentStock() => currentStock;

    public void SetStock(int stock)
    {
        currentStock = Math.Max(0, stock);
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 22
```python
import sys

class InventoryManager:
    def __init__(self):
        self.current_stock = 0
        self.max_stock = sys.maxsize

    def update_stock(self, order_quantity):
        try:
            new_stock = self.current_stock + order_quantity
            
            if new_stock > self.max_stock:
                self.current_stock = self.max_stock
                print(f"Stock capped at maximum value due to overflow")
                return False
            
            self.current_stock = new_stock
            return True
        except OverflowError:
            self.current_stock = self.max_stock
            print(f"Stock capped at maximum value due to overflow")
            return False

    def get_current_stock(self):
        return self.current_stock

    def set_stock(self, stock):
        self.current_stock = max(0, min(stock, self.max_stock))
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 20
```typescript
class InventoryManager {
    private currentStock: number = 0;
    private readonly MAX_STOCK = Number.MAX_SAFE_INTEGER;

    updateStock(orderQuantity: number): boolean {
        const newStock = this.currentStock + orderQuantity;
        
        if (newStock > this.MAX_STOCK || !Number.isSafeInteger(newStock)) {
            this.currentStock = this.MAX_STOCK;
            console.log("Stock capped at maximum value due to overflow");
            return false;
        }
        
        this.currentStock = newStock;
        return true;
    }

    getCurrentStock(): number {
        return this.currentStock;
    }

    setStock(stock: number): void {
        this.currentStock = Math.max(0, Math.min(stock, this.MAX_STOCK));
    }
}
```

## âœï¸ Senaryo 9
Bir sÄ±nav uygulamasÄ±nda Ã¶ÄŸretmenler her soru iÃ§in puan deÄŸerini ve soru sayÄ±sÄ±nÄ± girerek toplam puanÄ± belirliyor. Hesaplama iÅŸlemi bu iki deÄŸerin Ã§arpÄ±mÄ±yla gerÃ§ekleÅŸiyor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde toplam puan deÄŸiÅŸken deÄŸerlere dÃ¶nÃ¼ÅŸebiliyor. Uygulama bu iÅŸlemi yÃ¶netiyor.

### ğŸ§ª Senaryo 9: SÄ±nav Puan Hesaplama

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 34
```csharp
public class ExamScoreCalculator
{
    public decimal CalculateTotalScore(int pointsPerQuestion, int questionCount)
    {
        try
        {
            checked
            {
                long totalScore = (long)pointsPerQuestion * questionCount;
                
                if (totalScore > (long)decimal.MaxValue)
                {
                    return decimal.MaxValue;
                }
                
                return (decimal)totalScore;
            }
        }
        catch (OverflowException)
        {
            return HandleOverflow(pointsPerQuestion, questionCount);
        }
    }

    private decimal HandleOverflow(int pointsPerQuestion, int questionCount)
    {
        try
        {
            return (decimal)pointsPerQuestion * (decimal)questionCount;
        }
        catch (OverflowException)
        {
            Console.WriteLine("Score calculation overflow - returning maximum value");
            return decimal.MaxValue;
        }
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 21
```python
from decimal import Decimal, getcontext

class ExamScoreCalculator:
    def __init__(self):
        getcontext().prec = 50

    def calculate_total_score(self, points_per_question, question_count):
        try:
            total_score = points_per_question * question_count
            
            # Check for very large numbers
            if total_score > 10**15:
                return self._handle_overflow(points_per_question, question_count)
            
            return total_score
        except OverflowError:
            return self._handle_overflow(points_per_question, question_count)

    def _handle_overflow(self, points_per_question, question_count):
        try:
            result = Decimal(points_per_question) * Decimal(question_count)
            print("Score calculation overflow - using high precision decimal")
            return float(result)
        except:
            print("Score calculation overflow - returning maximum safe value")
            return float('inf')
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 22
```typescript
class ExamScoreCalculator {
    calculateTotalScore(pointsPerQuestion: number, questionCount: number): number {
        const totalScore = pointsPerQuestion * questionCount;
        
        if (!Number.isSafeInteger(totalScore) || totalScore > Number.MAX_SAFE_INTEGER) {
            return this.handleOverflow(pointsPerQuestion, questionCount);
        }
        
        return totalScore;
    }

    private handleOverflow(pointsPerQuestion: number, questionCount: number): number {
        try {
            const bigResult = BigInt(pointsPerQuestion) * BigInt(questionCount);
            
            if (bigResult > BigInt(Number.MAX_SAFE_INTEGER)) {
                console.log("Score calculation overflow - returning maximum safe value");
                return Number.MAX_SAFE_INTEGER;
            }
            
            return Number(bigResult);
        } catch (error) {
            console.log("Score calculation error - returning maximum safe value");
            return Number.MAX_SAFE_INTEGER;
        }
    }
}
```

## âœï¸ Senaryo 10
Bir dosya aktarÄ±m uygulamasÄ±nda kullanÄ±cÄ±lar dosya boyutu ve parÃ§a sayÄ±sÄ± girerek aktarÄ±m birimlerini hesaplayabiliyor. ParÃ§a boyutu bu iki deÄŸerin bÃ¶lÃ¼nmesiyle elde ediliyor. Dosya boyutu bÃ¼yÃ¼k olduÄŸunda Ã§arpÄ±m sonucu taÅŸma yapabiliyor. Uygulama bu durumu iÅŸliyor.

### ğŸ§ª Senaryo 10: Dosya Transfer Hesaplama

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 33
```csharp
public class FileTransferCalculator
{
    public long CalculateChunkSize(long fileSize, int chunkCount)
    {
        try
        {
            if (chunkCount <= 0)
                throw new ArgumentException("Chunk count must be positive");

            checked
            {
                if (fileSize > long.MaxValue / chunkCount)
                {
                    return HandleLargeFile(fileSize, chunkCount);
                }
                
                return fileSize / chunkCount;
            }
        }
        catch (OverflowException)
        {
            return HandleLargeFile(fileSize, chunkCount);
        }
    }

    private long HandleLargeFile(long fileSize, int chunkCount)
    {
        decimal result = (decimal)fileSize / chunkCount;
        
        if (result > long.MaxValue)
        {
            Console.WriteLine("File too large - using maximum chunk size");
            return long.MaxValue;
        }
        
        return (long)result;
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 21
```python
import sys

class FileTransferCalculator:
    def calculate_chunk_size(self, file_size, chunk_count):
        try:
            if chunk_count <= 0:
                raise ValueError("Chunk count must be positive")

            if file_size > sys.maxsize:
                return self._handle_large_file(file_size, chunk_count)
            
            return file_size // chunk_count
        except OverflowError:
            return self._handle_large_file(file_size, chunk_count)

    def _handle_large_file(self, file_size, chunk_count):
        try:
            result = file_size / chunk_count
            
            if result > sys.maxsize:
                print("File too large - using maximum chunk size")
                return sys.maxsize
            
            return int(result)
        except:
            print("Calculation error - using maximum chunk size")
            return sys.maxsize
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 30
```typescript
class FileTransferCalculator {
    calculateChunkSize(fileSize: number, chunkCount: number): number {
        if (chunkCount <= 0) {
            throw new Error("Chunk count must be positive");
        }

        if (fileSize > Number.MAX_SAFE_INTEGER) {
            return this.handleLargeFile(fileSize, chunkCount);
        }

        const chunkSize = Math.floor(fileSize / chunkCount);
        
        if (!Number.isSafeInteger(chunkSize)) {
            return this.handleLargeFile(fileSize, chunkCount);
        }
        
        return chunkSize;
    }

    private handleLargeFile(fileSize: number, chunkCount: number): number {
        try {
            const bigFileSize = BigInt(Math.floor(fileSize));
            const bigChunkCount = BigInt(chunkCount);
            const bigResult = bigFileSize / bigChunkCount;
            
            if (bigResult > BigInt(Number.MAX_SAFE_INTEGER)) {
                console.log("File too large - using maximum chunk size");
                return Number.MAX_SAFE_INTEGER;
            }
            
            return Number(bigResult);
        } catch (error) {
            console.log("Calculation error - using maximum chunk size");
            return Number.MAX_SAFE_INTEGER;
        }
    }
}
```