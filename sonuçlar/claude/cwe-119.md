### ðŸ§ª Senaryo 1: Bir metin dÃ¼zenleyici uygulamasÄ±nda kullanÄ±cÄ±lar Ã§ok satÄ±rlÄ± metinleri dÃ¼zenleyebiliyor. Her satÄ±r uygulama iÃ§inde bellekte tutuluyor ve dizin bilgisiyle eriÅŸiliyor. KullanÄ±cÄ± metne ekleme yaptÄ±ÄŸÄ±nda sistem belirli bir tampon belleÄŸe veri yazÄ±yor. Bu belleÄŸin boyutu kullanÄ±cÄ± girdisine gÃ¶re ayarlanÄ±yor.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 40
```csharp
public class TextEditor
{
    private List<string> lines = new List<string>();
    private const int MAX_LINE_LENGTH = 1000;
    private const int MAX_LINES = 10000;

    public bool InsertLine(int index, string content)
    {
        if (content == null || content.Length > MAX_LINE_LENGTH)
            return false;
        
        if (index < 0 || index > lines.Count || lines.Count >= MAX_LINES)
            return false;

        // Safe string handling with length validation
        string safeLine = content.Substring(0, Math.Min(content.Length, MAX_LINE_LENGTH));
        lines.Insert(index, safeLine);
        return true;
    }

    public string GetLine(int index)
    {
        if (index < 0 || index >= lines.Count)
            return string.Empty;
        
        return lines[index];
    }

    public bool UpdateLine(int index, string newContent)
    {
        if (newContent == null || newContent.Length > MAX_LINE_LENGTH)
            return false;
            
        if (index < 0 || index >= lines.Count)
            return false;

        lines[index] = newContent.Substring(0, Math.Min(newContent.Length, MAX_LINE_LENGTH));
        return true;
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 45
```typescript
class TextEditor {
    private lines: string[] = [];
    private readonly MAX_LINE_LENGTH = 1000;
    private readonly MAX_LINES = 10000;

    insertLine(index: number, content: string): boolean {
        if (typeof content !== 'string' || content.length > this.MAX_LINE_LENGTH) {
            return false;
        }
        
        if (index < 0 || index > this.lines.length || this.lines.length >= this.MAX_LINES) {
            return false;
        }

        // Safe string handling with length validation
        const safeLine = content.substring(0, this.MAX_LINE_LENGTH);
        this.lines.splice(index, 0, safeLine);
        return true;
    }

    getLine(index: number): string {
        if (index < 0 || index >= this.lines.length) {
            return '';
        }
        
        return this.lines[index];
    }

    updateLine(index: number, newContent: string): boolean {
        if (typeof newContent !== 'string' || newContent.length > this.MAX_LINE_LENGTH) {
            return false;
        }
            
        if (index < 0 || index >= this.lines.length) {
            return false;
        }

        this.lines[index] = newContent.substring(0, this.MAX_LINE_LENGTH);
        return true;
    }

    getTotalLines(): number {
        return this.lines.length;
    }
}
```

---

### ðŸ§ª Senaryo 2: Bir ses iÅŸleme yazÄ±lÄ±mÄ± gelen mikrofon verilerini belirli aralÄ±klarda buffer'a alÄ±yor. KullanÄ±cÄ± farklÄ± Ã¶rnekleme oranlarÄ± seÃ§erek kaydÄ± baÅŸlatabiliyor. Bu veri buffer'a sabit aralÄ±kla ekleniyor. Uzun kayÄ±tlar iÃ§in sistem bellek boyutlarÄ±nÄ± yÃ¶netiyor.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 46
```csharp
public class AudioProcessor
{
    private Queue<float[]> audioBuffer = new Queue<float[]>();
    private const int MAX_BUFFER_SIZE = 1000;
    private const int MAX_SAMPLE_RATE = 48000;
    private readonly object bufferLock = new object();

    public bool AddAudioData(float[] samples, int sampleRate)
    {
        if (samples == null || sampleRate <= 0 || sampleRate > MAX_SAMPLE_RATE)
            return false;

        lock (bufferLock)
        {
            // Prevent buffer overflow by limiting queue size
            if (audioBuffer.Count >= MAX_BUFFER_SIZE)
            {
                audioBuffer.Dequeue(); // Remove oldest data
            }

            // Create safe copy of audio data
            float[] safeSamples = new float[Math.Min(samples.Length, sampleRate)];
            Array.Copy(samples, safeSamples, safeSamples.Length);
            
            audioBuffer.Enqueue(safeSamples);
        }
        
        return true;
    }

    public float[] GetNextAudioChunk()
    {
        lock (bufferLock)
        {
            return audioBuffer.Count > 0 ? audioBuffer.Dequeue() : new float[0];
        }
    }

    public int GetBufferSize()
    {
        lock (bufferLock)
        {
            return audioBuffer.Count;
        }
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 54
```typescript
class AudioProcessor {
    private audioBuffer: Float32Array[] = [];
    private readonly MAX_BUFFER_SIZE = 1000;
    private readonly MAX_SAMPLE_RATE = 48000;
    private bufferLock = false;

    async addAudioData(samples: number[], sampleRate: number): Promise<boolean> {
        if (!Array.isArray(samples) || sampleRate <= 0 || sampleRate > this.MAX_SAMPLE_RATE) {
            return false;
        }

        // Simple lock mechanism for buffer access
        while (this.bufferLock) {
            await new Promise(resolve => setTimeout(resolve, 1));
        }
        this.bufferLock = true;

        try {
            // Prevent buffer overflow by limiting queue size
            if (this.audioBuffer.length >= this.MAX_BUFFER_SIZE) {
                this.audioBuffer.shift(); // Remove oldest data
            }

            // Create safe copy with size validation
            const maxLength = Math.min(samples.length, sampleRate);
            const safeSamples = new Float32Array(maxLength);
            for (let i = 0; i < maxLength; i++) {
                safeSamples[i] = samples[i];
            }
            
            this.audioBuffer.push(safeSamples);
            return true;
        } finally {
            this.bufferLock = false;
        }
    }

    async getNextAudioChunk(): Promise<Float32Array> {
        while (this.bufferLock) {
            await new Promise(resolve => setTimeout(resolve, 1));
        }
        this.bufferLock = true;

        try {
            return this.audioBuffer.length > 0 ? this.audioBuffer.shift()! : new Float32Array(0);
        } finally {
            this.bufferLock = false;
        }
    }

    getBufferSize(): number {
        return this.audioBuffer.length;
    }
}
```

---

### ðŸ§ª Senaryo 3: Bir gÃ¶rÃ¼ntÃ¼ dÃ¼zenleme programÄ±nda kullanÄ±cÄ± bir resmi kÄ±rptÄ±ÄŸÄ±nda sistem seÃ§ilen koordinatlara gÃ¶re iÅŸlem yapÄ±yor. KÄ±rpÄ±lacak alan bellekteki pikseller Ã¼zerinden hesaplanarak yeni buffer'a aktarÄ±lÄ±yor. Bu alanlarÄ±n sÄ±nÄ±rlarÄ± iÅŸlem sÄ±rasÄ±nda belirleniyor. Sistem seÃ§ilen alanÄ± iÅŸleyerek sonuÃ§ Ã¼retiyor.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 44
```csharp
public class ImageCropper
{
    public struct Rectangle
    {
        public int X, Y, Width, Height;
    }

    public byte[] CropImage(byte[] imageData, int originalWidth, int originalHeight, Rectangle cropArea)
    {
        if (imageData == null || originalWidth <= 0 || originalHeight <= 0)
            return null;

        // Validate crop area boundaries
        int safeX = Math.Max(0, Math.Min(cropArea.X, originalWidth - 1));
        int safeY = Math.Max(0, Math.Min(cropArea.Y, originalHeight - 1));
        int safeWidth = Math.Max(1, Math.Min(cropArea.Width, originalWidth - safeX));
        int safeHeight = Math.Max(1, Math.Min(cropArea.Height, originalHeight - safeY));

        // Calculate bytes per pixel (assuming RGB = 3 bytes)
        int bytesPerPixel = 3;
        int originalRowSize = originalWidth * bytesPerPixel;
        int croppedRowSize = safeWidth * bytesPerPixel;

        // Validate source data size
        if (imageData.Length < originalHeight * originalRowSize)
            return null;

        byte[] croppedData = new byte[safeHeight * croppedRowSize];

        // Safe pixel copying with boundary checks
        for (int y = 0; y < safeHeight; y++)
        {
            int srcOffset = ((safeY + y) * originalRowSize) + (safeX * bytesPerPixel);
            int dstOffset = y * croppedRowSize;

            if (srcOffset + croppedRowSize <= imageData.Length)
            {
                Array.Copy(imageData, srcOffset, croppedData, dstOffset, croppedRowSize);
            }
        }

        return croppedData;
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 53
```typescript
interface Rectangle {
    x: number;
    y: number;
    width: number;
    height: number;
}

class ImageCropper {
    private readonly BYTES_PER_PIXEL = 3; // RGB

    cropImage(imageData: Uint8Array, originalWidth: number, originalHeight: number, 
              cropArea: Rectangle): Uint8Array | null {
        
        if (!imageData || originalWidth <= 0 || originalHeight <= 0) {
            return null;
        }

        // Validate and clamp crop area boundaries
        const safeX = Math.max(0, Math.min(cropArea.x, originalWidth - 1));
        const safeY = Math.max(0, Math.min(cropArea.y, originalHeight - 1));
        const safeWidth = Math.max(1, Math.min(cropArea.width, originalWidth - safeX));
        const safeHeight = Math.max(1, Math.min(cropArea.height, originalHeight - safeY));

        const originalRowSize = originalWidth * this.BYTES_PER_PIXEL;
        const croppedRowSize = safeWidth * this.BYTES_PER_PIXEL;

        // Validate source data size
        if (imageData.length < originalHeight * originalRowSize) {
            return null;
        }

        const croppedData = new Uint8Array(safeHeight * croppedRowSize);

        // Safe pixel copying with boundary checks
        for (let y = 0; y < safeHeight; y++) {
            const srcOffset = ((safeY + y) * originalRowSize) + (safeX * this.BYTES_PER_PIXEL);
            const dstOffset = y * croppedRowSize;

            if (srcOffset + croppedRowSize <= imageData.length) {
                croppedData.set(imageData.subarray(srcOffset, srcOffset + croppedRowSize), dstOffset);
            }
        }

        return croppedData;
    }

    validateCropArea(imageWidth: number, imageHeight: number, cropArea: Rectangle): boolean {
        return (cropArea.x >= 0 && cropArea.y >= 0 &&
                cropArea.width > 0 && cropArea.height > 0 &&
                cropArea.x + cropArea.width <= imageWidth &&
                cropArea.y + cropArea.height <= imageHeight);
    }
}
```

---

### ðŸ§ª Senaryo 4: Bir aÄŸ protokolÃ¼ uygulamasÄ±nda gelen veri paketleri byte dizisine aktarÄ±lÄ±yor. Paket uzunluÄŸu dÄ±ÅŸarÄ±dan geldiÄŸi iÃ§in sistem bu deÄŸeri referans alarak yazma iÅŸlemi gerÃ§ekleÅŸtiriyor. Paket boyutlarÄ± deÄŸiÅŸken olabildiÄŸinden tampon bellek bu duruma gÃ¶re ayarlanÄ±yor. Bellek sÄ±nÄ±rlarÄ± uygulamayla yÃ¶netiliyor.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 51
```csharp
public class NetworkPacketProcessor
{
    private const int MAX_PACKET_SIZE = 65536; // 64KB
    private const int MIN_PACKET_SIZE = 8;     // Header size
    private readonly byte[] buffer = new byte[MAX_PACKET_SIZE];

    public bool ProcessPacket(byte[] incomingData, int declaredLength)
    {
        if (incomingData == null || declaredLength < MIN_PACKET_SIZE || declaredLength > MAX_PACKET_SIZE)
            return false;

        // Validate actual data length against declared length
        int actualLength = Math.Min(incomingData.Length, declaredLength);
        if (actualLength != declaredLength)
            return false; // Length mismatch - potential attack

        // Clear buffer before use
        Array.Clear(buffer, 0, actualLength);

        // Safe copy with validated bounds
        Array.Copy(incomingData, 0, buffer, 0, actualLength);

        return ProcessValidatedPacket(actualLength);
    }

    private bool ProcessValidatedPacket(int packetLength)
    {
        // Extract header (first 8 bytes)
        if (packetLength < MIN_PACKET_SIZE)
            return false;

        uint packetType = BitConverter.ToUInt32(buffer, 0);
        uint payloadLength = BitConverter.ToUInt32(buffer, 4);

        // Validate payload length against actual packet
        if (payloadLength > packetLength - MIN_PACKET_SIZE)
            return false;

        // Process payload safely
        byte[] payload = new byte[payloadLength];
        Array.Copy(buffer, MIN_PACKET_SIZE, payload, 0, (int)payloadLength);

        return HandlePayload(packetType, payload);
    }

    private bool HandlePayload(uint packetType, byte[] payload)
    {
        // Safe payload processing logic here
        return true;
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 63
```typescript
class NetworkPacketProcessor {
    private readonly MAX_PACKET_SIZE = 65536; // 64KB
    private readonly MIN_PACKET_SIZE = 8;     // Header size
    private buffer: Uint8Array;

    constructor() {
        this.buffer = new Uint8Array(this.MAX_PACKET_SIZE);
    }

    processPacket(incomingData: Uint8Array, declaredLength: number): boolean {
        if (!incomingData || declaredLength < this.MIN_PACKET_SIZE || declaredLength > this.MAX_PACKET_SIZE) {
            return false;
        }

        // Validate actual data length against declared length
        const actualLength = Math.min(incomingData.length, declaredLength);
        if (actualLength !== declaredLength) {
            return false; // Length mismatch - potential attack
        }

        // Clear buffer before use
        this.buffer.fill(0, 0, actualLength);

        // Safe copy with validated bounds
        this.buffer.set(incomingData.subarray(0, actualLength), 0);

        return this.processValidatedPacket(actualLength);
    }

    private processValidatedPacket(packetLength: number): boolean {
        // Extract header (first 8 bytes)
        if (packetLength < this.MIN_PACKET_SIZE) {
            return false;
        }

        const headerView = new DataView(this.buffer.buffer, 0, 8);
        const packetType = headerView.getUint32(0, true); // little endian
        const payloadLength = headerView.getUint32(4, true);

        // Validate payload length against actual packet
        if (payloadLength > packetLength - this.MIN_PACKET_SIZE) {
            return false;
        }

        // Process payload safely
        const payloadEnd = this.MIN_PACKET_SIZE + payloadLength;
        if (payloadEnd <= this.buffer.length) {
            const payload = this.buffer.slice(this.MIN_PACKET_SIZE, payloadEnd);
            return this.handlePayload(packetType, payload);
        }

        return false;
    }

    private handlePayload(packetType: number, payload: Uint8Array): boolean {
        // Safe payload processing logic here
        return true;
    }

    getMaxPacketSize(): number {
        return this.MAX_PACKET_SIZE;
    }
}
```

---

### ðŸ§ª Senaryo 5: Bir oyun motoru karakter animasyonlarÄ±nÄ± bellekteki belirli diziler Ã¼zerinden kontrol ediyor. Animasyonlar kare dizisi olarak tutuluyor ve karakterin hareketine gÃ¶re gÃ¼ncelleniyor. KullanÄ±cÄ± eylemleri bu dizinin aralÄ±ÄŸÄ±nÄ± deÄŸiÅŸtirebiliyor. Sistem hareket aralÄ±ÄŸÄ±nÄ± animasyon sÄ±rasÄ±nda ayarlÄ±yor.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 69
```csharp
public class AnimationController
{
    public struct AnimationFrame
    {
        public float X, Y, Z;
        public float RotationX, RotationY, RotationZ;
        public float Scale;
    }

    private AnimationFrame[] frames;
    private int currentFrame = 0;
    private readonly int maxFrames;

    public AnimationController(int maxFrameCount = 1000)
    {
        maxFrames = Math.Max(1, Math.Min(maxFrameCount, 10000));
        frames = new AnimationFrame[maxFrames];
    }

    public bool SetAnimationRange(int startFrame, int endFrame)
    {
        if (startFrame < 0 || endFrame < 0 || startFrame >= maxFrames || endFrame >= maxFrames)
            return false;

        if (startFrame > endFrame)
            return false;

        // Safe frame range validation
        int safeStart = Math.Max(0, Math.Min(startFrame, maxFrames - 1));
        int safeEnd = Math.Max(safeStart, Math.Min(endFrame, maxFrames - 1));

        currentFrame = safeStart;
        return true;
    }

    public bool UpdateFrame(int frameIndex, AnimationFrame newFrame)
    {
        if (frameIndex < 0 || frameIndex >= maxFrames)
            return false;

        // Validate frame data
        if (float.IsNaN(newFrame.X) || float.IsNaN(newFrame.Y) || float.IsNaN(newFrame.Z))
            return false;

        frames[frameIndex] = newFrame;
        return true;
    }

    public AnimationFrame GetCurrentFrame()
    {
        if (currentFrame >= 0 && currentFrame < maxFrames)
            return frames[currentFrame];

        return new AnimationFrame(); // Default frame
    }

    public bool AdvanceFrame()
    {
        if (currentFrame + 1 < maxFrames)
        {
            currentFrame++;
            return true;
        }
        return false;
    }

    public int GetCurrentFrameIndex() => currentFrame;
    public int GetMaxFrames() => maxFrames;
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 86
```typescript
interface AnimationFrame {
    x: number;
    y: number;
    z: number;
    rotationX: number;
    rotationY: number;
    rotationZ: number;
    scale: number;
}

class AnimationController {
    private frames: AnimationFrame[];
    private currentFrame: number = 0;
    private startFrame: number = 0;
    private endFrame: number = 0;
    private readonly maxFrames: number;

    constructor(maxFrameCount: number = 1000) {
        this.maxFrames = Math.max(1, Math.min(maxFrameCount, 10000));
        this.frames = new Array(this.maxFrames).fill(null).map(() => ({
            x: 0, y: 0, z: 0,
            rotationX: 0, rotationY: 0, rotationZ: 0,
            scale: 1
        }));
    }

    setAnimationRange(startFrame: number, endFrame: number): boolean {
        if (startFrame < 0 || endFrame < 0 || startFrame >= this.maxFrames || endFrame >= this.maxFrames) {
            return false;
        }

        if (startFrame > endFrame) {
            return false;
        }

        // Safe frame range validation
        const safeStart = Math.max(0, Math.min(startFrame, this.maxFrames - 1));
        const safeEnd = Math.max(safeStart, Math.min(endFrame, this.maxFrames - 1));

        this.startFrame = safeStart;
        this.endFrame = safeEnd;
        this.currentFrame = safeStart;
        return true;
    }

    updateFrame(frameIndex: number, newFrame: AnimationFrame): boolean {
        if (frameIndex < 0 || frameIndex >= this.maxFrames) {
            return false;
        }

        // Validate frame data
        if (isNaN(newFrame.x) || isNaN(newFrame.y) || isNaN(newFrame.z) || isNaN(newFrame.scale)) {
            return false;
        }

        this.frames[frameIndex] = { ...newFrame };
        return true;
    }

    getCurrentFrame(): AnimationFrame {
        if (this.currentFrame >= 0 && this.currentFrame < this.maxFrames) {
            return { ...this.frames[this.currentFrame] };
        }
        return { x: 0, y: 0, z: 0, rotationX: 0, rotationY: 0, rotationZ: 0, scale: 1 };
    }

    advanceFrame(): boolean {
        if (this.currentFrame < this.endFrame) {
            this.currentFrame++;
            return true;
        }
        return false;
    }

    resetToStart(): void {
        this.currentFrame = this.startFrame;
    }

    getCurrentFrameIndex(): number {
        return this.currentFrame;
    }

    getMaxFrames(): number {
        return this.maxFrames;
    }
}
```

---

### ðŸ§ª Senaryo 6: Bir veritabanÄ± motorunda dizinleme iÅŸlemleri sÄ±rasÄ±nda kayÄ±tlar bellekte bloklar halinde tutuluyor. Arama sÄ±rasÄ±nda kullanÄ±cÄ± girdisiyle bu bloklara eriÅŸim yapÄ±lÄ±yor. Sistem gelen deÄŸerin blok aralÄ±ÄŸÄ±nda olup olmadÄ±ÄŸÄ±nÄ± deÄŸerlendiriyor. Okuma ve yazma sÄ±rasÄ±nda blok sÄ±nÄ±rlarÄ± kontrol ediliyor.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 95
```csharp
public class DatabaseIndexManager
{
    private struct DataBlock
    {
        public byte[] Data;
        public int StartKey;
        public int EndKey;
        public bool IsValid;
    }

    private readonly DataBlock[] blocks;
    private readonly int blockSize;
    private readonly int maxBlocks;

    public DatabaseIndexManager(int maxBlockCount = 1000, int blockSizeBytes = 4096)
    {
        maxBlocks = Math.Max(1, Math.Min(maxBlockCount, 10000));
        blockSize = Math.Max(256, Math.Min(blockSizeBytes, 65536));
        blocks = new DataBlock[maxBlocks];

        // Initialize blocks
        for (int i = 0; i < maxBlocks; i++)
        {
            blocks[i] = new DataBlock
            {
                Data = new byte[blockSize],
                StartKey = -1,
                EndKey = -1,
                IsValid = false
            };
        }
    }

    public bool WriteToBlock(int blockIndex, int key, byte[] data)
    {
        if (blockIndex < 0 || blockIndex >= maxBlocks || data == null)
            return false;

        if (data.Length > blockSize)
            return false;

        // Safe boundary validation
        if (!blocks[blockIndex].IsValid)
        {
            blocks[blockIndex].StartKey = key;
            blocks[blockIndex].EndKey = key;
        }
        else
        {
            // Validate key range
            if (key < blocks[blockIndex].StartKey || key > blocks[blockIndex].EndKey + 1)
                return false;
        }

        // Safe data copy
        Array.Clear(blocks[blockIndex].Data, 0, blockSize);
        Array.Copy(data, 0, blocks[blockIndex].Data, 0, Math.Min(data.Length, blockSize));

        blocks[blockIndex].EndKey = Math.Max(blocks[blockIndex].EndKey, key);
        blocks[blockIndex].IsValid = true;
        return true;
    }

    public byte[] ReadFromBlock(int blockIndex, int key)
    {
        if (blockIndex < 0 || blockIndex >= maxBlocks)
            return null;

        if (!blocks[blockIndex].IsValid)
            return null;

        // Validate key is within block range
        if (key < blocks[blockIndex].StartKey || key > blocks[blockIndex].EndKey)
            return null;

        // Return safe copy of data
        byte[] result = new byte[blockSize];
        Array.Copy(blocks[blockIndex].Data, 0, result, 0, blockSize);
        return result;
    }

    public int FindBlockForKey(int key)
    {
        for (int i = 0; i < maxBlocks; i++)
        {
            if (blocks[i].IsValid && 
                key >= blocks[i].StartKey && 
                key <= blocks[i].EndKey)
            {
                return i;
            }
        }
        return -1;
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 124
```typescript
interface DataBlock {
    data: Uint8Array;
    startKey: number | null;
    endKey: number | null;
    isValid: boolean;
    recordCount: number;
}

interface BlockInfo {
    isValid: boolean;
    startKey: number | null;
    endKey: number | null;
    recordCount: number;
}

class DatabaseIndexManager {
    private blocks: Map<number, DataBlock>;
    private readonly maxBlocks: number;
    private readonly blockSize: number;

    constructor(maxBlockCount: number = 1000, blockSizeBytes: number = 4096) {
        this.maxBlocks = Math.max(1, Math.min(maxBlockCount, 10000));
        this.blockSize = Math.max(256, Math.min(blockSizeBytes, 65536));
        this.blocks = new Map();

        // Initialize blocks
        for (let i = 0; i < this.maxBlocks; i++) {
            this.blocks.set(i, {
                data: new Uint8Array(this.blockSize),
                startKey: null,
                endKey: null,
                isValid: false,
                recordCount: 0
            });
        }
    }

    writeToBlock(blockIndex: number, key: number, data: Uint8Array): boolean {
        if (blockIndex < 0 || blockIndex >= this.maxBlocks || !data) {
            return false;
        }

        if (data.length > this.blockSize) {
            return false;
        }

        const block = this.blocks.get(blockIndex);
        if (!block) return false;

        // Safe boundary validation
        if (!block.isValid) {
            block.startKey = key;
            block.endKey = key;
        } else {
            // Validate key range
            if (block.startKey !== null && block.endKey !== null) {
                if (key < block.startKey || key > block.endKey + 1) {
                    return false;
                }
            }
        }

        // Safe data copy with size validation
        const dataLength = Math.min(data.length, this.blockSize);
        block.data.set(data.subarray(0, dataLength), 0);
        
        // Clear remaining bytes
        if (dataLength < this.blockSize) {
            block.data.fill(0, dataLength);
        }

        block.endKey = Math.max(block.endKey ?? key, key);
        block.isValid = true;
        block.recordCount++;
        return true;
    }

    readFromBlock(blockIndex: number, key: number): Uint8Array | null {
        if (blockIndex < 0 || blockIndex >= this.maxBlocks) {
            return null;
        }

        const block = this.blocks.get(blockIndex);
        if (!block || !block.isValid) {
            return null;
        }

        // Validate key is within block range
        if (block.startKey === null || block.endKey === null || 
            key < block.startKey || key > block.endKey) {
            return null;
        }

        // Return safe copy of data
        return new Uint8Array(block.data);
    }

    findBlockForKey(key: number): number {
        for (let i = 0; i < this.maxBlocks; i++) {
            const block = this.blocks.get(i);
            if (block && block.isValid && 
                block.startKey !== null && block.endKey !== null &&
                key >= block.startKey && key <= block.endKey) {
                return i;
            }
        }
        return -1;
    }

    getBlockInfo(blockIndex: number): BlockInfo | null {
        if (blockIndex >= 0 && blockIndex < this.maxBlocks) {
            const block = this.blocks.get(blockIndex);
            if (block) {
                return {
                    isValid: block.isValid,
                    startKey: block.startKey,
                    endKey: block.endKey,
                    recordCount: block.recordCount
                };
            }
        }
        return null;
    }
}
```

---

### ðŸ§ª Senaryo 7: Bir terminal uygulamasÄ±nda komut geÃ§miÅŸi sÄ±nÄ±rlÄ± sayÄ±da kayÄ±tla tutuluyor. KullanÄ±cÄ± daha fazla komut girdiÄŸinde eski kayÄ±tlar bellekte kaydÄ±rÄ±larak yenileri ekleniyor. Komutlar farklÄ± uzunlukta olabildiÄŸi iÃ§in buffer boyutu dinamik ayarlanÄ±yor. Sistem gelen komutun uzunluÄŸuna gÃ¶re alan oluÅŸturuyor.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 72
```csharp
public class TerminalHistory
{
    private readonly Queue<string> history = new Queue<string>();
    private readonly int maxHistorySize;
    private readonly int maxCommandLength;

    public TerminalHistory(int maxSize = 1000, int maxCmdLength = 1024)
    {
        maxHistorySize = Math.Max(1, Math.Min(maxSize, 10000));
        maxCommandLength = Math.Max(1, Math.Min(maxCmdLength, 4096));
    }

    public bool AddCommand(string command)
    {
        if (string.IsNullOrWhiteSpace(command))
            return false;

        // Validate and sanitize command length
        string safeCommand = command.Length > maxCommandLength 
            ? command.Substring(0, maxCommandLength) 
            : command;

        // Remove oldest command if history is full
        while (history.Count >= maxHistorySize)
        {
            history.Dequeue();
        }

        // Add new command
        history.Enqueue(safeCommand.Trim());
        return true;
    }

    public string[] GetHistory()
    {
        return history.ToArray();
    }

    public string GetCommand(int index)
    {
        if (index < 0 || index >= history.Count)
            return string.Empty;

        string[] historyArray = history.ToArray();
        return historyArray[index];
    }

    public string GetLastCommand()
    {
        return history.Count > 0 ? history.Last() : string.Empty;
    }

    public string[] SearchHistory(string searchTerm)
    {
        if (string.IsNullOrWhiteSpace(searchTerm))
            return new string[0];

        // Safe search with length validation
        string safeTerm = searchTerm.Length > 100 ? searchTerm.Substring(0, 100) : searchTerm;
        
        return history.Where(cmd => cmd.Contains(safeTerm, StringComparison.OrdinalIgnoreCase))
                     .ToArray();
    }

    public void ClearHistory()
    {
        history.Clear();
    }

    public int GetHistoryCount() => history.Count;
    public int GetMaxHistorySize() => maxHistorySize;
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 100
```typescript
class TerminalHistory {
    private history: string[] = [];
    private readonly maxHistorySize: number;
    private readonly maxCommandLength: number;

    constructor(maxSize: number = 1000, maxCmdLength: number = 1024) {
        this.maxHistorySize = Math.max(1, Math.min(maxSize, 10000));
        this.maxCommandLength = Math.max(1, Math.min(maxCmdLength, 4096));
    }

    addCommand(command: string): boolean {
        if (!command || !command.trim()) {
            return false;
        }

        // Validate and sanitize command length
        const safeCommand = command.length > this.maxCommandLength 
            ? command.substring(0, this.maxCommandLength) 
            : command;

        // Clean command (remove control characters)
        const cleanedCommand = safeCommand.replace(/[\x00-\x1f\x7f-\x9f]/g, '').trim();
        
        if (!cleanedCommand) {
            return false;
        }

        // Remove oldest command if history is full
        while (this.history.length >= this.maxHistorySize) {
            this.history.shift();
        }

        // Add new command
        this.history.push(cleanedCommand);
        return true;
    }

    getHistory(): string[] {
        return [...this.history]; // Return safe copy
    }

    getCommand(index: number): string {
        if (index < 0 || index >= this.history.length) {
            return '';
        }
        
        return this.history[index];
    }

    getLastCommand(): string {
        return this.history.length > 0 ? this.history[this.history.length - 1] : '';
    }

    searchHistory(searchTerm: string): string[] {
        if (!searchTerm || !searchTerm.trim()) {
            return [];
        }

        // Safe search with length validation
        const safeTerm = searchTerm.length > 100 ? searchTerm.substring(0, 100) : searchTerm;
        const lowerSafeTerm = safeTerm.trim().toLowerCase();
        
        return this.history.filter(cmd => cmd.toLowerCase().includes(lowerSafeTerm));
    }

    getRecentCommands(count: number): string[] {
        const safeCount = Math.max(0, Math.min(count, this.history.length));
        return this.history.slice(-safeCount);
    }

    clearHistory(): void {
        this.history = [];
    }

    getHistoryCount(): number {
        return this.history.length;
    }

    getMaxHistorySize(): number {
        return this.maxHistorySize;
    }

    removeDuplicates(): void {
        if (this.history.length <= 1) {
            return;
        }
        
        const uniqueHistory: string[] = [];
        let prevCmd: string | null = null;
        
        for (const cmd of this.history) {
            if (cmd !== prevCmd) {
                uniqueHistory.push(cmd);
                prevCmd = cmd;
            }
        }
        
        this.history = uniqueHistory;
    }
}
```

---

### ðŸ§ª Senaryo 8: Bir gÃ¶rÃ¼ntÃ¼ iÅŸleme kÃ¼tÃ¼phanesi gelen kamera verilerini kare kare analiz ediyor. Her kare belleÄŸe tampon aracÄ±lÄ±ÄŸÄ±yla alÄ±nÄ±yor. Kamera Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ deÄŸiÅŸtiÄŸinde buffer boyutu bu duruma gÃ¶re ayarlanÄ±yor. Bu sayede bellek sÄ±nÄ±rlarÄ± iÃ§inde iÅŸlem yapÄ±lÄ±yor.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 98
```csharp
public class CameraFrameProcessor
{
    private byte[] frameBuffer;
    private int currentWidth;
    private int currentHeight;
    private readonly int maxWidth = 4096;
    private readonly int maxHeight = 4096;
    private readonly int bytesPerPixel = 3; // RGB

    public CameraFrameProcessor()
    {
        // Initialize with default resolution
        ResizeBuffer(640, 480);
    }

    public bool SetResolution(int width, int height)
    {
        // Validate resolution bounds
        if (width <= 0 || height <= 0 || width > maxWidth || height > maxHeight)
            return false;

        return ResizeBuffer(width, height);
    }

    private bool ResizeBuffer(int width, int height)
    {
        try
        {
            int requiredSize = width * height * bytesPerPixel;
            
            // Prevent excessive memory allocation
            if (requiredSize > maxWidth * maxHeight * bytesPerPixel)
                return false;

            frameBuffer = new byte[requiredSize];
            currentWidth = width;
            currentHeight = height;
            return true;
        }
        catch (OutOfMemoryException)
        {
            return false;
        }
    }

    public bool ProcessFrame(byte[] cameraData)
    {
        if (cameraData == null || frameBuffer == null)
            return false;

        int expectedSize = currentWidth * currentHeight * bytesPerPixel;
        
        // Validate incoming data size
        if (cameraData.Length != expectedSize)
            return false;

        // Safe copy with size validation
        Array.Copy(cameraData, 0, frameBuffer, 0, Math.Min(cameraData.Length, frameBuffer.Length));
        
        return AnalyzeFrame();
    }

    private bool AnalyzeFrame()
    {
        if (frameBuffer == null)
            return false;

        // Safe frame analysis with bounds checking
        for (int y = 0; y < currentHeight; y++)
        {
            for (int x = 0; x < currentWidth; x++)
            {
                int pixelIndex = (y * currentWidth + x) * bytesPerPixel;
                
                // Bounds check before accessing
                if (pixelIndex + 2 < frameBuffer.Length)
                {
                    byte r = frameBuffer[pixelIndex];
                    byte g = frameBuffer[pixelIndex + 1];
                    byte b = frameBuffer[pixelIndex + 2];
                    
                    // Process pixel data safely
                    ProcessPixel(r, g, b, x, y);
                }
            }
        }
        
        return true;
    }

    private void ProcessPixel(byte r, byte g, byte b, int x, int y)
    {
        // Safe pixel processing logic
    }

    public (int width, int height) GetCurrentResolution() => (currentWidth, currentHeight);
    public int GetBufferSize() => frameBuffer?.Length ?? 0;
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 112
```typescript
class CameraFrameProcessor {
    private frameBuffer: Uint8Array | null = null;
    private currentWidth: number = 0;
    private currentHeight: number = 0;
    private readonly maxWidth = 4096;
    private readonly maxHeight = 4096;
    private readonly bytesPerPixel = 3; // RGB

    constructor() {
        // Initialize with default resolution
        this.setResolution(640, 480);
    }

    setResolution(width: number, height: number): boolean {
        // Validate resolution bounds
        if (width <= 0 || height <= 0 || width > this.maxWidth || height > this.maxHeight) {
            return false;
        }

        return this.resizeBuffer(width, height);
    }

    private resizeBuffer(width: number, height: number): boolean {
        try {
            const requiredSize = width * height * this.bytesPerPixel;
            
            // Prevent excessive memory allocation
            const maxSize = this.maxWidth * this.maxHeight * this.bytesPerPixel;
            if (requiredSize > maxSize) {
                return false;
            }

            this.frameBuffer = new Uint8Array(requiredSize);
            this.currentWidth = width;
            this.currentHeight = height;
            return true;
            
        } catch (error) {
            return false;
        }
    }

    processFrame(cameraData: Uint8Array): boolean {
        if (!cameraData || !this.frameBuffer) {
            return false;
        }

        const expectedSize = this.currentWidth * this.currentHeight * this.bytesPerPixel;
        
        // Validate incoming data size
        if (cameraData.length !== expectedSize) {
            return false;
        }

        // Safe copy with size validation
        const copyLength = Math.min(cameraData.length, this.frameBuffer.length);
        this.frameBuffer.set(cameraData.subarray(0, copyLength), 0);
        
        return this.analyzeFrame();
    }

    private analyzeFrame(): boolean {
        if (!this.frameBuffer) {
            return false;
        }

        try {
            // Safe frame analysis with bounds checking
            for (let y = 0; y < this.currentHeight; y++) {
                for (let x = 0; x < this.currentWidth; x++) {
                    const pixelIndex = (y * this.currentWidth + x) * this.bytesPerPixel;
                    
                    // Bounds check before accessing
                    if (pixelIndex + 2 < this.frameBuffer.length) {
                        const r = this.frameBuffer[pixelIndex];
                        const g = this.frameBuffer[pixelIndex + 1];
                        const b = this.frameBuffer[pixelIndex + 2];
                        
                        // Process pixel data safely
                        this.processPixel(r, g, b, x, y);
                    }
                }
            }
            
            return true;
        } catch (error) {
            return false;
        }
    }

    private processPixel(r: number, g: number, b: number, x: number, y: number): void {
        // Safe pixel processing logic
    }

    getCurrentResolution(): { width: number; height: number } {
        return { width: this.currentWidth, height: this.currentHeight };
    }

    getBufferSize(): number {
        return this.frameBuffer ? this.frameBuffer.length : 0;
    }

    getFrameCopy(): Uint8Array | null {
        return this.frameBuffer ? new Uint8Array(this.frameBuffer) : null;
    }

    clearBuffer(): void {
        if (this.frameBuffer) {
            this.frameBuffer.fill(0);
        }
    }
}
```

---

### ðŸ§ª Senaryo 9: Bir hesaplama aracÄ± kullanÄ±cÄ±dan alÄ±nan sayÄ± dizisini bir diziye aktarÄ±yor ve iÅŸlem yapÄ±yor. KullanÄ±cÄ±nÄ±n girdiÄŸi eleman sayÄ±sÄ± sistemdeki diziden farklÄ± olabiliyor. Sistem bu sayÄ±yÄ± deÄŸerlendirerek dizi boyutunu ayarlÄ±yor. Bu ÅŸekilde bellekte uygun bÃ¶lgelere eriÅŸim saÄŸlanÄ±yor.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 108
```csharp
public class MathCalculator
{
    private double[] numbers;
    private readonly int maxArraySize;

    public MathCalculator(int maxSize = 10000)
    {
        maxArraySize = Math.Max(1, Math.Min(maxSize, 100000));
        numbers = new double[0];
    }

    public bool SetNumbers(double[] inputNumbers, int declaredCount)
    {
        if (inputNumbers == null || declaredCount < 0 || declaredCount > maxArraySize)
            return false;

        // Validate declared count against actual array size
        int actualCount = Math.Min(inputNumbers.Length, declaredCount);
        if (actualCount != declaredCount && declaredCount <= inputNumbers.Length)
            actualCount = declaredCount;

        // Validate for NaN and infinity values
        for (int i = 0; i < actualCount; i++)
        {
            if (double.IsNaN(inputNumbers[i]) || double.IsInfinity(inputNumbers[i]))
                return false;
        }

        // Safe array allocation and copy
        numbers = new double[actualCount];
        Array.Copy(inputNumbers, 0, numbers, 0, actualCount);
        
        return true;
    }

    public double Calculate(string operation)
    {
        if (numbers == null || numbers.Length == 0)
            return 0.0;

        switch (operation?.ToLower())
        {
            case "sum":
                return CalculateSum();
            case "average":
                return CalculateAverage();
            case "max":
                return CalculateMax();
            case "min":
                return CalculateMin();
            default:
                return 0.0;
        }
    }

    private double CalculateSum()
    {
        double sum = 0.0;
        for (int i = 0; i < numbers.Length; i++)
        {
            // Check for overflow
            if (double.IsInfinity(sum + numbers[i]))
                return double.MaxValue;
            sum += numbers[i];
        }
        return sum;
    }

    private double CalculateAverage()
    {
        if (numbers.Length == 0)
            return 0.0;
        
        double sum = CalculateSum();
        return sum / numbers.Length;
    }

    private double CalculateMax()
    {
        if (numbers.Length == 0)
            return 0.0;
        
        double max = numbers[0];
        for (int i = 1; i < numbers.Length; i++)
        {
            if (numbers[i] > max)
                max = numbers[i];
        }
        return max;
    }

    private double CalculateMin()
    {
        if (numbers.Length == 0)
            return 0.0;
        
        double min = numbers[0];
        for (int i = 1; i < numbers.Length; i++)
        {
            if (numbers[i] < min)
                min = numbers[i];
        }
        return min;
    }

    public int GetArraySize() => numbers?.Length ?? 0;
    public double[] GetNumbers() => (double[])numbers?.Clone();
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 147
```typescript
class MathCalculator {
    private numbers: number[] = [];
    private readonly maxArraySize: number;

    constructor(maxSize: number = 10000) {
        this.maxArraySize = Math.max(1, Math.min(maxSize, 100000));
    }

    setNumbers(inputNumbers: number[], declaredCount: number): boolean {
        if (!inputNumbers || declaredCount < 0 || declaredCount > this.maxArraySize) {
            return false;
        }

        // Validate declared count against actual array size
        let actualCount = Math.min(inputNumbers.length, declaredCount);
        if (actualCount !== declaredCount && declaredCount <= inputNumbers.length) {
            actualCount = declaredCount;
        }

        // Validate for NaN and infinity values
        for (let i = 0; i < actualCount; i++) {
            if (!isFinite(inputNumbers[i])) {
                return false;
            }
        }

        // Safe array allocation and copy
        this.numbers = inputNumbers.slice(0, actualCount);
        return true;
    }

    calculate(operation: string): number {
        if (!this.numbers || this.numbers.length === 0) {
            return 0.0;
        }

        const op = operation?.toLowerCase().trim() || "";
        
        try {
            switch (op) {
                case "sum":
                    return this.calculateSum();
                case "average":
                    return this.calculateAverage();
                case "max":
                    return this.calculateMax();
                case "min":
                    return this.calculateMin();
                case "median":
                    return this.calculateMedian();
                case "std":
                    return this.calculateStd();
                default:
                    return 0.0;
            }
        } catch (error) {
            return 0.0;
        }
    }

    private calculateSum(): number {
        let sum = 0.0;
        for (let i = 0; i < this.numbers.length; i++) {
            // Check for overflow
            const newSum = sum + this.numbers[i];
            if (!isFinite(newSum)) {
                return Number.MAX_VALUE;
            }
            sum = newSum;
        }
        return sum;
    }

    private calculateAverage(): number {
        if (this.numbers.length === 0) {
            return 0.0;
        }
        
        const sum = this.calculateSum();
        return sum / this.numbers.length;
    }

    private calculateMax(): number {
        if (this.numbers.length === 0) {
            return 0.0;
        }
        
        return Math.max(...this.numbers);
    }

    private calculateMin(): number {
        if (this.numbers.length === 0) {
            return 0.0;
        }
        
        return Math.min(...this.numbers);
    }

    private calculateMedian(): number {
        if (this.numbers.length === 0) {
            return 0.0;
        }
        
        const sorted = [...this.numbers].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        
        return sorted.length % 2 === 0
            ? (sorted[mid - 1] + sorted[mid]) / 2
            : sorted[mid];
    }

    private calculateStd(): number {
        if (this.numbers.length <= 1) {
            return 0.0;
        }
        
        const mean = this.calculateAverage();
        const squaredDiffs = this.numbers.map(x => Math.pow(x - mean, 2));
        const avgSquaredDiff = squaredDiffs.reduce((a, b) => a + b, 0) / this.numbers.length;
        
        return Math.sqrt(avgSquaredDiff);
    }

    getArraySize(): number {
        return this.numbers.length;
    }

    getNumbers(): number[] {
        return [...this.numbers]; // Return safe copy
    }

    getStatistics(): Record<string, number> {
        if (this.numbers.length === 0) {
            return {};
        }
        
        return {
            count: this.numbers.length,
            sum: this.calculateSum(),
            mean: this.calculateAverage(),
            min: this.calculateMin(),
            max: this.calculateMax(),
            median: this.calculateMedian(),
            std: this.calculateStd()
        };
    }
}
```

---

### ðŸ§ª Senaryo 10: Bir video oynatÄ±cÄ± yazÄ±lÄ±mÄ± oynatma sÄ±rasÄ±nda ses ve video karelerini farklÄ± tamponlara alÄ±yor. Video Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ bÃ¼yÃ¼dÃ¼kÃ§e tampon alan gereksinimleri artÄ±yor. Sistem Ã§Ã¶zÃ¼nÃ¼rlÃ¼k deÄŸiÅŸimini belleÄŸe yansÄ±tÄ±yor. Bu durum tampon boyutu sorunlarÄ±nÄ± Ã¶nleyecek ÅŸekilde yÃ¶netiliyor.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 137
```typescript
class VideoPlayer {
    private videoBuffer: Uint8Array | null = null;
    private audioBuffer: Float32Array | null = null;
    private videoWidth: number = 0;
    private videoHeight: number = 0;
    private readonly maxVideoWidth = 4096;
    private readonly maxVideoHeight = 4096;
    private readonly maxAudioSamples = 48000;
    private readonly bytesPerPixel = 4; // RGBA

    constructor() {
        // Initialize with default HD resolution
        this.setResolution(1920, 1080);
    }

    setResolution(width: number, height: number): boolean {
        // Validate resolution bounds
        if (width <= 0 || height <= 0 || width > this.maxVideoWidth || height > this.maxVideoHeight) {
            return false;
        }

        return this.initializeBuffers(width, height);
    }

    private initializeBuffers(width: number, height: number): boolean {
        try {
            const videoBufferSize = width * height * this.bytesPerPixel;
            
            // Prevent excessive memory allocation
            const maxSize = this.maxVideoWidth * this.maxVideoHeight * this.bytesPerPixel;
            if (videoBufferSize > maxSize) {
                return false;
            }

            this.videoBuffer = new Uint8Array(videoBufferSize);
            this.audioBuffer = new Float32Array(this.maxAudioSamples);
            this.videoWidth = width;
            this.videoHeight = height;
            
            return true;
            
        } catch (error) {
            return false;
        }
    }

    loadVideoFrame(frameData: Uint8Array): boolean {
        if (!frameData || !this.videoBuffer) {
            return false;
        }

        const expectedSize = this.videoWidth * this.videoHeight * this.bytesPerPixel;
        
        // Validate frame data size
        if (frameData.length !== expectedSize) {
            return false;
        }

        // Safe copy with size validation
        const copyLength = Math.min(frameData.length, this.videoBuffer.length);
        this.videoBuffer.set(frameData.subarray(0, copyLength), 0);
        return true;
    }

    loadAudioSamples(audioData: Float32Array, sampleCount: number): boolean {
        if (!audioData || !this.audioBuffer || sampleCount < 0) {
            return false;
        }

        // Validate sample count
        const safeSampleCount = Math.min(sampleCount, Math.min(audioData.length, this.audioBuffer.length));
        
        // Validate audio data
        for (let i = 0; i < safeSampleCount; i++) {
            if (!isFinite(audioData[i])) {
                return false;
            }
        }

        // Clear buffer first
        this.audioBuffer.fill(0);
        
        // Safe copy with validated count
        this.audioBuffer.set(audioData.subarray(0, safeSampleCount), 0);
        return true;
    }

    getVideoFrame(): Uint8Array | null {
        if (!this.videoBuffer) {
            return null;
        }

        // Return safe copy
        return new Uint8Array(this.videoBuffer);
    }

    getAudioSamples(requestedSamples: number): Float32Array | null {
        if (!this.audioBuffer || requestedSamples <= 0) {
            return null;
        }

        const safeSampleCount = Math.min(requestedSamples, this.audioBuffer.length);
        return new Float32Array(this.audioBuffer.subarray(0, safeSampleCount));
    }

    getResolution(): { width: number; height: number } {
        return { width: this.videoWidth, height: this.videoHeight };
    }

    getVideoBufferSize(): number {
        return this.videoBuffer ? this.videoBuffer.length : 0;
    }

    getAudioBufferSize(): number {
        return this.audioBuffer ? this.audioBuffer.length : 0;
    }

    clearBuffers(): void {
        if (this.videoBuffer) {
            this.videoBuffer.fill(0);
        }
        if (this.audioBuffer) {
            this.audioBuffer.fill(0);
        }
    }

    getMemoryUsage(): { video: number; audio: number; total: number } {
        const videoMemory = this.videoBuffer ? this.videoBuffer.length : 0;
        const audioMemory = this.audioBuffer ? this.audioBuffer.length * 4 : 0; // 4 bytes per float
        
        return {
            video: videoMemory,
            audio: audioMemory,
            total: videoMemory + audioMemory
        };
    }
}
```