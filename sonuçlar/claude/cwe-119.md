### ğŸ§ª Senaryo 1: Bir metin dÃ¼zenleyici uygulamasÄ±nda kullanÄ±cÄ±lar Ã§ok satÄ±rlÄ± metinleri dÃ¼zenleyebiliyor. Her satÄ±r uygulama iÃ§inde bellekte tutuluyor ve dizin bilgisiyle eriÅŸiliyor. KullanÄ±cÄ± metne ekleme yaptÄ±ÄŸÄ±nda sistem belirli bir tampon belleÄŸe veri yazÄ±yor. Bu belleÄŸin boyutu kullanÄ±cÄ± girdisine gÃ¶re ayarlanÄ±yor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 40
```csharp
public class TextEditor
{
    private List<string> lines = new List<string>();
    private const int MAX_LINE_LENGTH = 1000;
    private const int MAX_LINES = 10000;

    public bool InsertLine(int index, string content)
    {
        if (content == null || content.Length > MAX_LINE_LENGTH)
            return false;
        
        if (index < 0 || index > lines.Count || lines.Count >= MAX_LINES)
            return false;

        // Safe string handling with length validation
        string safeLine = content.Substring(0, Math.Min(content.Length, MAX_LINE_LENGTH));
        lines.Insert(index, safeLine);
        return true;
    }

    public string GetLine(int index)
    {
        if (index < 0 || index >= lines.Count)
            return string.Empty;
        
        return lines[index];
    }

    public bool UpdateLine(int index, string newContent)
    {
        if (newContent == null || newContent.Length > MAX_LINE_LENGTH)
            return false;
            
        if (index < 0 || index >= lines.Count)
            return false;

        lines[index] = newContent.Substring(0, Math.Min(newContent.Length, MAX_LINE_LENGTH));
        return true;
    }
}
```
### ğŸ§ª Senaryo 1: Bir metin dÃ¼zenleyici uygulamasÄ±nda kullanÄ±cÄ±lar Ã§ok satÄ±rlÄ± metinleri dÃ¼zenleyebiliyor. Her satÄ±r uygulama iÃ§inde bellekte tutuluyor ve dizin bilgisiyle eriÅŸiliyor. KullanÄ±cÄ± metne ekleme yaptÄ±ÄŸÄ±nda sistem belirli bir tampon belleÄŸe veri yazÄ±yor. Bu belleÄŸin boyutu kullanÄ±cÄ± girdisine gÃ¶re ayarlanÄ±yor.

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 36
```python
class TextEditor:
    def __init__(self):
        self.lines = []
        self.MAX_LINE_LENGTH = 1000
        self.MAX_LINES = 10000

    def insert_line(self, index, content):
        if not isinstance(content, str) or len(content) > self.MAX_LINE_LENGTH:
            return False
        
        if index < 0 or index > len(self.lines) or len(self.lines) >= self.MAX_LINES:
            return False

        # Safe string handling with length validation
        safe_line = content[:self.MAX_LINE_LENGTH]
        self.lines.insert(index, safe_line)
        return True

    def get_line(self, index):
        if index < 0 or index >= len(self.lines):
            return ""
        
        return self.lines[index]

    def update_line(self, index, new_content):
        if not isinstance(new_content, str) or len(new_content) > self.MAX_LINE_LENGTH:
            return False
            
        if index < 0 or index >= len(self.lines):
            return False

        self.lines[index] = new_content[:self.MAX_LINE_LENGTH]
        return True

    def get_total_lines(self):
        return len(self.lines)
```
### ğŸ§ª Senaryo 1: Bir metin dÃ¼zenleyici uygulamasÄ±nda kullanÄ±cÄ±lar Ã§ok satÄ±rlÄ± metinleri dÃ¼zenleyebiliyor. Her satÄ±r uygulama iÃ§inde bellekte tutuluyor ve dizin bilgisiyle eriÅŸiliyor. KullanÄ±cÄ± metne ekleme yaptÄ±ÄŸÄ±nda sistem belirli bir tampon belleÄŸe veri yazÄ±yor. Bu belleÄŸin boyutu kullanÄ±cÄ± girdisine gÃ¶re ayarlanÄ±yor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 45
```typescript
class TextEditor {
    private lines: string[] = [];
    private readonly MAX_LINE_LENGTH = 1000;
    private readonly MAX_LINES = 10000;

    insertLine(index: number, content: string): boolean {
        if (typeof content !== 'string' || content.length > this.MAX_LINE_LENGTH) {
            return false;
        }
        
        if (index < 0 || index > this.lines.length || this.lines.length >= this.MAX_LINES) {
            return false;
        }

        // Safe string handling with length validation
        const safeLine = content.substring(0, this.MAX_LINE_LENGTH);
        this.lines.splice(index, 0, safeLine);
        return true;
    }

    getLine(index: number): string {
        if (index < 0 || index >= this.lines.length) {
            return '';
        }
        
        return this.lines[index];
    }

    updateLine(index: number, newContent: string): boolean {
        if (typeof newContent !== 'string' || newContent.length > this.MAX_LINE_LENGTH) {
            return false;
        }
            
        if (index < 0 || index >= this.lines.length) {
            return false;
        }

        this.lines[index] = newContent.substring(0, this.MAX_LINE_LENGTH);
        return true;
    }

    getTotalLines(): number {
        return this.lines.length;
    }
}
```
### ğŸ§ª Senaryo 2: Bir ses iÅŸleme yazÄ±lÄ±mÄ± gelen mikrofon verilerini belirli aralÄ±klarda buffer'a alÄ±yor. KullanÄ±cÄ± farklÄ± Ã¶rnekleme oranlarÄ± seÃ§erek kaydÄ± baÅŸlatabiliyor. Bu veri buffer'a sabit aralÄ±kla ekleniyor. Uzun kayÄ±tlar iÃ§in sistem bellek boyutlarÄ±nÄ± yÃ¶netiyor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 46
```csharp
public class AudioProcessor
{
    private Queue<float[]> audioBuffer = new Queue<float[]>();
    private const int MAX_BUFFER_SIZE = 1000;
    private const int MAX_SAMPLE_RATE = 48000;
    private readonly object bufferLock = new object();

    public bool AddAudioData(float[] samples, int sampleRate)
    {
        if (samples == null || sampleRate <= 0 || sampleRate > MAX_SAMPLE_RATE)
            return false;

        lock (bufferLock)
        {
            // Prevent buffer overflow by limiting queue size
            if (audioBuffer.Count >= MAX_BUFFER_SIZE)
            {
                audioBuffer.Dequeue(); // Remove oldest data
            }

            // Create safe copy of audio data
            float[] safeSamples = new float[Math.Min(samples.Length, sampleRate)];
            Array.Copy(samples, safeSamples, safeSamples.Length);
            
            audioBuffer.Enqueue(safeSamples);
        }
        
        return true;
    }

    public float[] GetNextAudioChunk()
    {
        lock (bufferLock)
        {
            return audioBuffer.Count > 0 ? audioBuffer.Dequeue() : new float[0];
        }
    }

    public int GetBufferSize()
    {
        lock (bufferLock)
        {
            return audioBuffer.Count;
        }
    }
}
```
### ğŸ§ª Senaryo 2: Bir ses iÅŸleme yazÄ±lÄ±mÄ± gelen mikrofon verilerini belirli aralÄ±klarda buffer'a alÄ±yor. KullanÄ±cÄ± farklÄ± Ã¶rnekleme oranlarÄ± seÃ§erek kaydÄ± baÅŸlatabiliyor. Bu veri buffer'a sabit aralÄ±kla ekleniyor. Uzun kayÄ±tlar iÃ§in sistem bellek boyutlarÄ±nÄ± yÃ¶netiyor.

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 38
```python
import threading
from collections import deque
import numpy as np

class AudioProcessor:
    def __init__(self):
        self.audio_buffer = deque(maxlen=1000)  # Auto-limiting deque
        self.MAX_SAMPLE_RATE = 48000
        self.buffer_lock = threading.Lock()

    def add_audio_data(self, samples, sample_rate):
        if not isinstance(samples, (list, np.ndarray)) or sample_rate <= 0 or sample_rate > self.MAX_SAMPLE_RATE:
            return False

        with self.buffer_lock:
            # Safe conversion and size limiting
            safe_samples = np.array(samples, dtype=np.float32)
            if len(safe_samples) > sample_rate:
                safe_samples = safe_samples[:sample_rate]
            
            # deque automatically handles buffer overflow with maxlen
            self.audio_buffer.append(safe_samples)
        
        return True

    def get_next_audio_chunk(self):
        with self.buffer_lock:
            if len(self.audio_buffer) > 0:
                return self.audio_buffer.popleft()
            return np.array([], dtype=np.float32)

    def get_buffer_size(self):
        with self.buffer_lock:
            return len(self.audio_buffer)

    def clear_buffer(self):
        with self.buffer_lock:
            self.audio_buffer.clear()
```
### ğŸ§ª Senaryo 2: Bir ses iÅŸleme yazÄ±lÄ±mÄ± gelen mikrofon verilerini belirli aralÄ±klarda buffer'a alÄ±yor. KullanÄ±cÄ± farklÄ± Ã¶rnekleme oranlarÄ± seÃ§erek kaydÄ± baÅŸlatabiliyor. Bu veri buffer'a sabit aralÄ±kla ekleniyor. Uzun kayÄ±tlar iÃ§in sistem bellek boyutlarÄ±nÄ± yÃ¶netiyor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 54
```typescript
class AudioProcessor {
    private audioBuffer: Float32Array[] = [];
    private readonly MAX_BUFFER_SIZE = 1000;
    private readonly MAX_SAMPLE_RATE = 48000;
    private bufferLock = false;

    async addAudioData(samples: number[], sampleRate: number): Promise<boolean> {
        if (!Array.isArray(samples) || sampleRate <= 0 || sampleRate > this.MAX_SAMPLE_RATE) {
            return false;
        }

        // Simple lock mechanism for buffer access
        while (this.bufferLock) {
            await new Promise(resolve => setTimeout(resolve, 1));
        }
        this.bufferLock = true;

        try {
            // Prevent buffer overflow by limiting queue size
            if (this.audioBuffer.length >= this.MAX_BUFFER_SIZE) {
                this.audioBuffer.shift(); // Remove oldest data
            }

            // Create safe copy with size validation
            const maxLength = Math.min(samples.length, sampleRate);
            const safeSamples = new Float32Array(maxLength);
            for (let i = 0; i < maxLength; i++) {
                safeSamples[i] = samples[i];
            }
            
            this.audioBuffer.push(safeSamples);
            return true;
        } finally {
            this.bufferLock = false;
        }
    }

    async getNextAudioChunk(): Promise<Float32Array> {
        while (this.bufferLock) {
            await new Promise(resolve => setTimeout(resolve, 1));
        }
        this.bufferLock = true;

        try {
            return this.audioBuffer.length > 0 ? this.audioBuffer.shift()! : new Float32Array(0);
        } finally {
            this.bufferLock = false;
        }
    }

    getBufferSize(): number {
        return this.audioBuffer.length;
    }
}
```
### ğŸ§ª Senaryo 3: Bir gÃ¶rÃ¼ntÃ¼ dÃ¼zenleme programÄ±nda kullanÄ±cÄ± bir resmi kÄ±rptÄ±ÄŸÄ±nda sistem seÃ§ilen koordinatlara gÃ¶re iÅŸlem yapÄ±yor. KÄ±rpÄ±lacak alan bellekteki pikseller Ã¼zerinden hesaplanarak yeni buffer'a aktarÄ±lÄ±yor. Bu alanlarÄ±n sÄ±nÄ±rlarÄ± iÅŸlem sÄ±rasÄ±nda belirleniyor. Sistem seÃ§ilen alanÄ± iÅŸleyerek sonuÃ§ Ã¼retiyor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 44
```csharp
public class ImageCropper
{
    public struct Rectangle
    {
        public int X, Y, Width, Height;
    }

    public byte[] CropImage(byte[] imageData, int originalWidth, int originalHeight, Rectangle cropArea)
    {
        if (imageData == null || originalWidth <= 0 || originalHeight <= 0)
            return null;

        // Validate crop area boundaries
        int safeX = Math.Max(0, Math.Min(cropArea.X, originalWidth - 1));
        int safeY = Math.Max(0, Math.Min(cropArea.Y, originalHeight - 1));
        int safeWidth = Math.Max(1, Math.Min(cropArea.Width, originalWidth - safeX));
        int safeHeight = Math.Max(1, Math.Min(cropArea.Height, originalHeight - safeY));

        // Calculate bytes per pixel (assuming RGB = 3 bytes)
        int bytesPerPixel = 3;
        int originalRowSize = originalWidth * bytesPerPixel;
        int croppedRowSize = safeWidth * bytesPerPixel;

        // Validate source data size
        if (imageData.Length < originalHeight * originalRowSize)
            return null;

        byte[] croppedData = new byte[safeHeight * croppedRowSize];

        // Safe pixel copying with boundary checks
        for (int y = 0; y < safeHeight; y++)
        {
            int srcOffset = ((safeY + y) * originalRowSize) + (safeX * bytesPerPixel);
            int dstOffset = y * croppedRowSize;

            if (srcOffset + croppedRowSize <= imageData.Length)
            {
                Array.Copy(imageData, srcOffset, croppedData, dstOffset, croppedRowSize);
            }
        }

        return croppedData;
    }
}
```
### ğŸ§ª Senaryo 3: Bir gÃ¶rÃ¼ntÃ¼ dÃ¼zenleme programÄ±nda kullanÄ±cÄ± bir resmi kÄ±rptÄ±ÄŸÄ±nda sistem seÃ§ilen koordinatlara gÃ¶re iÅŸlem yapÄ±yor. KÄ±rpÄ±lacak alan bellekteki pikseller Ã¼zerinden hesaplanarak yeni buffer'a aktarÄ±lÄ±yor. Bu alanlarÄ±n sÄ±nÄ±rlarÄ± iÅŸlem sÄ±rasÄ±nda belirleniyor. Sistem seÃ§ilen alanÄ± iÅŸleyerek sonuÃ§ Ã¼retiyor.

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 46
```python
import numpy as np
from typing import Optional, Tuple

class ImageCropper:
    def __init__(self):
        self.BYTES_PER_PIXEL = 3  # RGB

    def crop_image(self, image_data: np.ndarray, original_width: int, original_height: int, 
                   crop_area: Tuple[int, int, int, int]) -> Optional[np.ndarray]:
        
        if image_data is None or original_width <= 0 or original_height <= 0:
            return None

        x, y, width, height = crop_area

        # Validate and clamp crop area boundaries
        safe_x = max(0, min(x, original_width - 1))
        safe_y = max(0, min(y, original_height - 1))
        safe_width = max(1, min(width, original_width - safe_x))
        safe_height = max(1, min(height, original_height - safe_y))

        # Validate source data shape
        expected_size = original_height * original_width * self.BYTES_PER_PIXEL
        if image_data.size < expected_size:
            return None

        # Reshape to 3D array for safe indexing
        try:
            reshaped_data = image_data.reshape(original_height, original_width, self.BYTES_PER_PIXEL)
        except ValueError:
            return None

        # Safe cropping with boundary validation
        end_y = min(safe_y + safe_height, original_height)
        end_x = min(safe_x + safe_width, original_width)
        
        cropped_data = reshaped_data[safe_y:end_y, safe_x:end_x, :]
        
        return cropped_data.flatten()

    def validate_crop_area(self, image_width: int, image_height: int, 
                          crop_area: Tuple[int, int, int, int]) -> bool:
        x, y, width, height = crop_area
        return (0 <= x < image_width and 0 <= y < image_height and 
                width > 0 and height > 0 and 
                x + width <= image_width and y + height <= image_height)
```
### ğŸ§ª Senaryo 3: Bir gÃ¶rÃ¼ntÃ¼ dÃ¼zenleme programÄ±nda kullanÄ±cÄ± bir resmi kÄ±rptÄ±ÄŸÄ±nda sistem seÃ§ilen koordinatlara gÃ¶re iÅŸlem yapÄ±yor. KÄ±rpÄ±lacak alan bellekteki pikseller Ã¼zerinden hesaplanarak yeni buffer'a aktarÄ±lÄ±yor. Bu alanlarÄ±n sÄ±nÄ±rlarÄ± iÅŸlem sÄ±rasÄ±nda belirleniyor. Sistem seÃ§ilen alanÄ± iÅŸleyerek sonuÃ§ Ã¼retiyor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 53
```typescript
interface Rectangle {
    x: number;
    y: number;
    width: number;
    height: number;
}

class ImageCropper {
    private readonly BYTES_PER_PIXEL = 3; // RGB

    cropImage(imageData: Uint8Array, originalWidth: number, originalHeight: number, 
              cropArea: Rectangle): Uint8Array | null {
        
        if (!imageData || originalWidth <= 0 || originalHeight <= 0) {
            return null;
        }

        // Validate and clamp crop area boundaries
        const safeX = Math.max(0, Math.min(cropArea.x, originalWidth - 1));
        const safeY = Math.max(0, Math.min(cropArea.y, originalHeight - 1));
        const safeWidth = Math.max(1, Math.min(cropArea.width, originalWidth - safeX));
        const safeHeight = Math.max(1, Math.min(cropArea.height, originalHeight - safeY));

        const originalRowSize = originalWidth * this.BYTES_PER_PIXEL;
        const croppedRowSize = safeWidth * this.BYTES_PER_PIXEL;

        // Validate source data size
        if (imageData.length < originalHeight * originalRowSize) {
            return null;
        }

        const croppedData = new Uint8Array(safeHeight * croppedRowSize);

        // Safe pixel copying with boundary checks
        for (let y = 0; y < safeHeight; y++) {
            const srcOffset = ((safeY + y) * originalRowSize) + (safeX * this.BYTES_PER_PIXEL);
            const dstOffset = y * croppedRowSize;

            if (srcOffset + croppedRowSize <= imageData.length) {
                croppedData.set(imageData.subarray(srcOffset, srcOffset + croppedRowSize), dstOffset);
            }
        }

        return croppedData;
    }

    validateCropArea(imageWidth: number, imageHeight: number, cropArea: Rectangle): boolean {
        return (cropArea.x >= 0 && cropArea.y >= 0 &&
                cropArea.width > 0 && cropArea.height > 0 &&
                cropArea.x + cropArea.width <= imageWidth &&
                cropArea.y + cropArea.height <= imageHeight);
    }
}
```
### ğŸ§ª Senaryo 4: Bir aÄŸ protokolÃ¼ uygulamasÄ±nda gelen veri paketleri byte dizisine aktarÄ±lÄ±yor. Paket uzunluÄŸu dÄ±ÅŸarÄ±dan geldiÄŸi iÃ§in sistem bu deÄŸeri referans alarak yazma iÅŸlemi gerÃ§ekleÅŸtiriyor. Paket boyutlarÄ± deÄŸiÅŸken olabildiÄŸinden tampon bellek bu duruma gÃ¶re ayarlanÄ±yor. Bellek sÄ±nÄ±rlarÄ± uygulamayla yÃ¶netiliyor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 51
```csharp
public class NetworkPacketProcessor
{
    private const int MAX_PACKET_SIZE = 65536; // 64KB
    private const int MIN_PACKET_SIZE = 8;     // Header size
    private readonly byte[] buffer = new byte[MAX_PACKET_SIZE];

    public bool ProcessPacket(byte[] incomingData, int declaredLength)
    {
        if (incomingData == null || declaredLength < MIN_PACKET_SIZE || declaredLength > MAX_PACKET_SIZE)
            return false;

        // Validate actual data length against declared length
        int actualLength = Math.Min(incomingData.Length, declaredLength);
        if (actualLength != declaredLength)
            return false; // Length mismatch - potential attack

        // Clear buffer before use
        Array.Clear(buffer, 0, actualLength);

        // Safe copy with validated bounds
        Array.Copy(incomingData, 0, buffer, 0, actualLength);

        return ProcessValidatedPacket(actualLength);
    }

    private bool ProcessValidatedPacket(int packetLength)
    {
        // Extract header (first 8 bytes)
        if (packetLength < MIN_PACKET_SIZE)
            return false;

        uint packetType = BitConverter.ToUInt32(buffer, 0);
        uint payloadLength = BitConverter.ToUInt32(buffer, 4);

        // Validate payload length against actual packet
        if (payloadLength > packetLength - MIN_PACKET_SIZE)
            return false;

        // Process payload safely
        byte[] payload = new byte[payloadLength];
        Array.Copy(buffer, MIN_PACKET_SIZE, payload, 0, (int)payloadLength);

        return HandlePayload(packetType, payload);
    }

    private bool HandlePayload(uint packetType, byte[] payload)
    {
        // Safe payload processing logic here
        return true;
    }
}
```
### ğŸ§ª Senaryo 4: Bir aÄŸ protokolÃ¼ uygulamasÄ±nda gelen veri paketleri byte dizisine aktarÄ±lÄ±yor. Paket uzunluÄŸu dÄ±ÅŸarÄ±dan geldiÄŸi iÃ§in sistem bu deÄŸeri referans alarak yazma iÅŸlemi gerÃ§ekleÅŸtiriyor. Paket boyutlarÄ± deÄŸiÅŸken olabildiÄŸinden tampon bellek bu duruma gÃ¶re ayarlanÄ±yor. Bellek sÄ±nÄ±rlarÄ± uygulamayla yÃ¶netiliyor.

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 54
```python
import struct
from typing import Optional, Tuple

class NetworkPacketProcessor:
    def __init__(self):
        self.MAX_PACKET_SIZE = 65536  # 64KB
        self.MIN_PACKET_SIZE = 8      # Header size
        self.buffer = bytearray(self.MAX_PACKET_SIZE)

    def process_packet(self, incoming_data: bytes, declared_length: int) -> bool:
        if not incoming_data or declared_length < self.MIN_PACKET_SIZE or declared_length > self.MAX_PACKET_SIZE:
            return False

        # Validate actual data length against declared length
        actual_length = min(len(incoming_data), declared_length)
        if actual_length != declared_length:
            return False  # Length mismatch - potential attack

        # Clear buffer before use
        self.buffer[:actual_length] = b'\x00' * actual_length

        # Safe copy with validated bounds
        self.buffer[:actual_length] = incoming_data[:actual_length]

        return self._process_validated_packet(actual_length)

    def _process_validated_packet(self, packet_length: int) -> bool:
        # Extract header (first 8 bytes)
        if packet_length < self.MIN_PACKET_SIZE:
            return False

        try:
            packet_type, payload_length = struct.unpack('<II', self.buffer[:8])
        except struct.error:
            return False

        # Validate payload length against actual packet
        if payload_length > packet_length - self.MIN_PACKET_SIZE:
            return False

        # Process payload safely
        payload_end = self.MIN_PACKET_SIZE + payload_length
        if payload_end <= len(self.buffer):
            payload = bytes(self.buffer[self.MIN_PACKET_SIZE:payload_end])
            return self._handle_payload(packet_type, payload)

        return False

    def _handle_payload(self, packet_type: int, payload: bytes) -> bool:
        # Safe payload processing logic here
        return True

    def get_max_packet_size(self) -> int:
        return self.MAX_PACKET_SIZE
```
### ğŸ§ª Senaryo 4: Bir aÄŸ protokolÃ¼ uygulamasÄ±nda gelen veri paketleri byte dizisine aktarÄ±lÄ±yor. Paket uzunluÄŸu dÄ±ÅŸarÄ±dan geldiÄŸi iÃ§in sistem bu deÄŸeri referans alarak yazma iÅŸlemi gerÃ§ekleÅŸtiriyor. Paket boyutlarÄ± deÄŸiÅŸken olabildiÄŸinden tampon bellek bu duruma gÃ¶re ayarlanÄ±yor. Bellek sÄ±nÄ±rlarÄ± uygulamayla yÃ¶netiliyor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 63
```typescript
class NetworkPacketProcessor {
    private readonly MAX_PACKET_SIZE = 65536; // 64KB
    private readonly MIN_PACKET_SIZE = 8;     // Header size
    private buffer: Uint8Array;

    constructor() {
        this.buffer = new Uint8Array(this.MAX_PACKET_SIZE);
    }

    processPacket(incomingData: Uint8Array, declaredLength: number): boolean {
        if (!incomingData || declaredLength < this.MIN_PACKET_SIZE || declaredLength > this.MAX_PACKET_SIZE) {
            return false;
        }

        // Validate actual data length against declared length
        const actualLength = Math.min(incomingData.length, declaredLength);
        if (actualLength !== declaredLength) {
            return false; // Length mismatch - potential attack
        }

        // Clear buffer before use
        this.buffer.fill(0, 0, actualLength);

        // Safe copy with validated bounds
        this.buffer.set(incomingData.subarray(0, actualLength), 0);

        return this.processValidatedPacket(actualLength);
    }

    private processValidatedPacket(packetLength: number): boolean {
        // Extract header (first 8 bytes)
        if (packetLength < this.MIN_PACKET_SIZE) {
            return false;
        }

        const headerView = new DataView(this.buffer.buffer, 0, 8);
        const packetType = headerView.getUint32(0, true); // little endian
        const payloadLength = headerView.getUint32(4, true);

        // Validate payload length against actual packet
        if (payloadLength > packetLength - this.MIN_PACKET_SIZE) {
            return false;
        }

        // Process payload safely
        const payloadEnd = this.MIN_PACKET_SIZE + payloadLength;
        if (payloadEnd <= this.buffer.length) {
            const payload = this.buffer.slice(this.MIN_PACKET_SIZE, payloadEnd);
            return this.handlePayload(packetType, payload);
        }

        return false;
    }

    private handlePayload(packetType: number, payload: Uint8Array): boolean {
        // Safe payload processing logic here
        return true;
    }

    getMaxPacketSize(): number {
        return this.MAX_PACKET_SIZE;
    }
}
```
### ğŸ§ª Senaryo 5: Bir oyun motoru karakter animasyonlarÄ±nÄ± bellekteki belirli diziler Ã¼zerinden kontrol ediyor. Animasyonlar kare dizisi olarak tutuluyor ve karakterin hareketine gÃ¶re gÃ¼ncelleniyor. KullanÄ±cÄ± eylemleri bu dizinin aralÄ±ÄŸÄ±nÄ± deÄŸiÅŸtirebiliyor. Sistem hareket aralÄ±ÄŸÄ±nÄ± animasyon sÄ±rasÄ±nda ayarlÄ±yor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 69
```csharp
public class AnimationController
{
    public struct AnimationFrame
    {
        public float X, Y, Z;
        public float RotationX, RotationY, RotationZ;
        public float Scale;
    }

    private AnimationFrame[] frames;
    private int currentFrame = 0;
    private readonly int maxFrames;

    public AnimationController(int maxFrameCount = 1000)
    {
        maxFrames = Math.Max(1, Math.Min(maxFrameCount, 10000));
        frames = new AnimationFrame[maxFrames];
    }

    public bool SetAnimationRange(int startFrame, int endFrame)
    {
        if (startFrame < 0 || endFrame < 0 || startFrame >= maxFrames || endFrame >= maxFrames)
            return false;

        if (startFrame > endFrame)
            return false;

        // Safe frame range validation
        int safeStart = Math.Max(0, Math.Min(startFrame, maxFrames - 1));
        int safeEnd = Math.Max(safeStart, Math.Min(endFrame, maxFrames - 1));

        currentFrame = safeStart;
        return true;
    }

    public bool UpdateFrame(int frameIndex, AnimationFrame newFrame)
    {
        if (frameIndex < 0 || frameIndex >= maxFrames)
            return false;

        // Validate frame data
        if (float.IsNaN(newFrame.X) || float.IsNaN(newFrame.Y) || float.IsNaN(newFrame.Z))
            return false;

        frames[frameIndex] = newFrame;
        return true;
    }

    public AnimationFrame GetCurrentFrame()
    {
        if (currentFrame >= 0 && currentFrame < maxFrames)
            return frames[currentFrame];

        return new AnimationFrame(); // Default frame
    }

    public bool AdvanceFrame()
    {
        if (currentFrame + 1 < maxFrames)
        {
            currentFrame++;
            return true;
        }
        return false;
    }

    public int GetCurrentFrameIndex() => currentFrame;
    public int GetMaxFrames() => maxFrames;
}
```
### ğŸ§ª Senaryo 5: Bir oyun motoru karakter animasyonlarÄ±nÄ± bellekteki belirli diziler Ã¼zerinden kontrol ediyor. Animasyonlar kare dizisi olarak tutuluyor ve karakterin hareketine gÃ¶re gÃ¼ncelleniyor. KullanÄ±cÄ± eylemleri bu dizinin aralÄ±ÄŸÄ±nÄ± deÄŸiÅŸtirebiliyor. Sistem hareket aralÄ±ÄŸÄ±nÄ± animasyon sÄ±rasÄ±nda ayarlÄ±yor.

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 69
```python
import math
from dataclasses import dataclass
from typing import Optional

@dataclass
class AnimationFrame:
    x: float = 0.0
    y: float = 0.0
    z: float = 0.0
    rotation_x: float = 0.0
    rotation_y: float = 0.0
    rotation_z: float = 0.0
    scale: float = 1.0

class AnimationController:
    def __init__(self, max_frame_count: int = 1000):
        self.max_frames = max(1, min(max_frame_count, 10000))
        self.frames = [AnimationFrame() for _ in range(self.max_frames)]
        self.current_frame = 0
        self.start_frame = 0
        self.end_frame = 0

    def set_animation_range(self, start_frame: int, end_frame: int) -> bool:
        if start_frame < 0 or end_frame < 0 or start_frame >= self.max_frames or end_frame >= self.max_frames:
            return False

        if start_frame > end_frame:
            return False

        # Safe frame range validation
        safe_start = max(0, min(start_frame, self.max_frames - 1))
        safe_end = max(safe_start, min(end_frame, self.max_frames - 1))

        self.start_frame = safe_start
        self.end_frame = safe_end
        self.current_frame = safe_start
        return True

    def update_frame(self, frame_index: int, new_frame: AnimationFrame) -> bool:
        if frame_index < 0 or frame_index >= self.max_frames:
            return False

        # Validate frame data
        if (math.isnan(new_frame.x) or math.isnan(new_frame.y) or 
            math.isnan(new_frame.z) or math.isnan(new_frame.scale)):
            return False

        self.frames[frame_index] = new_frame
        return True

    def get_current_frame(self) -> AnimationFrame:
        if 0 <= self.current_frame < self.max_frames:
            return self.frames[self.current_frame]
        return AnimationFrame()

    def advance_frame(self) -> bool:
        if self.current_frame < self.end_frame:
            self.current_frame += 1
            return True
        return False

    def reset_to_start(self):
        self.current_frame = self.start_frame

    def get_current_frame_index(self) -> int:
        return self.current_frame

    def get_max_frames(self) -> int:
        return self.max_frames
```
### ğŸ§ª Senaryo 5: Bir oyun motoru karakter animasyonlarÄ±nÄ± bellekteki belirli diziler Ã¼zerinden kontrol ediyor. Animasyonlar kare dizisi olarak tutuluyor ve karakterin hareketine gÃ¶re gÃ¼ncelleniyor. KullanÄ±cÄ± eylemleri bu dizinin aralÄ±ÄŸÄ±nÄ± deÄŸiÅŸtirebiliyor. Sistem hareket aralÄ±ÄŸÄ±nÄ± animasyon sÄ±rasÄ±nda ayarlÄ±yor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 86
```typescript
interface AnimationFrame {
    x: number;
    y: number;
    z: number;
    rotationX: number;
    rotationY: number;
    rotationZ: number;
    scale: number;
}

class AnimationController {
    private frames: AnimationFrame[];
    private currentFrame: number = 0;
    private startFrame: number = 0;
    private endFrame: number = 0;
    private readonly maxFrames: number;

    constructor(maxFrameCount: number = 1000) {
        this.maxFrames = Math.max(1, Math.min(maxFrameCount, 10000));
        this.frames = new Array(this.maxFrames).fill(null).map(() => ({
            x: 0, y: 0, z: 0,
            rotationX: 0, rotationY: 0, rotationZ: 0,
            scale: 1
        }));
    }

    setAnimationRange(startFrame: number, endFrame: number): boolean {
        if (startFrame < 0 || endFrame < 0 || startFrame >= this.maxFrames || endFrame >= this.maxFrames) {
            return false;
        }

        if (startFrame > endFrame) {
            return false;
        }

        // Safe frame range validation
        const safeStart = Math.max(0, Math.min(startFrame, this.maxFrames - 1));
        const safeEnd = Math.max(safeStart, Math.min(endFrame, this.maxFrames - 1));

        this.startFrame = safeStart;
        this.endFrame = safeEnd;
        this.currentFrame = safeStart;
        return true;
    }

    updateFrame(frameIndex: number, newFrame: AnimationFrame): boolean {
        if (frameIndex < 0 || frameIndex >= this.maxFrames) {
            return false;
        }

        // Validate frame data
        if (isNaN(newFrame.x) || isNaN(newFrame.y) || isNaN(newFrame.z) || isNaN(newFrame.scale)) {
            return false;
        }

        this.frames[frameIndex] = { ...newFrame };
        return true;
    }

    getCurrentFrame(): AnimationFrame {
        if (this.currentFrame >= 0 && this.currentFrame < this.maxFrames) {
            return { ...this.frames[this.currentFrame] };
        }
        return { x: 0, y: 0, z: 0, rotationX: 0, rotationY: 0, rotationZ: 0, scale: 1 };
    }

    advanceFrame(): boolean {
        if (this.currentFrame < this.endFrame) {
            this.currentFrame++;
            return true;
        }
        return false;
    }

    resetToStart(): void {
        this.currentFrame = this.startFrame;
    }

    getCurrentFrameIndex(): number {
        return this.currentFrame;
    }

    getMaxFrames(): number {
        return this.maxFrames;
    }
}
```
### ğŸ§ª Senaryo 6: Bir veritabanÄ± motorunda dizinleme iÅŸlemleri sÄ±rasÄ±nda kayÄ±tlar bellekte bloklar halinde tutuluyor. Arama sÄ±rasÄ±nda kullanÄ±cÄ± girdisiyle bu bloklara eriÅŸim yapÄ±lÄ±yor. Sistem gelen deÄŸerin blok aralÄ±ÄŸÄ±nda olup olmadÄ±ÄŸÄ±nÄ± deÄŸerlendiriyor. Okuma ve yazma sÄ±rasÄ±nda blok sÄ±nÄ±rlarÄ± kontrol ediliyor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 95
```csharp
public class DatabaseIndexManager
{
    private struct DataBlock
    {
        public byte[] Data;
        public int StartKey;
        public int EndKey;
        public bool IsValid;
    }

    private readonly DataBlock[] blocks;
    private readonly int blockSize;
    private readonly int maxBlocks;

    public DatabaseIndexManager(int maxBlockCount = 1000, int blockSizeBytes = 4096)
    {
        maxBlocks = Math.Max(1, Math.Min(maxBlockCount, 10000));
        blockSize = Math.Max(256, Math.Min(blockSizeBytes, 65536));
        blocks = new DataBlock[maxBlocks];

        // Initialize blocks
        for (int i = 0; i < maxBlocks; i++)
        {
            blocks[i] = new DataBlock
            {
                Data = new byte[blockSize],
                StartKey = -1,
                EndKey = -1,
                IsValid = false
            };
        }
    }

    public bool WriteToBlock(int blockIndex, int key, byte[] data)
    {
        if (blockIndex < 0 || blockIndex >= maxBlocks || data == null)
            return false;

        if (data.Length > blockSize)
            return false;

        // Safe boundary validation
        if (!blocks[blockIndex].IsValid)
        {
            blocks[blockIndex].StartKey = key;
            blocks[blockIndex].EndKey = key;
        }
        else
        {
            // Validate key range
            if (key < blocks[blockIndex].StartKey || key > blocks[blockIndex].EndKey + 1)
                return false;
        }

        // Safe data copy
        Array.Clear(blocks[blockIndex].Data, 0, blockSize);
        Array.Copy(data, 0, blocks[blockIndex].Data, 0, Math.Min(data.Length, blockSize));

        blocks[blockIndex].EndKey = Math.Max(blocks[blockIndex].EndKey, key);
        blocks[blockIndex].IsValid = true;
        return true;
    }

    public byte[] ReadFromBlock(int blockIndex, int key)
    {
        if (blockIndex < 0 || blockIndex >= maxBlocks)
            return null;

        if (!blocks[blockIndex].IsValid)
            return null;

        // Validate key is within block range
        if (key < blocks[blockIndex].StartKey || key > blocks[blockIndex].EndKey)
            return null;

        // Return safe copy of data
        byte[] result = new byte[blockSize];
        Array.Copy(blocks[blockIndex].Data, 0, result, 0, blockSize);
        return result;
    }

    public int FindBlockForKey(int key)
    {
        for (int i = 0; i < maxBlocks; i++)
        {
            if (blocks[i].IsValid && 
                key >= blocks[i].StartKey && 
                key <= blocks[i].EndKey)
            {
                return i;
            }
        }
        return -1;
    }
}
```
### ğŸ§ª Senaryo 6: Bir veritabanÄ± motorunda dizinleme iÅŸlemleri sÄ±rasÄ±nda kayÄ±tlar bellekte bloklar halinde tutuluyor. Arama sÄ±rasÄ±nda kullanÄ±cÄ± girdisiyle bu bloklara eriÅŸim yapÄ±lÄ±yor. Sistem gelen deÄŸerin blok aralÄ±ÄŸÄ±nda olup olmadÄ±ÄŸÄ±nÄ± deÄŸerlendiriyor. Okuma ve yazma sÄ±rasÄ±nda blok sÄ±nÄ±rlarÄ± kontrol ediliyor.

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 86
```python
from typing import Optional, Dict, Tuple
import copy

class DatabaseIndexManager:
    def __init__(self, max_block_count: int = 1000, block_size_bytes: int = 4096):
        self.max_blocks = max(1, min(max_block_count, 10000))
        self.block_size = max(256, min(block_size_bytes, 65536))
        
        # Initialize blocks with metadata
        self.blocks = {}
        for i in range(self.max_blocks):
            self.blocks[i] = {
                'data': bytearray(self.block_size),
                'start_key': None,
                'end_key': None,
                'is_valid': False,
                'record_count': 0
            }

    def write_to_block(self, block_index: int, key: int, data: bytes) -> bool:
        if block_index < 0 or block_index >= self.max_blocks or not data:
            return False

        if len(data) > self.block_size:
            return False

        block = self.blocks[block_index]

        # Safe boundary validation
        if not block['is_valid']:
            block['start_key'] = key
            block['end_key'] = key
        else:
            # Validate key range
            if key < block['start_key'] or key > block['end_key'] + 1:
                return False

        # Safe data copy with size validation
        data_length = min(len(data), self.block_size)
        block['data'][:data_length] = data[:data_length]
        
        # Clear remaining bytes
        if data_length < self.block_size:
            block['data'][data_length:] = b'\x00' * (self.block_size - data_length)

        block['end_key'] = max(block['end_key'] if block['end_key'] is not None else key, key)
        block['is_valid'] = True
        block['record_count'] += 1
        return True

    def read_from_block(self, block_index: int, key: int) -> Optional[bytes]:
        if block_index < 0 or block_index >= self.max_blocks:
            return None

        block = self.blocks[block_index]
        if not block['is_valid']:
            return None

        # Validate key is within block range
        if (block['start_key'] is None or block['end_key'] is None or 
            key < block['start_key'] or key > block['end_key']):
            return None

        # Return safe copy of data
        return bytes(block['data'])

    def find_block_for_key(self, key: int) -> int:
        for i in range(self.max_blocks):
            block = self.blocks[i]
            if (block['is_valid'] and 
                block['start_key'] is not None and 
                block['end_key'] is not None and
                block['start_key'] <= key <= block['end_key']):
                return i
        return -1

    def get_block_info(self, block_index: int) -> Optional[Dict]:
        if 0 <= block_index < self.max_blocks:
            block = self.blocks[block_index]
            return {
                'is_valid': block['is_valid'],
                'start_key': block['start_key'],
                'end_key': block['end_key'],
                'record_count': block['record_count']
            }
        return None
```
### ğŸ§ª Senaryo 6: Bir veritabanÄ± motorunda dizinleme iÅŸlemleri sÄ±rasÄ±nda kayÄ±tlar bellekte bloklar halinde tutuluyor. Arama sÄ±rasÄ±nda kullanÄ±cÄ± girdisiyle bu bloklara eriÅŸim yapÄ±lÄ±yor. Sistem gelen deÄŸerin blok aralÄ±ÄŸÄ±nda olup olmadÄ±ÄŸÄ±nÄ± deÄŸerlendiriyor. Okuma ve yazma sÄ±rasÄ±nda blok sÄ±nÄ±rlarÄ± kontrol ediliyor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 124
```typescript
interface DataBlock {
    data: Uint8Array;
    startKey: number | null;
    endKey: number | null;
    isValid: boolean;
    recordCount: number;
}

interface BlockInfo {
    isValid: boolean;
    startKey: number | null;
    endKey: number | null;
    recordCount: number;
}

class DatabaseIndexManager {
    private blocks: Map<number, DataBlock>;
    private readonly maxBlocks: number;
    private readonly blockSize: number;

    constructor(maxBlockCount: number = 1000, blockSizeBytes: number = 4096) {
        this.maxBlocks = Math.max(1, Math.min(maxBlockCount, 10000));
        this.blockSize = Math.max(256, Math.min(blockSizeBytes, 65536));
        this.blocks = new Map();

        // Initialize blocks
        for (let i = 0; i < this.maxBlocks; i++) {
            this.blocks.set(i, {
                data: new Uint8Array(this.blockSize),
                startKey: null,
                endKey: null,
                isValid: false,
                recordCount: 0
            });
        }
    }

    writeToBlock(blockIndex: number, key: number, data: Uint8Array): boolean {
        if (blockIndex < 0 || blockIndex >= this.maxBlocks || !data) {
            return false;
        }

        if (data.length > this.blockSize) {
            return false;
        }

        const block = this.blocks.get(blockIndex);
        if (!block) return false;

        // Safe boundary validation
        if (!block.isValid) {
            block.startKey = key;
            block.endKey = key;
        } else {
            // Validate key range
            if (block.startKey !== null && block.endKey !== null) {
                if (key < block.startKey || key > block.endKey + 1) {
                    return false;
                }
            }
        }

        // Safe data copy with size validation
        const dataLength = Math.min(data.length, this.blockSize);
        block.data.set(data.subarray(0, dataLength), 0);
        
        // Clear remaining bytes
        if (dataLength < this.blockSize) {
            block.data.fill(0, dataLength);
        }

        block.endKey = Math.max(block.endKey ?? key, key);
        block.isValid = true;
        block.recordCount++;
        return true;
    }

    readFromBlock(blockIndex: number, key: number): Uint8Array | null {
        if (blockIndex < 0 || blockIndex >= this.maxBlocks) {
            return null;
        }

        const block = this.blocks.get(blockIndex);
        if (!block || !block.isValid) {
            return null;
        }

        // Validate key is within block range
        if (block.startKey === null || block.endKey === null || 
            key < block.startKey || key > block.endKey) {
            return null;
        }

        // Return safe copy of data
        return new Uint8Array(block.data);
    }

    findBlockForKey(key: number): number {
        for (let i = 0; i < this.maxBlocks; i++) {
            const block = this.blocks.get(i);
            if (block && block.isValid && 
                block.startKey !== null && block.endKey !== null &&
                key >= block.startKey && key <= block.endKey) {
                return i;
            }
        }
        return -1;
    }

    getBlockInfo(blockIndex: number): BlockInfo | null {
        if (blockIndex >= 0 && blockIndex < this.maxBlocks) {
            const block = this.blocks.get(blockIndex);
            if (block) {
                return {
                    isValid: block.isValid,
                    startKey: block.startKey,
                    endKey: block.endKey,
                    recordCount: block.recordCount
                };
            }
        }
        return null;
    }
}
```
### ğŸ§ª Senaryo 7: Bir terminal uygulamasÄ±nda komut geÃ§miÅŸi sÄ±nÄ±rlÄ± sayÄ±da kayÄ±tla tutuluyor. KullanÄ±cÄ± daha fazla komut girdiÄŸinde eski kayÄ±tlar bellekte kaydÄ±rÄ±larak yenileri ekleniyor. Komutlar farklÄ± uzunlukta olabildiÄŸi iÃ§in buffer boyutu dinamik ayarlanÄ±yor. Sistem gelen komutun uzunluÄŸuna gÃ¶re alan oluÅŸturuyor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 72
```csharp
public class TerminalHistory
{
    private readonly Queue<string> history = new Queue<string>();
    private readonly int maxHistorySize;
    private readonly int maxCommandLength;

    public TerminalHistory(int maxSize = 1000, int maxCmdLength = 1024)
    {
        maxHistorySize = Math.Max(1, Math.Min(maxSize, 10000));
        maxCommandLength = Math.Max(1, Math.Min(maxCmdLength, 4096));
    }

    public bool AddCommand(string command)
    {
        if (string.IsNullOrWhiteSpace(command))
            return false;

        // Validate and sanitize command length
        string safeCommand = command.Length > maxCommandLength 
            ? command.Substring(0, maxCommandLength) 
            : command;

        // Remove oldest command if history is full
        while (history.Count >= maxHistorySize)
        {
            history.Dequeue();
        }

        // Add new command
        history.Enqueue(safeCommand.Trim());
        return true;
    }

    public string[] GetHistory()
    {
        return history.ToArray();
    }

    public string GetCommand(int index)
    {
        if (index < 0 || index >= history.Count)
            return string.Empty;

        string[] historyArray = history.ToArray();
        return historyArray[index];
    }

    public string GetLastCommand()
    {
        return history.Count > 0 ? history.Last() : string.Empty;
    }

    public string[] SearchHistory(string searchTerm)
    {
        if (string.IsNullOrWhiteSpace(searchTerm))
            return new string[0];

        // Safe search with length validation
        string safeTerm = searchTerm.Length > 100 ? searchTerm.Substring(0, 100) : searchTerm;
        
        return history.Where(cmd => cmd.Contains(safeTerm, StringComparison.OrdinalIgnoreCase))
                     .ToArray();
    }

    public void ClearHistory()
    {
        history.Clear();
    }

    public int GetHistoryCount() => history.Count;
    public int GetMaxHistorySize() => maxHistorySize;
}
```
### ğŸ§ª Senaryo 7: Bir terminal uygulamasÄ±nda komut geÃ§miÅŸi sÄ±nÄ±rlÄ± sayÄ±da kayÄ±tla tutuluyor. KullanÄ±cÄ± daha fazla komut girdiÄŸinde eski kayÄ±tlar bellekte kaydÄ±rÄ±larak yenileri ekleniyor. Komutlar farklÄ± uzunlukta olabildiÄŸi iÃ§in buffer boyutu dinamik ayarlanÄ±yor. Sistem gelen komutun uzunluÄŸuna gÃ¶re alan oluÅŸturuyor.

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 78
```python
from collections import deque
from typing import List, Optional
import re

class TerminalHistory:
    def __init__(self, max_size: int = 1000, max_cmd_length: int = 1024):
        self.max_history_size = max(1, min(max_size, 10000))
        self.max_command_length = max(1, min(max_cmd_length, 4096))
        # deque automatically handles size limiting
        self.history = deque(maxlen=self.max_history_size)

    def add_command(self, command: str) -> bool:
        if not command or not command.strip():
            return False

        # Validate and sanitize command length
        safe_command = command[:self.max_command_length] if len(command) > self.max_command_length else command
        
        # Clean command (remove control characters)
        cleaned_command = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', safe_command.strip())
        
        if not cleaned_command:
            return False

        # deque automatically removes oldest when maxlen is reached
        self.history.append(cleaned_command)
        return True

    def get_history(self) -> List[str]:
        return list(self.history)

    def get_command(self, index: int) -> str:
        if index < 0 or index >= len(self.history):
            return ""
        
        return self.history[index]

    def get_last_command(self) -> str:
        return self.history[-1] if self.history else ""

    def search_history(self, search_term: str) -> List[str]:
        if not search_term or not search_term.strip():
            return []

        # Safe search with length validation
        safe_term = search_term[:100] if len(search_term) > 100 else search_term
        safe_term = safe_term.strip().lower()
        
        return [cmd for cmd in self.history if safe_term in cmd.lower()]

    def get_recent_commands(self, count: int) -> List[str]:
        safe_count = max(0, min(count, len(self.history)))
        return list(self.history)[-safe_count:] if safe_count > 0 else []

    def clear_history(self):
        self.history.clear()

    def get_history_count(self) -> int:
        return len(self.history)

    def get_max_history_size(self) -> int:
        return self.max_history_size

    def remove_duplicates(self):
        """Remove consecutive duplicate commands"""
        if len(self.history) <= 1:
            return
            
        unique_history = []
        prev_cmd = None
        
        for cmd in self.history:
            if cmd != prev_cmd:
                unique_history.append(cmd)
                prev_cmd = cmd
        
        self.history.clear()
        self.history.extend(unique_history)
```
### ğŸ§ª Senaryo 7: Bir terminal uygulamasÄ±nda komut geÃ§miÅŸi sÄ±nÄ±rlÄ± sayÄ±da kayÄ±tla tutuluyor. KullanÄ±cÄ± daha fazla komut girdiÄŸinde eski kayÄ±tlar bellekte kaydÄ±rÄ±larak yenileri ekleniyor. Komutlar farklÄ± uzunlukta olabildiÄŸi iÃ§in buffer boyutu dinamik ayarlanÄ±yor. Sistem gelen komutun uzunluÄŸuna gÃ¶re alan oluÅŸturuyor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 100
```typescript
class TerminalHistory {
    private history: string[] = [];
    private readonly maxHistorySize: number;
    private readonly maxCommandLength: number;

    constructor(maxSize: number = 1000, maxCmdLength: number = 1024) {
        this.maxHistorySize = Math.max(1, Math.min(maxSize, 10000));
        this.maxCommandLength = Math.max(1, Math.min(maxCmdLength, 4096));
    }

    addCommand(command: string): boolean {
        if (!command || !command.trim()) {
            return false;
        }

        // Validate and sanitize command length
        const safeCommand = command.length > this.maxCommandLength 
            ? command.substring(0, this.maxCommandLength) 
            : command;

        // Clean command (remove control characters)
        const cleanedCommand = safeCommand.replace(/[\x00-\x1f\x7f-\x9f]/g, '').trim();
        
        if (!cleanedCommand) {
            return false;
        }

        // Remove oldest command if history is full
        while (this.history.length >= this.maxHistorySize) {
            this.history.shift();
        }

        // Add new command
        this.history.push(cleanedCommand);
        return true;
    }

    getHistory(): string[] {
        return [...this.history]; // Return safe copy
    }

    getCommand(index: number): string {
        if (index < 0 || index >= this.history.length) {
            return '';
        }
        
        return this.history[index];
    }

    getLastCommand(): string {
        return this.history.length > 0 ? this.history[this.history.length - 1] : '';
    }

    searchHistory(searchTerm: string): string[] {
        if (!searchTerm || !searchTerm.trim()) {
            return [];
        }

        // Safe search with length validation
        const safeTerm = searchTerm.length > 100 ? searchTerm.substring(0, 100) : searchTerm;
        const lowerSafeTerm = safeTerm.trim().toLowerCase();
        
        return this.history.filter(cmd => cmd.toLowerCase().includes(lowerSafeTerm));
    }

    getRecentCommands(count: number): string[] {
        const safeCount = Math.max(0, Math.min(count, this.history.length));
        return this.history.slice(-safeCount);
    }

    clearHistory(): void {
        this.history = [];
    }

    getHistoryCount(): number {
        return this.history.length;
    }

    getMaxHistorySize(): number {
        return this.maxHistorySize;
    }

    removeDuplicates(): void {
        if (this.history.length <= 1) {
            return;
        }
        
        const uniqueHistory: string[] = [];
        let prevCmd: string | null = null;
        
        for (const cmd of this.history) {
            if (cmd !== prevCmd) {
                uniqueHistory.push(cmd);
                prevCmd = cmd;
            }
        }
        
        this.history = uniqueHistory;
    }
}
```
### ğŸ§ª Senaryo 8: Bir gÃ¶rÃ¼ntÃ¼ iÅŸleme kÃ¼tÃ¼phanesi gelen kamera verilerini kare kare analiz ediyor. Her kare belleÄŸe tampon aracÄ±lÄ±ÄŸÄ±yla alÄ±nÄ±yor. Kamera Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ deÄŸiÅŸtiÄŸinde buffer boyutu bu duruma gÃ¶re ayarlanÄ±yor. Bu sayede bellek sÄ±nÄ±rlarÄ± iÃ§inde iÅŸlem yapÄ±lÄ±yor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 98
```csharp
public class CameraFrameProcessor
{
    private byte[] frameBuffer;
    private int currentWidth;
    private int currentHeight;
    private readonly int maxWidth = 4096;
    private readonly int maxHeight = 4096;
    private readonly int bytesPerPixel = 3; // RGB

    public CameraFrameProcessor()
    {
        // Initialize with default resolution
        ResizeBuffer(640, 480);
    }

    public bool SetResolution(int width, int height)
    {
        // Validate resolution bounds
        if (width <= 0 || height <= 0 || width > maxWidth || height > maxHeight)
            return false;

        return ResizeBuffer(width, height);
    }

    private bool ResizeBuffer(int width, int height)
    {
        try
        {
            int requiredSize = width * height * bytesPerPixel;
            
            // Prevent excessive memory allocation
            if (requiredSize > maxWidth * maxHeight * bytesPerPixel)
                return false;

            frameBuffer = new byte[requiredSize];
            currentWidth = width;
            currentHeight = height;
            return true;
        }
        catch (OutOfMemoryException)
        {
            return false;
        }
    }

    public bool ProcessFrame(byte[] cameraData)
    {
        if (cameraData == null || frameBuffer == null)
            return false;

        int expectedSize = currentWidth * currentHeight * bytesPerPixel;
        
        // Validate incoming data size
        if (cameraData.Length != expectedSize)
            return false;

        // Safe copy with size validation
        Array.Copy(cameraData, 0, frameBuffer, 0, Math.Min(cameraData.Length, frameBuffer.Length));
        
        return AnalyzeFrame();
    }

    private bool AnalyzeFrame()
    {
        if (frameBuffer == null)
            return false;

        // Safe frame analysis with bounds checking
        for (int y = 0; y < currentHeight; y++)
        {
            for (int x = 0; x < currentWidth; x++)
            {
                int pixelIndex = (y * currentWidth + x) * bytesPerPixel;
                
                // Bounds check before accessing
                if (pixelIndex + 2 < frameBuffer.Length)
                {
                    byte r = frameBuffer[pixelIndex];
                    byte g = frameBuffer[pixelIndex + 1];
                    byte b = frameBuffer[pixelIndex + 2];
                    
                    // Process pixel data safely
                    ProcessPixel(r, g, b, x, y);
                }
            }
        }
        
        return true;
    }

    private void ProcessPixel(byte r, byte g, byte b, int x, int y)
    {
        // Safe pixel processing logic
    }

    public (int width, int height) GetCurrentResolution() => (currentWidth, currentHeight);
    public int GetBufferSize() => frameBuffer?.Length ?? 0;
}
```
### ğŸ§ª Senaryo 8: Bir gÃ¶rÃ¼ntÃ¼ iÅŸleme kÃ¼tÃ¼phanesi gelen kamera verilerini kare kare analiz ediyor. Her kare belleÄŸe tampon aracÄ±lÄ±ÄŸÄ±yla alÄ±nÄ±yor. Kamera Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ deÄŸiÅŸtiÄŸinde buffer boyutu bu duruma gÃ¶re ayarlanÄ±yor. Bu sayede bellek sÄ±nÄ±rlarÄ± iÃ§inde iÅŸlem yapÄ±lÄ±yor.

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 101
```python
import numpy as np
from typing import Tuple, Optional

class CameraFrameProcessor:
    def __init__(self):
        self.frame_buffer: Optional[np.ndarray] = None
        self.current_width = 0
        self.current_height = 0
        self.max_width = 4096
        self.max_height = 4096
        self.bytes_per_pixel = 3  # RGB
        
        # Initialize with default resolution
        self.set_resolution(640, 480)

    def set_resolution(self, width: int, height: int) -> bool:
        # Validate resolution bounds
        if width <= 0 or height <= 0 or width > self.max_width or height > self.max_height:
            return False

        return self._resize_buffer(width, height)

    def _resize_buffer(self, width: int, height: int) -> bool:
        try:
            required_size = width * height * self.bytes_per_pixel
            
            # Prevent excessive memory allocation
            max_size = self.max_width * self.max_height * self.bytes_per_pixel
            if required_size > max_size:
                return False

            # Create new buffer with safe dimensions
            self.frame_buffer = np.zeros((height, width, self.bytes_per_pixel), dtype=np.uint8)
            self.current_width = width
            self.current_height = height
            return True
            
        except MemoryError:
            return False

    def process_frame(self, camera_data: np.ndarray) -> bool:
        if camera_data is None or self.frame_buffer is None:
            return False

        # Validate incoming data shape and type
        if not isinstance(camera_data, np.ndarray) or camera_data.dtype != np.uint8:
            return False

        expected_shape = (self.current_height, self.current_width, self.bytes_per_pixel)
        
        # Handle different input formats safely
        if camera_data.shape != expected_shape:
            # Try to reshape if sizes match
            if camera_data.size == np.prod(expected_shape):
                try:
                    camera_data = camera_data.reshape(expected_shape)
                except ValueError:
                    return False
            else:
                return False

        # Safe copy with shape validation
        self.frame_buffer[:] = camera_data
        
        return self._analyze_frame()

    def _analyze_frame(self) -> bool:
        if self.frame_buffer is None:
            return False

        try:
            # Safe frame analysis with numpy operations
            height, width, channels = self.frame_buffer.shape
            
            # Process each pixel safely using vectorized operations
            for y in range(height):
                for x in range(width):
                    if (y < self.frame_buffer.shape[0] and 
                        x < self.frame_buffer.shape[1]):
                        
                        pixel = self.frame_buffer[y, x]
                        r, g, b = pixel[0], pixel[1], pixel[2]
                        self._process_pixel(r, g, b, x, y)
            
            return True
            
        except (IndexError, ValueError):
            return False

    def _process_pixel(self, r: int, g: int, b: int, x: int, y: int):
        # Safe pixel processing logic
        pass

    def get_current_resolution(self) -> Tuple[int, int]:
        return (self.current_width, self.current_height)

    def get_buffer_size(self) -> int:
        return self.frame_buffer.size if self.frame_buffer is not None else 0

    def get_frame_copy(self) -> Optional[np.ndarray]:
        return self.frame_buffer.copy() if self.frame_buffer is not None else None
```
### ğŸ§ª Senaryo 8: Bir gÃ¶rÃ¼ntÃ¼ iÅŸleme kÃ¼tÃ¼phanesi gelen kamera verilerini kare kare analiz ediyor. Her kare belleÄŸe tampon aracÄ±lÄ±ÄŸÄ±yla alÄ±nÄ±yor. Kamera Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ deÄŸiÅŸtiÄŸinde buffer boyutu bu duruma gÃ¶re ayarlanÄ±yor. Bu sayede bellek sÄ±nÄ±rlarÄ± iÃ§inde iÅŸlem yapÄ±lÄ±yor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 112
```typescript
class CameraFrameProcessor {
    private frameBuffer: Uint8Array | null = null;
    private currentWidth: number = 0;
    private currentHeight: number = 0;
    private readonly maxWidth = 4096;
    private readonly maxHeight = 4096;
    private readonly bytesPerPixel = 3; // RGB

    constructor() {
        // Initialize with default resolution
        this.setResolution(640, 480);
    }

    setResolution(width: number, height: number): boolean {
        // Validate resolution bounds
        if (width <= 0 || height <= 0 || width > this.maxWidth || height > this.maxHeight) {
            return false;
        }

        return this.resizeBuffer(width, height);
    }

    private resizeBuffer(width: number, height: number): boolean {
        try {
            const requiredSize = width * height * this.bytesPerPixel;
            
            // Prevent excessive memory allocation
            const maxSize = this.maxWidth * this.maxHeight * this.bytesPerPixel;
            if (requiredSize > maxSize) {
                return false;
            }

            this.frameBuffer = new Uint8Array(requiredSize);
            this.currentWidth = width;
            this.currentHeight = height;
            return true;
            
        } catch (error) {
            return false;
        }
    }

    processFrame(cameraData: Uint8Array): boolean {
        if (!cameraData || !this.frameBuffer) {
            return false;
        }

        const expectedSize = this.currentWidth * this.currentHeight * this.bytesPerPixel;
        
        // Validate incoming data size
        if (cameraData.length !== expectedSize) {
            return false;
        }

        // Safe copy with size validation
        const copyLength = Math.min(cameraData.length, this.frameBuffer.length);
        this.frameBuffer.set(cameraData.subarray(0, copyLength), 0);
        
        return this.analyzeFrame();
    }

    private analyzeFrame(): boolean {
        if (!this.frameBuffer) {
            return false;
        }

        try {
            // Safe frame analysis with bounds checking
            for (let y = 0; y < this.currentHeight; y++) {
                for (let x = 0; x < this.currentWidth; x++) {
                    const pixelIndex = (y * this.currentWidth + x) * this.bytesPerPixel;
                    
                    // Bounds check before accessing
                    if (pixelIndex + 2 < this.frameBuffer.length) {
                        const r = this.frameBuffer[pixelIndex];
                        const g = this.frameBuffer[pixelIndex + 1];
                        const b = this.frameBuffer[pixelIndex + 2];
                        
                        // Process pixel data safely
                        this.processPixel(r, g, b, x, y);
                    }
                }
            }
            
            return true;
        } catch (error) {
            return false;
        }
    }

    private processPixel(r: number, g: number, b: number, x: number, y: number): void {
        // Safe pixel processing logic
    }

    getCurrentResolution(): { width: number; height: number } {
        return { width: this.currentWidth, height: this.currentHeight };
    }

    getBufferSize(): number {
        return this.frameBuffer ? this.frameBuffer.length : 0;
    }

    getFrameCopy(): Uint8Array | null {
        return this.frameBuffer ? new Uint8Array(this.frameBuffer) : null;
    }

    clearBuffer(): void {
        if (this.frameBuffer) {
            this.frameBuffer.fill(0);
        }
    }
}
```
### ğŸ§ª Senaryo 9: Bir hesaplama aracÄ± kullanÄ±cÄ±dan alÄ±nan sayÄ± dizisini bir diziye aktarÄ±yor ve iÅŸlem yapÄ±yor. KullanÄ±cÄ±nÄ±n girdiÄŸi eleman sayÄ±sÄ± sistemdeki diziden farklÄ± olabiliyor. Sistem bu sayÄ±yÄ± deÄŸerlendirerek dizi boyutunu ayarlÄ±yor. Bu ÅŸekilde bellekte uygun bÃ¶lgelere eriÅŸim saÄŸlanÄ±yor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 108
```csharp
public class MathCalculator
{
    private double[] numbers;
    private readonly int maxArraySize;

    public MathCalculator(int maxSize = 10000)
    {
        maxArraySize = Math.Max(1, Math.Min(maxSize, 100000));
        numbers = new double[0];
    }

    public bool SetNumbers(double[] inputNumbers, int declaredCount)
    {
        if (inputNumbers == null || declaredCount < 0 || declaredCount > maxArraySize)
            return false;

        // Validate declared count against actual array size
        int actualCount = Math.Min(inputNumbers.Length, declaredCount);
        if (actualCount != declaredCount && declaredCount <= inputNumbers.Length)
            actualCount = declaredCount;

        // Validate for NaN and infinity values
        for (int i = 0; i < actualCount; i++)
        {
            if (double.IsNaN(inputNumbers[i]) || double.IsInfinity(inputNumbers[i]))
                return false;
        }

        // Safe array allocation and copy
        numbers = new double[actualCount];
        Array.Copy(inputNumbers, 0, numbers, 0, actualCount);
        
        return true;
    }

    public double Calculate(string operation)
    {
        if (numbers == null || numbers.Length == 0)
            return 0.0;

        switch (operation?.ToLower())
        {
            case "sum":
                return CalculateSum();
            case "average":
                return CalculateAverage();
            case "max":
                return CalculateMax();
            case "min":
                return CalculateMin();
            default:
                return 0.0;
        }
    }

    private double CalculateSum()
    {
        double sum = 0.0;
        for (int i = 0; i < numbers.Length; i++)
        {
            // Check for overflow
            if (double.IsInfinity(sum + numbers[i]))
                return double.MaxValue;
            sum += numbers[i];
        }
        return sum;
    }

    private double CalculateAverage()
    {
        if (numbers.Length == 0)
            return 0.0;
        
        double sum = CalculateSum();
        return sum / numbers.Length;
    }

    private double CalculateMax()
    {
        if (numbers.Length == 0)
            return 0.0;
        
        double max = numbers[0];
        for (int i = 1; i < numbers.Length; i++)
        {
            if (numbers[i] > max)
                max = numbers[i];
        }
        return max;
    }

    private double CalculateMin()
    {
        if (numbers.Length == 0)
            return 0.0;
        
        double min = numbers[0];
        for (int i = 1; i < numbers.Length; i++)
        {
            if (numbers[i] < min)
                min = numbers[i];
        }
        return min;
    }

    public int GetArraySize() => numbers?.Length ?? 0;
    public double[] GetNumbers() => (double[])numbers?.Clone();
}
```
### ğŸ§ª Senaryo 9: Bir hesaplama aracÄ± kullanÄ±cÄ±dan alÄ±nan sayÄ± dizisini bir diziye aktarÄ±yor ve iÅŸlem yapÄ±yor. KullanÄ±cÄ±nÄ±n girdiÄŸi eleman sayÄ±sÄ± sistemdeki diziden farklÄ± olabiliyor. Sistem bu sayÄ±yÄ± deÄŸerlendirerek dizi boyutunu ayarlÄ±yor. Bu ÅŸekilde bellekte uygun bÃ¶lgelere eriÅŸim saÄŸlanÄ±yor.

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 105
```python
import math
from typing import List, Optional, Union
import numpy as np

class MathCalculator:
    def __init__(self, max_size: int = 10000):
        self.max_array_size = max(1, min(max_size, 100000))
        self.numbers: np.ndarray = np.array([])

    def set_numbers(self, input_numbers: List[float], declared_count: int) -> bool:
        if not input_numbers or declared_count < 0 or declared_count > self.max_array_size:
            return False

        # Validate declared count against actual array size
        actual_count = min(len(input_numbers), declared_count)
        if actual_count != declared_count and declared_count <= len(input_numbers):
            actual_count = declared_count

        # Convert to numpy array for safe processing
        try:
            temp_array = np.array(input_numbers[:actual_count], dtype=np.float64)
        except (ValueError, OverflowError):
            return False

        # Validate for NaN and infinity values
        if np.any(np.isnan(temp_array)) or np.any(np.isinf(temp_array)):
            return False

        # Safe array assignment
        self.numbers = temp_array.copy()
        return True

    def calculate(self, operation: str) -> float:
        if self.numbers.size == 0:
            return 0.0

        operation = operation.lower().strip() if operation else ""
        
        try:
            if operation == "sum":
                return self._calculate_sum()
            elif operation == "average":
                return self._calculate_average()
            elif operation == "max":
                return self._calculate_max()
            elif operation == "min":
                return self._calculate_min()
            elif operation == "median":
                return self._calculate_median()
            elif operation == "std":
                return self._calculate_std()
            else:
                return 0.0
        except (OverflowError, ValueError):
            return 0.0

    def _calculate_sum(self) -> float:
        # Use numpy's safe sum with overflow checking
        result = np.sum(self.numbers)
        return float(result) if not np.isinf(result) else float('inf')

    def _calculate_average(self) -> float:
        if self.numbers.size == 0:
            return 0.0
        return float(np.mean(self.numbers))

    def _calculate_max(self) -> float:
        if self.numbers.size == 0:
            return 0.0
        return float(np.max(self.numbers))

    def _calculate_min(self) -> float:
        if self.numbers.size == 0:
            return 0.0
        return float(np.min(self.numbers))

    def _calculate_median(self) -> float:
        if self.numbers.size == 0:
            return 0.0
        return float(np.median(self.numbers))

    def _calculate_std(self) -> float:
        if self.numbers.size <= 1:
            return 0.0
        return float(np.std(self.numbers))

    def get_array_size(self) -> int:
        return self.numbers.size

    def get_numbers(self) -> List[float]:
        return self.numbers.tolist() if self.numbers.size > 0 else []

    def get_statistics(self) -> dict:
        if self.numbers.size == 0:
            return {}
        
        return {
            'count': self.numbers.size,
            'sum': self._calculate_sum(),
            'mean': self._calculate_average(),
            'min': self._calculate_min(),
            'max': self._calculate_max(),
            'median': self._calculate_median(),
            'std': self._calculate_std()
        }
```
### ğŸ§ª Senaryo 9: Bir hesaplama aracÄ± kullanÄ±cÄ±dan alÄ±nan sayÄ± dizisini bir diziye aktarÄ±yor ve iÅŸlem yapÄ±yor. KullanÄ±cÄ±nÄ±n girdiÄŸi eleman sayÄ±sÄ± sistemdeki diziden farklÄ± olabiliyor. Sistem bu sayÄ±yÄ± deÄŸerlendirerek dizi boyutunu ayarlÄ±yor. Bu ÅŸekilde bellekte uygun bÃ¶lgelere eriÅŸim saÄŸlanÄ±yor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 147
```typescript
class MathCalculator {
    private numbers: number[] = [];
    private readonly maxArraySize: number;

    constructor(maxSize: number = 10000) {
        this.maxArraySize = Math.max(1, Math.min(maxSize, 100000));
    }

    setNumbers(inputNumbers: number[], declaredCount: number): boolean {
        if (!inputNumbers || declaredCount < 0 || declaredCount > this.maxArraySize) {
            return false;
        }

        // Validate declared count against actual array size
        let actualCount = Math.min(inputNumbers.length, declaredCount);
        if (actualCount !== declaredCount && declaredCount <= inputNumbers.length) {
            actualCount = declaredCount;
        }

        // Validate for NaN and infinity values
        for (let i = 0; i < actualCount; i++) {
            if (!isFinite(inputNumbers[i])) {
                return false;
            }
        }

        // Safe array allocation and copy
        this.numbers = inputNumbers.slice(0, actualCount);
        return true;
    }

    calculate(operation: string): number {
        if (!this.numbers || this.numbers.length === 0) {
            return 0.0;
        }

        const op = operation?.toLowerCase().trim() || "";
        
        try {
            switch (op) {
                case "sum":
                    return this.calculateSum();
                case "average":
                    return this.calculateAverage();
                case "max":
                    return this.calculateMax();
                case "min":
                    return this.calculateMin();
                case "median":
                    return this.calculateMedian();
                case "std":
                    return this.calculateStd();
                default:
                    return 0.0;
            }
        } catch (error) {
            return 0.0;
        }
    }

    private calculateSum(): number {
        let sum = 0.0;
        for (let i = 0; i < this.numbers.length; i++) {
            // Check for overflow
            const newSum = sum + this.numbers[i];
            if (!isFinite(newSum)) {
                return Number.MAX_VALUE;
            }
            sum = newSum;
        }
        return sum;
    }

    private calculateAverage(): number {
        if (this.numbers.length === 0) {
            return 0.0;
        }
        
        const sum = this.calculateSum();
        return sum / this.numbers.length;
    }

    private calculateMax(): number {
        if (this.numbers.length === 0) {
            return 0.0;
        }
        
        return Math.max(...this.numbers);
    }

    private calculateMin(): number {
        if (this.numbers.length === 0) {
            return 0.0;
        }
        
        return Math.min(...this.numbers);
    }

    private calculateMedian(): number {
        if (this.numbers.length === 0) {
            return 0.0;
        }
        
        const sorted = [...this.numbers].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        
        return sorted.length % 2 === 0
            ? (sorted[mid - 1] + sorted[mid]) / 2
            : sorted[mid];
    }

    private calculateStd(): number {
        if (this.numbers.length <= 1) {
            return 0.0;
        }
        
        const mean = this.calculateAverage();
        const squaredDiffs = this.numbers.map(x => Math.pow(x - mean, 2));
        const avgSquaredDiff = squaredDiffs.reduce((a, b) => a + b, 0) / this.numbers.length;
        
        return Math.sqrt(avgSquaredDiff);
    }

    getArraySize(): number {
        return this.numbers.length;
    }

    getNumbers(): number[] {
        return [...this.numbers]; // Return safe copy
    }

    getStatistics(): Record<string, number> {
        if (this.numbers.length === 0) {
            return {};
        }
        
        return {
            count: this.numbers.length,
            sum: this.calculateSum(),
            mean: this.calculateAverage(),
            min: this.calculateMin(),
            max: this.calculateMax(),
            median: this.calculateMedian(),
            std: this.calculateStd()
        };
    }
}
```
### ğŸ§ª Senaryo 10: Bir video oynatÄ±cÄ± yazÄ±lÄ±mÄ± oynatma sÄ±rasÄ±nda ses ve video karelerini farklÄ± tamponlara alÄ±yor. Video Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ bÃ¼yÃ¼dÃ¼kÃ§e tampon alan gereksinimleri artÄ±yor. Sistem Ã§Ã¶zÃ¼nÃ¼rlÃ¼k deÄŸiÅŸimini belleÄŸe yansÄ±tÄ±yor. Bu durum tampon boyutu sorunlarÄ±nÄ± Ã¶nleyecek ÅŸekilde yÃ¶netiliyor.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 112
```csharp
public class VideoPlayer
{
    private byte[] videoBuffer;
    private float[] audioBuffer;
    private int videoWidth, videoHeight;
    private readonly int maxVideoWidth = 4096;
    private readonly int maxVideoHeight = 4096;
    private readonly int maxAudioSamples = 48000;
    private readonly int bytesPerPixel = 4; // RGBA

    public VideoPlayer()
    {
        InitializeBuffers(1920, 1080); // Default HD resolution
    }

    public bool SetResolution(int width, int height)
    {
        // Validate resolution bounds
        if (width <= 0 || height <= 0 || width > maxVideoWidth || height > maxVideoHeight)
            return false;

        return InitializeBuffers(width, height);
    }

    private bool InitializeBuffers(int width, int height)
    {
        try
        {
            long videoBufferSize = (long)width * height * bytesPerPixel;
            
            // Prevent excessive memory allocation
            if (videoBufferSize > int.MaxValue || videoBufferSize > maxVideoWidth * maxVideoHeight * bytesPerPixel)
                return false;

            videoBuffer = new byte[videoBufferSize];
            audioBuffer = new float[maxAudioSamples];
            videoWidth = width;
            videoHeight = height;
            
            return true;
        }
        catch (OutOfMemoryException)
        {
            return false;
        }
    }

    public bool LoadVideoFrame(byte[] frameData)
    {
        if (frameData == null || videoBuffer == null)
            return false;

        int expectedSize = videoWidth * videoHeight * bytesPerPixel;
        
        // Validate frame data size
        if (frameData.Length != expectedSize)
            return false;

        // Safe copy with size validation
        Array.Copy(frameData, 0, videoBuffer, 0, Math.Min(frameData.Length, videoBuffer.Length));
        return true;
    }

    public bool LoadAudioSamples(float[] audioData, int sampleCount)
    {
        if (audioData == null || audioBuffer == null || sampleCount < 0)
            return false;

        // Validate sample count
        int safeSampleCount = Math.Min(sampleCount, Math.Min(audioData.Length, audioBuffer.Length));
        
        // Validate audio data
        for (int i = 0; i < safeSampleCount; i++)
        {
            if (float.IsNaN(audioData[i]) || float.IsInfinity(audioData[i]))
                return false;
        }

        // Clear buffer first
        Array.Clear(audioBuffer, 0, audioBuffer.Length);
        
        // Safe copy with validated count
        Array.Copy(audioData, 0, audioBuffer, 0, safeSampleCount);
        return true;
    }

    public byte[] GetVideoFrame()
    {
        if (videoBuffer == null)
            return null;

        // Return safe copy
        byte[] frameCopy = new byte[videoBuffer.Length];
        Array.Copy(videoBuffer, 0, frameCopy, 0, videoBuffer.Length);
        return frameCopy;
    }

    public float[] GetAudioSamples(int requestedSamples)
    {
        if (audioBuffer == null || requestedSamples <= 0)
            return null;

        int safeSampleCount = Math.Min(requestedSamples, audioBuffer.Length);
        float[] audioSamples = new float[safeSampleCount];
        Array.Copy(audioBuffer, 0, audioSamples, 0, safeSampleCount);
        return audioSamples;
    }

    public (int width, int height) GetResolution() => (videoWidth, videoHeight);
    public int GetVideoBufferSize() => videoBuffer?.Length ?? 0;
    public int GetAudioBufferSize() => audioBuffer?.Length ?? 0;
}
```

ğŸ§ª Senaryo 10: Bir video oynatÄ±cÄ± yazÄ±lÄ±mÄ± oynatma sÄ±rasÄ±nda ses ve video karelerini farklÄ± tamponlara alÄ±yor. Video Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ bÃ¼yÃ¼dÃ¼kÃ§e tampon alan gereksinimleri artÄ±yor. Sistem Ã§Ã¶zÃ¼nÃ¼rlÃ¼k deÄŸiÅŸimini belleÄŸe yansÄ±tÄ±yor. Bu durum tampon boyutu sorunlarÄ±nÄ± Ã¶nleyecek ÅŸekilde yÃ¶netiliyor.
ğŸ’» Dil: Python
ğŸ¤– AI: Claude

**SatÄ±r SayÄ±sÄ±:** 118
```python
pythonimport numpy as np
from typing import Optional, Tuple

class VideoPlayer:
    def __init__(self):
        self.video_buffer: Optional[np.ndarray] = None
        self.audio_buffer: Optional[np.ndarray] = None
        self.video_width = 0
        self.video_height = 0
        self.max_video_width = 4096
        self.max_video_height = 4096
        self.max_audio_samples = 48000
        self.bytes_per_pixel = 4  # RGBA
        
        # Initialize with default HD resolution
        self.set_resolution(1920, 1080)

    def set_resolution(self, width: int, height: int) -> bool:
        # Validate resolution bounds
        if width <= 0 or height <= 0 or width > self.max_video_width or height > self.max_video_height:
            return False

        return self._initialize_buffers(width, height)

    def _initialize_buffers(self, width: int, height: int) -> bool:
        try:
            video_buffer_size = width * height * self.bytes_per_pixel
            
            # Prevent excessive memory allocation
            max_size = self.max_video_width * self.max_video_height * self.bytes_per_pixel
            if video_buffer_size > max_size:
                return False

            self.video_buffer = np.zeros((height, width, self.bytes_per_pixel), dtype=np.uint8)
            self.audio_buffer = np.zeros(self.max_audio_samples, dtype=np.float32)
            self.video_width = width
            self.video_height = height
            
            return True
            
        except MemoryError:
            return False

    def load_video_frame(self, frame_data: np.ndarray) -> bool:
        if frame_data is None or self.video_buffer is None:
            return False

        expected_shape = (self.video_height, self.video_width, self.bytes_per_pixel)
        
        # Validate frame data shape and type
        if not isinstance(frame_data, np.ndarray) or frame_data.dtype != np.uint8:
            return False

        # Handle different input formats safely
        if frame_data.shape != expected_shape:
            # Try to reshape if sizes match
            if frame_data.size == np.prod(expected_shape):
                try:
                    frame_data = frame_data.reshape(expected_shape)
                except ValueError:
                    return False
            else:
                return False

        # Safe copy with shape validation
        self.video_buffer[:] = frame_data
        return True

    def load_audio_samples(self, audio_data: np.ndarray, sample_count: int) -> bool:
        if audio_data is None or self.audio_buffer is None or sample_count < 0:
            return False

        # Validate sample count and audio data
        safe_sample_count = min(sample_count, min(len(audio_data), len(self.audio_buffer)))
        
        if not isinstance(audio_data, np.ndarray):
            return False

        # Validate audio data for NaN and infinity
        audio_slice = audio_data[:safe_sample_count]
        if np.any(np.isnan(audio_slice)) or np.any(np.isinf(audio_slice)):
            return False

        # Clear buffer first
        self.audio_buffer.fill(0)
        
        # Safe copy with validated count
        self.audio_buffer[:safe_sample_count] = audio_slice.astype(np.float32)
        return True

    def get_video_frame(self) -> Optional[np.ndarray]:
        if self.video_buffer is None:
            return None
        
        # Return safe copy
        return self.video_buffer.copy()

    def get_audio_samples(self, requested_samples: int) -> Optional[np.ndarray]:
        if self.audio_buffer is None or requested_samples <= 0:
            return None

        safe_sample_count = min(requested_samples, len(self.audio_buffer))
        return self.audio_buffer[:safe_sample_count].copy()

    def get_resolution(self) -> Tuple[int, int]:
        return (self.video_width, self.video_height)

    def get_video_buffer_size(self) -> int:
        return self.video_buffer.size if self.video_buffer is not None else 0

    def get_audio_buffer_size(self) -> int:
        return self.audio_buffer.size if self.audio_buffer is not None else 0

    def clear_buffers(self):
        if self.video_buffer is not None:
            self.video_buffer.fill(0)
        if self.audio_buffer is not None:
            self.audio_buffer.fill(0)
```
---

### ğŸ§ª Senaryo 10: Bir video oynatÄ±cÄ± yazÄ±lÄ±mÄ± oynatma sÄ±rasÄ±nda ses ve video karelerini farklÄ± tamponlara alÄ±yor. Video Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ bÃ¼yÃ¼dÃ¼kÃ§e tampon alan gereksinimleri artÄ±yor. Sistem Ã§Ã¶zÃ¼nÃ¼rlÃ¼k deÄŸiÅŸimini belleÄŸe yansÄ±tÄ±yor. Bu durum tampon boyutu sorunlarÄ±nÄ± Ã¶nleyecek ÅŸekilde yÃ¶netiliyor.

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 137
```typescript
class VideoPlayer {
    private videoBuffer: Uint8Array | null = null;
    private audioBuffer: Float32Array | null = null;
    private videoWidth: number = 0;
    private videoHeight: number = 0;
    private readonly maxVideoWidth = 4096;
    private readonly maxVideoHeight = 4096;
    private readonly maxAudioSamples = 48000;
    private readonly bytesPerPixel = 4; // RGBA

    constructor() {
        // Initialize with default HD resolution
        this.setResolution(1920, 1080);
    }

    setResolution(width: number, height: number): boolean {
        // Validate resolution bounds
        if (width <= 0 || height <= 0 || width > this.maxVideoWidth || height > this.maxVideoHeight) {
            return false;
        }

        return this.initializeBuffers(width, height);
    }

    private initializeBuffers(width: number, height: number): boolean {
        try {
            const videoBufferSize = width * height * this.bytesPerPixel;
            
            // Prevent excessive memory allocation
            const maxSize = this.maxVideoWidth * this.maxVideoHeight * this.bytesPerPixel;
            if (videoBufferSize > maxSize) {
                return false;
            }

            this.videoBuffer = new Uint8Array(videoBufferSize);
            this.audioBuffer = new Float32Array(this.maxAudioSamples);
            this.videoWidth = width;
            this.videoHeight = height;
            
            return true;
            
        } catch (error) {
            return false;
        }
    }

    loadVideoFrame(frameData: Uint8Array): boolean {
        if (!frameData || !this.videoBuffer) {
            return false;
        }

        const expectedSize = this.videoWidth * this.videoHeight * this.bytesPerPixel;
        
        // Validate frame data size
        if (frameData.length !== expectedSize) {
            return false;
        }

        // Safe copy with size validation
        const copyLength = Math.min(frameData.length, this.videoBuffer.length);
        this.videoBuffer.set(frameData.subarray(0, copyLength), 0);
        return true;
    }

    loadAudioSamples(audioData: Float32Array, sampleCount: number): boolean {
        if (!audioData || !this.audioBuffer || sampleCount < 0) {
            return false;
        }

        // Validate sample count
        const safeSampleCount = Math.min(sampleCount, Math.min(audioData.length, this.audioBuffer.length));
        
        // Validate audio data
        for (let i = 0; i < safeSampleCount; i++) {
            if (!isFinite(audioData[i])) {
                return false;
            }
        }

        // Clear buffer first
        this.audioBuffer.fill(0);
        
        // Safe copy with validated count
        this.audioBuffer.set(audioData.subarray(0, safeSampleCount), 0);
        return true;
    }

    getVideoFrame(): Uint8Array | null {
        if (!this.videoBuffer) {
            return null;
        }

        // Return safe copy
        return new Uint8Array(this.videoBuffer);
    }

    getAudioSamples(requestedSamples: number): Float32Array | null {
        if (!this.audioBuffer || requestedSamples <= 0) {
            return null;
        }

        const safeSampleCount = Math.min(requestedSamples, this.audioBuffer.length);
        return new Float32Array(this.audioBuffer.subarray(0, safeSampleCount));
    }

    getResolution(): { width: number; height: number } {
        return { width: this.videoWidth, height: this.videoHeight };
    }

    getVideoBufferSize(): number {
        return this.videoBuffer ? this.videoBuffer.length : 0;
    }

    getAudioBufferSize(): number {
        return this.audioBuffer ? this.audioBuffer.length : 0;
    }

    clearBuffers(): void {
        if (this.videoBuffer) {
            this.videoBuffer.fill(0);
        }
        if (this.audioBuffer) {
            this.audioBuffer.fill(0);
        }
    }

    getMemoryUsage(): { video: number; audio: number; total: number } {
        const videoMemory = this.videoBuffer ? this.videoBuffer.length : 0;
        const audioMemory = this.audioBuffer ? this.audioBuffer.length * 4 : 0; // 4 bytes per float
        
        return {
            video: videoMemory,
            audio: audioMemory,
            total: videoMemory + audioMemory
        };
    }
}
```