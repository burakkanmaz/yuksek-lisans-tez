### ðŸ§ª Senaryo 1: Bir web uygulamasÄ±nda kullanÄ±cÄ± oturum bilgileri cookie formatÄ±nda saklanÄ±r

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 37
```csharp
[HttpPost("login")]
public IActionResult Login(LoginModel model)
{
    var sessionData = new UserSession
    {
        UserId = user.Id,
        Username = user.Username,
        LoginTime = DateTime.UtcNow,
        Roles = user.Roles
    };

    var serializedData = JsonSerializer.Serialize(sessionData);
    var encodedData = Convert.ToBase64String(Encoding.UTF8.GetBytes(serializedData));

    Response.Cookies.Append("UserSession", encodedData, new CookieOptions
    {
        HttpOnly = true,
        Secure = true,
        SameSite = SameSiteMode.Strict
    });

    return Ok();
}

[HttpGet("profile")]
public IActionResult GetProfile()
{
    if (Request.Cookies.TryGetValue("UserSession", out string cookieValue))
    {
        var decodedData = Encoding.UTF8.GetString(Convert.FromBase64String(cookieValue));
        var sessionData = JsonSerializer.Deserialize<UserSession>(decodedData);

        return Ok(new { UserId = sessionData.UserId, Username = sessionData.Username });
    }

    return Unauthorized();
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 37
```python
import json
import base64
from datetime import datetime
from flask import Flask, request, make_response

@app.route('/login', methods=['POST'])
def login():
    session_data = {
        'user_id': user.id,
        'username': user.username,
        'login_time': datetime.utcnow().isoformat(),
        'roles': user.roles
    }

    serialized_data = json.dumps(session_data)
    encoded_data = base64.b64encode(serialized_data.encode('utf-8')).decode('utf-8')

    response = make_response({'status': 'success'})
    response.set_cookie('UserSession', encoded_data,
                       httponly=True, secure=True, samesite='Strict')

    return response

@app.route('/profile')
def get_profile():
    cookie_value = request.cookies.get('UserSession')

    if cookie_value:
        decoded_data = base64.b64decode(cookie_value.encode('utf-8')).decode('utf-8')
        session_data = json.loads(decoded_data)

        return {
            'user_id': session_data['user_id'],
            'username': session_data['username']
        }

    return {'error': 'Unauthorized'}, 401
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 44
```typescript
import { Request, Response } from 'express';

interface UserSession {
  userId: string;
  username: string;
  loginTime: string;
  roles: string[];
}

export const login = (req: Request, res: Response) => {
  const sessionData: UserSession = {
    userId: user.id,
    username: user.username,
    loginTime: new Date().toISOString(),
    roles: user.roles
  };

  const serializedData = JSON.stringify(sessionData);
  const encodedData = Buffer.from(serializedData, 'utf-8').toString('base64');

  res.cookie('UserSession', encodedData, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  });

  res.json({ status: 'success' });
};

export const getProfile = (req: Request, res: Response) => {
  const cookieValue = req.cookies.UserSession;

  if (cookieValue) {
    const decodedData = Buffer.from(cookieValue, 'base64').toString('utf-8');
    const sessionData: UserSession = JSON.parse(decodedData);

    res.json({
      userId: sessionData.userId,
      username: sessionData.username
    });
  } else {
    res.status(401).json({ error: 'Unauthorized' });
  }
};
```

---

### ðŸ§ª Senaryo 2: Bir dosya paylaÅŸÄ±m uygulamasÄ±nda kullanÄ±cÄ± tercihleri dosya formatÄ±nda kaydedilir

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 37
```csharp
[Serializable]
public class UserPreferences
{
    public string Theme { get; set; }
    public int PageSize { get; set; }
    public List<string> FavoriteTypes { get; set; }
    public bool AutoDownload { get; set; }
}

public class PreferencesService
{
    private readonly string _preferencesPath = "preferences.dat";

    public void SavePreferences(UserPreferences preferences)
    {
        using var stream = new FileStream(_preferencesPath, FileMode.Create);
        var formatter = new BinaryFormatter();
        formatter.Serialize(stream, preferences);
    }

    public UserPreferences LoadPreferences()
    {
        if (!File.Exists(_preferencesPath))
            return new UserPreferences();

        using var stream = new FileStream(_preferencesPath, FileMode.Open);
        var formatter = new BinaryFormatter();
        return (UserPreferences)formatter.Deserialize(stream);
    }

    public void UpdateTheme(string newTheme)
    {
        var preferences = LoadPreferences();
        preferences.Theme = newTheme;
        SavePreferences(preferences);
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 35
```python
import pickle
import os
from dataclasses import dataclass
from typing import List

@dataclass
class UserPreferences:
    theme: str = "light"
    page_size: int = 20
    favorite_types: List[str] = None
    auto_download: bool = False

    def __post_init__(self):
        if self.favorite_types is None:
            self.favorite_types = []

class PreferencesService:
    def __init__(self, preferences_path="preferences.dat"):
        self.preferences_path = preferences_path

    def save_preferences(self, preferences: UserPreferences):
        with open(self.preferences_path, 'wb') as f:
            pickle.dump(preferences, f)

    def load_preferences(self) -> UserPreferences:
        if not os.path.exists(self.preferences_path):
            return UserPreferences()

        with open(self.preferences_path, 'rb') as f:
            return pickle.load(f)

    def update_theme(self, new_theme: str):
        preferences = self.load_preferences()
        preferences.theme = new_theme
        self.save_preferences(preferences)
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 46
```typescript
import * as fs from 'fs';
import * as path from 'path';

interface UserPreferences {
  theme: string;
  pageSize: number;
  favoriteTypes: string[];
  autoDownload: boolean;
}

class PreferencesService {
  private preferencesPath = 'preferences.json';

  savePreferences(preferences: UserPreferences): void {
    const serializedData = JSON.stringify(preferences, null, 2);
    fs.writeFileSync(this.preferencesPath, serializedData, 'utf-8');
  }

  loadPreferences(): UserPreferences {
    if (!fs.existsSync(this.preferencesPath)) {
      return {
        theme: 'light',
        pageSize: 20,
        favoriteTypes: [],
        autoDownload: false
      };
    }

    const fileContent = fs.readFileSync(this.preferencesPath, 'utf-8');
    return JSON.parse(fileContent) as UserPreferences;
  }

  updateTheme(newTheme: string): void {
    const preferences = this.loadPreferences();
    preferences.theme = newTheme;
    this.savePreferences(preferences);
  }

  addFavoriteType(fileType: string): void {
    const preferences = this.loadPreferences();
    if (!preferences.favoriteTypes.includes(fileType)) {
      preferences.favoriteTypes.push(fileType);
      this.savePreferences(preferences);
    }
  }
}
```

---

### ðŸ§ª Senaryo 3: Bir oyun uygulamasÄ±nda oyuncu ilerlemesi kayÄ±t dosyalarÄ±nda tutulur

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 40
```csharp
[Serializable]
public class GameProgress
{
    public int Level { get; set; }
    public int Score { get; set; }
    public Vector3 PlayerPosition { get; set; }
    public List<string> UnlockedItems { get; set; }
    public DateTime LastSaved { get; set; }
}

public class SaveGameService
{
    private readonly string _saveDirectory = "saves";

    public void SaveProgress(string playerId, GameProgress progress)
    {
        Directory.CreateDirectory(_saveDirectory);
        var fileName = Path.Combine(_saveDirectory, $"{playerId}.save");

        progress.LastSaved = DateTime.UtcNow;

        using var fileStream = new FileStream(fileName, FileMode.Create);
        using var gzipStream = new GZipStream(fileStream, CompressionMode.Compress);
        var formatter = new BinaryFormatter();
        formatter.Serialize(gzipStream, progress);
    }

    public GameProgress LoadProgress(string playerId)
    {
        var fileName = Path.Combine(_saveDirectory, $"{playerId}.save");

        if (!File.Exists(fileName))
            return new GameProgress { Level = 1, Score = 0, UnlockedItems = new List<string>() };

        using var fileStream = new FileStream(fileName, FileMode.Open);
        using var gzipStream = new GZipStream(fileStream, CompressionMode.Decompress);
        var formatter = new BinaryFormatter();
        return (GameProgress)formatter.Deserialize(gzipStream);
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 45
```python
import pickle
import gzip
import os
from datetime import datetime
from dataclasses import dataclass
from typing import List, Tuple

@dataclass
class GameProgress:
    level: int = 1
    score: int = 0
    player_position: Tuple[float, float, float] = (0.0, 0.0, 0.0)
    unlocked_items: List[str] = None
    last_saved: datetime = None

    def __post_init__(self):
        if self.unlocked_items is None:
            self.unlocked_items = []

class SaveGameService:
    def __init__(self, save_directory="saves"):
        self.save_directory = save_directory
        os.makedirs(save_directory, exist_ok=True)

    def save_progress(self, player_id: str, progress: GameProgress):
        file_name = os.path.join(self.save_directory, f"{player_id}.save")
        progress.last_saved = datetime.utcnow()

        with gzip.open(file_name, 'wb') as f:
            pickle.dump(progress, f)

    def load_progress(self, player_id: str) -> GameProgress:
        file_name = os.path.join(self.save_directory, f"{player_id}.save")

        if not os.path.exists(file_name):
            return GameProgress()

        with gzip.open(file_name, 'rb') as f:
            return pickle.load(f)

    def unlock_item(self, player_id: str, item_name: str):
        progress = self.load_progress(player_id)
        if item_name not in progress.unlocked_items:
            progress.unlocked_items.append(item_name)
            self.save_progress(player_id, progress)
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 55
```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as zlib from 'zlib';

interface Vector3 {
  x: number;
  y: number;
  z: number;
}

interface GameProgress {
  level: number;
  score: number;
  playerPosition: Vector3;
  unlockedItems: string[];
  lastSaved: string;
}

class SaveGameService {
  private saveDirectory = 'saves';

  constructor() {
    if (!fs.existsSync(this.saveDirectory)) {
      fs.mkdirSync(this.saveDirectory, { recursive: true });
    }
  }

  saveProgress(playerId: string, progress: GameProgress): void {
    const fileName = path.join(this.saveDirectory, `${playerId}.save`);
    progress.lastSaved = new Date().toISOString();

    const serializedData = JSON.stringify(progress);
    const compressedData = zlib.gzipSync(Buffer.from(serializedData, 'utf-8'));

    fs.writeFileSync(fileName, compressedData);
  }

  loadProgress(playerId: string): GameProgress {
    const fileName = path.join(this.saveDirectory, `${playerId}.save`);

    if (!fs.existsSync(fileName)) {
      return {
        level: 1,
        score: 0,
        playerPosition: { x: 0, y: 0, z: 0 },
        unlockedItems: [],
        lastSaved: new Date().toISOString()
      };
    }

    const compressedData = fs.readFileSync(fileName);
    const decompressedData = zlib.gunzipSync(compressedData);
    return JSON.parse(decompressedData.toString('utf-8')) as GameProgress;
  }
}
```

---

### ðŸ§ª Senaryo 4: Bir API uygulamasÄ±nda istemci verileri JSON formatÄ±nda alÄ±nÄ±r

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 62
```csharp
public class ProductDto
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Category { get; set; }
    public List<string> Tags { get; set; }
}

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Category { get; set; }
    public string[] Tags { get; set; }
    public DateTime CreatedAt { get; set; }
}

[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    [HttpPost]
    public async Task<IActionResult> CreateProduct([FromBody] ProductDto dto)
    {
        var product = new Product
        {
            Name = dto.Name,
            Price = dto.Price,
            Category = dto.Category,
            Tags = dto.Tags?.ToArray() ?? Array.Empty<string>(),
            CreatedAt = DateTime.UtcNow
        };

        await _productRepository.AddAsync(product);

        var responseDto = new ProductDto
        {
            Name = product.Name,
            Price = product.Price,
            Category = product.Category,
            Tags = product.Tags?.ToList() ?? new List<string>()
        };

        return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, responseDto);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<ProductDto>> GetProduct(int id)
    {
        var product = await _productRepository.GetByIdAsync(id);
        if (product == null) return NotFound();

        return new ProductDto
        {
            Name = product.Name,
            Price = product.Price,
            Category = product.Category,
            Tags = product.Tags?.ToList() ?? new List<string>()
        };
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 67
```typescript
import { Request, Response } from 'express';

interface ProductDto {
  name: string;
  price: number;
  category: string;
  tags: string[];
}

interface Product {
  id?: number;
  name: string;
  price: number;
  category: string;
  tags: string[];
  createdAt: Date;
}

class ProductsController {
  async createProduct(req: Request, res: Response): Promise<void> {
    try {
      const dto: ProductDto = req.body;

      // Convert DTO to domain object
      const product: Product = {
        name: dto.name,
        price: dto.price,
        category: dto.category,
        tags: dto.tags || [],
        createdAt: new Date()
      };

      const savedProduct = await productRepository.add(product);

      // Convert back to DTO for response
      const responseDto: ProductDto = {
        name: savedProduct.name,
        price: savedProduct.price,
        category: savedProduct.category,
        tags: savedProduct.tags
      };

      res.status(201).json(responseDto);
    } catch (error) {
      res.status(400).json({ error: 'Invalid product data' });
    }
  }

  async getProduct(req: Request, res: Response): Promise<void> {
    const id = parseInt(req.params.id);
    const product = await productRepository.getById(id);

    if (!product) {
      res.status(404).json({ error: 'Product not found' });
      return;
    }

    const dto: ProductDto = {
      name: product.name,
      price: product.price,
      category: product.category,
      tags: product.tags
    };

    res.json(dto);
  }
}
```

---

### ðŸ§ª Senaryo 5: Bir konfigÃ¼rasyon yÃ¶netim sisteminde ayar dosyalarÄ± YAML formatÄ±nda saklanÄ±r

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 74
```csharp
public class DatabaseConfig
{
    public string ConnectionString { get; set; }
    public int MaxConnections { get; set; }
    public int TimeoutSeconds { get; set; }
}

public class ApiConfig
{
    public string BaseUrl { get; set; }
    public int Port { get; set; }
    public List<string> AllowedOrigins { get; set; }
}

public class AppConfig
{
    public DatabaseConfig Database { get; set; }
    public ApiConfig Api { get; set; }
    public bool EnableLogging { get; set; }
    public string LogLevel { get; set; }
}

public class ConfigurationService
{
    private readonly IDeserializer _deserializer;
    private readonly ISerializer _serializer;

    public ConfigurationService()
    {
        _deserializer = new DeserializerBuilder()
            .WithNamingConvention(CamelCaseNamingConvention.Instance)
            .Build();

        _serializer = new SerializerBuilder()
            .WithNamingConvention(CamelCaseNamingConvention.Instance)
            .Build();
    }

    public AppConfig LoadConfiguration(string filePath = "appsettings.yml")
    {
        if (!File.Exists(filePath))
            return CreateDefaultConfig();

        var yamlContent = File.ReadAllText(filePath);
        return _deserializer.Deserialize<AppConfig>(yamlContent);
    }

    public void SaveConfiguration(AppConfig config, string filePath = "appsettings.yml")
    {
        var yamlContent = _serializer.Serialize(config);
        File.WriteAllText(filePath, yamlContent);
    }

    private AppConfig CreateDefaultConfig()
    {
        return new AppConfig
        {
            Database = new DatabaseConfig
            {
                ConnectionString = "Server=localhost;Database=myapp;",
                MaxConnections = 100,
                TimeoutSeconds = 30
            },
            Api = new ApiConfig
            {
                BaseUrl = "https://localhost",
                Port = 5000,
                AllowedOrigins = new List<string> { "*" }
            },
            EnableLogging = true,
            LogLevel = "Info"
        };
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 60
```python
import yaml
import os
from dataclasses import dataclass, asdict
from typing import List

@dataclass
class DatabaseConfig:
    connection_string: str = "postgresql://localhost/myapp"
    max_connections: int = 100
    timeout_seconds: int = 30

@dataclass
class ApiConfig:
    base_url: str = "https://localhost"
    port: int = 5000
    allowed_origins: List[str] = None

    def __post_init__(self):
        if self.allowed_origins is None:
            self.allowed_origins = ["*"]

@dataclass
class AppConfig:
    database: DatabaseConfig = None
    api: ApiConfig = None
    enable_logging: bool = True
    log_level: str = "INFO"

    def __post_init__(self):
        if self.database is None:
            self.database = DatabaseConfig()
        if self.api is None:
            self.api = ApiConfig()

class ConfigurationService:
    def __init__(self, config_file="appsettings.yml"):
        self.config_file = config_file

    def load_configuration(self) -> AppConfig:
        if not os.path.exists(self.config_file):
            return self._create_default_config()

        with open(self.config_file, 'r') as f:
            data = yaml.safe_load(f)

        return AppConfig(
            database=DatabaseConfig(**data.get('database', {})),
            api=ApiConfig(**data.get('api', {})),
            enable_logging=data.get('enable_logging', True),
            log_level=data.get('log_level', 'INFO')
        )

    def save_configuration(self, config: AppConfig):
        config_dict = asdict(config)

        with open(self.config_file, 'w') as f:
            yaml.dump(config_dict, f, default_flow_style=False, indent=2)

    def _create_default_config(self) -> AppConfig:
        return AppConfig()
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 75
```typescript
import * as yaml from 'js-yaml';
import * as fs from 'fs';

interface DatabaseConfig {
  connectionString: string;
  maxConnections: number;
  timeoutSeconds: number;
}

interface ApiConfig {
  baseUrl: string;
  port: number;
  allowedOrigins: string[];
}

interface AppConfig {
  database: DatabaseConfig;
  api: ApiConfig;
  enableLogging: boolean;
  logLevel: string;
}

class ConfigurationService {
  private configFile: string;

  constructor(configFile = 'appsettings.yml') {
    this.configFile = configFile;
  }

  loadConfiguration(): AppConfig {
    if (!fs.existsSync(this.configFile)) {
      return this.createDefaultConfig();
    }

    const fileContent = fs.readFileSync(this.configFile, 'utf-8');
    const data = yaml.load(fileContent) as any;

    return {
      database: {
        connectionString: data.database?.connectionString || 'mongodb://localhost/myapp',
        maxConnections: data.database?.maxConnections || 100,
        timeoutSeconds: data.database?.timeoutSeconds || 30
      },
      api: {
        baseUrl: data.api?.baseUrl || 'https://localhost',
        port: data.api?.port || 5000,
        allowedOrigins: data.api?.allowedOrigins || ['*']
      },
      enableLogging: data.enableLogging ?? true,
      logLevel: data.logLevel || 'info'
    };
  }

  saveConfiguration(config: AppConfig): void {
    const yamlContent = yaml.dump(config, { indent: 2 });
    fs.writeFileSync(this.configFile, yamlContent, 'utf-8');
  }

  private createDefaultConfig(): AppConfig {
    return {
      database: {
        connectionString: 'mongodb://localhost/myapp',
        maxConnections: 100,
        timeoutSeconds: 30
      },
      api: {
        baseUrl: 'https://localhost',
        port: 5000,
        allowedOrigins: ['*']
      },
      enableLogging: true,
      logLevel: 'info'
    };
  }
}
```

---

### ðŸ§ª Senaryo 6: Bir mesajlaÅŸma uygulamasÄ±nda mesaj geÃ§miÅŸi arÅŸiv formatÄ±nda kaydedilir

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 74
```csharp
[Serializable]
public class Message
{
    public Guid Id { get; set; }
    public string SenderId { get; set; }
    public string ReceiverId { get; set; }
    public string Content { get; set; }
    public DateTime Timestamp { get; set; }
    public MessageType Type { get; set; }
}

public enum MessageType : byte
{
    Text = 0,
    Image = 1,
    File = 2,
    System = 3
}

public class MessageArchiveService
{
    public void ArchiveMessages(string conversationId, List<Message> messages)
    {
        var archivePath = $"archives/{conversationId}.arch";
        Directory.CreateDirectory(Path.GetDirectoryName(archivePath));

        using var fileStream = new FileStream(archivePath, FileMode.Create);
        using var gzipStream = new GZipStream(fileStream, CompressionMode.Compress);
        using var binaryWriter = new BinaryWriter(gzipStream);

        binaryWriter.Write(messages.Count);

        foreach (var message in messages)
        {
            binaryWriter.Write(message.Id.ToByteArray());
            binaryWriter.Write(message.SenderId ?? string.Empty);
            binaryWriter.Write(message.ReceiverId ?? string.Empty);
            binaryWriter.Write(message.Content ?? string.Empty);
            binaryWriter.Write(message.Timestamp.ToBinary());
            binaryWriter.Write((byte)message.Type);
        }
    }

    public List<Message> LoadArchivedMessages(string conversationId)
    {
        var archivePath = $"archives/{conversationId}.arch";
        if (!File.Exists(archivePath)) return new List<Message>();

        var messages = new List<Message>();

        using var fileStream = new FileStream(archivePath, FileMode.Open);
        using var gzipStream = new GZipStream(fileStream, CompressionMode.Decompress);
        using var binaryReader = new BinaryReader(gzipStream);

        var count = binaryReader.ReadInt32();

        for (int i = 0; i < count; i++)
        {
            var message = new Message
            {
                Id = new Guid(binaryReader.ReadBytes(16)),
                SenderId = binaryReader.ReadString(),
                ReceiverId = binaryReader.ReadString(),
                Content = binaryReader.ReadString(),
                Timestamp = DateTime.FromBinary(binaryReader.ReadInt64()),
                Type = (MessageType)binaryReader.ReadByte()
            };

            messages.Add(message);
        }

        return messages;
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 76
```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as zlib from 'zlib';

enum MessageType {
  TEXT = 0,
  IMAGE = 1,
  FILE = 2,
  SYSTEM = 3
}

interface Message {
  id: string;
  senderId: string;
  receiverId: string;
  content: string;
  timestamp: Date;
  type: MessageType;
}

class MessageArchiveService {
  private archiveDir = 'archives';

  constructor() {
    if (!fs.existsSync(this.archiveDir)) {
      fs.mkdirSync(this.archiveDir, { recursive: true });
    }
  }

  archiveMessages(conversationId: string, messages: Message[]): void {
    const archivePath = path.join(this.archiveDir, `${conversationId}.arch`);

    // Convert messages to JSON and compress
    const serializedData = JSON.stringify(messages.map(msg => ({
      id: msg.id,
      senderId: msg.senderId,
      receiverId: msg.receiverId,
      content: msg.content,
      timestamp: msg.timestamp.toISOString(),
      type: msg.type
    })));

    const compressedData = zlib.gzipSync(Buffer.from(serializedData, 'utf-8'));
    fs.writeFileSync(archivePath, compressedData);
  }

  loadArchivedMessages(conversationId: string): Message[] {
    const archivePath = path.join(this.archiveDir, `${conversationId}.arch`);

    if (!fs.existsSync(archivePath)) {
      return [];
    }

    const compressedData = fs.readFileSync(archivePath);
    const decompressedData = zlib.gunzipSync(compressedData);
    const serializedData = decompressedData.toString('utf-8');

    const rawMessages = JSON.parse(serializedData);

    return rawMessages.map((msg: any) => ({
      id: msg.id,
      senderId: msg.senderId,
      receiverId: msg.receiverId,
      content: msg.content,
      timestamp: new Date(msg.timestamp),
      type: msg.type as MessageType
    }));
  }

  searchInArchive(conversationId: string, searchTerm: string): Message[] {
    const messages = this.loadArchivedMessages(conversationId);
    return messages.filter(msg =>
      msg.content.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }
}
```

---

### ðŸ§ª Senaryo 7: Bir cache sistemi veri nesnelerini hÄ±zlÄ± eriÅŸim iÃ§in depolar

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 96
```csharp
public class CacheEntry<T>
{
    public T Data { get; set; }
    public DateTime ExpiresAt { get; set; }
    public TimeSpan SlidingExpiration { get; set; }
    public DateTime LastAccessed { get; set; }
}

public class MemoryCache
{
    private readonly ConcurrentDictionary<string, byte[]> _cache = new();
    private readonly Timer _cleanupTimer;

    public MemoryCache()
    {
        _cleanupTimer = new Timer(CleanupExpiredEntries, null,
            TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));
    }

    public void Set<T>(string key, T value, TimeSpan? expiration = null)
    {
        var entry = new CacheEntry<T>
        {
            Data = value,
            ExpiresAt = DateTime.UtcNow.Add(expiration ?? TimeSpan.FromHours(1)),
            SlidingExpiration = expiration ?? TimeSpan.FromHours(1),
            LastAccessed = DateTime.UtcNow
        };

        using var stream = new MemoryStream();
        var formatter = new BinaryFormatter();
        formatter.Serialize(stream, entry);

        _cache.TryAdd(key, stream.ToArray());
    }

    public T Get<T>(string key)
    {
        if (_cache.TryGetValue(key, out var data))
        {
            using var stream = new MemoryStream(data);
            var formatter = new BinaryFormatter();
            var entry = (CacheEntry<T>)formatter.Deserialize(stream);

            if (entry.ExpiresAt > DateTime.UtcNow)
            {
                // Update last accessed and sliding expiration
                entry.LastAccessed = DateTime.UtcNow;
                entry.ExpiresAt = DateTime.UtcNow.Add(entry.SlidingExpiration);

                // Re-serialize with updated timestamp
                using var updateStream = new MemoryStream();
                formatter.Serialize(updateStream, entry);
                _cache.TryUpdate(key, updateStream.ToArray(), data);

                return entry.Data;
            }
            else
            {
                _cache.TryRemove(key, out _);
            }
        }

        return default(T);
    }

    private void CleanupExpiredEntries(object state)
    {
        var expiredKeys = new List<string>();
        var now = DateTime.UtcNow;

        foreach (var kvp in _cache)
        {
            try
            {
                using var stream = new MemoryStream(kvp.Value);
                var formatter = new BinaryFormatter();
                var entry = formatter.Deserialize(stream) as dynamic;

                if (entry?.ExpiresAt < now)
                {
                    expiredKeys.Add(kvp.Key);
                }
            }
            catch
            {
                expiredKeys.Add(kvp.Key);
            }
        }

        foreach (var key in expiredKeys)
        {
            _cache.TryRemove(key, out _);
        }
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 118
```typescript
interface CacheEntry<T> {
  data: T;
  expiresAt: Date;
  slidingExpiration: number; // milliseconds
  lastAccessed: Date;
}

class MemoryCache {
  private cache = new Map<string, string>();
  private cleanupTimer: NodeJS.Timeout;

  constructor() {
    // Run cleanup every 5 minutes
    this.cleanupTimer = setInterval(() => {
      this.cleanupExpiredEntries();
    }, 5 * 60 * 1000);
  }

  set<T>(key: string, value: T, expiration = 60 * 60 * 1000): void { // 1 hour default
    const entry: CacheEntry<T> = {
      data: value,
      expiresAt: new Date(Date.now() + expiration),
      slidingExpiration: expiration,
      lastAccessed: new Date()
    };

    const serializedEntry = JSON.stringify(entry, (key, value) => {
      if (key === 'expiresAt' || key === 'lastAccessed') {
        return value instanceof Date ? value.toISOString() : value;
      }
      return value;
    });

    this.cache.set(key, serializedEntry);
  }

  get<T>(key: string): T | null {
    const serializedEntry = this.cache.get(key);

    if (!serializedEntry) {
      return null;
    }

    try {
      const entry: CacheEntry<T> = JSON.parse(serializedEntry, (key, value) => {
        if (key === 'expiresAt' || key === 'lastAccessed') {
          return new Date(value);
        }
        return value;
      });

      const now = new Date();

      if (entry.expiresAt > now) {
        // Update last accessed and sliding expiration
        entry.lastAccessed = now;
        entry.expiresAt = new Date(now.getTime() + entry.slidingExpiration);

        // Re-serialize with updated timestamp
        const updatedSerialized = JSON.stringify(entry, (key, value) => {
          if (key === 'expiresAt' || key === 'lastAccessed') {
            return value instanceof Date ? value.toISOString() : value;
          }
          return value;
        });

        this.cache.set(key, updatedSerialized);

        return entry.data;
      } else {
        // Entry expired, remove it
        this.cache.delete(key);
        return null;
      }
    } catch (error) {
      // Corrupted entry, remove it
      this.cache.delete(key);
      return null;
    }
  }

  remove(key: string): boolean {
    return this.cache.delete(key);
  }

  clear(): void {
    this.cache.clear();
  }

  private cleanupExpiredEntries(): void {
    const now = new Date();
    const expiredKeys: string[] = [];

    for (const [key, serializedEntry] of this.cache.entries()) {
      try {
        const entry = JSON.parse(serializedEntry, (key, value) => {
          if (key === 'expiresAt' || key === 'lastAccessed') {
            return new Date(value);
          }
          return value;
        });

        if (entry.expiresAt < now) {
          expiredKeys.push(key);
        }
      } catch {
        expiredKeys.push(key);
      }
    }

    expiredKeys.forEach(key => this.cache.delete(key));
  }

  destroy(): void {
    clearInterval(this.cleanupTimer);
    this.cache.clear();
  }
}
```

---

### ðŸ§ª Senaryo 8: Bir rapor uygulamasÄ±nda ÅŸablon dosyalarÄ± Ã¶zel formatta kaydedilir

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 109
```csharp
public class ReportTemplate
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public List<ReportSection> Sections { get; set; }
    public Dictionary<string, object> Parameters { get; set; }
    public DateTime CreatedAt { get; set; }
}

public class ReportSection
{
    public string Type { get; set; } // "table", "chart", "text"
    public string Title { get; set; }
    public Dictionary<string, object> Properties { get; set; }
    public string DataSource { get; set; }
}

public class ReportTemplateService
{
    private readonly string _templatesPath = "templates";

    public ReportTemplateService()
    {
        Directory.CreateDirectory(_templatesPath);
    }

    public void SaveTemplate(ReportTemplate template)
    {
        var fileName = Path.Combine(_templatesPath, $"{template.Id}.rpt");

        var templateData = new
        {
            Metadata = new
            {
                template.Id,
                template.Name,
                template.Description,
                template.CreatedAt
            },
            Sections = template.Sections,
            Parameters = template.Parameters
        };

        var jsonContent = JsonSerializer.Serialize(templateData, new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });

        File.WriteAllText(fileName, jsonContent);
    }

    public ReportTemplate LoadTemplate(string templateId)
    {
        var fileName = Path.Combine(_templatesPath, $"{templateId}.rpt");

        if (!File.Exists(fileName))
            throw new FileNotFoundException($"Template {templateId} not found");

        var jsonContent = File.ReadAllText(fileName);
        var templateData = JsonSerializer.Deserialize<dynamic>(jsonContent);

        return JsonSerializer.Deserialize<ReportTemplate>(jsonContent, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });
    }

    public Report GenerateReport(string templateId, Dictionary<string, object> data)
    {
        var template = LoadTemplate(templateId);
        var report = new Report
        {
            Id = Guid.NewGuid().ToString(),
            TemplateId = templateId,
            GeneratedAt = DateTime.UtcNow,
            Sections = new List<ReportSection>()
        };

        foreach (var section in template.Sections)
        {
            var processedSection = ProcessSection(section, data);
            report.Sections.Add(processedSection);
        }

        return report;
    }

    private ReportSection ProcessSection(ReportSection template, Dictionary<string, object> data)
    {
        return new ReportSection
        {
            Type = template.Type,
            Title = ReplacePlaceholders(template.Title, data),
            Properties = template.Properties,
            DataSource = template.DataSource
        };
    }

    private string ReplacePlaceholders(string text, Dictionary<string, object> data)
    {
        foreach (var kvp in data)
        {
            text = text.Replace($"{{{kvp.Key}}}", kvp.Value?.ToString() ?? "");
        }
        return text;
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 109
```typescript
import * as fs from 'fs';
import * as path from 'path';

interface ReportSection {
  type: string; // "table", "chart", "text"
  title: string;
  properties: Record<string, any>;
  dataSource: string;
}

interface ReportTemplate {
  id: string;
  name: string;
  description: string;
  sections: ReportSection[];
  parameters: Record<string, any>;
  createdAt: Date;
}

interface Report {
  id: string;
  templateId: string;
  generatedAt: Date;
  sections: ReportSection[];
}

class ReportTemplateService {
  private templatesPath: string;

  constructor(templatesPath = 'templates') {
    this.templatesPath = templatesPath;
    if (!fs.existsSync(templatesPath)) {
      fs.mkdirSync(templatesPath, { recursive: true });
    }
  }

  saveTemplate(template: ReportTemplate): void {
    const fileName = path.join(this.templatesPath, `${template.id}.rpt`);

    const templateData = {
      metadata: {
        id: template.id,
        name: template.name,
        description: template.description,
        createdAt: template.createdAt.toISOString()
      },
      sections: template.sections,
      parameters: template.parameters
    };

    fs.writeFileSync(fileName, JSON.stringify(templateData, null, 2), 'utf-8');
  }

  loadTemplate(templateId: string): ReportTemplate {
    const fileName = path.join(this.templatesPath, `${templateId}.rpt`);

    if (!fs.existsSync(fileName)) {
      throw new Error(`Template ${templateId} not found`);
    }

    const fileContent = fs.readFileSync(fileName, 'utf-8');
    const templateData = JSON.parse(fileContent);

    return {
      id: templateData.metadata.id,
      name: templateData.metadata.name,
      description: templateData.metadata.description,
      sections: templateData.sections,
      parameters: templateData.parameters,
      createdAt: new Date(templateData.metadata.createdAt)
    };
  }

  generateReport(templateId: string, data: Record<string, any>): Report {
    const template = this.loadTemplate(templateId);

    const processedSections = template.sections.map(section =>
      this.processSection(section, data)
    );

    return {
      id: this.generateId(),
      templateId,
      generatedAt: new Date(),
      sections: processedSections
    };
  }

  private processSection(templateSection: ReportSection, data: Record<string, any>): ReportSection {
    return {
      type: templateSection.type,
      title: this.replacePlaceholders(templateSection.title, data),
      properties: templateSection.properties,
      dataSource: templateSection.dataSource
    };
  }

  private replacePlaceholders(text: string, data: Record<string, any>): string {
    for (const [key, value] of Object.entries(data)) {
      const placeholder = `{${key}}`;
      text = text.replace(new RegExp(placeholder, 'g'), String(value ?? ''));
    }
    return text;
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}
```

---

### ðŸ§ª Senaryo 9: Bir workflow sistemi sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± dosyalarda saklar

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 114
```csharp
public class WorkflowDefinition
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Version { get; set; }
    public List<WorkflowStep> Steps { get; set; }
    public Dictionary<string, object> Variables { get; set; }
}

public class WorkflowStep
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Type { get; set; }
    public Dictionary<string, object> Properties { get; set; }
    public List<string> NextSteps { get; set; }
    public string Condition { get; set; }
}

public class WorkflowService
{
    private readonly string _workflowsPath = "workflows";

    public WorkflowService()
    {
        Directory.CreateDirectory(_workflowsPath);
    }

    public void SaveWorkflowDefinition(WorkflowDefinition workflow)
    {
        var fileName = Path.Combine(_workflowsPath, $"{workflow.Id}.xml");

        var doc = new XDocument(
            new XElement("Workflow",
                new XAttribute("id", workflow.Id),
                new XAttribute("name", workflow.Name),
                new XAttribute("version", workflow.Version),
                new XElement("Variables",
                    workflow.Variables.Select(v =>
                        new XElement("Variable",
                            new XAttribute("name", v.Key),
                            new XAttribute("value", v.Value?.ToString() ?? "")
                        )
                    )
                ),
                new XElement("Steps",
                    workflow.Steps.Select(step =>
                        new XElement("Step",
                            new XAttribute("id", step.Id),
                            new XAttribute("name", step.Name),
                            new XAttribute("type", step.Type),
                            step.Condition != null ? new XAttribute("condition", step.Condition) : null,
                            new XElement("Properties",
                                step.Properties.Select(p =>
                                    new XElement("Property",
                                        new XAttribute("name", p.Key),
                                        new XCData(JsonSerializer.Serialize(p.Value))
                                    )
                                )
                            ),
                            new XElement("NextSteps",
                                step.NextSteps?.Select(ns => new XElement("NextStep", ns)) ?? Enumerable.Empty<XElement>()
                            )
                        )
                    )
                )
            )
        );

        doc.Save(fileName);
    }

    public WorkflowDefinition LoadWorkflowDefinition(string workflowId)
    {
        var fileName = Path.Combine(_workflowsPath, $"{workflowId}.xml");

        if (!File.Exists(fileName))
            throw new FileNotFoundException($"Workflow {workflowId} not found");

        var doc = XDocument.Load(fileName);
        var root = doc.Root;

        var variables = root.Element("Variables")?.Elements("Variable")
            .ToDictionary(
                v => v.Attribute("name")?.Value ?? "",
                v => (object)(v.Attribute("value")?.Value ?? "")
            ) ?? new Dictionary<string, object>();

        var steps = root.Element("Steps")?.Elements("Step")
            .Select(stepElement => new WorkflowStep
            {
                Id = stepElement.Attribute("id")?.Value ?? "",
                Name = stepElement.Attribute("name")?.Value ?? "",
                Type = stepElement.Attribute("type")?.Value ?? "",
                Condition = stepElement.Attribute("condition")?.Value,
                Properties = stepElement.Element("Properties")?.Elements("Property")
                    .ToDictionary(
                        p => p.Attribute("name")?.Value ?? "",
                        p => JsonSerializer.Deserialize<object>(p.Value)
                    ) ?? new Dictionary<string, object>(),
                NextSteps = stepElement.Element("NextSteps")?.Elements("NextStep")
                    .Select(ns => ns.Value).ToList() ?? new List<string>()
            }).ToList() ?? new List<WorkflowStep>();

        return new WorkflowDefinition
        {
            Id = root.Attribute("id")?.Value ?? "",
            Name = root.Attribute("name")?.Value ?? "",
            Version = root.Attribute("version")?.Value ?? "",
            Variables = variables,
            Steps = steps
        };
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 170
```typescript
import * as fs from 'fs';
import * as path from 'path';
import { DOMParser, XMLSerializer } from 'xmldom';

interface WorkflowStep {
  id: string;
  name: string;
  type: string;
  properties: Record<string, any>;
  nextSteps: string[];
  condition?: string;
}

interface WorkflowDefinition {
  id: string;
  name: string;
  version: string;
  steps: WorkflowStep[];
  variables: Record<string, any>;
}

class WorkflowService {
  private workflowsPath: string;

  constructor(workflowsPath = 'workflows') {
    this.workflowsPath = workflowsPath;
    if (!fs.existsSync(workflowsPath)) {
      fs.mkdirSync(workflowsPath, { recursive: true });
    }
  }

  saveWorkflowDefinition(workflow: WorkflowDefinition): void {
    const fileName = path.join(this.workflowsPath, `${workflow.id}.xml`);

    const parser = new DOMParser();
    const serializer = new XMLSerializer();
    const doc = parser.parseFromString('<root/>', 'text/xml');

    const root = doc.createElement('Workflow');
    root.setAttribute('id', workflow.id);
    root.setAttribute('name', workflow.name);
    root.setAttribute('version', workflow.version);

    // Add variables
    const variablesElem = doc.createElement('Variables');
    for (const [name, value] of Object.entries(workflow.variables)) {
      const varElem = doc.createElement('Variable');
      varElem.setAttribute('name', name);
      varElem.setAttribute('value', String(value));
      variablesElem.appendChild(varElem);
    }
    root.appendChild(variablesElem);

    // Add steps
    const stepsElem = doc.createElement('Steps');
    for (const step of workflow.steps) {
      const stepElem = doc.createElement('Step');
      stepElem.setAttribute('id', step.id);
      stepElem.setAttribute('name', step.name);
      stepElem.setAttribute('type', step.type);

      if (step.condition) {
        stepElem.setAttribute('condition', step.condition);
      }

      // Add properties
      const propsElem = doc.createElement('Properties');
      for (const [propName, propValue] of Object.entries(step.properties)) {
        const propElem = doc.createElement('Property');
        propElem.setAttribute('name', propName);
        propElem.textContent = JSON.stringify(propValue);
        propsElem.appendChild(propElem);
      }
      stepElem.appendChild(propsElem);

      // Add next steps
      const nextStepsElem = doc.createElement('NextSteps');
      for (const nextStep of step.nextSteps) {
        const nextStepElem = doc.createElement('NextStep');
        nextStepElem.textContent = nextStep;
        nextStepsElem.appendChild(nextStepElem);
      }
      stepElem.appendChild(nextStepsElem);

      stepsElem.appendChild(stepElem);
    }
    root.appendChild(stepsElem);

    const xmlString = serializer.serializeToString(root);
    fs.writeFileSync(fileName, `<?xml version="1.0" encoding="UTF-8"?>\n${xmlString}`, 'utf-8');
  }

  loadWorkflowDefinition(workflowId: string): WorkflowDefinition {
    const fileName = path.join(this.workflowsPath, `${workflowId}.xml`);

    if (!fs.existsSync(fileName)) {
      throw new Error(`Workflow ${workflowId} not found`);
    }

    const xmlContent = fs.readFileSync(fileName, 'utf-8');
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlContent, 'text/xml');
    const root = doc.documentElement;

    // Parse variables
    const variables: Record<string, any> = {};
    const variablesElem = root.getElementsByTagName('Variables')[0];
    if (variablesElem) {
      const varElems = variablesElem.getElementsByTagName('Variable');
      for (let i = 0; i < varElems.length; i++) {
        const varElem = varElems[i];
        const name = varElem.getAttribute('name') || '';
        const value = varElem.getAttribute('value') || '';
        variables[name] = value;
      }
    }

    // Parse steps
    const steps: WorkflowStep[] = [];
    const stepsElem = root.getElementsByTagName('Steps')[0];
    if (stepsElem) {
      const stepElems = stepsElem.getElementsByTagName('Step');
      for (let i = 0; i < stepElems.length; i++) {
        const stepElem = stepElems[i];

        // Parse properties
        const properties: Record<string, any> = {};
        const propsElem = stepElem.getElementsByTagName('Properties')[0];
        if (propsElem) {
          const propElems = propsElem.getElementsByTagName('Property');
          for (let j = 0; j < propElems.length; j++) {
            const propElem = propElems[j];
            const propName = propElem.getAttribute('name') || '';
            const propValue = JSON.parse(propElem.textContent || '{}');
            properties[propName] = propValue;
          }
        }

        // Parse next steps
        const nextSteps: string[] = [];
        const nextStepsElem = stepElem.getElementsByTagName('NextSteps')[0];
        if (nextStepsElem) {
          const nextStepElems = nextStepsElem.getElementsByTagName('NextStep');
          for (let j = 0; j < nextStepElems.length; j++) {
            nextSteps.push(nextStepElems[j].textContent || '');
          }
        }

        const step: WorkflowStep = {
          id: stepElem.getAttribute('id') || '',
          name: stepElem.getAttribute('name') || '',
          type: stepElem.getAttribute('type') || '',
          properties,
          nextSteps,
          condition: stepElem.getAttribute('condition') || undefined
        };

        steps.push(step);
      }
    }

    return {
      id: root.getAttribute('id') || '',
      name: root.getAttribute('name') || '',
      version: root.getAttribute('version') || '',
      steps,
      variables
    };
  }
}
```

---

### ðŸ§ª Senaryo 10: Bir e-ticaret uygulamasÄ±nda sepet bilgileri session datasÄ±nda tutulur

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 98
```csharp
public class CartItem
{
    public string ProductId { get; set; }
    public string ProductName { get; set; }
    public decimal Price { get; set; }
    public int Quantity { get; set; }
    public Dictionary<string, string> Options { get; set; }
}

public class ShoppingCart
{
    public string UserId { get; set; }
    public List<CartItem> Items { get; set; } = new List<CartItem>();
    public DateTime CreatedAt { get; set; }
    public DateTime LastUpdated { get; set; }
    public decimal TotalAmount => Items.Sum(i => i.Price * i.Quantity);
}

[ApiController]
[Route("api/[controller]")]
public class CartController : ControllerBase
{
    private const string CART_SESSION_KEY = "ShoppingCart";

    [HttpPost("add-item")]
    public IActionResult AddItem([FromBody] CartItem item)
    {
        var cart = GetCartFromSession();

        var existingItem = cart.Items.FirstOrDefault(i =>
            i.ProductId == item.ProductId &&
            i.Options.SequenceEqual(item.Options ?? new Dictionary<string, string>()));

        if (existingItem != null)
        {
            existingItem.Quantity += item.Quantity;
        }
        else
        {
            cart.Items.Add(item);
        }

        cart.LastUpdated = DateTime.UtcNow;
        SaveCartToSession(cart);

        return Ok(new { cart.TotalAmount, ItemCount = cart.Items.Sum(i => i.Quantity) });
    }

    [HttpGet]
    public IActionResult GetCart()
    {
        var cart = GetCartFromSession();
        return Ok(cart);
    }

    [HttpDelete("remove-item/{productId}")]
    public IActionResult RemoveItem(string productId)
    {
        var cart = GetCartFromSession();
        cart.Items.RemoveAll(i => i.ProductId == productId);
        cart.LastUpdated = DateTime.UtcNow;
        SaveCartToSession(cart);

        return Ok(cart);
    }

    private ShoppingCart GetCartFromSession()
    {
        var cartJson = HttpContext.Session.GetString(CART_SESSION_KEY);

        if (string.IsNullOrEmpty(cartJson))
        {
            return new ShoppingCart
            {
                UserId = GetCurrentUserId(),
                CreatedAt = DateTime.UtcNow,
                LastUpdated = DateTime.UtcNow
            };
        }

        return JsonSerializer.Deserialize<ShoppingCart>(cartJson) ?? new ShoppingCart();
    }

    private void SaveCartToSession(ShoppingCart cart)
    {
        var cartJson = JsonSerializer.Serialize(cart, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });

        HttpContext.Session.SetString(CART_SESSION_KEY, cartJson);
    }

    private string GetCurrentUserId()
    {
        return HttpContext.User.FindFirst("user_id")?.Value ?? "anonymous";
    }
}
```