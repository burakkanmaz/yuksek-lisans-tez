### ðŸ§ª Senaryo 1: Bir web uygulamasÄ±nda kullanÄ±cÄ± oturum bilgileri cookie formatÄ±nda saklanÄ±r

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 37
```csharp
[HttpPost("login")]
public IActionResult Login(LoginModel model)
{
    var sessionData = new UserSession
    {
        UserId = user.Id,
        Username = user.Username,
        LoginTime = DateTime.UtcNow,
        Roles = user.Roles
    };
    
    var serializedData = JsonSerializer.Serialize(sessionData);
    var encodedData = Convert.ToBase64String(Encoding.UTF8.GetBytes(serializedData));
    
    Response.Cookies.Append("UserSession", encodedData, new CookieOptions
    {
        HttpOnly = true,
        Secure = true,
        SameSite = SameSiteMode.Strict
    });
    
    return Ok();
}

[HttpGet("profile")]
public IActionResult GetProfile()
{
    if (Request.Cookies.TryGetValue("UserSession", out string cookieValue))
    {
        var decodedData = Encoding.UTF8.GetString(Convert.FromBase64String(cookieValue));
        var sessionData = JsonSerializer.Deserialize<UserSession>(decodedData);
        
        return Ok(new { UserId = sessionData.UserId, Username = sessionData.Username });
    }
    
    return Unauthorized();
}
```
### ðŸ§ª Senaryo 1: Bir web uygulamasÄ±nda kullanÄ±cÄ± oturum bilgileri cookie formatÄ±nda saklanÄ±r

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 37
```python
import json
import base64
from datetime import datetime
from flask import Flask, request, make_response

@app.route('/login', methods=['POST'])
def login():
    session_data = {
        'user_id': user.id,
        'username': user.username,
        'login_time': datetime.utcnow().isoformat(),
        'roles': user.roles
    }
    
    serialized_data = json.dumps(session_data)
    encoded_data = base64.b64encode(serialized_data.encode('utf-8')).decode('utf-8')
    
    response = make_response({'status': 'success'})
    response.set_cookie('UserSession', encoded_data, 
                       httponly=True, secure=True, samesite='Strict')
    
    return response

@app.route('/profile')
def get_profile():
    cookie_value = request.cookies.get('UserSession')
    
    if cookie_value:
        decoded_data = base64.b64decode(cookie_value.encode('utf-8')).decode('utf-8')
        session_data = json.loads(decoded_data)
        
        return {
            'user_id': session_data['user_id'],
            'username': session_data['username']
        }
    
    return {'error': 'Unauthorized'}, 401
```
### ðŸ§ª Senaryo 1: Bir web uygulamasÄ±nda kullanÄ±cÄ± oturum bilgileri cookie formatÄ±nda saklanÄ±r

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 44
```typescript
import { Request, Response } from 'express';

interface UserSession {
  userId: string;
  username: string;
  loginTime: string;
  roles: string[];
}

export const login = (req: Request, res: Response) => {
  const sessionData: UserSession = {
    userId: user.id,
    username: user.username,
    loginTime: new Date().toISOString(),
    roles: user.roles
  };
  
  const serializedData = JSON.stringify(sessionData);
  const encodedData = Buffer.from(serializedData, 'utf-8').toString('base64');
  
  res.cookie('UserSession', encodedData, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  });
  
  res.json({ status: 'success' });
};

export const getProfile = (req: Request, res: Response) => {
  const cookieValue = req.cookies.UserSession;
  
  if (cookieValue) {
    const decodedData = Buffer.from(cookieValue, 'base64').toString('utf-8');
    const sessionData: UserSession = JSON.parse(decodedData);
    
    res.json({
      userId: sessionData.userId,
      username: sessionData.username
    });
  } else {
    res.status(401).json({ error: 'Unauthorized' });
  }
};
```
### ðŸ§ª Senaryo 2: Bir dosya paylaÅŸÄ±m uygulamasÄ±nda kullanÄ±cÄ± tercihleri dosya formatÄ±nda kaydedilir

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 37
```csharp
[Serializable]
public class UserPreferences
{
    public string Theme { get; set; }
    public int PageSize { get; set; }
    public List<string> FavoriteTypes { get; set; }
    public bool AutoDownload { get; set; }
}

public class PreferencesService
{
    private readonly string _preferencesPath = "preferences.dat";
    
    public void SavePreferences(UserPreferences preferences)
    {
        using var stream = new FileStream(_preferencesPath, FileMode.Create);
        var formatter = new BinaryFormatter();
        formatter.Serialize(stream, preferences);
    }
    
    public UserPreferences LoadPreferences()
    {
        if (!File.Exists(_preferencesPath))
            return new UserPreferences();
            
        using var stream = new FileStream(_preferencesPath, FileMode.Open);
        var formatter = new BinaryFormatter();
        return (UserPreferences)formatter.Deserialize(stream);
    }
    
    public void UpdateTheme(string newTheme)
    {
        var preferences = LoadPreferences();
        preferences.Theme = newTheme;
        SavePreferences(preferences);
    }
}
```
### ðŸ§ª Senaryo 2: Bir dosya paylaÅŸÄ±m uygulamasÄ±nda kullanÄ±cÄ± tercihleri dosya formatÄ±nda kaydedilir

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 35
```python
import pickle
import os
from dataclasses import dataclass
from typing import List

@dataclass
class UserPreferences:
    theme: str = "light"
    page_size: int = 20
    favorite_types: List[str] = None
    auto_download: bool = False
    
    def __post_init__(self):
        if self.favorite_types is None:
            self.favorite_types = []

class PreferencesService:
    def __init__(self, preferences_path="preferences.dat"):
        self.preferences_path = preferences_path
    
    def save_preferences(self, preferences: UserPreferences):
        with open(self.preferences_path, 'wb') as f:
            pickle.dump(preferences, f)
    
    def load_preferences(self) -> UserPreferences:
        if not os.path.exists(self.preferences_path):
            return UserPreferences()
        
        with open(self.preferences_path, 'rb') as f:
            return pickle.load(f)
    
    def update_theme(self, new_theme: str):
        preferences = self.load_preferences()
        preferences.theme = new_theme
        self.save_preferences(preferences)
```
### ðŸ§ª Senaryo 2: Bir dosya paylaÅŸÄ±m uygulamasÄ±nda kullanÄ±cÄ± tercihleri dosya formatÄ±nda kaydedilir

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 46
```typescript
import * as fs from 'fs';
import * as path from 'path';

interface UserPreferences {
  theme: string;
  pageSize: number;
  favoriteTypes: string[];
  autoDownload: boolean;
}

class PreferencesService {
  private preferencesPath = 'preferences.json';
  
  savePreferences(preferences: UserPreferences): void {
    const serializedData = JSON.stringify(preferences, null, 2);
    fs.writeFileSync(this.preferencesPath, serializedData, 'utf-8');
  }
  
  loadPreferences(): UserPreferences {
    if (!fs.existsSync(this.preferencesPath)) {
      return {
        theme: 'light',
        pageSize: 20,
        favoriteTypes: [],
        autoDownload: false
      };
    }
    
    const fileContent = fs.readFileSync(this.preferencesPath, 'utf-8');
    return JSON.parse(fileContent) as UserPreferences;
  }
  
  updateTheme(newTheme: string): void {
    const preferences = this.loadPreferences();
    preferences.theme = newTheme;
    this.savePreferences(preferences);
  }
  
  addFavoriteType(fileType: string): void {
    const preferences = this.loadPreferences();
    if (!preferences.favoriteTypes.includes(fileType)) {
      preferences.favoriteTypes.push(fileType);
      this.savePreferences(preferences);
    }
  }
}
```
### ðŸ§ª Senaryo 3: Bir oyun uygulamasÄ±nda oyuncu ilerlemesi kayÄ±t dosyalarÄ±nda tutulur

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 40
```csharp
[Serializable]
public class GameProgress
{
    public int Level { get; set; }
    public int Score { get; set; }
    public Vector3 PlayerPosition { get; set; }
    public List<string> UnlockedItems { get; set; }
    public DateTime LastSaved { get; set; }
}

public class SaveGameService
{
    private readonly string _saveDirectory = "saves";
    
    public void SaveProgress(string playerId, GameProgress progress)
    {
        Directory.CreateDirectory(_saveDirectory);
        var fileName = Path.Combine(_saveDirectory, $"{playerId}.save");
        
        progress.LastSaved = DateTime.UtcNow;
        
        using var fileStream = new FileStream(fileName, FileMode.Create);
        using var gzipStream = new GZipStream(fileStream, CompressionMode.Compress);
        var formatter = new BinaryFormatter();
        formatter.Serialize(gzipStream, progress);
    }
    
    public GameProgress LoadProgress(string playerId)
    {
        var fileName = Path.Combine(_saveDirectory, $"{playerId}.save");
        
        if (!File.Exists(fileName))
            return new GameProgress { Level = 1, Score = 0, UnlockedItems = new List<string>() };
        
        using var fileStream = new FileStream(fileName, FileMode.Open);
        using var gzipStream = new GZipStream(fileStream, CompressionMode.Decompress);
        var formatter = new BinaryFormatter();
        return (GameProgress)formatter.Deserialize(gzipStream);
    }
}
```
### ðŸ§ª Senaryo 3: Bir oyun uygulamasÄ±nda oyuncu ilerlemesi kayÄ±t dosyalarÄ±nda tutulur

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 45
```python
import pickle
import gzip
import os
from datetime import datetime
from dataclasses import dataclass
from typing import List, Tuple

@dataclass
class GameProgress:
    level: int = 1
    score: int = 0
    player_position: Tuple[float, float, float] = (0.0, 0.0, 0.0)
    unlocked_items: List[str] = None
    last_saved: datetime = None
    
    def __post_init__(self):
        if self.unlocked_items is None:
            self.unlocked_items = []

class SaveGameService:
    def __init__(self, save_directory="saves"):
        self.save_directory = save_directory
        os.makedirs(save_directory, exist_ok=True)
    
    def save_progress(self, player_id: str, progress: GameProgress):
        file_name = os.path.join(self.save_directory, f"{player_id}.save")
        progress.last_saved = datetime.utcnow()
        
        with gzip.open(file_name, 'wb') as f:
            pickle.dump(progress, f)
    
    def load_progress(self, player_id: str) -> GameProgress:
        file_name = os.path.join(self.save_directory, f"{player_id}.save")
        
        if not os.path.exists(file_name):
            return GameProgress()
        
        with gzip.open(file_name, 'rb') as f:
            return pickle.load(f)
    
    def unlock_item(self, player_id: str, item_name: str):
        progress = self.load_progress(player_id)
        if item_name not in progress.unlocked_items:
            progress.unlocked_items.append(item_name)
            self.save_progress(player_id, progress)
```
### ðŸ§ª Senaryo 3: Bir oyun uygulamasÄ±nda oyuncu ilerlemesi kayÄ±t dosyalarÄ±nda tutulur

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 55
```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as zlib from 'zlib';

interface Vector3 {
  x: number;
  y: number;
  z: number;
}

interface GameProgress {
  level: number;
  score: number;
  playerPosition: Vector3;
  unlockedItems: string[];
  lastSaved: string;
}

class SaveGameService {
  private saveDirectory = 'saves';
  
  constructor() {
    if (!fs.existsSync(this.saveDirectory)) {
      fs.mkdirSync(this.saveDirectory, { recursive: true });
    }
  }
  
  saveProgress(playerId: string, progress: GameProgress): void {
    const fileName = path.join(this.saveDirectory, `${playerId}.save`);
    progress.lastSaved = new Date().toISOString();
    
    const serializedData = JSON.stringify(progress);
    const compressedData = zlib.gzipSync(Buffer.from(serializedData, 'utf-8'));
    
    fs.writeFileSync(fileName, compressedData);
  }
  
  loadProgress(playerId: string): GameProgress {
    const fileName = path.join(this.saveDirectory, `${playerId}.save`);
    
    if (!fs.existsSync(fileName)) {
      return {
        level: 1,
        score: 0,
        playerPosition: { x: 0, y: 0, z: 0 },
        unlockedItems: [],
        lastSaved: new Date().toISOString()
      };
    }
    
    const compressedData = fs.readFileSync(fileName);
    const decompressedData = zlib.gunzipSync(compressedData);
    return JSON.parse(decompressedData.toString('utf-8')) as GameProgress;
  }
}
```
### ðŸ§ª Senaryo 4: Bir API uygulamasÄ±nda istemci verileri JSON formatÄ±nda alÄ±nÄ±r

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 62
```csharp
public class ProductDto
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Category { get; set; }
    public List<string> Tags { get; set; }
}

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Category { get; set; }
    public string[] Tags { get; set; }
    public DateTime CreatedAt { get; set; }
}

[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    [HttpPost]
    public async Task<IActionResult> CreateProduct([FromBody] ProductDto dto)
    {
        var product = new Product
        {
            Name = dto.Name,
            Price = dto.Price,
            Category = dto.Category,
            Tags = dto.Tags?.ToArray() ?? Array.Empty<string>(),
            CreatedAt = DateTime.UtcNow
        };
        
        await _productRepository.AddAsync(product);
        
        var responseDto = new ProductDto
        {
            Name = product.Name,
            Price = product.Price,
            Category = product.Category,
            Tags = product.Tags?.ToList() ?? new List<string>()
        };
        
        return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, responseDto);
    }
    
    [HttpGet("{id}")]
    public async Task<ActionResult<ProductDto>> GetProduct(int id)
    {
        var product = await _productRepository.GetByIdAsync(id);
        if (product == null) return NotFound();
        
        return new ProductDto
        {
            Name = product.Name,
            Price = product.Price,
            Category = product.Category,
            Tags = product.Tags?.ToList() ?? new List<string>()
        };
    }
}
```
### ðŸ§ª Senaryo 4: Bir API uygulamasÄ±nda istemci verileri JSON formatÄ±nda alÄ±nÄ±r

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 72
```python
from dataclasses import dataclass, asdict
from typing import List, Optional
from datetime import datetime
import json
from flask import Flask, request, jsonify

@dataclass
class ProductDto:
    name: str
    price: float
    category: str
    tags: List[str]

@dataclass 
class Product:
    id: Optional[int]
    name: str
    price: float
    category: str
    tags: List[str]
    created_at: datetime

@app.route('/api/products', methods=['POST'])
def create_product():
    data = request.get_json()
    
    # Deserialize JSON to DTO
    dto = ProductDto(
        name=data['name'],
        price=data['price'],
        category=data['category'],
        tags=data.get('tags', [])
    )
    
    # Convert DTO to domain object
    product = Product(
        id=None,
        name=dto.name,
        price=dto.price,
        category=dto.category,
        tags=dto.tags,
        created_at=datetime.utcnow()
    )
    
    # Save to repository
    saved_product = product_repository.add(product)
    
    # Convert back to DTO for response
    response_dto = ProductDto(
        name=saved_product.name,
        price=saved_product.price,
        category=saved_product.category,
        tags=saved_product.tags
    )
    
    return jsonify(asdict(response_dto)), 201

@app.route('/api/products/<int:product_id>')
def get_product(product_id):
    product = product_repository.get_by_id(product_id)
    
    if not product:
        return jsonify({'error': 'Product not found'}), 404
    
    dto = ProductDto(
        name=product.name,
        price=product.price,
        category=product.category,
        tags=product.tags
    )
    
    return jsonify(asdict(dto))
```
### ðŸ§ª Senaryo 4: Bir API uygulamasÄ±nda istemci verileri JSON formatÄ±nda alÄ±nÄ±r

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 67
```typescript
import { Request, Response } from 'express';

interface ProductDto {
  name: string;
  price: number;
  category: string;
  tags: string[];
}

interface Product {
  id?: number;
  name: string;
  price: number;
  category: string;
  tags: string[];
  createdAt: Date;
}

class ProductsController {
  async createProduct(req: Request, res: Response): Promise<void> {
    try {
      const dto: ProductDto = req.body;
      
      // Convert DTO to domain object
      const product: Product = {
        name: dto.name,
        price: dto.price,
        category: dto.category,
        tags: dto.tags || [],
        createdAt: new Date()
      };
      
      const savedProduct = await productRepository.add(product);
      
      // Convert back to DTO for response
      const responseDto: ProductDto = {
        name: savedProduct.name,
        price: savedProduct.price,
        category: savedProduct.category,
        tags: savedProduct.tags
      };
      
      res.status(201).json(responseDto);
    } catch (error) {
      res.status(400).json({ error: 'Invalid product data' });
    }
  }
  
  async getProduct(req: Request, res: Response): Promise<void> {
    const id = parseInt(req.params.id);
    const product = await productRepository.getById(id);
    
    if (!product) {
      res.status(404).json({ error: 'Product not found' });
      return;
    }
    
    const dto: ProductDto = {
      name: product.name,
      price: product.price,
      category: product.category,
      tags: product.tags
    };
    
    res.json(dto);
  }
}
```
### ðŸ§ª Senaryo 5: Bir konfigÃ¼rasyon yÃ¶netim sisteminde ayar dosyalarÄ± YAML formatÄ±nda saklanÄ±r

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 74
```csharp
public class DatabaseConfig
{
    public string ConnectionString { get; set; }
    public int MaxConnections { get; set; }
    public int TimeoutSeconds { get; set; }
}

public class ApiConfig
{
    public string BaseUrl { get; set; }
    public int Port { get; set; }
    public List<string> AllowedOrigins { get; set; }
}

public class AppConfig
{
    public DatabaseConfig Database { get; set; }
    public ApiConfig Api { get; set; }
    public bool EnableLogging { get; set; }
    public string LogLevel { get; set; }
}

public class ConfigurationService
{
    private readonly IDeserializer _deserializer;
    private readonly ISerializer _serializer;
    
    public ConfigurationService()
    {
        _deserializer = new DeserializerBuilder()
            .WithNamingConvention(CamelCaseNamingConvention.Instance)
            .Build();
            
        _serializer = new SerializerBuilder()
            .WithNamingConvention(CamelCaseNamingConvention.Instance)
            .Build();
    }
    
    public AppConfig LoadConfiguration(string filePath = "appsettings.yml")
    {
        if (!File.Exists(filePath))
            return CreateDefaultConfig();
            
        var yamlContent = File.ReadAllText(filePath);
        return _deserializer.Deserialize<AppConfig>(yamlContent);
    }
    
    public void SaveConfiguration(AppConfig config, string filePath = "appsettings.yml")
    {
        var yamlContent = _serializer.Serialize(config);
        File.WriteAllText(filePath, yamlContent);
    }
    
    private AppConfig CreateDefaultConfig()
    {
        return new AppConfig
        {
            Database = new DatabaseConfig
            {
                ConnectionString = "Server=localhost;Database=myapp;",
                MaxConnections = 100,
                TimeoutSeconds = 30
            },
            Api = new ApiConfig
            {
                BaseUrl = "https://localhost",
                Port = 5000,
                AllowedOrigins = new List<string> { "*" }
            },
            EnableLogging = true,
            LogLevel = "Info"
        };
    }
}
```
### ðŸ§ª Senaryo 5: Bir konfigÃ¼rasyon yÃ¶netim sisteminde ayar dosyalarÄ± YAML formatÄ±nda saklanÄ±r

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 60
```python
import yaml
import os
from dataclasses import dataclass, asdict
from typing import List

@dataclass
class DatabaseConfig:
    connection_string: str = "postgresql://localhost/myapp"
    max_connections: int = 100
    timeout_seconds: int = 30

@dataclass
class ApiConfig:
    base_url: str = "https://localhost"
    port: int = 5000
    allowed_origins: List[str] = None
    
    def __post_init__(self):
        if self.allowed_origins is None:
            self.allowed_origins = ["*"]

@dataclass
class AppConfig:
    database: DatabaseConfig = None
    api: ApiConfig = None
    enable_logging: bool = True
    log_level: str = "INFO"
    
    def __post_init__(self):
        if self.database is None:
            self.database = DatabaseConfig()
        if self.api is None:
            self.api = ApiConfig()

class ConfigurationService:
    def __init__(self, config_file="appsettings.yml"):
        self.config_file = config_file
    
    def load_configuration(self) -> AppConfig:
        if not os.path.exists(self.config_file):
            return self._create_default_config()
        
        with open(self.config_file, 'r') as f:
            data = yaml.safe_load(f)
        
        return AppConfig(
            database=DatabaseConfig(**data.get('database', {})),
            api=ApiConfig(**data.get('api', {})),
            enable_logging=data.get('enable_logging', True),
            log_level=data.get('log_level', 'INFO')
        )
    
    def save_configuration(self, config: AppConfig):
        config_dict = asdict(config)
        
        with open(self.config_file, 'w') as f:
            yaml.dump(config_dict, f, default_flow_style=False, indent=2)
    
    def _create_default_config(self) -> AppConfig:
        return AppConfig()
```
### ðŸ§ª Senaryo 5: Bir konfigÃ¼rasyon yÃ¶netim sisteminde ayar dosyalarÄ± YAML formatÄ±nda saklanÄ±r

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 75
```typescript
import * as yaml from 'js-yaml';
import * as fs from 'fs';

interface DatabaseConfig {
  connectionString: string;
  maxConnections: number;
  timeoutSeconds: number;
}

interface ApiConfig {
  baseUrl: string;
  port: number;
  allowedOrigins: string[];
}

interface AppConfig {
  database: DatabaseConfig;
  api: ApiConfig;
  enableLogging: boolean;
  logLevel: string;
}

class ConfigurationService {
  private configFile: string;
  
  constructor(configFile = 'appsettings.yml') {
    this.configFile = configFile;
  }
  
  loadConfiguration(): AppConfig {
    if (!fs.existsSync(this.configFile)) {
      return this.createDefaultConfig();
    }
    
    const fileContent = fs.readFileSync(this.configFile, 'utf-8');
    const data = yaml.load(fileContent) as any;
    
    return {
      database: {
        connectionString: data.database?.connectionString || 'mongodb://localhost/myapp',
        maxConnections: data.database?.maxConnections || 100,
        timeoutSeconds: data.database?.timeoutSeconds || 30
      },
      api: {
        baseUrl: data.api?.baseUrl || 'https://localhost',
        port: data.api?.port || 5000,
        allowedOrigins: data.api?.allowedOrigins || ['*']
      },
      enableLogging: data.enableLogging ?? true,
      logLevel: data.logLevel || 'info'
    };
  }
  
  saveConfiguration(config: AppConfig): void {
    const yamlContent = yaml.dump(config, { indent: 2 });
    fs.writeFileSync(this.configFile, yamlContent, 'utf-8');
  }
  
  private createDefaultConfig(): AppConfig {
    return {
      database: {
        connectionString: 'mongodb://localhost/myapp',
        maxConnections: 100,
        timeoutSeconds: 30
      },
      api: {
        baseUrl: 'https://localhost',
        port: 5000,
        allowedOrigins: ['*']
      },
      enableLogging: true,
      logLevel: 'info'
    };
  }
}
```
### ðŸ§ª Senaryo 6: Bir mesajlaÅŸma uygulamasÄ±nda mesaj geÃ§miÅŸi arÅŸiv formatÄ±nda kaydedilir

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 74
```csharp
[Serializable]
public class Message
{
    public Guid Id { get; set; }
    public string SenderId { get; set; }
    public string ReceiverId { get; set; }
    public string Content { get; set; }
    public DateTime Timestamp { get; set; }
    public MessageType Type { get; set; }
}

public enum MessageType : byte
{
    Text = 0,
    Image = 1,
    File = 2,
    System = 3
}

public class MessageArchiveService
{
    public void ArchiveMessages(string conversationId, List<Message> messages)
    {
        var archivePath = $"archives/{conversationId}.arch";
        Directory.CreateDirectory(Path.GetDirectoryName(archivePath));
        
        using var fileStream = new FileStream(archivePath, FileMode.Create);
        using var gzipStream = new GZipStream(fileStream, CompressionMode.Compress);
        using var binaryWriter = new BinaryWriter(gzipStream);
        
        binaryWriter.Write(messages.Count);
        
        foreach (var message in messages)
        {
            binaryWriter.Write(message.Id.ToByteArray());
            binaryWriter.Write(message.SenderId ?? string.Empty);
            binaryWriter.Write(message.ReceiverId ?? string.Empty);
            binaryWriter.Write(message.Content ?? string.Empty);
            binaryWriter.Write(message.Timestamp.ToBinary());
            binaryWriter.Write((byte)message.Type);
        }
    }
    
    public List<Message> LoadArchivedMessages(string conversationId)
    {
        var archivePath = $"archives/{conversationId}.arch";
        if (!File.Exists(archivePath)) return new List<Message>();
        
        var messages = new List<Message>();
        
        using var fileStream = new FileStream(archivePath, FileMode.Open);
        using var gzipStream = new GZipStream(fileStream, CompressionMode.Decompress);
        using var binaryReader = new BinaryReader(gzipStream);
        
        var count = binaryReader.ReadInt32();
        
        for (int i = 0; i < count; i++)
        {
            var message = new Message
            {
                Id = new Guid(binaryReader.ReadBytes(16)),
                SenderId = binaryReader.ReadString(),
                ReceiverId = binaryReader.ReadString(),
                Content = binaryReader.ReadString(),
                Timestamp = DateTime.FromBinary(binaryReader.ReadInt64()),
                Type = (MessageType)binaryReader.ReadByte()
            };
            
            messages.Add(message);
        }
        
        return messages;
    }
}
```
### ðŸ§ª Senaryo 6: Bir mesajlaÅŸma uygulamasÄ±nda mesaj geÃ§miÅŸi arÅŸiv formatÄ±nda kaydedilir

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 107
```python
import gzip
import struct
import os
from dataclasses import dataclass
from datetime import datetime
from typing import List
from enum import IntEnum
import uuid

class MessageType(IntEnum):
    TEXT = 0
    IMAGE = 1
    FILE = 2
    SYSTEM = 3

@dataclass
class Message:
    id: str
    sender_id: str
    receiver_id: str
    content: str
    timestamp: datetime
    message_type: MessageType

class MessageArchiveService:
    def __init__(self, archive_dir="archives"):
        self.archive_dir = archive_dir
        os.makedirs(archive_dir, exist_ok=True)
    
    def archive_messages(self, conversation_id: str, messages: List[Message]):
        archive_path = os.path.join(self.archive_dir, f"{conversation_id}.arch")
        
        with gzip.open(archive_path, 'wb') as f:
            # Write message count
            f.write(struct.pack('I', len(messages)))
            
            for message in messages:
                # Write message data in binary format
                message_data = {
                    'id': message.id,
                    'sender_id': message.sender_id,
                    'receiver_id': message.receiver_id,
                    'content': message.content,
                    'timestamp': message.timestamp.timestamp(),
                    'type': int(message.message_type)
                }
                
                # Write each field with length prefix for strings
                id_bytes = message.id.encode('utf-8')
                f.write(struct.pack('I', len(id_bytes)))
                f.write(id_bytes)
                
                sender_bytes = message.sender_id.encode('utf-8')
                f.write(struct.pack('I', len(sender_bytes)))
                f.write(sender_bytes)
                
                receiver_bytes = message.receiver_id.encode('utf-8')
                f.write(struct.pack('I', len(receiver_bytes)))
                f.write(receiver_bytes)
                
                content_bytes = message.content.encode('utf-8')
                f.write(struct.pack('I', len(content_bytes)))
                f.write(content_bytes)
                
                f.write(struct.pack('d', message.timestamp.timestamp()))
                f.write(struct.pack('B', int(message.message_type)))
    
    def load_archived_messages(self, conversation_id: str) -> List[Message]:
        archive_path = os.path.join(self.archive_dir, f"{conversation_id}.arch")
        
        if not os.path.exists(archive_path):
            return []
        
        messages = []
        
        with gzip.open(archive_path, 'rb') as f:
            count = struct.unpack('I', f.read(4))[0]
            
            for _ in range(count):
                # Read message data
                id_len = struct.unpack('I', f.read(4))[0]
                message_id = f.read(id_len).decode('utf-8')
                
                sender_len = struct.unpack('I', f.read(4))[0]
                sender_id = f.read(sender_len).decode('utf-8')
                
                receiver_len = struct.unpack('I', f.read(4))[0]
                receiver_id = f.read(receiver_len).decode('utf-8')
                
                content_len = struct.unpack('I', f.read(4))[0]
                content = f.read(content_len).decode('utf-8')
                
                timestamp = datetime.fromtimestamp(struct.unpack('d', f.read(8))[0])
                message_type = MessageType(struct.unpack('B', f.read(1))[0])
                
                message = Message(
                    id=message_id,
                    sender_id=sender_id,
                    receiver_id=receiver_id,
                    content=content,
                    timestamp=timestamp,
                    message_type=message_type
                )
                
                messages.append(message)
        
        return messages
```
### ðŸ§ª Senaryo 6: Bir mesajlaÅŸma uygulamasÄ±nda mesaj geÃ§miÅŸi arÅŸiv formatÄ±nda kaydedilir

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 76
```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as zlib from 'zlib';

enum MessageType {
  TEXT = 0,
  IMAGE = 1,
  FILE = 2,
  SYSTEM = 3
}

interface Message {
  id: string;
  senderId: string;
  receiverId: string;
  content: string;
  timestamp: Date;
  type: MessageType;
}

class MessageArchiveService {
  private archiveDir = 'archives';
  
  constructor() {
    if (!fs.existsSync(this.archiveDir)) {
      fs.mkdirSync(this.archiveDir, { recursive: true });
    }
  }
  
  archiveMessages(conversationId: string, messages: Message[]): void {
    const archivePath = path.join(this.archiveDir, `${conversationId}.arch`);
    
    // Convert messages to JSON and compress
    const serializedData = JSON.stringify(messages.map(msg => ({
      id: msg.id,
      senderId: msg.senderId,
      receiverId: msg.receiverId,
      content: msg.content,
      timestamp: msg.timestamp.toISOString(),
      type: msg.type
    })));
    
    const compressedData = zlib.gzipSync(Buffer.from(serializedData, 'utf-8'));
    fs.writeFileSync(archivePath, compressedData);
  }
  
  loadArchivedMessages(conversationId: string): Message[] {
    const archivePath = path.join(this.archiveDir, `${conversationId}.arch`);
    
    if (!fs.existsSync(archivePath)) {
      return [];
    }
    
    const compressedData = fs.readFileSync(archivePath);
    const decompressedData = zlib.gunzipSync(compressedData);
    const serializedData = decompressedData.toString('utf-8');
    
    const rawMessages = JSON.parse(serializedData);
    
    return rawMessages.map((msg: any) => ({
      id: msg.id,
      senderId: msg.senderId,
      receiverId: msg.receiverId,
      content: msg.content,
      timestamp: new Date(msg.timestamp),
      type: msg.type as MessageType
    }));
  }
  
  searchInArchive(conversationId: string, searchTerm: string): Message[] {
    const messages = this.loadArchivedMessages(conversationId);
    return messages.filter(msg => 
      msg.content.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }
}
```
### ðŸ§ª Senaryo 7: Bir cache sistemi veri nesnelerini hÄ±zlÄ± eriÅŸim iÃ§in depolar

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 96
```csharp
public class CacheEntry<T>
{
    public T Data { get; set; }
    public DateTime ExpiresAt { get; set; }
    public TimeSpan SlidingExpiration { get; set; }
    public DateTime LastAccessed { get; set; }
}

public class MemoryCache
{
    private readonly ConcurrentDictionary<string, byte[]> _cache = new();
    private readonly Timer _cleanupTimer;
    
    public MemoryCache()
    {
        _cleanupTimer = new Timer(CleanupExpiredEntries, null, 
            TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));
    }
    
    public void Set<T>(string key, T value, TimeSpan? expiration = null)
    {
        var entry = new CacheEntry<T>
        {
            Data = value,
            ExpiresAt = DateTime.UtcNow.Add(expiration ?? TimeSpan.FromHours(1)),
            SlidingExpiration = expiration ?? TimeSpan.FromHours(1),
            LastAccessed = DateTime.UtcNow
        };
        
        using var stream = new MemoryStream();
        var formatter = new BinaryFormatter();
        formatter.Serialize(stream, entry);
        
        _cache.TryAdd(key, stream.ToArray());
    }
    
    public T Get<T>(string key)
    {
        if (_cache.TryGetValue(key, out var data))
        {
            using var stream = new MemoryStream(data);
            var formatter = new BinaryFormatter();
            var entry = (CacheEntry<T>)formatter.Deserialize(stream);
            
            if (entry.ExpiresAt > DateTime.UtcNow)
            {
                // Update last accessed and sliding expiration
                entry.LastAccessed = DateTime.UtcNow;
                entry.ExpiresAt = DateTime.UtcNow.Add(entry.SlidingExpiration);
                
                // Re-serialize with updated timestamp
                using var updateStream = new MemoryStream();
                formatter.Serialize(updateStream, entry);
                _cache.TryUpdate(key, updateStream.ToArray(), data);
                
                return entry.Data;
            }
            else
            {
                _cache.TryRemove(key, out _);
            }
        }
        
        return default(T);
    }
    
    private void CleanupExpiredEntries(object state)
    {
        var expiredKeys = new List<string>();
        var now = DateTime.UtcNow;
        
        foreach (var kvp in _cache)
        {
            try
            {
                using var stream = new MemoryStream(kvp.Value);
                var formatter = new BinaryFormatter();
                var entry = formatter.Deserialize(stream) as dynamic;
                
                if (entry?.ExpiresAt < now)
                {
                    expiredKeys.Add(kvp.Key);
                }
            }
            catch
            {
                expiredKeys.Add(kvp.Key);
            }
        }
        
        foreach (var key in expiredKeys)
        {
            _cache.TryRemove(key, out _);
        }
    }
}
```
### ðŸ§ª Senaryo 7: Bir cache sistemi veri nesnelerini hÄ±zlÄ± eriÅŸim iÃ§in depolar

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 90
```python
import pickle
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
from dataclasses import dataclass

@dataclass
class CacheEntry:
    data: Any
    expires_at: datetime
    sliding_expiration: timedelta
    last_accessed: datetime

class MemoryCache:
    def __init__(self):
        self._cache: Dict[str, bytes] = {}
        self._lock = threading.RLock()
        self._cleanup_thread = threading.Thread(target=self._cleanup_expired_entries, daemon=True)
        self._cleanup_thread.start()
    
    def set(self, key: str, value: Any, expiration: Optional[timedelta] = None) -> None:
        if expiration is None:
            expiration = timedelta(hours=1)
        
        entry = CacheEntry(
            data=value,
            expires_at=datetime.now() + expiration,
            sliding_expiration=expiration,
            last_accessed=datetime.now()
        )
        
        serialized_entry = pickle.dumps(entry)
        
        with self._lock:
            self._cache[key] = serialized_entry
    
    def get(self, key: str) -> Any:
        with self._lock:
            if key not in self._cache:
                return None
            
            try:
                entry = pickle.loads(self._cache[key])
                
                if entry.expires_at > datetime.now():
                    # Update last accessed and sliding expiration
                    entry.last_accessed = datetime.now()
                    entry.expires_at = datetime.now() + entry.sliding_expiration
                    
                    # Re-serialize with updated timestamp
                    self._cache[key] = pickle.dumps(entry)
                    
                    return entry.data
                else:
                    # Entry expired, remove it
                    del self._cache[key]
                    return None
                    
            except (pickle.PickleError, AttributeError):
                # Corrupted entry, remove it
                del self._cache[key]
                return None
    
    def remove(self, key: str) -> bool:
        with self._lock:
            return self._cache.pop(key, None) is not None
    
    def clear(self) -> None:
        with self._lock:
            self._cache.clear()
    
    def _cleanup_expired_entries(self):
        while True:
            time.sleep(300)  # Run every 5 minutes
            
            expired_keys = []
            now = datetime.now()
            
            with self._lock:
                for key, serialized_entry in self._cache.items():
                    try:
                        entry = pickle.loads(serialized_entry)
                        if entry.expires_at < now:
                            expired_keys.append(key)
                    except:
                        expired_keys.append(key)
                
                for key in expired_keys:
                    self._cache.pop(key, None)
```
### ðŸ§ª Senaryo 7: Bir cache sistemi veri nesnelerini hÄ±zlÄ± eriÅŸim iÃ§in depolar

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 118
```typescript
interface CacheEntry<T> {
  data: T;
  expiresAt: Date;
  slidingExpiration: number; // milliseconds
  lastAccessed: Date;
}

class MemoryCache {
  private cache = new Map<string, string>();
  private cleanupTimer: NodeJS.Timeout;
  
  constructor() {
    // Run cleanup every 5 minutes
    this.cleanupTimer = setInterval(() => {
      this.cleanupExpiredEntries();
    }, 5 * 60 * 1000);
  }
  
  set<T>(key: string, value: T, expiration = 60 * 60 * 1000): void { // 1 hour default
    const entry: CacheEntry<T> = {
      data: value,
      expiresAt: new Date(Date.now() + expiration),
      slidingExpiration: expiration,
      lastAccessed: new Date()
    };
    
    const serializedEntry = JSON.stringify(entry, (key, value) => {
      if (key === 'expiresAt' || key === 'lastAccessed') {
        return value instanceof Date ? value.toISOString() : value;
      }
      return value;
    });
    
    this.cache.set(key, serializedEntry);
  }
  
  get<T>(key: string): T | null {
    const serializedEntry = this.cache.get(key);
    
    if (!serializedEntry) {
      return null;
    }
    
    try {
      const entry: CacheEntry<T> = JSON.parse(serializedEntry, (key, value) => {
        if (key === 'expiresAt' || key === 'lastAccessed') {
          return new Date(value);
        }
        return value;
      });
      
      const now = new Date();
      
      if (entry.expiresAt > now) {
        // Update last accessed and sliding expiration
        entry.lastAccessed = now;
        entry.expiresAt = new Date(now.getTime() + entry.slidingExpiration);
        
        // Re-serialize with updated timestamp
        const updatedSerialized = JSON.stringify(entry, (key, value) => {
          if (key === 'expiresAt' || key === 'lastAccessed') {
            return value instanceof Date ? value.toISOString() : value;
          }
          return value;
        });
        
        this.cache.set(key, updatedSerialized);
        
        return entry.data;
      } else {
        // Entry expired, remove it
        this.cache.delete(key);
        return null;
      }
    } catch (error) {
      // Corrupted entry, remove it
      this.cache.delete(key);
      return null;
    }
  }
  
  remove(key: string): boolean {
    return this.cache.delete(key);
  }
  
  clear(): void {
    this.cache.clear();
  }
  
  private cleanupExpiredEntries(): void {
    const now = new Date();
    const expiredKeys: string[] = [];
    
    for (const [key, serializedEntry] of this.cache.entries()) {
      try {
        const entry = JSON.parse(serializedEntry, (key, value) => {
          if (key === 'expiresAt' || key === 'lastAccessed') {
            return new Date(value);
          }
          return value;
        });
        
        if (entry.expiresAt < now) {
          expiredKeys.push(key);
        }
      } catch {
        expiredKeys.push(key);
      }
    }
    
    expiredKeys.forEach(key => this.cache.delete(key));
  }
  
  destroy(): void {
    clearInterval(this.cleanupTimer);
    this.cache.clear();
  }
}
```
### ðŸ§ª Senaryo 8: Bir rapor uygulamasÄ±nda ÅŸablon dosyalarÄ± Ã¶zel formatta kaydedilir

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 109
```csharp
public class ReportTemplate
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public List<ReportSection> Sections { get; set; }
    public Dictionary<string, object> Parameters { get; set; }
    public DateTime CreatedAt { get; set; }
}

public class ReportSection
{
    public string Type { get; set; } // "table", "chart", "text"
    public string Title { get; set; }
    public Dictionary<string, object> Properties { get; set; }
    public string DataSource { get; set; }
}

public class ReportTemplateService
{
    private readonly string _templatesPath = "templates";
    
    public ReportTemplateService()
    {
        Directory.CreateDirectory(_templatesPath);
    }
    
    public void SaveTemplate(ReportTemplate template)
    {
        var fileName = Path.Combine(_templatesPath, $"{template.Id}.rpt");
        
        var templateData = new
        {
            Metadata = new
            {
                template.Id,
                template.Name,
                template.Description,
                template.CreatedAt
            },
            Sections = template.Sections,
            Parameters = template.Parameters
        };
        
        var jsonContent = JsonSerializer.Serialize(templateData, new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });
        
        File.WriteAllText(fileName, jsonContent);
    }
    
    public ReportTemplate LoadTemplate(string templateId)
    {
        var fileName = Path.Combine(_templatesPath, $"{templateId}.rpt");
        
        if (!File.Exists(fileName))
            throw new FileNotFoundException($"Template {templateId} not found");
        
        var jsonContent = File.ReadAllText(fileName);
        var templateData = JsonSerializer.Deserialize<dynamic>(jsonContent);
        
        return JsonSerializer.Deserialize<ReportTemplate>(jsonContent, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });
    }
    
    public Report GenerateReport(string templateId, Dictionary<string, object> data)
    {
        var template = LoadTemplate(templateId);
        var report = new Report
        {
            Id = Guid.NewGuid().ToString(),
            TemplateId = templateId,
            GeneratedAt = DateTime.UtcNow,
            Sections = new List<ReportSection>()
        };
        
        foreach (var section in template.Sections)
        {
            var processedSection = ProcessSection(section, data);
            report.Sections.Add(processedSection);
        }
        
        return report;
    }
    
    private ReportSection ProcessSection(ReportSection template, Dictionary<string, object> data)
    {
        return new ReportSection
        {
            Type = template.Type,
            Title = ReplacePlaceholders(template.Title, data),
            Properties = template.Properties,
            DataSource = template.DataSource
        };
    }
    
    private string ReplacePlaceholders(string text, Dictionary<string, object> data)
    {
        foreach (var kvp in data)
        {
            text = text.Replace($"{{{kvp.Key}}}", kvp.Value?.ToString() ?? "");
        }
        return text;
    }
}
```
### ðŸ§ª Senaryo 8: Bir rapor uygulamasÄ±nda ÅŸablon dosyalarÄ± Ã¶zel formatta kaydedilir

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 101
```python
import json
import os
from datetime import datetime
from dataclasses import dataclass, asdict
from typing import Dict, List, Any, Optional

@dataclass
class ReportSection:
    section_type: str  # "table", "chart", "text"
    title: str
    properties: Dict[str, Any]
    data_source: str

@dataclass
class ReportTemplate:
    id: str
    name: str
    description: str
    sections: List[ReportSection]
    parameters: Dict[str, Any]
    created_at: datetime

@dataclass
class Report:
    id: str
    template_id: str
    generated_at: datetime
    sections: List[ReportSection]

class ReportTemplateService:
    def __init__(self, templates_path="templates"):
        self.templates_path = templates_path
        os.makedirs(templates_path, exist_ok=True)
    
    def save_template(self, template: ReportTemplate):
        file_name = os.path.join(self.templates_path, f"{template.id}.rpt")
        
        template_data = {
            "metadata": {
                "id": template.id,
                "name": template.name,
                "description": template.description,
                "created_at": template.created_at.isoformat()
            },
            "sections": [asdict(section) for section in template.sections],
            "parameters": template.parameters
        }
        
        with open(file_name, 'w') as f:
            json.dump(template_data, f, indent=2)
    
    def load_template(self, template_id: str) -> ReportTemplate:
        file_name = os.path.join(self.templates_path, f"{template_id}.rpt")
        
        if not os.path.exists(file_name):
            raise FileNotFoundError(f"Template {template_id} not found")
        
        with open(file_name, 'r') as f:
            template_data = json.load(f)
        
        metadata = template_data["metadata"]
        sections = [
            ReportSection(**section) for section in template_data["sections"]
        ]
        
        return ReportTemplate(
            id=metadata["id"],
            name=metadata["name"],
            description=metadata["description"],
            sections=sections,
            parameters=template_data["parameters"],
            created_at=datetime.fromisoformat(metadata["created_at"])
        )
    
    def generate_report(self, template_id: str, data: Dict[str, Any]) -> Report:
        template = self.load_template(template_id)
        
        processed_sections = [
            self._process_section(section, data) for section in template.sections
        ]
        
        return Report(
            id=str(uuid.uuid4()),
            template_id=template_id,
            generated_at=datetime.utcnow(),
            sections=processed_sections
        )
    
    def _process_section(self, template_section: ReportSection, data: Dict[str, Any]) -> ReportSection:
        return ReportSection(
            section_type=template_section.section_type,
            title=self._replace_placeholders(template_section.title, data),
            properties=template_section.properties,
            data_source=template_section.data_source
        )
    
    def _replace_placeholders(self, text: str, data: Dict[str, Any]) -> str:
        for key, value in data.items():
            placeholder = f"{{{key}}}"
            text = text.replace(placeholder, str(value) if value is not None else "")
        return text
```
### ðŸ§ª Senaryo 8: Bir rapor uygulamasÄ±nda ÅŸablon dosyalarÄ± Ã¶zel formatta kaydedilir

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 109
```typescript
import * as fs from 'fs';
import * as path from 'path';

interface ReportSection {
  type: string; // "table", "chart", "text"
  title: string;
  properties: Record<string, any>;
  dataSource: string;
}

interface ReportTemplate {
  id: string;
  name: string;
  description: string;
  sections: ReportSection[];
  parameters: Record<string, any>;
  createdAt: Date;
}

interface Report {
  id: string;
  templateId: string;
  generatedAt: Date;
  sections: ReportSection[];
}

class ReportTemplateService {
  private templatesPath: string;
  
  constructor(templatesPath = 'templates') {
    this.templatesPath = templatesPath;
    if (!fs.existsSync(templatesPath)) {
      fs.mkdirSync(templatesPath, { recursive: true });
    }
  }
  
  saveTemplate(template: ReportTemplate): void {
    const fileName = path.join(this.templatesPath, `${template.id}.rpt`);
    
    const templateData = {
      metadata: {
        id: template.id,
        name: template.name,
        description: template.description,
        createdAt: template.createdAt.toISOString()
      },
      sections: template.sections,
      parameters: template.parameters
    };
    
    fs.writeFileSync(fileName, JSON.stringify(templateData, null, 2), 'utf-8');
  }
  
  loadTemplate(templateId: string): ReportTemplate {
    const fileName = path.join(this.templatesPath, `${templateId}.rpt`);
    
    if (!fs.existsSync(fileName)) {
      throw new Error(`Template ${templateId} not found`);
    }
    
    const fileContent = fs.readFileSync(fileName, 'utf-8');
    const templateData = JSON.parse(fileContent);
    
    return {
      id: templateData.metadata.id,
      name: templateData.metadata.name,
      description: templateData.metadata.description,
      sections: templateData.sections,
      parameters: templateData.parameters,
      createdAt: new Date(templateData.metadata.createdAt)
    };
  }
  
  generateReport(templateId: string, data: Record<string, any>): Report {
    const template = this.loadTemplate(templateId);
    
    const processedSections = template.sections.map(section => 
      this.processSection(section, data)
    );
    
    return {
      id: this.generateId(),
      templateId,
      generatedAt: new Date(),
      sections: processedSections
    };
  }
  
  private processSection(templateSection: ReportSection, data: Record<string, any>): ReportSection {
    return {
      type: templateSection.type,
      title: this.replacePlaceholders(templateSection.title, data),
      properties: templateSection.properties,
      dataSource: templateSection.dataSource
    };
  }
  
  private replacePlaceholders(text: string, data: Record<string, any>): string {
    for (const [key, value] of Object.entries(data)) {
      const placeholder = `{${key}}`;
      text = text.replace(new RegExp(placeholder, 'g'), String(value ?? ''));
    }
    return text;
  }
  
  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}
```
### ðŸ§ª Senaryo 9: Bir workflow sistemi sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± dosyalarda saklar

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 114
```csharp
public class WorkflowDefinition
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Version { get; set; }
    public List<WorkflowStep> Steps { get; set; }
    public Dictionary<string, object> Variables { get; set; }
}

public class WorkflowStep
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Type { get; set; }
    public Dictionary<string, object> Properties { get; set; }
    public List<string> NextSteps { get; set; }
    public string Condition { get; set; }
}

public class WorkflowService
{
    private readonly string _workflowsPath = "workflows";
    
    public WorkflowService()
    {
        Directory.CreateDirectory(_workflowsPath);
    }
    
    public void SaveWorkflowDefinition(WorkflowDefinition workflow)
    {
        var fileName = Path.Combine(_workflowsPath, $"{workflow.Id}.xml");
        
        var doc = new XDocument(
            new XElement("Workflow",
                new XAttribute("id", workflow.Id),
                new XAttribute("name", workflow.Name),
                new XAttribute("version", workflow.Version),
                new XElement("Variables",
                    workflow.Variables.Select(v => 
                        new XElement("Variable",
                            new XAttribute("name", v.Key),
                            new XAttribute("value", v.Value?.ToString() ?? "")
                        )
                    )
                ),
                new XElement("Steps",
                    workflow.Steps.Select(step =>
                        new XElement("Step",
                            new XAttribute("id", step.Id),
                            new XAttribute("name", step.Name),
                            new XAttribute("type", step.Type),
                            step.Condition != null ? new XAttribute("condition", step.Condition) : null,
                            new XElement("Properties",
                                step.Properties.Select(p =>
                                    new XElement("Property",
                                        new XAttribute("name", p.Key),
                                        new XCData(JsonSerializer.Serialize(p.Value))
                                    )
                                )
                            ),
                            new XElement("NextSteps",
                                step.NextSteps?.Select(ns => new XElement("NextStep", ns)) ?? Enumerable.Empty<XElement>()
                            )
                        )
                    )
                )
            )
        );
        
        doc.Save(fileName);
    }
    
    public WorkflowDefinition LoadWorkflowDefinition(string workflowId)
    {
        var fileName = Path.Combine(_workflowsPath, $"{workflowId}.xml");
        
        if (!File.Exists(fileName))
            throw new FileNotFoundException($"Workflow {workflowId} not found");
        
        var doc = XDocument.Load(fileName);
        var root = doc.Root;
        
        var variables = root.Element("Variables")?.Elements("Variable")
            .ToDictionary(
                v => v.Attribute("name")?.Value ?? "",
                v => (object)(v.Attribute("value")?.Value ?? "")
            ) ?? new Dictionary<string, object>();
        
        var steps = root.Element("Steps")?.Elements("Step")
            .Select(stepElement => new WorkflowStep
            {
                Id = stepElement.Attribute("id")?.Value ?? "",
                Name = stepElement.Attribute("name")?.Value ?? "",
                Type = stepElement.Attribute("type")?.Value ?? "",
                Condition = stepElement.Attribute("condition")?.Value,
                Properties = stepElement.Element("Properties")?.Elements("Property")
                    .ToDictionary(
                        p => p.Attribute("name")?.Value ?? "",
                        p => JsonSerializer.Deserialize<object>(p.Value)
                    ) ?? new Dictionary<string, object>(),
                NextSteps = stepElement.Element("NextSteps")?.Elements("NextStep")
                    .Select(ns => ns.Value).ToList() ?? new List<string>()
            }).ToList() ?? new List<WorkflowStep>();
        
        return new WorkflowDefinition
        {
            Id = root.Attribute("id")?.Value ?? "",
            Name = root.Attribute("name")?.Value ?? "",
            Version = root.Attribute("version")?.Value ?? "",
            Variables = variables,
            Steps = steps
        };
    }
}
```
### ðŸ§ª Senaryo 9: Bir workflow sistemi sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± dosyalarda saklar

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 126
```python
import xml.etree.ElementTree as ET
import json
import os
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional

@dataclass
class WorkflowStep:
    id: str
    name: str
    step_type: str
    properties: Dict[str, Any] = field(default_factory=dict)
    next_steps: List[str] = field(default_factory=list)
    condition: Optional[str] = None

@dataclass
class WorkflowDefinition:
    id: str
    name: str
    version: str
    steps: List[WorkflowStep] = field(default_factory=list)
    variables: Dict[str, Any] = field(default_factory=dict)

class WorkflowService:
    def __init__(self, workflows_path="workflows"):
        self.workflows_path = workflows_path
        os.makedirs(workflows_path, exist_ok=True)
    
    def save_workflow_definition(self, workflow: WorkflowDefinition):
        file_name = os.path.join(self.workflows_path, f"{workflow.id}.xml")
        
        root = ET.Element("Workflow")
        root.set("id", workflow.id)
        root.set("name", workflow.name)
        root.set("version", workflow.version)
        
        # Add variables
        variables_elem = ET.SubElement(root, "Variables")
        for name, value in workflow.variables.items():
            var_elem = ET.SubElement(variables_elem, "Variable")
            var_elem.set("name", name)
            var_elem.set("value", str(value))
        
        # Add steps
        steps_elem = ET.SubElement(root, "Steps")
        for step in workflow.steps:
            step_elem = ET.SubElement(steps_elem, "Step")
            step_elem.set("id", step.id)
            step_elem.set("name", step.name)
            step_elem.set("type", step.step_type)
            
            if step.condition:
                step_elem.set("condition", step.condition)
            
            # Add properties
            props_elem = ET.SubElement(step_elem, "Properties")
            for prop_name, prop_value in step.properties.items():
                prop_elem = ET.SubElement(props_elem, "Property")
                prop_elem.set("name", prop_name)
                prop_elem.text = json.dumps(prop_value)
            
            # Add next steps
            next_steps_elem = ET.SubElement(step_elem, "NextSteps")
            for next_step in step.next_steps:
                next_step_elem = ET.SubElement(next_steps_elem, "NextStep")
                next_step_elem.text = next_step
        
        tree = ET.ElementTree(root)
        tree.write(file_name, encoding='utf-8', xml_declaration=True)
    
    def load_workflow_definition(self, workflow_id: str) -> WorkflowDefinition:
        file_name = os.path.join(self.workflows_path, f"{workflow_id}.xml")
        
        if not os.path.exists(file_name):
            raise FileNotFoundError(f"Workflow {workflow_id} not found")
        
        tree = ET.parse(file_name)
        root = tree.getroot()
        
        # Parse variables
        variables = {}
        variables_elem = root.find("Variables")
        if variables_elem is not None:
            for var_elem in variables_elem.findall("Variable"):
                name = var_elem.get("name", "")
                value = var_elem.get("value", "")
                variables[name] = value
        
        # Parse steps
        steps = []
        steps_elem = root.find("Steps")
        if steps_elem is not None:
            for step_elem in steps_elem.findall("Step"):
                # Parse properties
                properties = {}
                props_elem = step_elem.find("Properties")
                if props_elem is not None:
                    for prop_elem in props_elem.findall("Property"):
                        prop_name = prop_elem.get("name", "")
                        prop_value = json.loads(prop_elem.text or "{}")
                        properties[prop_name] = prop_value
                
                # Parse next steps
                next_steps = []
                next_steps_elem = step_elem.find("NextSteps")
                if next_steps_elem is not None:
                    for next_step_elem in next_steps_elem.findall("NextStep"):
                        next_steps.append(next_step_elem.text or "")
                
                step = WorkflowStep(
                    id=step_elem.get("id", ""),
                    name=step_elem.get("name", ""),
                    step_type=step_elem.get("type", ""),
                    properties=properties,
                    next_steps=next_steps,
                    condition=step_elem.get("condition")
                )
                steps.append(step)
        
        return WorkflowDefinition(
            id=root.get("id", ""),
            name=root.get("name", ""),
            version=root.get("version", ""),
            steps=steps,
            variables=variables
        )
```
### ðŸ§ª Senaryo 9: Bir workflow sistemi sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± dosyalarda saklar

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 170
```typescript
import * as fs from 'fs';
import * as path from 'path';
import { DOMParser, XMLSerializer } from 'xmldom';

interface WorkflowStep {
  id: string;
  name: string;
  type: string;
  properties: Record<string, any>;
  nextSteps: string[];
  condition?: string;
}

interface WorkflowDefinition {
  id: string;
  name: string;
  version: string;
  steps: WorkflowStep[];
  variables: Record<string, any>;
}

class WorkflowService {
  private workflowsPath: string;
  
  constructor(workflowsPath = 'workflows') {
    this.workflowsPath = workflowsPath;
    if (!fs.existsSync(workflowsPath)) {
      fs.mkdirSync(workflowsPath, { recursive: true });
    }
  }
  
  saveWorkflowDefinition(workflow: WorkflowDefinition): void {
    const fileName = path.join(this.workflowsPath, `${workflow.id}.xml`);
    
    const parser = new DOMParser();
    const serializer = new XMLSerializer();
    const doc = parser.parseFromString('<root/>', 'text/xml');
    
    const root = doc.createElement('Workflow');
    root.setAttribute('id', workflow.id);
    root.setAttribute('name', workflow.name);
    root.setAttribute('version', workflow.version);
    
    // Add variables
    const variablesElem = doc.createElement('Variables');
    for (const [name, value] of Object.entries(workflow.variables)) {
      const varElem = doc.createElement('Variable');
      varElem.setAttribute('name', name);
      varElem.setAttribute('value', String(value));
      variablesElem.appendChild(varElem);
    }
    root.appendChild(variablesElem);
    
    // Add steps
    const stepsElem = doc.createElement('Steps');
    for (const step of workflow.steps) {
      const stepElem = doc.createElement('Step');
      stepElem.setAttribute('id', step.id);
      stepElem.setAttribute('name', step.name);
      stepElem.setAttribute('type', step.type);
      
      if (step.condition) {
        stepElem.setAttribute('condition', step.condition);
      }
      
      // Add properties
      const propsElem = doc.createElement('Properties');
      for (const [propName, propValue] of Object.entries(step.properties)) {
        const propElem = doc.createElement('Property');
        propElem.setAttribute('name', propName);
        propElem.textContent = JSON.stringify(propValue);
        propsElem.appendChild(propElem);
      }
      stepElem.appendChild(propsElem);
      
      // Add next steps
      const nextStepsElem = doc.createElement('NextSteps');
      for (const nextStep of step.nextSteps) {
        const nextStepElem = doc.createElement('NextStep');
        nextStepElem.textContent = nextStep;
        nextStepsElem.appendChild(nextStepElem);
      }
      stepElem.appendChild(nextStepsElem);
      
      stepsElem.appendChild(stepElem);
    }
    root.appendChild(stepsElem);
    
    const xmlString = serializer.serializeToString(root);
    fs.writeFileSync(fileName, `<?xml version="1.0" encoding="UTF-8"?>\n${xmlString}`, 'utf-8');
  }
  
  loadWorkflowDefinition(workflowId: string): WorkflowDefinition {
    const fileName = path.join(this.workflowsPath, `${workflowId}.xml`);
    
    if (!fs.existsSync(fileName)) {
      throw new Error(`Workflow ${workflowId} not found`);
    }
    
    const xmlContent = fs.readFileSync(fileName, 'utf-8');
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlContent, 'text/xml');
    const root = doc.documentElement;
    
    // Parse variables
    const variables: Record<string, any> = {};
    const variablesElem = root.getElementsByTagName('Variables')[0];
    if (variablesElem) {
      const varElems = variablesElem.getElementsByTagName('Variable');
      for (let i = 0; i < varElems.length; i++) {
        const varElem = varElems[i];
        const name = varElem.getAttribute('name') || '';
        const value = varElem.getAttribute('value') || '';
        variables[name] = value;
      }
    }
    
    // Parse steps
    const steps: WorkflowStep[] = [];
    const stepsElem = root.getElementsByTagName('Steps')[0];
    if (stepsElem) {
      const stepElems = stepsElem.getElementsByTagName('Step');
      for (let i = 0; i < stepElems.length; i++) {
        const stepElem = stepElems[i];
        
        // Parse properties
        const properties: Record<string, any> = {};
        const propsElem = stepElem.getElementsByTagName('Properties')[0];
        if (propsElem) {
          const propElems = propsElem.getElementsByTagName('Property');
          for (let j = 0; j < propElems.length; j++) {
            const propElem = propElems[j];
            const propName = propElem.getAttribute('name') || '';
            const propValue = JSON.parse(propElem.textContent || '{}');
            properties[propName] = propValue;
          }
        }
        
        // Parse next steps
        const nextSteps: string[] = [];
        const nextStepsElem = stepElem.getElementsByTagName('NextSteps')[0];
        if (nextStepsElem) {
          const nextStepElems = nextStepsElem.getElementsByTagName('NextStep');
          for (let j = 0; j < nextStepElems.length; j++) {
            nextSteps.push(nextStepElems[j].textContent || '');
          }
        }
        
        const step: WorkflowStep = {
          id: stepElem.getAttribute('id') || '',
          name: stepElem.getAttribute('name') || '',
          type: stepElem.getAttribute('type') || '',
          properties,
          nextSteps,
          condition: stepElem.getAttribute('condition') || undefined
        };
        
        steps.push(step);
      }
    }
    
    return {
      id: root.getAttribute('id') || '',
      name: root.getAttribute('name') || '',
      version: root.getAttribute('version') || '',
      steps,
      variables
    };
  }
}
```
### ðŸ§ª Senaryo 10: Bir e-ticaret uygulamasÄ±nda sepet bilgileri session datasÄ±nda tutulur

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 98
```csharp
public class CartItem
{
    public string ProductId { get; set; }
    public string ProductName { get; set; }
    public decimal Price { get; set; }
    public int Quantity { get; set; }
    public Dictionary<string, string> Options { get; set; }
}

public class ShoppingCart
{
    public string UserId { get; set; }
    public List<CartItem> Items { get; set; } = new List<CartItem>();
    public DateTime CreatedAt { get; set; }
    public DateTime LastUpdated { get; set; }
    public decimal TotalAmount => Items.Sum(i => i.Price * i.Quantity);
}

[ApiController]
[Route("api/[controller]")]
public class CartController : ControllerBase
{
    private const string CART_SESSION_KEY = "ShoppingCart";
    
    [HttpPost("add-item")]
    public IActionResult AddItem([FromBody] CartItem item)
    {
        var cart = GetCartFromSession();
        
        var existingItem = cart.Items.FirstOrDefault(i => 
            i.ProductId == item.ProductId && 
            i.Options.SequenceEqual(item.Options ?? new Dictionary<string, string>()));
        
        if (existingItem != null)
        {
            existingItem.Quantity += item.Quantity;
        }
        else
        {
            cart.Items.Add(item);
        }
        
        cart.LastUpdated = DateTime.UtcNow;
        SaveCartToSession(cart);
        
        return Ok(new { cart.TotalAmount, ItemCount = cart.Items.Sum(i => i.Quantity) });
    }
    
    [HttpGet]
    public IActionResult GetCart()
    {
        var cart = GetCartFromSession();
        return Ok(cart);
    }
    
    [HttpDelete("remove-item/{productId}")]
    public IActionResult RemoveItem(string productId)
    {
        var cart = GetCartFromSession();
        cart.Items.RemoveAll(i => i.ProductId == productId);
        cart.LastUpdated = DateTime.UtcNow;
        SaveCartToSession(cart);
        
        return Ok(cart);
    }
    
    private ShoppingCart GetCartFromSession()
    {
        var cartJson = HttpContext.Session.GetString(CART_SESSION_KEY);
        
        if (string.IsNullOrEmpty(cartJson))
        {
            return new ShoppingCart
            {
                UserId = GetCurrentUserId(),
                CreatedAt = DateTime.UtcNow,
                LastUpdated = DateTime.UtcNow
            };
        }
        
        return JsonSerializer.Deserialize<ShoppingCart>(cartJson) ?? new ShoppingCart();
    }
    
    private void SaveCartToSession(ShoppingCart cart)
    {
        var cartJson = JsonSerializer.Serialize(cart, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });
        
        HttpContext.Session.SetString(CART_SESSION_KEY, cartJson);
    }
    
    private string GetCurrentUserId()
    {
        return HttpContext.User.FindFirst("user_id")?.Value ?? "anonymous";
    }
}
```
### ðŸ§ª Senaryo 10: Bir e-ticaret uygulamasÄ±nda sepet bilgileri session datasÄ±nda tutulur

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 110
```python
import json
from datetime import datetime
from dataclasses import dataclass, asdict
from typing import List, Dict, Optional
from flask import Flask, session, request, jsonify

@dataclass
class CartItem:
    product_id: str
    product_name: str
    price: float
    quantity: int
    options: Dict[str, str] = None
    
    def __post_init__(self):
        if self.options is None:
            self.options = {}

@dataclass
class ShoppingCart:
    user_id: str
    items: List[CartItem]
    created_at: datetime
    last_updated: datetime
    
    @property
    def total_amount(self) -> float:
        return sum(item.price * item.quantity for item in self.items)
    
    @property
    def item_count(self) -> int:
        return sum(item.quantity for item in self.items)

class CartService:
    CART_SESSION_KEY = 'shopping_cart'
    
    def get_cart_from_session(self, user_id: str = "anonymous") -> ShoppingCart:
        cart_data = session.get(self.CART_SESSION_KEY)
        
        if not cart_data:
            return ShoppingCart(
                user_id=user_id,
                items=[],
                created_at=datetime.utcnow(),
                last_updated=datetime.utcnow()
            )
        
        # Deserialize cart data
        cart_dict = json.loads(cart_data)
        items = [CartItem(**item) for item in cart_dict['items']]
        
        return ShoppingCart(
            user_id=cart_dict['user_id'],
            items=items,
            created_at=datetime.fromisoformat(cart_dict['created_at']),
            last_updated=datetime.fromisoformat(cart_dict['last_updated'])
        )
    
    def save_cart_to_session(self, cart: ShoppingCart):
        cart_dict = {
            'user_id': cart.user_id,
            'items': [asdict(item) for item in cart.items],
            'created_at': cart.created_at.isoformat(),
            'last_updated': cart.last_updated.isoformat()
        }
        
        session[self.CART_SESSION_KEY] = json.dumps(cart_dict)

cart_service = CartService()

@app.route('/api/cart/add-item', methods=['POST'])
def add_item():
    data = request.get_json()
    item = CartItem(**data)
    
    cart = cart_service.get_cart_from_session()
    
    # Check if item already exists
    existing_item = next(
        (i for i in cart.items 
         if i.product_id == item.product_id and i.options == item.options),
        None
    )
    
    if existing_item:
        existing_item.quantity += item.quantity
    else:
        cart.items.append(item)
    
    cart.last_updated = datetime.utcnow()
    cart_service.save_cart_to_session(cart)
    
    return jsonify({
        'total_amount': cart.total_amount,
        'item_count': cart.item_count
    })

@app.route('/api/cart')
def get_cart():
    cart = cart_service.get_cart_from_session()
    return jsonify(asdict(cart))

@app.route('/api/cart/remove-item/<product_id>', methods=['DELETE'])
def remove_item(product_id):
    cart = cart_service.get_cart_from_session()
    cart.items = [item for item in cart.items if item.product_id != product_id]
    cart.last_updated = datetime.utcnow()
    cart_service.save_cart_to_session(cart)
    
    return jsonify(asdict(cart))
```
---
### ðŸ§ª Senaryo 10: Bir e-ticaret uygulamasÄ±nda sepet bilgileri session datasÄ±nda tutulur
**ðŸ’» Dil:** `TypeScript`  
**ðŸ¤– AI:** Claude Sonnet 4

```typescript
import { Request, Response } from 'express';

interface CartItem {
  productId: string;
  productName: string;
  price: number;
  quantity: number;
  options: Record<string, string>;
}

interface ShoppingCart {
  userId: string;
  items: CartItem[];
  createdAt: Date;
  lastUpdated: Date;
  totalAmount: number;
  itemCount: number;
}

class CartService {
  private static readonly CART_SESSION_KEY = 'shoppingCart';
  
  getCartFromSession(req: Request, userId = 'anonymous'): ShoppingCart {
    const cartData = req.session[CartService.CART_SESSION_KEY];
    
    if (!cartData) {
      return {
        userId,
        items: [],
        createdAt: new Date(),
        lastUpdated: new Date(),
        totalAmount: 0,
        itemCount: 0
      };
    }
    
    const cart = JSON.parse(cartData);
    return {
      ...cart,
      createdAt: new Date(cart.createdAt),
      lastUpdated: new Date(cart.lastUpdated),
      totalAmount: this.calculateTotalAmount(cart.items),
      itemCount: this.calculateItemCount(cart.items)
    };
  }
  
  saveCartToSession(req: Request, cart: ShoppingCart): void {
    const cartToSave = {
      ...cart,
      totalAmount: this.calculateTotalAmount(cart.items),
      itemCount: this.calculateItemCount(cart.items)
    };
    
    req.session[CartService.CART_SESSION_KEY] = JSON.stringify(cartToSave);
  }
  
  private calculateTotalAmount(items: CartItem[]): number {
    return items.reduce((total, item) => total + (item.price * item.quantity), 0);
  }
  
  private calculateItemCount(items: CartItem[]): number {
    return items.reduce((count, item) => count + item.quantity, 0);
  }
}

class CartController {
  private cartService = new CartService();
  
  addItem = (req: Request, res: Response): void => {
    const item: CartItem = req.body;
    const cart = this.cartService.getCartFromSession(req);
    
    // Check if item already exists
    const existingItemIndex = cart.items.findIndex(
      i => i.productId === item.productId && 
           JSON.stringify(i.options) === JSON.stringify(item.options)
    );
    
    if (existingItemIndex >= 0) {
      cart.items[existingItemIndex].quantity += item.quantity;
    } else {
      cart.items.push(item);
    }
    
    cart.lastUpdated = new Date();
    this.cartService.saveCartToSession(req, cart);
    
    res.json({
      totalAmount: cart.totalAmount,
      itemCount: cart.itemCount
    });
  };
  
  getCart = (req: Request, res: Response): void => {
    const cart = this.cartService.getCartFromSession(req);
    res.json(cart);
  };
  
  removeItem = (req: Request, res: Response): void => {
    const { productId } = req.params;
    const cart = this.cartService.getCartFromSession(req);
    
    cart.items = cart.items.filter(item => item.productId !== productId);
    cart.lastUpdated = new Date();
    this.cartService.saveCartToSession(req, cart);
    
    res.json(cart);
  };
  
  updateQuantity = (req: Request, res: Response): void => {
    const { productId } = req.params;
    const { quantity } = req.body;
    const cart = this.cartService.getCartFromSession(req);
    
    const item = cart.items.find(i => i.productId === productId);
    if (item) {
      item.quantity = Math.max(0, quantity);
      if (item.quantity === 0) {
        cart.items = cart.items.filter(i => i.productId !== productId);
      }
    }
    
    cart.lastUpdated = new Date();
    this.cartService.saveCartToSession(req, cart);
    
    res.json(cart);
  };
}