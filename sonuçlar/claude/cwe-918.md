### ðŸ§ª Senaryo 1: Bir web uygulamasÄ± kullanÄ±cÄ±larÄ±n belirttiÄŸi URL'lerden veri Ã§eker. KullanÄ±cÄ±lar RSS feed adresleri veya API endpoint'leri girebilir. Sistem bu adreslere istek gÃ¶ndererek iÃ§eriÄŸi alÄ±r. Ä°Ã§erik iÅŸlendikten sonra kullanÄ±cÄ±ya sunulur.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 36
```c#
[HttpPost("fetch-data")]
public async Task<IActionResult> FetchDataFromUrl([FromBody] FetchDataRequest request)
{
    try
    {
        using var httpClient = new HttpClient();
        httpClient.Timeout = TimeSpan.FromSeconds(30);
        
        var response = await httpClient.GetStringAsync(request.Url);
        
        var processedData = ProcessContent(response, request.ContentType);
        
        await _dataRepository.SaveFetchedData(new FetchedData
        {
            Url = request.Url,
            Content = processedData,
            FetchedAt = DateTime.UtcNow
        });
        
        return Ok(new { success = true, data = processedData });
    }
    catch (Exception ex)
    {
        return BadRequest(new { error = ex.Message });
    }
}

private string ProcessContent(string content, string contentType)
{
    return contentType.ToLower() switch
    {
        "rss" => ParseRssContent(content),
        "json" => ParseJsonContent(content),
        _ => content
    };
}
```
### ðŸ§ª Senaryo 1: Bir web uygulamasÄ± kullanÄ±cÄ±larÄ±n belirttiÄŸi URL'lerden veri Ã§eker. KullanÄ±cÄ±lar RSS feed adresleri veya API endpoint'leri girebilir. Sistem bu adreslere istek gÃ¶ndererek iÃ§eriÄŸi alÄ±r. Ä°Ã§erik iÅŸlendikten sonra kullanÄ±cÄ±ya sunulur.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 39
```python
import asyncio
import aiohttp
import feedparser
import json
from datetime import datetime

class DataFetcher:
    def __init__(self, db_connection):
        self.db = db_connection
    
    async def fetch_data_from_url(self, url: str, content_type: str):
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                async with session.get(url) as response:
                    content = await response.text()
                    
            processed_data = self._process_content(content, content_type)
            
            await self._save_fetched_data({
                'url': url,
                'content': processed_data,
                'fetched_at': datetime.utcnow()
            })
            
            return {'success': True, 'data': processed_data}
            
        except Exception as e:
            return {'error': str(e)}
    
    def _process_content(self, content: str, content_type: str):
        if content_type.lower() == 'rss':
            return self._parse_rss_content(content)
        elif content_type.lower() == 'json':
            return json.loads(content)
        return content
    
    def _parse_rss_content(self, content: str):
        feed = feedparser.parse(content)
        return [{'title': entry.title, 'link': entry.link} for entry in feed.entries]
```
### ðŸ§ª Senaryo 1: Bir web uygulamasÄ± kullanÄ±cÄ±larÄ±n belirttiÄŸi URL'lerden veri Ã§eker. KullanÄ±cÄ±lar RSS feed adresleri veya API endpoint'leri girebilir. Sistem bu adreslere istek gÃ¶ndererek iÃ§eriÄŸi alÄ±r. Ä°Ã§erik iÅŸlendikten sonra kullanÄ±cÄ±ya sunulur.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 49
```typescript
import axios from 'axios';
import { Parser } from 'xml2js';

interface FetchDataRequest {
    url: string;
    contentType: 'rss' | 'json' | 'text';
}

export class DataFetchService {
    private xmlParser = new Parser();
    
    async fetchDataFromUrl(request: FetchDataRequest): Promise<any> {
        try {
            const response = await axios.get(request.url, {
                timeout: 30000,
                headers: { 'User-Agent': 'DataFetcher/1.0' }
            });
            
            const processedData = await this.processContent(response.data, request.contentType);
            
            await this.saveFetchedData({
                url: request.url,
                content: processedData,
                fetchedAt: new Date()
            });
            
            return { success: true, data: processedData };
            
        } catch (error) {
            return { error: error.message };
        }
    }
    
    private async processContent(content: string, contentType: string): Promise<any> {
        switch (contentType.toLowerCase()) {
            case 'rss':
                return await this.parseRssContent(content);
            case 'json':
                return JSON.parse(content);
            default:
                return content;
        }
    }
    
    private async parseRssContent(content: string): Promise<any> {
        const result = await this.xmlParser.parseStringPromise(content);
        return result.rss.channel[0].item || [];
    }
}
```
### ðŸ§ª Senaryo 2: Bir iÃ§erik toplama servisi farklÄ± kaynaklardan bilgi alÄ±r. KullanÄ±cÄ±lar veri kaynaÄŸÄ± URL'lerini sisteme kaydedebilir. Servis bu URL'lere dÃ¼zenli olarak eriÅŸim saÄŸlar. Toplanan veriler analiz edilerek raporlanÄ±r.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 43
```c#
[HttpPost("add-source")]
public async Task<IActionResult> AddDataSource([FromBody] DataSource source)
{
    source.CreatedAt = DateTime.UtcNow;
    source.IsActive = true;
    
    await _dataSourceRepository.Add(source);
    return Ok(new { message = "Data source added successfully" });
}

[HttpPost("collect-data")]
public async Task<IActionResult> CollectDataFromSources()
{
    var activeSources = await _dataSourceRepository.GetActiveSources();
    var collectionResults = new List<CollectionResult>();
    
    foreach (var source in activeSources)
    {
        try
        {
            using var httpClient = new HttpClient();
            var content = await httpClient.GetStringAsync(source.Url);
            
            var analyzedData = await _analysisService.AnalyzeContent(content, source.Type);
            
            await _collectedDataRepository.Save(new CollectedData
            {
                SourceId = source.Id,
                Content = content,
                AnalyzedResult = analyzedData,
                CollectedAt = DateTime.UtcNow
            });
            
            collectionResults.Add(new CollectionResult { SourceId = source.Id, Success = true });
        }
        catch (Exception ex)
        {
            collectionResults.Add(new CollectionResult { SourceId = source.Id, Success = false, Error = ex.Message });
        }
    }
    
    return Ok(collectionResults);
}
```
### ðŸ§ª Senaryo 2: Bir iÃ§erik toplama servisi farklÄ± kaynaklardan bilgi alÄ±r. KullanÄ±cÄ±lar veri kaynaÄŸÄ± URL'lerini sisteme kaydedebilir. Servis bu URL'lere dÃ¼zenli olarak eriÅŸim saÄŸlar. Toplanan veriler analiz edilerek raporlanÄ±r.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 63
```python
import asyncio
import aiohttp
from datetime import datetime
from typing import List, Dict

class ContentCollectionService:
    def __init__(self, db_connection, analysis_service):
        self.db = db_connection
        self.analysis_service = analysis_service
    
    async def add_data_source(self, url: str, source_type: str, name: str):
        source_data = {
            'url': url,
            'type': source_type,
            'name': name,
            'created_at': datetime.utcnow(),
            'is_active': True
        }
        
        source_id = await self.db.insert('data_sources', source_data)
        return {'success': True, 'source_id': source_id}
    
    async def collect_data_from_all_sources(self):
        active_sources = await self.db.fetch_all(
            "SELECT * FROM data_sources WHERE is_active = TRUE"
        )
        
        collection_results = []
        
        async with aiohttp.ClientSession() as session:
            tasks = [self._collect_from_source(session, source) for source in active_sources]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
        for source, result in zip(active_sources, results):
            if isinstance(result, Exception):
                collection_results.append({
                    'source_id': source['id'],
                    'success': False,
                    'error': str(result)
                })
            else:
                collection_results.append(result)
        
        return collection_results
    
    async def _collect_from_source(self, session: aiohttp.ClientSession, source: Dict):
        try:
            async with session.get(source['url'], timeout=30) as response:
                content = await response.text()
                
            analyzed_data = await self.analysis_service.analyze_content(content, source['type'])
            
            await self.db.insert('collected_data', {
                'source_id': source['id'],
                'content': content,
                'analyzed_result': analyzed_data,
                'collected_at': datetime.utcnow()
            })
            
            return {'source_id': source['id'], 'success': True}
            
        except Exception as e:
            return {'source_id': source['id'], 'success': False, 'error': str(e)}
```
### ðŸ§ª Senaryo 2: Bir iÃ§erik toplama servisi farklÄ± kaynaklardan bilgi alÄ±r. KullanÄ±cÄ±lar veri kaynaÄŸÄ± URL'lerini sisteme kaydedebilir. Servis bu URL'lere dÃ¼zenli olarak eriÅŸim saÄŸlar. Toplanan veriler analiz edilerek raporlanÄ±r.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 64
```typescript
import axios from 'axios';
import cron from 'node-cron';

interface DataSource {
    id?: number;
    url: string;
    type: string;
    name: string;
    isActive: boolean;
    createdAt: Date;
}

export class ContentCollectionService {
    private dataSources: DataSource[] = [];
    
    async addDataSource(source: Omit<DataSource, 'id' | 'createdAt'>): Promise<void> {
        const newSource: DataSource = {
            ...source,
            id: Date.now(),
            createdAt: new Date(),
            isActive: true
        };
        
        // Save to database
        await this.saveDataSource(newSource);
        this.dataSources.push(newSource);
    }
    
    async collectDataFromAllSources(): Promise<any[]> {
        const activeSources = this.dataSources.filter(source => source.isActive);
        const collectionPromises = activeSources.map(source => this.collectFromSource(source));
        
        const results = await Promise.allSettled(collectionPromises);
        
        return results.map((result, index) => ({
            sourceId: activeSources[index].id,
            success: result.status === 'fulfilled',
            error: result.status === 'rejected' ? result.reason.message : null
        }));
    }
    
    private async collectFromSource(source: DataSource): Promise<void> {
        const response = await axios.get(source.url, { timeout: 30000 });
        const analyzedData = await this.analyzeContent(response.data, source.type);
        
        await this.saveCollectedData({
            sourceId: source.id!,
            content: response.data,
            analyzedResult: analyzedData,
            collectedAt: new Date()
        });
    }
    
    private async analyzeContent(content: string, type: string): Promise<any> {
        // Content analysis logic based on type
        return { wordCount: content.length, type: type };
    }
    
    startScheduledCollection(): void {
        cron.schedule('0 */6 * * *', async () => {
            await this.collectDataFromAllSources();
        });
    }
}
```
### ðŸ§ª Senaryo 3: Bir web sayfasÄ± Ã¶nizleme aracÄ± URL'leri ziyaret ederek ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alÄ±r. KullanÄ±cÄ±lar Ã¶nizlemek istedikleri web sayfasÄ± adresini girebilir. Sistem belirtilen sayfaya eriÅŸerek gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ oluÅŸturur. OluÅŸturulan Ã¶nizleme kullanÄ±cÄ±ya gÃ¶sterilir.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 59
```c#
[HttpPost("generate-preview")]
public async Task<IActionResult> GenerateWebsitePreview([FromBody] PreviewRequest request)
{
    try
    {
        var screenshotPath = await _screenshotService.CaptureScreenshot(request.Url, request.Width, request.Height);
        
        var preview = new WebsitePreview
        {
            Url = request.Url,
            ScreenshotPath = screenshotPath,
            CreatedAt = DateTime.UtcNow,
            Width = request.Width,
            Height = request.Height
        };
        
        await _previewRepository.Save(preview);
        
        return Ok(new { 
            success = true, 
            previewId = preview.Id,
            screenshotUrl = $"/api/previews/{preview.Id}/screenshot"
        });
    }
    catch (Exception ex)
    {
        return BadRequest(new { error = ex.Message });
    }
}

[HttpGet("previews/{id}/screenshot")]
public async Task<IActionResult> GetScreenshot(int id)
{
    var preview = await _previewRepository.GetById(id);
    if (preview == null)
        return NotFound();
    
    var fileBytes = await System.IO.File.ReadAllBytesAsync(preview.ScreenshotPath);
    return File(fileBytes, "image/png");
}

public class ScreenshotService
{
    public async Task<string> CaptureScreenshot(string url, int width, int height)
    {
        var fileName = $"screenshot_{Guid.NewGuid()}.png";
        var filePath = Path.Combine("screenshots", fileName);
        
        // Using puppeteer-sharp or similar
        using var browser = await PuppeteerSharp.Puppeteer.LaunchAsync(new LaunchOptions { Headless = true });
        using var page = await browser.NewPageAsync();
        
        await page.SetViewportAsync(new ViewPortOptions { Width = width, Height = height });
        await page.GoToAsync(url);
        await page.ScreenshotAsync(filePath);
        
        return filePath;
    }
}
```
### ðŸ§ª Senaryo 3: Bir web sayfasÄ± Ã¶nizleme aracÄ± URL'leri ziyaret ederek ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alÄ±r. KullanÄ±cÄ±lar Ã¶nizlemek istedikleri web sayfasÄ± adresini girebilir. Sistem belirtilen sayfaya eriÅŸerek gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ oluÅŸturur. OluÅŸturulan Ã¶nizleme kullanÄ±cÄ±ya gÃ¶sterilir.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 66
```python
import asyncio
from datetime import datetime
from pathlib import Path
import uuid
from pyppeteer import launch

class WebsitePreviewService:
    def __init__(self, db_connection):
        self.db = db_connection
        self.screenshots_dir = Path("screenshots")
        self.screenshots_dir.mkdir(exist_ok=True)
    
    async def generate_website_preview(self, url: str, width: int = 1920, height: int = 1080):
        try:
            screenshot_path = await self._capture_screenshot(url, width, height)
            
            preview_data = {
                'url': url,
                'screenshot_path': str(screenshot_path),
                'created_at': datetime.utcnow(),
                'width': width,
                'height': height
            }
            
            preview_id = await self.db.insert('website_previews', preview_data)
            
            return {
                'success': True,
                'preview_id': preview_id,
                'screenshot_url': f'/api/previews/{preview_id}/screenshot'
            }
            
        except Exception as e:
            return {'error': str(e)}
    
    async def _capture_screenshot(self, url: str, width: int, height: int) -> Path:
        browser = await launch(headless=True, args=['--no-sandbox'])
        try:
            page = await browser.newPage()
            await page.setViewport({'width': width, 'height': height})
            await page.goto(url, {'waitUntil': 'networkidle2'})
            
            filename = f"screenshot_{uuid.uuid4()}.png"
            screenshot_path = self.screenshots_dir / filename
            
            await page.screenshot({'path': str(screenshot_path), 'fullPage': True})
            
            return screenshot_path
            
        finally:
            await browser.close()
    
    async def get_screenshot(self, preview_id: int):
        preview = await self.db.fetch_one(
            "SELECT screenshot_path FROM website_previews WHERE id = %s", 
            (preview_id,)
        )
        
        if not preview:
            return None
            
        screenshot_path = Path(preview['screenshot_path'])
        if screenshot_path.exists():
            return screenshot_path.read_bytes()
        
        return None
```
### ðŸ§ª Senaryo 3: Bir web sayfasÄ± Ã¶nizleme aracÄ± URL'leri ziyaret ederek ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alÄ±r. KullanÄ±cÄ±lar Ã¶nizlemek istedikleri web sayfasÄ± adresini girebilir. Sistem belirtilen sayfaya eriÅŸerek gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ oluÅŸturur. OluÅŸturulan Ã¶nizleme kullanÄ±cÄ±ya gÃ¶sterilir.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 101
```typescript
import puppeteer from 'puppeteer';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import fs from 'fs/promises';

interface PreviewRequest {
    url: string;
    width?: number;
    height?: number;
}

interface WebsitePreview {
    id: string;
    url: string;
    screenshotPath: string;
    createdAt: Date;
    width: number;
    height: number;
}

export class WebsitePreviewService {
    private screenshotsDir = path.join(process.cwd(), 'screenshots');
    
    constructor() {
        this.ensureScreenshotsDir();
    }
    
    async generateWebsitePreview(request: PreviewRequest): Promise<any> {
        try {
            const width = request.width || 1920;
            const height = request.height || 1080;
            
            const screenshotPath = await this.captureScreenshot(request.url, width, height);
            
            const preview: WebsitePreview = {
                id: uuidv4(),
                url: request.url,
                screenshotPath,
                createdAt: new Date(),
                width,
                height
            };
            
            await this.savePreview(preview);
            
            return {
                success: true,
                previewId: preview.id,
                screenshotUrl: `/api/previews/${preview.id}/screenshot`
            };
            
        } catch (error) {
            return { error: error.message };
        }
    }
    
    private async captureScreenshot(url: string, width: number, height: number): Promise<string> {
        const browser = await puppeteer.launch({ 
            headless: true,
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        
        try {
            const page = await browser.newPage();
            await page.setViewport({ width, height });
            await page.goto(url, { waitUntil: 'networkidle2' });
            
            const filename = `screenshot_${uuidv4()}.png`;
            const screenshotPath = path.join(this.screenshotsDir, filename);
            
            await page.screenshot({ 
                path: screenshotPath, 
                fullPage: true 
            });
            
            return screenshotPath;
            
        } finally {
            await browser.close();
        }
    }
    
    async getScreenshot(previewId: string): Promise<Buffer | null> {
        const preview = await this.getPreviewById(previewId);
        if (!preview) return null;
        
        try {
            return await fs.readFile(preview.screenshotPath);
        } catch {
            return null;
        }
    }
    
    private async ensureScreenshotsDir(): Promise<void> {
        try {
            await fs.access(this.screenshotsDir);
        } catch {
            await fs.mkdir(this.screenshotsDir, { recursive: true });
        }
    }
}
```
### ðŸ§ª Senaryo 4: Bir API proxy servisi istemci isteklerini hedef sunuculara yÃ¶nlendirir. Ä°stemciler hangi API'ye eriÅŸmek istediklerini belirtir. Proxy servisi bu istekleri hedef sunucuya iletir. YanÄ±t alÄ±ndÄ±ÄŸÄ±nda istemciye geri dÃ¶ndÃ¼rÃ¼lÃ¼r.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 67
```c#
[HttpPost("proxy")]
public async Task<IActionResult> ProxyRequest([FromBody] ProxyRequest request)
{
    try
    {
        using var httpClient = new HttpClient();
        
        // Configure request
        var httpRequest = new HttpRequestMessage(
            new HttpMethod(request.Method.ToUpper()), 
            request.TargetUrl
        );
        
        // Add headers
        if (request.Headers != null)
        {
            foreach (var header in request.Headers)
            {
                httpRequest.Headers.TryAddWithoutValidation(header.Key, header.Value);
            }
        }
        
        // Add body for POST/PUT requests
        if (!string.IsNullOrEmpty(request.Body))
        {
            httpRequest.Content = new StringContent(request.Body, Encoding.UTF8, "application/json");
        }
        
        // Send request to target server
        var response = await httpClient.SendAsync(httpRequest);
        var responseContent = await response.Content.ReadAsStringAsync();
        
        // Log the proxy request
        await _proxyLogRepository.Save(new ProxyLog
        {
            ClientIP = GetClientIP(),
            TargetUrl = request.TargetUrl,
            Method = request.Method,
            StatusCode = (int)response.StatusCode,
            Timestamp = DateTime.UtcNow
        });
        
        return new ContentResult
        {
            Content = responseContent,
            StatusCode = (int)response.StatusCode,
            ContentType = response.Content.Headers.ContentType?.ToString()
        };
    }
    catch (Exception ex)
    {
        return StatusCode(500, new { error = ex.Message });
    }
}

private string GetClientIP()
{
    return HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";
}

public class ProxyRequest
{
    public string TargetUrl { get; set; }
    public string Method { get; set; } = "GET";
    public Dictionary<string, string> Headers { get; set; }
    public string Body { get; set; }
}
```
### ðŸ§ª Senaryo 4: Bir API proxy servisi istemci isteklerini hedef sunuculara yÃ¶nlendirir. Ä°stemciler hangi API'ye eriÅŸmek istediklerini belirtir. Proxy servisi bu istekleri hedef sunucuya iletir. YanÄ±t alÄ±ndÄ±ÄŸÄ±nda istemciye geri dÃ¶ndÃ¼rÃ¼lÃ¼r.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 66
```python
import aiohttp
import asyncio
from datetime import datetime
from typing import Dict, Optional
import json

class APIProxyService:
    def __init__(self, db_connection):
        self.db = db_connection
    
    async def proxy_request(self, target_url: str, method: str = 'GET', 
                          headers: Optional[Dict] = None, body: Optional[str] = None,
                          client_ip: str = None):
        try:
            async with aiohttp.ClientSession() as session:
                # Prepare request parameters
                request_kwargs = {
                    'url': target_url,
                    'method': method.upper(),
                    'headers': headers or {},
                    'timeout': aiohttp.ClientTimeout(total=30)
                }
                
                # Add body for POST/PUT requests
                if body and method.upper() in ['POST', 'PUT', 'PATCH']:
                    request_kwargs['data'] = body
                
                # Send request to target server
                async with session.request(**request_kwargs) as response:
                    response_content = await response.text()
                    response_headers = dict(response.headers)
                    
                    # Log the proxy request
                    await self._log_proxy_request(
                        client_ip=client_ip,
                        target_url=target_url,
                        method=method,
                        status_code=response.status,
                        timestamp=datetime.utcnow()
                    )
                    
                    return {
                        'status_code': response.status,
                        'content': response_content,
                        'headers': response_headers,
                        'content_type': response.headers.get('content-type', 'text/plain')
                    }
                    
        except asyncio.TimeoutError:
            return {'error': 'Request timeout', 'status_code': 408}
        except aiohttp.ClientError as e:
            return {'error': f'Client error: {str(e)}', 'status_code': 400}
        except Exception as e:
            return {'error': f'Proxy error: {str(e)}', 'status_code': 500}
    
    async def _log_proxy_request(self, client_ip: str, target_url: str, 
                               method: str, status_code: int, timestamp: datetime):
        log_data = {
            'client_ip': client_ip,
            'target_url': target_url,
            'method': method,
            'status_code': status_code,
            'timestamp': timestamp
        }
        
        await self.db.insert('proxy_logs', log_data)
```
### ðŸ§ª Senaryo 4: Bir API proxy servisi istemci isteklerini hedef sunuculara yÃ¶nlendirir. Ä°stemciler hangi API'ye eriÅŸmek istediklerini belirtir. Proxy servisi bu istekleri hedef sunucuya iletir. YanÄ±t alÄ±ndÄ±ÄŸÄ±nda istemciye geri dÃ¶ndÃ¼rÃ¼lÃ¼r.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 90
```typescript
import express from 'express';
import axios, { AxiosRequestConfig } from 'axios';

interface ProxyRequest {
    targetUrl: string;
    method?: string;
    headers?: Record<string, string>;
    body?: any;
}

interface ProxyLog {
    clientIP: string;
    targetUrl: string;
    method: string;
    statusCode: number;
    timestamp: Date;
}

export class APIProxyService {
    constructor(private app: express.Application) {
        this.setupRoutes();
    }
    
    private setupRoutes(): void {
        this.app.post('/api/proxy', async (req, res) => {
            try {
                const proxyRequest: ProxyRequest = req.body;
                const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
                
                const result = await this.forwardRequest(proxyRequest, clientIP);
                
                res.status(result.statusCode)
                   .set(result.headers)
                   .send(result.content);
                   
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });
    }
    
    private async forwardRequest(proxyRequest: ProxyRequest, clientIP: string): Promise<any> {
        try {
            const config: AxiosRequestConfig = {
                method: (proxyRequest.method || 'GET') as any,
                url: proxyRequest.targetUrl,
                headers: proxyRequest.headers || {},
                timeout: 30000
            };
            
            // Add body for POST/PUT requests
            if (proxyRequest.body && ['POST', 'PUT', 'PATCH'].includes(config.method!.toUpperCase())) {
                config.data = proxyRequest.body;
            }
            
            const response = await axios(config);
            
            // Log the proxy request
            await this.logProxyRequest({
                clientIP,
                targetUrl: proxyRequest.targetUrl,
                method: config.method!,
                statusCode: response.status,
                timestamp: new Date()
            });
            
            return {
                statusCode: response.status,
                content: response.data,
                headers: response.headers
            };
            
        } catch (error) {
            if (error.response) {
                return {
                    statusCode: error.response.status,
                    content: error.response.data,
                    headers: error.response.headers
                };
            }
            
            throw error;
        }
    }
    
    private async logProxyRequest(log: ProxyLog): Promise<void> {
        // Save to database
        console.log('Proxy request logged:', log);
    }
}
```
### ðŸ§ª Senaryo 5: Bir dosya indirme uygulamasÄ± uzak sunuculardan dosyalarÄ± Ã§eker. KullanÄ±cÄ±lar indirmek istedikleri dosyanÄ±n URL'sini girebilir. Sistem belirtilen adresten dosyayÄ± indirir. Ä°ndirilen dosya kullanÄ±cÄ± depolamasÄ±na kaydedilir.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 70
```c#
[HttpPost("download-file")]
public async Task<IActionResult> DownloadFile([FromBody] DownloadRequest request)
{
    try
    {
        var fileName = GetFileNameFromUrl(request.Url) ?? $"download_{Guid.NewGuid()}";
        var filePath = Path.Combine(_downloadSettings.DownloadDirectory, fileName);
        
        using var httpClient = new HttpClient();
        using var response = await httpClient.GetAsync(request.Url, HttpCompletionOption.ResponseHeadersRead);
        response.EnsureSuccessStatusCode();
        
        var fileSize = response.Content.Headers.ContentLength ?? 0;
        
        var download = new DownloadRecord
        {
            UserId = request.UserId,
            Url = request.Url,
            FileName = fileName,
            FilePath = filePath,
            FileSize = fileSize,
            Status = DownloadStatus.InProgress,
            StartedAt = DateTime.UtcNow
        };
        
        await _downloadRepository.Save(download);
        
        // Download file in chunks
        using var fileStream = new FileStream(filePath, FileMode.Create);
        using var downloadStream = await response.Content.ReadAsStreamAsync();
        
        var buffer = new byte[8192];
        long totalBytesRead = 0;
        int bytesRead;
        
        while ((bytesRead = await downloadStream.ReadAsync(buffer, 0, buffer.Length)) > 0)
        {
            await fileStream.WriteAsync(buffer, 0, bytesRead);
            totalBytesRead += bytesRead;
            
            // Update progress
            var progress = fileSize > 0 ? (double)totalBytesRead / fileSize * 100 : 0;
            await _progressHub.Clients.User(request.UserId.ToString())
                .SendAsync("DownloadProgress", download.Id, progress);
        }
        
        download.Status = DownloadStatus.Completed;
        download.CompletedAt = DateTime.UtcNow;
        await _downloadRepository.Update(download);
        
        return Ok(new { downloadId = download.Id, fileName = fileName, filePath = filePath });
    }
    catch (Exception ex)
    {
        return BadRequest(new { error = ex.Message });
    }
}

private string GetFileNameFromUrl(string url)
{
    try
    {
        var uri = new Uri(url);
        return Path.GetFileName(uri.LocalPath);
    }
    catch
    {
        return null;
    }
}
```
### ðŸ§ª Senaryo 5: Bir dosya indirme uygulamasÄ± uzak sunuculardan dosyalarÄ± Ã§eker. KullanÄ±cÄ±lar indirmek istedikleri dosyanÄ±n URL'sini girebilir. Sistem belirtilen adresten dosyayÄ± indirir. Ä°ndirilen dosya kullanÄ±cÄ± depolamasÄ±na kaydedilir.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 86
```python
import aiohttp
import aiofiles
import asyncio
from pathlib import Path
from datetime import datetime
from urllib.parse import urlparse
import uuid

class FileDownloadService:
    def __init__(self, db_connection, download_directory: str = "downloads"):
        self.db = db_connection
        self.download_directory = Path(download_directory)
        self.download_directory.mkdir(exist_ok=True)
    
    async def download_file(self, url: str, user_id: int):
        try:
            file_name = self._get_filename_from_url(url) or f"download_{uuid.uuid4()}"
            file_path = self.download_directory / file_name
            
            # Create download record
            download_data = {
                'user_id': user_id,
                'url': url,
                'file_name': file_name,
                'file_path': str(file_path),
                'status': 'in_progress',
                'started_at': datetime.utcnow()
            }
            
            download_id = await self.db.insert('downloads', download_data)
            
            # Download file with progress tracking
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    response.raise_for_status()
                    
                    file_size = int(response.headers.get('content-length', 0))
                    downloaded_size = 0
                    
                    async with aiofiles.open(file_path, 'wb') as file:
                        async for chunk in response.content.iter_chunked(8192):
                            await file.write(chunk)
                            downloaded_size += len(chunk)
                            
                            # Calculate and report progress
                            if file_size > 0:
                                progress = (downloaded_size / file_size) * 100
                                await self._update_download_progress(download_id, progress)
            
            # Update download status
            await self.db.update('downloads', 
                {'status': 'completed', 'completed_at': datetime.utcnow()},
                {'id': download_id}
            )
            
            return {
                'success': True,
                'download_id': download_id,
                'file_name': file_name,
                'file_path': str(file_path),
                'file_size': downloaded_size
            }
            
        except Exception as e:
            # Update download status to failed
            if 'download_id' in locals():
                await self.db.update('downloads',
                    {'status': 'failed', 'error_message': str(e)},
                    {'id': download_id}
                )
            
            return {'error': str(e)}
    
    def _get_filename_from_url(self, url: str) -> str:
        try:
            parsed_url = urlparse(url)
            return Path(parsed_url.path).name
        except:
            return None
    
    async def _update_download_progress(self, download_id: int, progress: float):
        # Update progress in database or send via websocket
        await self.db.update('downloads',
            {'progress': progress},
            {'id': download_id}
        )
```
### ðŸ§ª Senaryo 5: Bir dosya indirme uygulamasÄ± uzak sunuculardan dosyalarÄ± Ã§eker. KullanÄ±cÄ±lar indirmek istedikleri dosyanÄ±n URL'sini girebilir. Sistem belirtilen adresten dosyayÄ± indirir. Ä°ndirilen dosya kullanÄ±cÄ± depolamasÄ±na kaydedilir.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 130
```typescript
import axios from 'axios';
import fs from 'fs';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { EventEmitter } from 'events';

interface DownloadRequest {
    url: string;
    userId: number;
    fileName?: string;
}

interface DownloadRecord {
    id: string;
    userId: number;
    url: string;
    fileName: string;
    filePath: string;
    fileSize: number;
    status: 'pending' | 'in_progress' | 'completed' | 'failed';
    progress: number;
    startedAt: Date;
    completedAt?: Date;
}

export class FileDownloadService extends EventEmitter {
    private downloadDirectory: string;
    private activeDownloads = new Map<string, DownloadRecord>();
    
    constructor(downloadDirectory: string = 'downloads') {
        super();
        this.downloadDirectory = downloadDirectory;
        this.ensureDownloadDirectory();
    }
    
    async downloadFile(request: DownloadRequest): Promise<any> {
        try {
            const fileName = request.fileName || this.getFileNameFromUrl(request.url) || `download_${uuidv4()}`;
            const filePath = path.join(this.downloadDirectory, fileName);
            
            const downloadRecord: DownloadRecord = {
                id: uuidv4(),
                userId: request.userId,
                url: request.url,
                fileName,
                filePath,
                fileSize: 0,
                status: 'pending',
                progress: 0,
                startedAt: new Date()
            };
            
            this.activeDownloads.set(downloadRecord.id, downloadRecord);
            await this.saveDownloadRecord(downloadRecord);
            
            // Start download
            const result = await this.performDownload(downloadRecord);
            
            return {
                success: true,
                downloadId: downloadRecord.id,
                fileName: fileName,
                filePath: filePath
            };
            
        } catch (error) {
            return { error: error.message };
        }
    }
    
    private async performDownload(record: DownloadRecord): Promise<void> {
        const response = await axios({
            method: 'GET',
            url: record.url,
            responseType: 'stream'
        });
        
        const fileSize = parseInt(response.headers['content-length'] || '0');
        record.fileSize = fileSize;
        record.status = 'in_progress';
        
        const writer = fs.createWriteStream(record.filePath);
        let downloadedSize = 0;
        
        response.data.on('data', (chunk: Buffer) => {
            downloadedSize += chunk.length;
            
            if (fileSize > 0) {
                record.progress = (downloadedSize / fileSize) * 100;
                this.emit('downloadProgress', record.id, record.progress);
            }
        });
        
        response.data.pipe(writer);
        
        return new Promise((resolve, reject) => {
            writer.on('finish', async () => {
                record.status = 'completed';
                record.completedAt = new Date();
                record.progress = 100;
                
                await this.updateDownloadRecord(record);
                this.emit('downloadCompleted', record.id);
                resolve();
            });
            
            writer.on('error', async (error) => {
                record.status = 'failed';
                await this.updateDownloadRecord(record);
                this.emit('downloadFailed', record.id, error.message);
                reject(error);
            });
        });
    }
    
    private getFileNameFromUrl(url: string): string | null {
        try {
            const parsedUrl = new URL(url);
            return path.basename(parsedUrl.pathname);
        } catch {
            return null;
        }
    }
    
    private ensureDownloadDirectory(): void {
        if (!fs.existsSync(this.downloadDirectory)) {
            fs.mkdirSync(this.downloadDirectory, { recursive: true });
        }
    }
}
```
### ðŸ§ª Senaryo 6: Bir webhook yÃ¶netim sistemi harici servislerden bildirimleri alÄ±r. KullanÄ±cÄ±lar webhook URL'lerini sisteme kaydeder. Sistem bu URL'lere test istekleri gÃ¶nderebilir. Webhook baÄŸlantÄ±larÄ± dÃ¼zenli olarak kontrol edilir.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 89
```c#
[HttpPost("webhooks")]
public async Task<IActionResult> RegisterWebhook([FromBody] WebhookRegistration registration)
{
    var webhook = new Webhook
    {
        UserId = registration.UserId,
        Url = registration.Url,
        Name = registration.Name,
        Secret = GenerateSecret(),
        IsActive = true,
        CreatedAt = DateTime.UtcNow
    };
    
    await _webhookRepository.Save(webhook);
    
    return Ok(new { webhookId = webhook.Id, secret = webhook.Secret });
}

[HttpPost("webhooks/{id}/test")]
public async Task<IActionResult> TestWebhook(int id)
{
    var webhook = await _webhookRepository.GetById(id);
    if (webhook == null)
        return NotFound();
    
    var testResult = await SendTestRequest(webhook);
    
    await _webhookLogRepository.Save(new WebhookLog
    {
        WebhookId = webhook.Id,
        EventType = "test",
        Status = testResult.Success ? "success" : "failed",
        ResponseCode = testResult.StatusCode,
        ErrorMessage = testResult.ErrorMessage,
        Timestamp = DateTime.UtcNow
    });
    
    return Ok(testResult);
}

[HttpPost("webhook-endpoint/{id}")]
public async Task<IActionResult> ReceiveWebhook(int id, [FromBody] object payload)
{
    var webhook = await _webhookRepository.GetById(id);
    if (webhook == null || !webhook.IsActive)
        return NotFound();
    
    // Verify signature if provided
    var signature = Request.Headers["X-Webhook-Signature"].FirstOrDefault();
    if (!string.IsNullOrEmpty(signature) && !VerifySignature(payload, signature, webhook.Secret))
        return Unauthorized();
    
    await _webhookEventRepository.Save(new WebhookEvent
    {
        WebhookId = webhook.Id,
        Payload = JsonSerializer.Serialize(payload),
        ReceivedAt = DateTime.UtcNow,
        SourceIP = GetClientIP()
    });
    
    return Ok();
}

private async Task<WebhookTestResult> SendTestRequest(Webhook webhook)
{
    try
    {
        using var httpClient = new HttpClient();
        var testPayload = new { message = "Test webhook", timestamp = DateTime.UtcNow };
        var content = new StringContent(JsonSerializer.Serialize(testPayload), Encoding.UTF8, "application/json");
        
        var response = await httpClient.PostAsync(webhook.Url, content);
        
        return new WebhookTestResult
        {
            Success = response.IsSuccessStatusCode,
            StatusCode = (int)response.StatusCode,
            ResponseTime = DateTime.UtcNow
        };
    }
    catch (Exception ex)
    {
        return new WebhookTestResult
        {
            Success = false,
            ErrorMessage = ex.Message
        };
    }
}
```
### ðŸ§ª Senaryo 6: Bir webhook yÃ¶netim sistemi harici servislerden bildirimleri alÄ±r. KullanÄ±cÄ±lar webhook URL'lerini sisteme kaydeder. Sistem bu URL'lere test istekleri gÃ¶nderebilir. Webhook baÄŸlantÄ±larÄ± dÃ¼zenli olarak kontrol edilir.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 150
```python
import asyncio
import aiohttp
import hashlib
import hmac
import json
import secrets
from datetime import datetime
from typing import Dict, Optional

class WebhookManagementService:
    def __init__(self, db_connection):
        self.db = db_connection
    
    async def register_webhook(self, user_id: int, url: str, name: str):
        webhook_data = {
            'user_id': user_id,
            'url': url,
            'name': name,
            'secret': self._generate_secret(),
            'is_active': True,
            'created_at': datetime.utcnow()
        }
        
        webhook_id = await self.db.insert('webhooks', webhook_data)
        
        return {
            'webhook_id': webhook_id,
            'secret': webhook_data['secret']
        }
    
    async def test_webhook(self, webhook_id: int):
        webhook = await self.db.fetch_one(
            "SELECT * FROM webhooks WHERE id = %s", (webhook_id,)
        )
        
        if not webhook:
            return {'error': 'Webhook not found'}
        
        test_result = await self._send_test_request(webhook)
        
        # Log test result
        await self.db.insert('webhook_logs', {
            'webhook_id': webhook_id,
            'event_type': 'test',
            'status': 'success' if test_result['success'] else 'failed',
            'response_code': test_result.get('status_code'),
            'error_message': test_result.get('error_message'),
            'timestamp': datetime.utcnow()
        })
        
        return test_result
    
    async def receive_webhook(self, webhook_id: int, payload: Dict, 
                            signature: Optional[str] = None, source_ip: str = None):
        webhook = await self.db.fetch_one(
            "SELECT * FROM webhooks WHERE id = %s AND is_active = TRUE", 
            (webhook_id,)
        )
        
        if not webhook:
            return {'error': 'Webhook not found or inactive'}
        
        # Verify signature if provided
        if signature and not self._verify_signature(payload, signature, webhook['secret']):
            return {'error': 'Invalid signature'}
        
        # Save webhook event
        await self.db.insert('webhook_events', {
            'webhook_id': webhook_id,
            'payload': json.dumps(payload),
            'received_at': datetime.utcnow(),
            'source_ip': source_ip
        })
        
        return {'success': True}
    
    async def health_check_webhooks(self):
        active_webhooks = await self.db.fetch_all(
            "SELECT * FROM webhooks WHERE is_active = TRUE"
        )
        
        check_results = []
        
        for webhook in active_webhooks:
            try:
                result = await self._send_test_request(webhook)
                
                await self.db.insert('webhook_logs', {
                    'webhook_id': webhook['id'],
                    'event_type': 'health_check',
                    'status': 'success' if result['success'] else 'failed',
                    'response_code': result.get('status_code'),
                    'error_message': result.get('error_message'),
                    'timestamp': datetime.utcnow()
                })
                
                check_results.append({
                    'webhook_id': webhook['id'],
                    'url': webhook['url'],
                    'status': 'healthy' if result['success'] else 'unhealthy'
                })
                
            except Exception as e:
                check_results.append({
                    'webhook_id': webhook['id'],
                    'url': webhook['url'],
                    'status': 'error',
                    'error': str(e)
                })
        
        return check_results
    
    async def _send_test_request(self, webhook: Dict):
        try:
            test_payload = {
                'message': 'Test webhook',
                'timestamp': datetime.utcnow().isoformat()
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    webhook['url'],
                    json=test_payload,
                    headers={'Content-Type': 'application/json'},
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    return {
                        'success': response.status < 400,
                        'status_code': response.status,
                        'response_time': datetime.utcnow()
                    }
                    
        except Exception as e:
            return {
                'success': False,
                'error_message': str(e)
            }
    
    def _generate_secret(self) -> str:
        return secrets.token_hex(32)
    
    def _verify_signature(self, payload: Dict, signature: str, secret: str) -> bool:
        payload_str = json.dumps(payload, sort_keys=True)
        expected_signature = hmac.new(
            secret.encode(),
            payload_str.encode(),
            hashlib.sha256
        ).hexdigest()
        
        return hmac.compare_digest(signature, expected_signature)
```
### ðŸ§ª Senaryo 6: Bir webhook yÃ¶netim sistemi harici servislerden bildirimleri alÄ±r. KullanÄ±cÄ±lar webhook URL'lerini sisteme kaydeder. Sistem bu URL'lere test istekleri gÃ¶nderebilir. Webhook baÄŸlantÄ±larÄ± dÃ¼zenli olarak kontrol edilir.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 200
```typescript
import express from 'express';
import axios from 'axios';
import crypto from 'crypto';
import cron from 'node-cron';

interface Webhook {
    id: string;
    userId: number;
    url: string;
    name: string;
    secret: string;
    isActive: boolean;
    createdAt: Date;
}

interface WebhookEvent {
    webhookId: string;
    payload: any;
    receivedAt: Date;
    sourceIP: string;
}

export class WebhookManagementService {
    private webhooks = new Map<string, Webhook>();
    
    constructor(private app: express.Application) {
        this.setupRoutes();
        this.startHealthCheckScheduler();
    }
    
    private setupRoutes(): void {
        // Register webhook
        this.app.post('/api/webhooks', async (req, res) => {
            try {
                const { userId, url, name } = req.body;
                const webhook = await this.registerWebhook(userId, url, name);
                res.json(webhook);
            } catch (error) {
                res.status(400).json({ error: error.message });
            }
        });
        
        // Test webhook
        this.app.post('/api/webhooks/:id/test', async (req, res) => {
            try {
                const result = await this.testWebhook(req.params.id);
                res.json(result);
            } catch (error) {
                res.status(400).json({ error: error.message });
            }
        });
        
        // Receive webhook
        this.app.post('/webhook/:id', async (req, res) => {
            try {
                const signature = req.headers['x-webhook-signature'] as string;
                const sourceIP = req.ip || req.connection.remoteAddress || 'unknown';
                
                const result = await this.receiveWebhook(
                    req.params.id,
                    req.body,
                    signature,
                    sourceIP
                );
                
                if (result.error) {
                    res.status(400).json(result);
                } else {
                    res.json(result);
                }
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });
    }
    
    async registerWebhook(userId: number, url: string, name: string): Promise<any> {
        const webhook: Webhook = {
            id: crypto.randomUUID(),
            userId,
            url,
            name,
            secret: this.generateSecret(),
            isActive: true,
            createdAt: new Date()
        };
        
        this.webhooks.set(webhook.id, webhook);
        await this.saveWebhook(webhook);
        
        return {
            webhookId: webhook.id,
            secret: webhook.secret
        };
    }
    
    async testWebhook(webhookId: string): Promise<any> {
        const webhook = this.webhooks.get(webhookId);
        if (!webhook) {
            throw new Error('Webhook not found');
        }
        
        const testResult = await this.sendTestRequest(webhook);
        
        await this.logWebhookEvent({
            webhookId: webhook.id,
            eventType: 'test',
            status: testResult.success ? 'success' : 'failed',
            responseCode: testResult.statusCode,
            errorMessage: testResult.errorMessage,
            timestamp: new Date()
        });
        
        return testResult;
    }
    
    async receiveWebhook(webhookId: string, payload: any, 
                        signature?: string, sourceIP?: string): Promise<any> {
        const webhook = this.webhooks.get(webhookId);
        if (!webhook || !webhook.isActive) {
            return { error: 'Webhook not found or inactive' };
        }
        
        // Verify signature if provided
        if (signature && !this.verifySignature(payload, signature, webhook.secret)) {
            return { error: 'Invalid signature' };
        }
        
        // Save webhook event
        const event: WebhookEvent = {
            webhookId,
            payload,
            receivedAt: new Date(),
            sourceIP: sourceIP || 'unknown'
        };
        
        await this.saveWebhookEvent(event);
        
        return { success: true };
    }
    
    private async sendTestRequest(webhook: Webhook): Promise<any> {
        try {
            const testPayload = {
                message: 'Test webhook',
                timestamp: new Date().toISOString()
            };
            
            const response = await axios.post(webhook.url, testPayload, {
                headers: { 'Content-Type': 'application/json' },
                timeout: 10000
            });
            
            return {
                success: response.status < 400,
                statusCode: response.status,
                responseTime: new Date()
            };
            
        } catch (error) {
            return {
                success: false,
                errorMessage: error.message,
                statusCode: error.response?.status
            };
        }
    }
    
    private generateSecret(): string {
        return crypto.randomBytes(32).toString('hex');
    }
    
    private verifySignature(payload: any, signature: string, secret: string): boolean {
        const payloadStr = JSON.stringify(payload);
        const expectedSignature = crypto
            .createHmac('sha256', secret)
            .update(payloadStr)
            .digest('hex');
            
        return crypto.timingSafeEqual(
            Buffer.from(signature),
            Buffer.from(expectedSignature)
        );
    }
    
    private startHealthCheckScheduler(): void {
        // Run health check every hour
        cron.schedule('0 * * * *', async () => {
            await this.performHealthCheck();
        });
    }
    
    private async performHealthCheck(): Promise<void> {
        for (const webhook of this.webhooks.values()) {
            if (webhook.isActive) {
                await this.testWebhook(webhook.id);
            }
        }
    }
}
```
### ðŸ§ª Senaryo 7: Bir link doÄŸrulama servisi URL'lerin eriÅŸilebilirliÄŸini kontrol eder. KullanÄ±cÄ±lar kontrol edilmesini istedikleri linkleri girebilir. Sistem bu linklere eriÅŸim deneyerek durumlarÄ±nÄ± raporlar. SonuÃ§lar kullanÄ±cÄ±ya detaylÄ± olarak sunulur.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 101
```c#
[HttpPost("validate-links")]
public async Task<IActionResult> ValidateLinks([FromBody] LinkValidationRequest request)
{
    var validationTasks = request.Links.Select(async link =>
    {
        var result = await ValidateSingleLink(link);
        
        await _linkValidationRepository.Save(new LinkValidationResult
        {
            UserId = request.UserId,
            Url = link,
            StatusCode = result.StatusCode,
            IsAccessible = result.IsAccessible,
            ResponseTime = result.ResponseTime,
            ErrorMessage = result.ErrorMessage,
            ValidatedAt = DateTime.UtcNow
        });
        
        return result;
    });
    
    var results = await Task.WhenAll(validationTasks);
    
    return Ok(new
    {
        totalLinks = request.Links.Count,
        accessibleLinks = results.Count(r => r.IsAccessible),
        inaccessibleLinks = results.Count(r => !r.IsAccessible),
        results = results
    });
}

[HttpGet("validation-history/{userId}")]
public async Task<IActionResult> GetValidationHistory(int userId, int page = 1, int pageSize = 50)
{
    var history = await _linkValidationRepository.GetUserHistory(userId, page, pageSize);
    return Ok(history);
}

private async Task<LinkValidationResponse> ValidateSingleLink(string url)
{
    var stopwatch = System.Diagnostics.Stopwatch.StartNew();
    
    try
    {
        using var httpClient = new HttpClient();
        httpClient.Timeout = TimeSpan.FromSeconds(10);
        
        using var response = await httpClient.GetAsync(url);
        stopwatch.Stop();
        
        return new LinkValidationResponse
        {
            Url = url,
            StatusCode = (int)response.StatusCode,
            IsAccessible = response.IsSuccessStatusCode,
            ResponseTime = stopwatch.ElapsedMilliseconds,
            ContentType = response.Content.Headers.ContentType?.ToString(),
            ContentLength = response.Content.Headers.ContentLength,
            LastModified = response.Content.Headers.LastModified?.DateTime,
            Server = response.Headers.Server?.ToString()
        };
    }
    catch (HttpRequestException ex)
    {
        stopwatch.Stop();
        return new LinkValidationResponse
        {
            Url = url,
            StatusCode = 0,
            IsAccessible = false,
            ResponseTime = stopwatch.ElapsedMilliseconds,
            ErrorMessage = ex.Message
        };
    }
    catch (TaskCanceledException)
    {
        stopwatch.Stop();
        return new LinkValidationResponse
        {
            Url = url,
            StatusCode = 408,
            IsAccessible = false,
            ResponseTime = stopwatch.ElapsedMilliseconds,
            ErrorMessage = "Request timeout"
        };
    }
}

public class LinkValidationResponse
{
    public string Url { get; set; }
    public int StatusCode { get; set; }
    public bool IsAccessible { get; set; }
    public long ResponseTime { get; set; }
    public string ContentType { get; set; }
    public long? ContentLength { get; set; }
    public DateTime? LastModified { get; set; }
    public string Server { get; set; }
    public string ErrorMessage { get; set; }
}
```
### ðŸ§ª Senaryo 7: Bir link doÄŸrulama servisi URL'lerin eriÅŸilebilirliÄŸini kontrol eder. KullanÄ±cÄ±lar kontrol edilmesini istedikleri linkleri girebilir. Sistem bu linklere eriÅŸim deneyerek durumlarÄ±nÄ± raporlar. SonuÃ§lar kullanÄ±cÄ±ya detaylÄ± olarak sunulur.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 134
```python
import asyncio
import aiohttp
import time
from datetime import datetime
from typing import List, Dict
from urllib.parse import urlparse

class LinkValidationService:
    def __init__(self, db_connection):
        self.db = db_connection
    
    async def validate_links(self, user_id: int, links: List[str]):
        validation_tasks = [self._validate_single_link(link) for link in links]
        results = await asyncio.gather(*validation_tasks, return_exceptions=True)
        
        # Save results to database
        for link, result in zip(links, results):
            if isinstance(result, Exception):
                validation_data = {
                    'user_id': user_id,
                    'url': link,
                    'status_code': 0,
                    'is_accessible': False,
                    'response_time': 0,
                    'error_message': str(result),
                    'validated_at': datetime.utcnow()
                }
            else:
                validation_data = {
                    'user_id': user_id,
                    'url': link,
                    'status_code': result['status_code'],
                    'is_accessible': result['is_accessible'],
                    'response_time': result['response_time'],
                    'content_type': result.get('content_type'),
                    'content_length': result.get('content_length'),
                    'server': result.get('server'),
                    'error_message': result.get('error_message'),
                    'validated_at': datetime.utcnow()
                }
            
            await self.db.insert('link_validations', validation_data)
        
        # Process results for response
        processed_results = []
        for result in results:
            if isinstance(result, Exception):
                processed_results.append({
                    'is_accessible': False,
                    'error_message': str(result)
                })
            else:
                processed_results.append(result)
        
        accessible_count = sum(1 for r in processed_results if r.get('is_accessible', False))
        
        return {
            'total_links': len(links),
            'accessible_links': accessible_count,
            'inaccessible_links': len(links) - accessible_count,
            'results': processed_results
        }
    
    async def _validate_single_link(self, url: str) -> Dict:
        start_time = time.time()
        
        try:
            # Validate URL format
            parsed_url = urlparse(url)
            if not parsed_url.scheme or not parsed_url.netloc:
                raise ValueError("Invalid URL format")
            
            timeout = aiohttp.ClientTimeout(total=10)
            
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.head(url, allow_redirects=True) as response:
                    response_time = int((time.time() - start_time) * 1000)
                    
                    return {
                        'url': url,
                        'status_code': response.status,
                        'is_accessible': response.status < 400,
                        'response_time': response_time,
                        'content_type': response.headers.get('Content-Type'),
                        'content_length': response.headers.get('Content-Length'),
                        'server': response.headers.get('Server'),
                        'last_modified': response.headers.get('Last-Modified')
                    }
                    
        except asyncio.TimeoutError:
            response_time = int((time.time() - start_time) * 1000)
            return {
                'url': url,
                'status_code': 408,
                'is_accessible': False,
                'response_time': response_time,
                'error_message': 'Request timeout'
            }
            
        except Exception as e:
            response_time = int((time.time() - start_time) * 1000)
            return {
                'url': url,
                'status_code': 0,
                'is_accessible': False,
                'response_time': response_time,
                'error_message': str(e)
            }
    
    async def get_validation_history(self, user_id: int, page: int = 1, page_size: int = 50):
        offset = (page - 1) * page_size
        
        history = await self.db.fetch_all(
            """
            SELECT * FROM link_validations 
            WHERE user_id = %s 
            ORDER BY validated_at DESC 
            LIMIT %s OFFSET %s
            """,
            (user_id, page_size, offset)
        )
        
        total_count = await self.db.fetch_value(
            "SELECT COUNT(*) FROM link_validations WHERE user_id = %s",
            (user_id,)
        )
        
        return {
            'history': history,
            'total_count': total_count,
            'page': page,
            'page_size': page_size,
            'total_pages': (total_count + page_size - 1) // page_size
        }
```
### ðŸ§ª Senaryo 7: Bir link doÄŸrulama servisi URL'lerin eriÅŸilebilirliÄŸini kontrol eder. KullanÄ±cÄ±lar kontrol edilmesini istedikleri linkleri girebilir. Sistem bu linklere eriÅŸim deneyerek durumlarÄ±nÄ± raporlar. SonuÃ§lar kullanÄ±cÄ±ya detaylÄ± olarak sunulur.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 172
```typescript
import axios, { AxiosResponse } from 'axios';

interface LinkValidationRequest {
    userId: number;
    links: string[];
}

interface LinkValidationResult {
    url: string;
    statusCode: number;
    isAccessible: boolean;
    responseTime: number;
    contentType?: string;
    contentLength?: number;
    server?: string;
    lastModified?: string;
    errorMessage?: string;
}

export class LinkValidationService {
    async validateLinks(request: LinkValidationRequest): Promise<any> {
        const startTime = Date.now();
        const validationPromises = request.links.map(link => this.validateSingleLink(link));
        
        const results = await Promise.allSettled(validationPromises);
        
        const processedResults: LinkValidationResult[] = results.map((result, index) => {
            if (result.status === 'fulfilled') {
                return result.value;
            } else {
                return {
                    url: request.links[index],
                    statusCode: 0,
                    isAccessible: false,
                    responseTime: 0,
                    errorMessage: result.reason.message
                };
            }
        });
        
        // Save results to database
        for (const result of processedResults) {
            await this.saveValidationResult(request.userId, result);
        }
        
        const accessibleCount = processedResults.filter(r => r.isAccessible).length;
        
        return {
            totalLinks: request.links.length,
            accessibleLinks: accessibleCount,
            inaccessibleLinks: request.links.length - accessibleCount,
            totalValidationTime: Date.now() - startTime,
            results: processedResults
        };
    }
    
    private async validateSingleLink(url: string): Promise<LinkValidationResult> {
        const startTime = Date.now();
        
        try {
            // Validate URL format
            new URL(url);
            
            const response = await axios.head(url, {
                timeout: 10000,
                maxRedirects: 5,
                validateStatus: () => true // Don't throw on 4xx/5xx
            });
            
            const responseTime = Date.now() - startTime;
            
            return {
                url,
                statusCode: response.status,
                isAccessible: response.status >= 200 && response.status < 400,
                responseTime,
                contentType: response.headers['content-type'],
                contentLength: response.headers['content-length'] ? 
                    parseInt(response.headers['content-length']) : undefined,
                server: response.headers['server'],
                lastModified: response.headers['last-modified']
            };
            
        } catch (error) {
            const responseTime = Date.now() - startTime;
            
            let statusCode = 0;
            let errorMessage = error.message;
            
            if (error.code === 'ENOTFOUND') {
                errorMessage = 'Domain not found';
            } else if (error.code === 'ECONNREFUSED') {
                errorMessage = 'Connection refused';
            } else if (error.code === 'ETIMEDOUT') {
                statusCode = 408;
                errorMessage = 'Request timeout';
            }
            
            return {
                url,
                statusCode,
                isAccessible: false,
                responseTime,
                errorMessage
            };
        }
    }
    
    async getValidationHistory(userId: number, page: number = 1, pageSize: number = 50): Promise<any> {
        const offset = (page - 1) * pageSize;
        
        // This would be a database query in real implementation
        const history = await this.fetchValidationHistory(userId, pageSize, offset);
        const totalCount = await this.getValidationCount(userId);
        
        return {
            history,
            totalCount,
            page,
            pageSize,
            totalPages: Math.ceil(totalCount / pageSize)
        };
    }
    
    async validateLinksBatch(links: string[], batchSize: number = 10): Promise<LinkValidationResult[]> {
        const results: LinkValidationResult[] = [];
        
        for (let i = 0; i < links.length; i += batchSize) {
            const batch = links.slice(i, i + batchSize);
            const batchPromises = batch.map(link => this.validateSingleLink(link));
            const batchResults = await Promise.allSettled(batchPromises);
            
            const processedBatch = batchResults.map((result, index) => {
                if (result.status === 'fulfilled') {
                    return result.value;
                } else {
                    return {
                        url: batch[index],
                        statusCode: 0,
                        isAccessible: false,
                        responseTime: 0,
                        errorMessage: result.reason.message
                    };
                }
            });
            
            results.push(...processedBatch);
            
            // Add delay between batches to avoid overwhelming servers
            if (i + batchSize < links.length) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        
        return results;
    }
    
    private async saveValidationResult(userId: number, result: LinkValidationResult): Promise<void> {
        // Database save implementation
        console.log(`Saving validation result for user ${userId}:`, result);
    }
    
    private async fetchValidationHistory(userId: number, limit: number, offset: number): Promise<any[]> {
        // Database fetch implementation
        return [];
    }
    
    private async getValidationCount(userId: number): Promise<number> {
        // Database count implementation
        return 0;
    }
}
```
### ðŸ§ª Senaryo 8: Bir veri senkronizasyon aracÄ± farklÄ± sistemler arasÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. KullanÄ±cÄ±lar senkronize edilecek veri kaynaklarÄ±nÄ± belirtir. AraÃ§ bu kaynaklara eriÅŸerek verileri Ã§eker. Ã‡ekilen veriler hedef sistemlere aktarÄ±lÄ±r.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 118
```c#
[HttpPost("sync-configurations")]
public async Task<IActionResult> CreateSyncConfiguration([FromBody] SyncConfigurationRequest request)
{
    var config = new SyncConfiguration
    {
        UserId = request.UserId,
        Name = request.Name,
        SourceSystem = request.SourceSystem,
        TargetSystem = request.TargetSystem,
        SyncInterval = request.SyncInterval,
        LastSyncAt = null,
        IsActive = true,
        CreatedAt = DateTime.UtcNow
    };
    
    await _syncConfigRepository.Save(config);
    
    return Ok(new { configId = config.Id });
}

[HttpPost("sync-configurations/{id}/execute")]
public async Task<IActionResult> ExecuteSync(int id)
{
    var config = await _syncConfigRepository.GetById(id);
    if (config == null)
        return NotFound();
    
    var syncResult = await ExecuteSynchronization(config);
    
    return Ok(syncResult);
}

private async Task<SyncResult> ExecuteSynchronization(SyncConfiguration config)
{
    var syncLog = new SyncLog
    {
        ConfigurationId = config.Id,
        StartedAt = DateTime.UtcNow,
        Status = SyncStatus.InProgress
    };
    
    await _syncLogRepository.Save(syncLog);
    
    try
    {
        // Extract data from source system
        var sourceData = await ExtractDataFromSource(config.SourceSystem);
        
        // Transform data if needed
        var transformedData = TransformData(sourceData, config);
        
        // Load data to target system
        var loadResult = await LoadDataToTarget(transformedData, config.TargetSystem);
        
        syncLog.Status = SyncStatus.Completed;
        syncLog.RecordsProcessed = transformedData.Count;
        syncLog.CompletedAt = DateTime.UtcNow;
        
        config.LastSyncAt = DateTime.UtcNow;
        await _syncConfigRepository.Update(config);
        
        return new SyncResult
        {
            Success = true,
            RecordsProcessed = transformedData.Count,
            Duration = syncLog.CompletedAt.Value - syncLog.StartedAt
        };
    }
    catch (Exception ex)
    {
        syncLog.Status = SyncStatus.Failed;
        syncLog.ErrorMessage = ex.Message;
        syncLog.CompletedAt = DateTime.UtcNow;
        
        return new SyncResult
        {
            Success = false,
            ErrorMessage = ex.Message
        };
    }
    finally
    {
        await _syncLogRepository.Update(syncLog);
    }
}

private async Task<List<object>> ExtractDataFromSource(SystemConnection sourceSystem)
{
    return sourceSystem.Type.ToLower() switch
    {
        "database" => await ExtractFromDatabase(sourceSystem),
        "api" => await ExtractFromAPI(sourceSystem),
        "file" => await ExtractFromFile(sourceSystem),
        _ => throw new NotSupportedException($"Source system type {sourceSystem.Type} not supported")
    };
}

private async Task<List<object>> ExtractFromAPI(SystemConnection system)
{
    using var httpClient = new HttpClient();
    
    if (!string.IsNullOrEmpty(system.AuthToken))
    {
        httpClient.DefaultRequestHeaders.Authorization = 
            new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", system.AuthToken);
    }
    
    var response = await httpClient.GetStringAsync(system.ConnectionString);
    var data = JsonSerializer.Deserialize<List<object>>(response);
    
    return data;
}

private List<object> TransformData(List<object> sourceData, SyncConfiguration config)
{
    // Apply transformation rules based on configuration
    return sourceData; // Simplified for example
}
```
### ðŸ§ª Senaryo 8: Bir veri senkronizasyon aracÄ± farklÄ± sistemler arasÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. KullanÄ±cÄ±lar senkronize edilecek veri kaynaklarÄ±nÄ± belirtir. AraÃ§ bu kaynaklara eriÅŸerek verileri Ã§eker. Ã‡ekilen veriler hedef sistemlere aktarÄ±lÄ±r.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 222
```python
import asyncio
import aiohttp
import json
from datetime import datetime, timedelta
from typing import List, Dict, Any
from enum import Enum

class SyncStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"

class DataSynchronizationService:
    def __init__(self, db_connection):
        self.db = db_connection
    
    async def create_sync_configuration(self, user_id: int, name: str, 
                                      source_system: Dict, target_system: Dict, 
                                      sync_interval: int):
        config_data = {
            'user_id': user_id,
            'name': name,
            'source_system': json.dumps(source_system),
            'target_system': json.dumps(target_system),
            'sync_interval': sync_interval,
            'is_active': True,
            'created_at': datetime.utcnow()
        }
        
        config_id = await self.db.insert('sync_configurations', config_data)
        return {'config_id': config_id}
    
    async def execute_sync(self, config_id: int):
        config = await self.db.fetch_one(
            "SELECT * FROM sync_configurations WHERE id = %s", (config_id,)
        )
        
        if not config:
            return {'error': 'Configuration not found'}
        
        return await self._execute_synchronization(config)
    
    async def _execute_synchronization(self, config: Dict):
        # Create sync log
        sync_log_data = {
            'configuration_id': config['id'],
            'started_at': datetime.utcnow(),
            'status': SyncStatus.IN_PROGRESS.value
        }
        
        log_id = await self.db.insert('sync_logs', sync_log_data)
        
        try:
            source_system = json.loads(config['source_system'])
            target_system = json.loads(config['target_system'])
            
            # Extract data from source
            source_data = await self._extract_data_from_source(source_system)
            
            # Transform data
            transformed_data = self._transform_data(source_data, config)
            
            # Load data to target
            load_result = await self._load_data_to_target(transformed_data, target_system)
            
            # Update sync log
            await self.db.update('sync_logs', {
                'status': SyncStatus.COMPLETED.value,
                'records_processed': len(transformed_data),
                'completed_at': datetime.utcnow()
            }, {'id': log_id})
            
            # Update last sync time
            await self.db.update('sync_configurations', {
                'last_sync_at': datetime.utcnow()
            }, {'id': config['id']})
            
            return {
                'success': True,
                'records_processed': len(transformed_data),
                'log_id': log_id
            }
            
        except Exception as e:
            # Update sync log with error
            await self.db.update('sync_logs', {
                'status': SyncStatus.FAILED.value,
                'error_message': str(e),
                'completed_at': datetime.utcnow()
            }, {'id': log_id})
            
            return {
                'success': False,
                'error_message': str(e),
                'log_id': log_id
            }
    
    async def _extract_data_from_source(self, source_system: Dict) -> List[Dict]:
        system_type = source_system.get('type', '').lower()
        
        if system_type == 'api':
            return await self._extract_from_api(source_system)
        elif system_type == 'database':
            return await self._extract_from_database(source_system)
        elif system_type == 'file':
            return await self._extract_from_file(source_system)
        else:
            raise ValueError(f"Unsupported source system type: {system_type}")
    
    async def _extract_from_api(self, system: Dict) -> List[Dict]:
        url = system['connection_string']
        headers = system.get('headers', {})
        
        if system.get('auth_token'):
            headers['Authorization'] = f"Bearer {system['auth_token']}"
        
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                response.raise_for_status()
                data = await response.json()
                
                # Handle different response formats
                if isinstance(data, list):
                    return data
                elif isinstance(data, dict) and 'data' in data:
                    return data['data']
                else:
                    return [data]
    
    async def _extract_from_database(self, system: Dict) -> List[Dict]:
        # Database extraction logic would go here
        # This is a simplified example
        query = system.get('query', 'SELECT * FROM data_table')
        connection_string = system['connection_string']
        
        # Use appropriate database driver based on connection string
        results = await self.db.fetch_all(query)
        return [dict(row) for row in results]
    
    async def _extract_from_file(self, system: Dict) -> List[Dict]:
        file_path = system['connection_string']
        file_type = system.get('file_type', 'json')
        
        if file_type == 'json':
            with open(file_path, 'r') as file:
                data = json.load(file)
                return data if isinstance(data, list) else [data]
        elif file_type == 'csv':
            import pandas as pd
            df = pd.read_csv(file_path)
            return df.to_dict('records')
        else:
            raise ValueError(f"Unsupported file type: {file_type}")
    
    def _transform_data(self, source_data: List[Dict], config: Dict) -> List[Dict]:
        # Apply transformation rules based on configuration
        # This is a simplified example - real implementation would have
        # configurable transformation rules
        
        transformation_rules = config.get('transformation_rules', {})
        
        if not transformation_rules:
            return source_data
        
        transformed_data = []
        for record in source_data:
            transformed_record = {}
            for target_field, source_field in transformation_rules.items():
                if source_field in record:
                    transformed_record[target_field] = record[source_field]
            transformed_data.append(transformed_record)
        
        return transformed_data
    
    async def _load_data_to_target(self, data: List[Dict], target_system: Dict):
        system_type = target_system.get('type', '').lower()
        
        if system_type == 'api':
            return await self._load_to_api(data, target_system)
        elif system_type == 'database':
            return await self._load_to_database(data, target_system)
        elif system_type == 'file':
            return await self._load_to_file(data, target_system)
        else:
            raise ValueError(f"Unsupported target system type: {system_type}")
    
    async def _load_to_api(self, data: List[Dict], system: Dict):
        url = system['connection_string']
        headers = system.get('headers', {'Content-Type': 'application/json'})
        
        if system.get('auth_token'):
            headers['Authorization'] = f"Bearer {system['auth_token']}"
        
        async with aiohttp.ClientSession() as session:
            async with session.post(url, json=data, headers=headers) as response:
                response.raise_for_status()
                return await response.json()
    
    async def start_scheduled_syncs(self):
        """Start scheduled synchronization for active configurations"""
        while True:
            try:
                # Get configurations that need to be synced
                configs = await self.db.fetch_all("""
                    SELECT * FROM sync_configurations 
                    WHERE is_active = TRUE 
                    AND (last_sync_at IS NULL OR 
                         last_sync_at < NOW() - INTERVAL sync_interval MINUTE)
                """)
                
                # Execute syncs concurrently
                sync_tasks = [self._execute_synchronization(config) for config in configs]
                if sync_tasks:
                    await asyncio.gather(*sync_tasks, return_exceptions=True)
                
                # Wait before next check
                await asyncio.sleep(60)  # Check every minute
                
            except Exception as e:
                print(f"Error in scheduled sync: {e}")
                await asyncio.sleep(60)
```
### ðŸ§ª Senaryo 8: Bir veri senkronizasyon aracÄ± farklÄ± sistemler arasÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. KullanÄ±cÄ±lar senkronize edilecek veri kaynaklarÄ±nÄ± belirtir. AraÃ§ bu kaynaklara eriÅŸerek verileri Ã§eker. Ã‡ekilen veriler hedef sistemlere aktarÄ±lÄ±r.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 269
```typescript
import axios from 'axios';
import cron from 'node-cron';

interface SystemConnection {
    type: 'api' | 'database' | 'file';
    connectionString: string;
    authToken?: string;
    headers?: Record<string, string>;
    query?: string;
    fileType?: 'json' | 'csv' | 'xml';
}

interface SyncConfiguration {
    id: string;
    userId: number;
    name: string;
    sourceSystem: SystemConnection;
    targetSystem: SystemConnection;
    syncInterval: number; // minutes
    transformationRules?: Record<string, string>;
    isActive: boolean;
    lastSyncAt?: Date;
    createdAt: Date;
}

enum SyncStatus {
    PENDING = 'pending',
    IN_PROGRESS = 'in_progress',
    COMPLETED = 'completed',
    FAILED = 'failed'
}

export class DataSynchronizationService {
    private syncConfigurations = new Map<string, SyncConfiguration>();
    
    async createSyncConfiguration(config: Omit<SyncConfiguration, 'id' | 'createdAt'>): Promise<string> {
        const syncConfig: SyncConfiguration = {
            ...config,
            id: this.generateId(),
            createdAt: new Date()
        };
        
        this.syncConfigurations.set(syncConfig.id, syncConfig);
        await this.saveSyncConfiguration(syncConfig);
        
        return syncConfig.id;
    }
    
    async executeSync(configId: string): Promise<any> {
        const config = this.syncConfigurations.get(configId);
        if (!config) {
            throw new Error('Sync configuration not found');
        }
        
        return await this.executeSynchronization(config);
    }
    
    private async executeSynchronization(config: SyncConfiguration): Promise<any> {
        const syncLog = {
            id: this.generateId(),
            configurationId: config.id,
            startedAt: new Date(),
            status: SyncStatus.IN_PROGRESS
        };
        
        await this.saveSyncLog(syncLog);
        
        try {
            // Extract data from source system
            const sourceData = await this.extractDataFromSource(config.sourceSystem);
            
            // Transform data
            const transformedData = this.transformData(sourceData, config.transformationRules);
            
            // Load data to target system
            await this.loadDataToTarget(transformedData, config.targetSystem);
            
            // Update sync log
            syncLog.status = SyncStatus.COMPLETED;
            await this.updateSyncLog(syncLog.id, {
                status: SyncStatus.COMPLETED,
                recordsProcessed: transformedData.length,
                completedAt: new Date()
            });
            
            // Update last sync time
            config.lastSyncAt = new Date();
            await this.updateSyncConfiguration(config);
            
            return {
                success: true,
                recordsProcessed: transformedData.length,
                logId: syncLog.id
            };
            
        } catch (error) {
            syncLog.status = SyncStatus.FAILED;
            await this.updateSyncLog(syncLog.id, {
                status: SyncStatus.FAILED,
                errorMessage: error.message,
                completedAt: new Date()
            });
            
            return {
                success: false,
                errorMessage: error.message,
                logId: syncLog.id
            };
        }
    }
    
    private async extractDataFromSource(sourceSystem: SystemConnection): Promise<any[]> {
        switch (sourceSystem.type) {
            case 'api':
                return await this.extractFromAPI(sourceSystem);
            case 'database':
                return await this.extractFromDatabase(sourceSystem);
            case 'file':
                return await this.extractFromFile(sourceSystem);
            default:
                throw new Error(`Unsupported source system type: ${sourceSystem.type}`);
        }
    }
    
    private async extractFromAPI(system: SystemConnection): Promise<any[]> {
        const headers = { ...system.headers };
        
        if (system.authToken) {
            headers['Authorization'] = `Bearer ${system.authToken}`;
        }
        
        const response = await axios.get(system.connectionString, {
            headers,
            timeout: 30000
        });
        
        const data = response.data;
        
        // Handle different response formats
        if (Array.isArray(data)) {
            return data;
        } else if (data && typeof data === 'object' && data.data) {
            return Array.isArray(data.data) ? data.data : [data.data];
        } else {
            return [data];
        }
    }
    
    private async extractFromDatabase(system: SystemConnection): Promise<any[]> {
        // Database extraction logic would go here
        // This is a simplified example using a hypothetical database client
        const query = system.query || 'SELECT * FROM data_table';
        
        // In real implementation, you would use appropriate database driver
        // const results = await databaseClient.query(query);
        // return results.rows;
        
        return []; // Placeholder
    }
    
    private async extractFromFile(system: SystemConnection): Promise<any[]> {
        const fs = require('fs').promises;
        
        if (system.fileType === 'json') {
            const fileContent = await fs.readFile(system.connectionString, 'utf8');
            const data = JSON.parse(fileContent);
            return Array.isArray(data) ? data : [data];
        } else if (system.fileType === 'csv') {
            // CSV parsing logic would go here
            // const csv = require('csv-parser');
            // Parse CSV and return array of objects
            return []; // Placeholder
        } else {
            throw new Error(`Unsupported file type: ${system.fileType}`);
        }
    }
    
    private transformData(sourceData: any[], transformationRules?: Record<string, string>): any[] {
        if (!transformationRules) {
            return sourceData;
        }
        
        return sourceData.map(record => {
            const transformedRecord: any = {};
            
            for (const [targetField, sourceField] of Object.entries(transformationRules)) {
                if (record[sourceField] !== undefined) {
                    transformedRecord[targetField] = record[sourceField];
                }
            }
            
            return transformedRecord;
        });
    }
    
    private async loadDataToTarget(data: any[], targetSystem: SystemConnection): Promise<void> {
        switch (targetSystem.type) {
            case 'api':
                await this.loadToAPI(data, targetSystem);
                break;
            case 'database':
                await this.loadToDatabase(data, targetSystem);
                break;
            case 'file':
                await this.loadToFile(data, targetSystem);
                break;
            default:
                throw new Error(`Unsupported target system type: ${targetSystem.type}`);
        }
    }
    
    private async loadToAPI(data: any[], system: SystemConnection): Promise<void> {
        const headers = { 'Content-Type': 'application/json', ...system.headers };
        
        if (system.authToken) {
            headers['Authorization'] = `Bearer ${system.authToken}`;
        }
        
        await axios.post(system.connectionString, data, {
            headers,
            timeout: 30000
        });
    }
    
    private async loadToDatabase(data: any[], system: SystemConnection): Promise<void> {
        // Database loading logic would go here
        console.log(`Loading ${data.length} records to database`);
    }
    
    private async loadToFile(data: any[], system: SystemConnection): Promise<void> {
        const fs = require('fs').promises;
        
        if (system.fileType === 'json') {
            await fs.writeFile(system.connectionString, JSON.stringify(data, null, 2));
        } else {
            throw new Error(`Unsupported file type for writing: ${system.fileType}`);
        }
    }
    
    startScheduledSyncs(): void {
        // Run every minute to check for due syncs
        cron.schedule('* * * * *', async () => {
            await this.checkAndExecuteScheduledSyncs();
        });
    }
    
    private async checkAndExecuteScheduledSyncs(): Promise<void> {
        const now = new Date();
        
        for (const config of this.syncConfigurations.values()) {
            if (!config.isActive) continue;
            
            const shouldSync = !config.lastSyncAt || 
                (now.getTime() - config.lastSyncAt.getTime()) >= (config.syncInterval * 60 * 1000);
            
            if (shouldSync) {
                try {
                    await this.executeSynchronization(config);
                } catch (error) {
                    console.error(`Scheduled sync failed for config ${config.id}:`, error.message);
                }
            }
        }
    }
    
    private generateId(): string {
        return Math.random().toString(36).substr(2, 9);
    }
}
```
### ðŸ§ª Senaryo 9: Bir medya iÃ§erik yÃ¶netimi servisi harici kaynaklardan medya dosyalarÄ±nÄ± alÄ±r. KullanÄ±cÄ±lar medya URL'lerini sisteme ekleyebilir. Servis bu URL'lerdeki iÃ§erikleri indirir ve iÅŸler. Ä°ÅŸlenen medya dosyalarÄ± kullanÄ±cÄ± galerisinde gÃ¶sterilir.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 113
```c#
[HttpPost("media-content")]
public async Task<IActionResult> AddMediaContent([FromBody] MediaContentRequest request)
{
    try
    {
        var mediaContent = new MediaContent
        {
            UserId = request.UserId,
            SourceUrl = request.Url,
            Title = request.Title,
            Status = MediaProcessingStatus.Pending,
            CreatedAt = DateTime.UtcNow
        };
        
        await _mediaContentRepository.Save(mediaContent);
        
        // Process media asynchronously
        _ = Task.Run(() => ProcessMediaContent(mediaContent.Id));
        
        return Ok(new { contentId = mediaContent.Id });
    }
    catch (Exception ex)
    {
        return BadRequest(new { error = ex.Message });
    }
}

[HttpGet("media-gallery/{userId}")]
public async Task<IActionResult> GetMediaGallery(int userId, int page = 1, int pageSize = 20)
{
    var mediaItems = await _mediaContentRepository.GetUserMedia(userId, page, pageSize);
    return Ok(mediaItems);
}

private async Task ProcessMediaContent(int contentId)
{
    var content = await _mediaContentRepository.GetById(contentId);
    if (content == null) return;
    
    try
    {
        content.Status = MediaProcessingStatus.Processing;
        await _mediaContentRepository.Update(content);
        
        // Download media file
        var downloadedFile = await DownloadMediaFile(content.SourceUrl);
        
        // Detect media type
        var mediaInfo = await _mediaAnalyzer.AnalyzeMedia(downloadedFile);
        content.MediaType = mediaInfo.Type;
        content.Duration = mediaInfo.Duration;
        content.FileSize = downloadedFile.Length;
        
        // Generate thumbnail for images/videos
        var thumbnailPath = await GenerateThumbnail(downloadedFile, mediaInfo.Type);
        
        // Store processed media
        var storedPath = await _mediaStorage.StoreMedia(downloadedFile, content.Id);
        
        content.FilePath = storedPath;
        content.ThumbnailPath = thumbnailPath;
        content.Status = MediaProcessingStatus.Completed;
        content.ProcessedAt = DateTime.UtcNow;
        
        await _mediaContentRepository.Update(content);
    }
    catch (Exception ex)
    {
        content.Status = MediaProcessingStatus.Failed;
        content.ErrorMessage = ex.Message;
        await _mediaContentRepository.Update(content);
    }
}

private async Task<byte[]> DownloadMediaFile(string url)
{
    using var httpClient = new HttpClient();
    httpClient.Timeout = TimeSpan.FromMinutes(5);
    
    var response = await httpClient.GetAsync(url);
    response.EnsureSuccessStatusCode();
    
    return await response.Content.ReadAsByteArrayAsync();
}

private async Task<string> GenerateThumbnail(byte[] mediaFile, MediaType mediaType)
{
    switch (mediaType)
    {
        case MediaType.Image:
            return await _imageProcessor.GenerateImageThumbnail(mediaFile);
        case MediaType.Video:
            return await _videoProcessor.GenerateVideoThumbnail(mediaFile);
        default:
            return null;
    }
}

public enum MediaProcessingStatus
{
    Pending,
    Processing,
    Completed,
    Failed
}

public enum MediaType
{
    Image,
    Video,
    Audio,
    Document
}
```
### ðŸ§ª Senaryo 9: Bir medya iÃ§erik yÃ¶netimi servisi harici kaynaklardan medya dosyalarÄ±nÄ± alÄ±r. KullanÄ±cÄ±lar medya URL'lerini sisteme ekleyebilir. Servis bu URL'lerdeki iÃ§erikleri indirir ve iÅŸler. Ä°ÅŸlenen medya dosyalarÄ± kullanÄ±cÄ± galerisinde gÃ¶sterilir.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 170
```python
import asyncio
import aiohttp
import aiofiles
from datetime import datetime
from pathlib import Path
from PIL import Image
import magic
from typing import Optional, Dict

class MediaContentService:
    def __init__(self, db_connection, storage_path: str = "media_storage"):
        self.db = db_connection
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(exist_ok=True)
        (self.storage_path / "thumbnails").mkdir(exist_ok=True)
    
    async def add_media_content(self, user_id: int, url: str, title: str):
        media_data = {
            'user_id': user_id,
            'source_url': url,
            'title': title,
            'status': 'pending',
            'created_at': datetime.utcnow()
        }
        
        content_id = await self.db.insert('media_content', media_data)
        
        # Process media asynchronously
        asyncio.create_task(self._process_media_content(content_id))
        
        return {'content_id': content_id}
    
    async def get_media_gallery(self, user_id: int, page: int = 1, page_size: int = 20):
        offset = (page - 1) * page_size
        
        media_items = await self.db.fetch_all("""
            SELECT * FROM media_content 
            WHERE user_id = %s AND status = 'completed'
            ORDER BY created_at DESC 
            LIMIT %s OFFSET %s
        """, (user_id, page_size, offset))
        
        total_count = await self.db.fetch_value(
            "SELECT COUNT(*) FROM media_content WHERE user_id = %s AND status = 'completed'",
            (user_id,)
        )
        
        return {
            'media_items': media_items,
            'total_count': total_count,
            'page': page,
            'page_size': page_size,
            'total_pages': (total_count + page_size - 1) // page_size
        }
    
    async def _process_media_content(self, content_id: int):
        try:
            # Update status to processing
            await self.db.update('media_content', 
                {'status': 'processing'}, 
                {'id': content_id}
            )
            
            content = await self.db.fetch_one(
                "SELECT * FROM media_content WHERE id = %s", (content_id,)
            )
            
            # Download media file
            media_file_path = await self._download_media_file(
                content['source_url'], content_id
            )
            
            # Analyze media
            media_info = await self._analyze_media(media_file_path)
            
            # Generate thumbnail
            thumbnail_path = await self._generate_thumbnail(
                media_file_path, media_info['type']
            )
            
            # Update database with processed info
            await self.db.update('media_content', {
                'file_path': str(media_file_path),
                'thumbnail_path': str(thumbnail_path) if thumbnail_path else None,
                'media_type': media_info['type'],
                'file_size': media_info['size'],
                'duration': media_info.get('duration'),
                'width': media_info.get('width'),
                'height': media_info.get('height'),
                'status': 'completed',
                'processed_at': datetime.utcnow()
            }, {'id': content_id})
            
        except Exception as e:
            await self.db.update('media_content', {
                'status': 'failed',
                'error_message': str(e)
            }, {'id': content_id})
    
    async def _download_media_file(self, url: str, content_id: int) -> Path:
        file_extension = self._get_file_extension_from_url(url) or '.bin'
        file_path = self.storage_path / f"media_{content_id}{file_extension}"
        
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=300)) as response:
                response.raise_for_status()
                
                async with aiofiles.open(file_path, 'wb') as file:
                    async for chunk in response.content.iter_chunked(8192):
                        await file.write(chunk)
        
        return file_path
    
    async def _analyze_media(self, file_path: Path) -> Dict:
        # Get file info
        file_size = file_path.stat().st_size
        
        # Detect MIME type
        mime_type = magic.from_file(str(file_path), mime=True)
        media_type = self._get_media_type_from_mime(mime_type)
        
        media_info = {
            'type': media_type,
            'size': file_size,
            'mime_type': mime_type
        }
        
        # Additional analysis based on media type
        if media_type == 'image':
            try:
                with Image.open(file_path) as img:
                    media_info['width'] = img.width
                    media_info['height'] = img.height
            except Exception:
                pass
        
        return media_info
    
    async def _generate_thumbnail(self, file_path: Path, media_type: str) -> Optional[Path]:
        if media_type != 'image':
            return None
        
        try:
            thumbnail_path = self.storage_path / "thumbnails" / f"thumb_{file_path.stem}.jpg"
            
            with Image.open(file_path) as img:
                img.thumbnail((300, 300), Image.Resampling.LANCZOS)
                img.convert('RGB').save(thumbnail_path, 'JPEG', quality=85)
            
            return thumbnail_path
            
        except Exception as e:
            print(f"Error generating thumbnail: {e}")
            return None
    
    def _get_file_extension_from_url(self, url: str) -> Optional[str]:
        from urllib.parse import urlparse
        parsed_url = urlparse(url)
        path = Path(parsed_url.path)
        return path.suffix if path.suffix else None
    
    def _get_media_type_from_mime(self, mime_type: str) -> str:
        if mime_type.startswith('image/'):
            return 'image'
        elif mime_type.startswith('video/'):
            return 'video'
        elif mime_type.startswith('audio/'):
            return 'audio'
        else:
            return 'document'
```
### ðŸ§ª Senaryo 9: Bir medya iÃ§erik yÃ¶netimi servisi harici kaynaklardan medya dosyalarÄ±nÄ± alÄ±r. KullanÄ±cÄ±lar medya URL'lerini sisteme ekleyebilir. Servis bu URL'lerdeki iÃ§erikleri indirir ve iÅŸler. Ä°ÅŸlenen medya dosyalarÄ± kullanÄ±cÄ± galerisinde gÃ¶sterilir.

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 215
```typescript
import axios from 'axios';
import fs from 'fs/promises';
import path from 'path';
import sharp from 'sharp';
import { v4 as uuidv4 } from 'uuid';

interface MediaContent {
    id: string;
    userId: number;
    sourceUrl: string;
    title: string;
    filePath?: string;
    thumbnailPath?: string;
    mediaType?: string;
    fileSize?: number;
    width?: number;
    height?: number;
    duration?: number;
    status: 'pending' | 'processing' | 'completed' | 'failed';
    errorMessage?: string;
    createdAt: Date;
    processedAt?: Date;
}

export class MediaContentService {
    private storagePath: string;
    private mediaContents = new Map<string, MediaContent>();
    
    constructor(storagePath: string = 'media_storage') {
        this.storagePath = storagePath;
        this.ensureStorageDirectories();
    }
    
    async addMediaContent(userId: number, url: string, title: string): Promise<string> {
        const mediaContent: MediaContent = {
            id: uuidv4(),
            userId,
            sourceUrl: url,
            title,
            status: 'pending',
            createdAt: new Date()
        };
        
        this.mediaContents.set(mediaContent.id, mediaContent);
        await this.saveMediaContent(mediaContent);
        
        // Process media asynchronously
        this.processMediaContent(mediaContent.id).catch(console.error);
        
        return mediaContent.id;
    }
    
    async getMediaGallery(userId: number, page: number = 1, pageSize: number = 20): Promise<any> {
        const userMedia = Array.from(this.mediaContents.values())
            .filter(media => media.userId === userId && media.status === 'completed')
            .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        
        const startIndex = (page - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const mediaItems = userMedia.slice(startIndex, endIndex);
        
        return {
            mediaItems,
            totalCount: userMedia.length,
            page,
            pageSize,
            totalPages: Math.ceil(userMedia.length / pageSize)
        };
    }
    
    private async processMediaContent(contentId: string): Promise<void> {
        const content = this.mediaContents.get(contentId);
        if (!content) return;
        
        try {
            content.status = 'processing';
            await this.updateMediaContent(content);
            
            // Download media file
            const filePath = await this.downloadMediaFile(content.sourceUrl, contentId);
            content.filePath = filePath;
            
            // Analyze media
            const mediaInfo = await this.analyzeMedia(filePath);
            content.mediaType = mediaInfo.type;
            content.fileSize = mediaInfo.size;
            content.width = mediaInfo.width;
            content.height = mediaInfo.height;
            
            // Generate thumbnail
            if (mediaInfo.type === 'image') {
                content.thumbnailPath = await this.generateThumbnail(filePath);
            }
            
            content.status = 'completed';
            content.processedAt = new Date();
            
            await this.updateMediaContent(content);
            
        } catch (error) {
            content.status = 'failed';
            content.errorMessage = error.message;
            await this.updateMediaContent(content);
        }
    }
    
    private async downloadMediaFile(url: string, contentId: string): Promise<string> {
        const fileExtension = this.getFileExtensionFromUrl(url) || '.bin';
        const fileName = `media_${contentId}${fileExtension}`;
        const filePath = path.join(this.storagePath, fileName);
        
        const response = await axios({
            method: 'GET',
            url: url,
            responseType: 'stream',
            timeout: 300000 // 5 minutes
        });
        
        const writer = fs.createWriteStream(filePath);
        response.data.pipe(writer);
        
        return new Promise((resolve, reject) => {
            writer.on('finish', () => resolve(filePath));
            writer.on('error', reject);
        });
    }
    
    private async analyzeMedia(filePath: string): Promise<any> {
        const stats = await fs.stat(filePath);
        const fileSize = stats.size;
        
        // Basic file type detection
        const extension = path.extname(filePath).toLowerCase();
        const mediaType = this.getMediaTypeFromExtension(extension);
        
        const mediaInfo: any = {
            type: mediaType,
            size: fileSize
        };
        
        // Additional analysis for images
        if (mediaType === 'image') {
            try {
                const metadata = await sharp(filePath).metadata();
                mediaInfo.width = metadata.width;
                mediaInfo.height = metadata.height;
            } catch (error) {
                console.error('Error analyzing image:', error);
            }
        }
        
        return mediaInfo;
    }
    
    private async generateThumbnail(filePath: string): Promise<string> {
        const thumbnailDir = path.join(this.storagePath, 'thumbnails');
        const fileName = path.basename(filePath, path.extname(filePath));
        const thumbnailPath = path.join(thumbnailDir, `thumb_${fileName}.jpg`);
        
        try {
            await sharp(filePath)
                .resize(300, 300, {
                    fit: 'inside',
                    withoutEnlargement: true
                })
                .jpeg({ quality: 85 })
                .toFile(thumbnailPath);
            
            return thumbnailPath;
        } catch (error) {
            console.error('Error generating thumbnail:', error);
            throw error;
        }
    }
    
    private getFileExtensionFromUrl(url: string): string | null {
        try {
            const parsedUrl = new URL(url);
            return path.extname(parsedUrl.pathname);
        } catch {
            return null;
        }
    }
    
    private getMediaTypeFromExtension(extension: string): string {
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
        const videoExtensions = ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv'];
        const audioExtensions = ['.mp3', '.wav', '.ogg', '.m4a', '.flac'];
        
        if (imageExtensions.includes(extension)) return 'image';
        if (videoExtensions.includes(extension)) return 'video';
        if (audioExtensions.includes(extension)) return 'audio';
        
        return 'document';
    }
    
    private async ensureStorageDirectories(): Promise<void> {
        try {
            await fs.mkdir(this.storagePath, { recursive: true });
            await fs.mkdir(path.join(this.storagePath, 'thumbnails'), { recursive: true });
        } catch (error) {
            console.error('Error creating storage directories:', error);
        }
    }
    
    private async saveMediaContent(content: MediaContent): Promise<void> {
        // Database save implementation
        console.log('Saving media content:', content.id);
    }
    
    private async updateMediaContent(content: MediaContent): Promise<void> {
        // Database update implementation
        console.log('Updating media content:', content.id, content.status);
    }
}
```
### ðŸ§ª Senaryo 10: Bir API test aracÄ± farklÄ± endpoint'leri test etmek iÃ§in istekler gÃ¶nderir. KullanÄ±cÄ±lar test edilecek API URL'lerini belirtir. AraÃ§ bu endpoint'lere test istekleri gÃ¶ndererek yanÄ±tlarÄ± analiz eder. Test sonuÃ§larÄ± rapor halinde sunulur.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 160
```c#
[HttpPost("api-tests")]
public async Task<IActionResult> CreateApiTest([FromBody] ApiTestRequest request)
{
    var test = new ApiTest
    {
        UserId = request.UserId,
        Name = request.Name,
        Endpoint = request.Endpoint,
        Method = request.Method,
        Headers = JsonSerializer.Serialize(request.Headers ?? new Dictionary<string, string>()),
        Body = request.Body,
        ExpectedStatusCode = request.ExpectedStatusCode,
        CreatedAt = DateTime.UtcNow
    };
    
    await _apiTestRepository.Save(test);
    
    return Ok(new { testId = test.Id });
}

[HttpPost("api-tests/{testId}/execute")]
public async Task<IActionResult> ExecuteApiTest(int testId)
{
    var test = await _apiTestRepository.GetById(testId);
    if (test == null)
        return NotFound();
    
    var result = await ExecuteTest(test);
    
    return Ok(result);
}

[HttpPost("api-tests/batch-execute")]
public async Task<IActionResult> ExecuteBatchTests([FromBody] BatchTestRequest request)
{
    var tests = await _apiTestRepository.GetByIds(request.TestIds);
    var results = new List<ApiTestResult>();
    
    var tasks = tests.Select(async test =>
    {
        var result = await ExecuteTest(test);
        lock (results)
        {
            results.Add(result);
        }
        return result;
    });
    
    await Task.WhenAll(tasks);
    
    var report = GenerateTestReport(results);
    
    return Ok(report);
}

private async Task<ApiTestResult> ExecuteTest(ApiTest test)
{
    var stopwatch = System.Diagnostics.Stopwatch.StartNew();
    var result = new ApiTestResult
    {
        TestId = test.Id,
        StartedAt = DateTime.UtcNow
    };
    
    try
    {
        using var httpClient = new HttpClient();
        httpClient.Timeout = TimeSpan.FromSeconds(30);
        
        var request = new HttpRequestMessage(
            new HttpMethod(test.Method.ToUpper()),
            test.Endpoint
        );
        
        // Add headers
        if (!string.IsNullOrEmpty(test.Headers))
        {
            var headers = JsonSerializer.Deserialize<Dictionary<string, string>>(test.Headers);
            foreach (var header in headers)
            {
                request.Headers.TryAddWithoutValidation(header.Key, header.Value);
            }
        }
        
        // Add body for POST/PUT requests
        if (!string.IsNullOrEmpty(test.Body) && 
            new[] { "POST", "PUT", "PATCH" }.Contains(test.Method.ToUpper()))
        {
            request.Content = new StringContent(test.Body, Encoding.UTF8, "application/json");
        }
        
        var response = await httpClient.SendAsync(request);
        var responseContent = await response.Content.ReadAsStringAsync();
        
        stopwatch.Stop();
        
        result.StatusCode = (int)response.StatusCode;
        result.ResponseBody = responseContent;
        result.ResponseTime = stopwatch.ElapsedMilliseconds;
        result.Success = test.ExpectedStatusCode == null || 
                        test.ExpectedStatusCode == (int)response.StatusCode;
        result.ResponseHeaders = JsonSerializer.Serialize(
            response.Headers.ToDictionary(h => h.Key, h => string.Join(", ", h.Value))
        );
    }
    catch (Exception ex)
    {
        stopwatch.Stop();
        result.Success = false;
        result.ErrorMessage = ex.Message;
        result.ResponseTime = stopwatch.ElapsedMilliseconds;
    }
    
    result.CompletedAt = DateTime.UtcNow;
    await _apiTestResultRepository.Save(result);
    
    return result;
}

private TestReport GenerateTestReport(List<ApiTestResult> results)
{
    var totalTests = results.Count;
    var passedTests = results.Count(r => r.Success);
    var failedTests = totalTests - passedTests;
    var averageResponseTime = results.Where(r => r.ResponseTime.HasValue)
                                    .Average(r => r.ResponseTime.Value);
    
    return new TestReport
    {
        TotalTests = totalTests,
        PassedTests = passedTests,
        FailedTests = failedTests,
        SuccessRate = totalTests > 0 ? (double)passedTests / totalTests * 100 : 0,
        AverageResponseTime = averageResponseTime,
        Results = results,
        GeneratedAt = DateTime.UtcNow
    };
}

public class ApiTestRequest
{
    public int UserId { get; set; }
    public string Name { get; set; }
    public string Endpoint { get; set; }
    public string Method { get; set; } = "GET";
    public Dictionary<string, string> Headers { get; set; }
    public string Body { get; set; }
    public int? ExpectedStatusCode { get; set; }
}

public class TestReport
{
    public int TotalTests { get; set; }
    public int PassedTests { get; set; }
    public int FailedTests { get; set; }
    public double SuccessRate { get; set; }
    public double AverageResponseTime { get; set; }
    public List<ApiTestResult> Results { get; set; }
    public DateTime GeneratedAt { get; set; }
}
```
### ðŸ§ª Senaryo 10: Bir API test aracÄ± farklÄ± endpoint'leri test etmek iÃ§in istekler gÃ¶nderir. KullanÄ±cÄ±lar test edilecek API URL'lerini belirtir. AraÃ§ bu endpoint'lere test istekleri gÃ¶ndererek yanÄ±tlarÄ± analiz eder. Test sonuÃ§larÄ± rapor halinde sunulur.

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 254
```python
import asyncio
import aiohttp
import time
import json
from datetime import datetime
from typing import List, Dict, Optional

class ApiTestService:
    def __init__(self, db_connection):
        self.db = db_connection
    
    async def create_api_test(self, user_id: int, name: str, endpoint: str, 
                            method: str = 'GET', headers: Optional[Dict] = None,
                            body: Optional[str] = None, expected_status_code: Optional[int] = None):
        test_data = {
            'user_id': user_id,
            'name': name,
            'endpoint': endpoint,
            'method': method.upper(),
            'headers': json.dumps(headers or {}),
            'body': body,
            'expected_status_code': expected_status_code,
            'created_at': datetime.utcnow()
        }
        
        test_id = await self.db.insert('api_tests', test_data)
        return {'test_id': test_id}
    
    async def execute_api_test(self, test_id: int):
        test = await self.db.fetch_one(
            "SELECT * FROM api_tests WHERE id = %s", (test_id,)
        )
        
        if not test:
            return {'error': 'Test not found'}
        
        result = await self._execute_test(test)
        return result
    
    async def execute_batch_tests(self, test_ids: List[int]):
        tests = await self.db.fetch_all(
            f"SELECT * FROM api_tests WHERE id IN ({','.join(['%s'] * len(test_ids))})",
            test_ids
        )
        
        # Execute tests concurrently
        tasks = [self._execute_test(test) for test in tests]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Process results
        processed_results = []
        for result in results:
            if isinstance(result, Exception):
                processed_results.append({
                    'success': False,
                    'error_message': str(result)
                })
            else:
                processed_results.append(result)
        
        # Generate report
        report = self._generate_test_report(processed_results)
        
        return report
    
    async def _execute_test(self, test: Dict):
        start_time = time.time()
        result_data = {
            'test_id': test['id'],
            'started_at': datetime.utcnow()
        }
        
        try:
            headers = json.loads(test['headers']) if test['headers'] else {}
            
            timeout = aiohttp.ClientTimeout(total=30)
            
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # Prepare request parameters
                request_kwargs = {
                    'url': test['endpoint'],
                    'method': test['method'],
                    'headers': headers
                }
                
                # Add body for POST/PUT/PATCH requests
                if test['body'] and test['method'] in ['POST', 'PUT', 'PATCH']:
                    request_kwargs['data'] = test['body']
                    if 'content-type' not in {k.lower() for k in headers.keys()}:
                        headers['Content-Type'] = 'application/json'
                
                async with session.request(**request_kwargs) as response:
                    response_text = await response.text()
                    response_time = int((time.time() - start_time) * 1000)
                    
                    # Check if test passed
                    success = (test['expected_status_code'] is None or 
                             test['expected_status_code'] == response.status)
                    
                    result_data.update({
                        'status_code': response.status,
                        'response_body': response_text,
                        'response_time': response_time,
                        'response_headers': json.dumps(dict(response.headers)),
                        'success': success,
                        'completed_at': datetime.utcnow()
                    })
                    
        except asyncio.TimeoutError:
            response_time = int((time.time() - start_time) * 1000)
            result_data.update({
                'success': False,
                'error_message': 'Request timeout',
                'response_time': response_time,
                'completed_at': datetime.utcnow()
            })
            
        except Exception as e:
            response_time = int((time.time() - start_time) * 1000)
            result_data.update({
                'success': False,
                'error_message': str(e),
                'response_time': response_time,
                'completed_at': datetime.utcnow()
            })
        
        # Save result to database
        await self.db.insert('api_test_results', result_data)
        
        return result_data
    
    def _generate_test_report(self, results: List[Dict]):
        total_tests = len(results)
        passed_tests = sum(1 for r in results if r.get('success', False))
        failed_tests = total_tests - passed_tests
        
        response_times = [r['response_time'] for r in results 
                         if 'response_time' in r and r['response_time'] is not None]
        avg_response_time = sum(response_times) / len(response_times) if response_times else 0
        
        return {
            'total_tests': total_tests,
            'passed_tests': passed_tests,
            'failed_tests': failed_tests,
            'success_rate': (passed_tests / total_tests * 100) if total_tests > 0 else 0,
            'average_response_time': avg_response_time,
            'results': results,
            'generated_at': datetime.utcnow()
        }
    
    async def get_test_history(self, user_id: int, page: int = 1, page_size: int = 50):
        offset = (page - 1) * page_size
        
        test_results = await self.db.fetch_all("""
            SELECT t.name, t.endpoint, t.method, r.*
            FROM api_test_results r
            JOIN api_tests t ON r.test_id = t.id
            WHERE t.user_id = %s
            ORDER BY r.started_at DESC
            LIMIT %s OFFSET %s
        """, (user_id, page_size, offset))
        
        total_count = await self.db.fetch_value("""
            SELECT COUNT(*)
            FROM api_test_results r
            JOIN api_tests t ON r.test_id = t.id
            WHERE t.user_id = %s
        """, (user_id,))
        
        return {
            'test_history': test_results,
            'total_count': total_count,
            'page': page,
            'page_size': page_size,
            'total_pages': (total_count + page_size - 1) // page_size
        }
    
    async def run_performance_test(self, test_id: int, concurrent_requests: int = 10, 
                                 duration_seconds: int = 60):
        test = await self.db.fetch_one(
            "SELECT * FROM api_tests WHERE id = %s", (test_id,)
        )
        
        if not test:
            return {'error': 'Test not found'}
        
        start_time = time.time()
        end_time = start_time + duration_seconds
        
        all_results = []
        
        while time.time() < end_time:
            # Run concurrent requests
            tasks = [self._execute_single_request(test) for _ in range(concurrent_requests)]
            batch_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            all_results.extend([r for r in batch_results if not isinstance(r, Exception)])
            
            # Small delay between batches
            await asyncio.sleep(0.1)
        
        # Analyze performance results
        return self._analyze_performance_results(all_results)
    
    async def _execute_single_request(self, test: Dict):
        start_time = time.time()
        
        try:
            headers = json.loads(test['headers']) if test['headers'] else {}
            
            async with aiohttp.ClientSession() as session:
                request_kwargs = {
                    'url': test['endpoint'],
                    'method': test['method'],
                    'headers': headers
                }
                
                if test['body'] and test['method'] in ['POST', 'PUT', 'PATCH']:
                    request_kwargs['data'] = test['body']
                
                async with session.request(**request_kwargs) as response:
                    await response.text()  # Read response
                    response_time = int((time.time() - start_time) * 1000)
                    
                    return {
                        'status_code': response.status,
                        'response_time': response_time,
                        'success': response.status < 400
                    }
                    
        except Exception:
            return {
                'status_code': 0,
                'response_time': int((time.time() - start_time) * 1000),
                'success': False
            }
    
    def _analyze_performance_results(self, results: List[Dict]):
        if not results:
            return {'error': 'No results to analyze'}
        
        response_times = [r['response_time'] for r in results]
        successful_requests = [r for r in results if r['success']]
        
        return {
            'total_requests': len(results),
            'successful_requests': len(successful_requests),
            'failed_requests': len(results) - len(successful_requests),
            'success_rate': len(successful_requests) / len(results) * 100,
            'average_response_time': sum(response_times) / len(response_times),
            'min_response_time': min(response_times),
            'max_response_time': max(response_times),
            'requests_per_second': len(results) / 60  # Assuming 60 second test
        }
```
### ðŸ§ª Senaryo 10: Bir API test aracÄ± farklÄ± endpoint'leri test etmek iÃ§in istekler gÃ¶nderir. KullanÄ±cÄ±lar test edilecek API URL'lerini belirtir. AraÃ§ bu endpoint'lere test istekleri gÃ¶ndererek yanÄ±tlarÄ± analiz eder. Test sonuÃ§larÄ± rapor halinde sunulur.