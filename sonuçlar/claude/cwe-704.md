### ðŸ§ª Senaryo 1: Bir hesap makinesi uygulamasÄ±nda kullanÄ±cÄ±lar farklÄ± sayÄ± tÃ¼rleri girebiliyor. Sistem ondalÄ±klÄ± ve tam sayÄ±larÄ± iÅŸleyebilir. GiriÅŸ verileri hesaplama sÄ±rasÄ±nda uygun formatlara dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r. SonuÃ§lar kullanÄ±cÄ±ya gÃ¶sterilir.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 30
```csharp
[HttpPost("calculate")]
public IActionResult Calculate([FromBody] CalculationRequest request)
{
    try
    {
        decimal num1 = Convert.ToDecimal(request.Number1);
        decimal num2 = Convert.ToDecimal(request.Number2);

        decimal result = request.Operation switch
        {
            "add" => num1 + num2,
            "subtract" => num1 - num2,
            "multiply" => num1 * num2,
            "divide" => num2 != 0 ? num1 / num2 : throw new DivideByZeroException(),
            _ => throw new ArgumentException("Invalid operation")
        };

        _context.Calculations.Add(new Calculation {
            Number1 = num1, Number2 = num2, Operation = request.Operation,
            Result = result, CreatedAt = DateTime.UtcNow
        });
        _context.SaveChanges();

        return Ok(new {
            Result = result % 1 == 0 ? ((long)result).ToString() : result.ToString("F2"),
            Type = result % 1 == 0 ? "integer" : "decimal"
        });
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 24
```python
@app.route('/calculate', methods=['POST'])
def calculate():
    try:
        data = request.get_json()
        num1, num2 = Decimal(str(data['number1'])), Decimal(str(data['number2']))
        operation = data['operation']

        operations = {
            'add': num1 + num2, 'subtract': num1 - num2,
            'multiply': num1 * num2, 'divide': num1 / num2 if num2 != 0 else None
        }

        result = operations.get(operation)
        if result is None: return jsonify({'error': 'Invalid operation'}), 400

        # Save to database
        cursor.execute('INSERT INTO calculations (number1, number2, operation, result, created_at) VALUES (?, ?, ?, ?, ?)',
                      (float(num1), float(num2), operation, float(result), datetime.now()))
        conn.commit()

        formatted = str(int(result)) if result % 1 == 0 else f"{result:.2f}"
        return jsonify({'result': formatted, 'type': 'integer' if result % 1 == 0 else 'decimal'})
    except Exception as e:
        return jsonify({'error': str(e)}), 400
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 31
```typescript
app.post('/calculate', (req, res) => {
    try {
        const { number1, number2, operation } = req.body;
        const num1 = parseFloat(number1.toString());
        const num2 = parseFloat(number2.toString());

        if (isNaN(num1) || isNaN(num2)) {
            return res.status(400).json({ error: 'Invalid number format' });
        }

        let result: number;
        switch (operation) {
            case 'add': result = num1 + num2; break;
            case 'subtract': result = num1 - num2; break;
            case 'multiply': result = num1 * num2; break;
            case 'divide':
                if (num2 === 0) return res.status(400).json({ error: 'Division by zero' });
                result = num1 / num2; break;
            default: return res.status(400).json({ error: 'Invalid operation' });
        }

        // Save to database
        db.run('INSERT INTO calculations (number1, number2, operation, result, created_at) VALUES (?, ?, ?, ?, ?)',
               [num1, num2, operation, result, new Date().toISOString()]);

        const isInteger = Number.isInteger(result);
        res.json({ result: isInteger ? result.toString() : result.toFixed(2), type: isInteger ? 'integer' : 'decimal' });
    } catch (error) {
        res.status(500).json({ error: 'Calculation error' });
    }
});
```

### ðŸ§ª Senaryo 2: Bir grafik uygulamasÄ±nda koordinat deÄŸerleri farklÄ± tÃ¼rlerde alÄ±nabiliyor. KullanÄ±cÄ±lar pozisyon bilgilerini Ã§eÅŸitli formatlarda girebilir. Sistem bu deÄŸerleri Ã§izim koordinatlarÄ±na Ã§evirir. Grafik nesneleri uygun pozisyonlarda oluÅŸturulur.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 32
```csharp
[HttpPost("create-graphic-object")]
public IActionResult CreateGraphicObject([FromBody] GraphicObjectRequest request)
{
    try
    {
        var coords = ConvertToCoordinates(request.Position);
        var obj = new GraphicObject
        {
            Id = Guid.NewGuid(), X = coords.X, Y = coords.Y,
            Type = request.ObjectType, CreatedAt = DateTime.UtcNow
        };

        _context.GraphicObjects.Add(obj);
        _context.SaveChanges();

        return Ok(new { Id = obj.Id, Position = new { X = coords.X, Y = coords.Y }, Type = obj.Type });
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}

private Coordinates ConvertToCoordinates(dynamic position)
{
    if (position is string posStr)
    {
        var parts = posStr.Split(',');
        return new Coordinates(float.Parse(parts[0]), float.Parse(parts[1]));
    }
    if (position.x != null && position.y != null)
        return new Coordinates(Convert.ToSingle(position.x), Convert.ToSingle(position.y));

    throw new ArgumentException("Invalid coordinate format");
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 28
```python
def create_graphic_object(position_data, object_type):
    try:
        coords = convert_to_coordinates(position_data)

        cursor.execute('INSERT INTO graphic_objects (x, y, type, created_at) VALUES (?, ?, ?, ?)',
                      (coords.x, coords.y, object_type, datetime.now()))
        object_id = cursor.lastrowid
        conn.commit()

        return {'id': object_id, 'position': {'x': coords.x, 'y': coords.y}, 'type': object_type}
    except Exception as e:
        raise ValueError(f"Failed to create graphic object: {str(e)}")

def convert_to_coordinates(position_data):
    if isinstance(position_data, str):
        x_str, y_str = position_data.split(',')
        return Coordinates(float(x_str.strip()), float(y_str.strip()))
    elif isinstance(position_data, dict):
        return Coordinates(float(position_data['x']), float(position_data['y']))
    elif isinstance(position_data, (list, tuple)):
        return Coordinates(float(position_data[0]), float(position_data[1]))
    else:
        raise ValueError("Unsupported coordinate format")

@dataclass
class Coordinates:
    x: float
    y: float
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 30
```typescript
export function createGraphicObject(positionData: string | {x: number, y: number} | [number, number], objectType: string) {
    try {
        const coords = convertToCoordinates(positionData);

        return new Promise((resolve, reject) => {
            db.run('INSERT INTO graphic_objects (x, y, type, created_at) VALUES (?, ?, ?, ?)',
                [coords.x, coords.y, objectType, new Date().toISOString()],
                function(err) {
                    if (err) reject(err);
                    else resolve({ id: this.lastID, position: coords, type: objectType });
                });
        });
    } catch (error) {
        throw new Error(`Failed to create graphic object: ${error.message}`);
    }
}

function convertToCoordinates(positionData: any): {x: number, y: number} {
    if (typeof positionData === 'string') {
        const [xStr, yStr] = positionData.split(',');
        return { x: parseFloat(xStr.trim()), y: parseFloat(yStr.trim()) };
    }
    if (Array.isArray(positionData)) {
        return { x: parseFloat(positionData[0]), y: parseFloat(positionData[1]) };
    }
    if (typeof positionData === 'object') {
        return { x: parseFloat(positionData.x), y: parseFloat(positionData.y) };
    }
    throw new Error('Unsupported coordinate format');
}
```

### ðŸ§ª Senaryo 3: Bir dosya boyutu hesaplama aracÄ±nda kullanÄ±cÄ±lar sayÄ±sal deÄŸerler girebiliyor. FarklÄ± birimler arasÄ± dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemleri yapÄ±lÄ±r. Sistem byte, kilobyte ve megabyte deÄŸerleri iÅŸleyebilir. Hesaplanan sonuÃ§lar kullanÄ±cÄ±ya sunulur.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 28
```csharp
[HttpPost("convert-file-size")]
public IActionResult ConvertFileSize([FromBody] FileSizeRequest request)
{
    try
    {
        long bytes = ConvertToBytes(request.Value, request.FromUnit);
        var result = new {
            Bytes = bytes, KB = Math.Round(bytes / 1024.0, 2),
            MB = Math.Round(bytes / (1024.0 * 1024.0), 2), GB = Math.Round(bytes / (1024.0 * 1024.0 * 1024.0), 4)
        };

        _context.FileSizeConversions.Add(new FileSizeConversion {
            InputValue = request.Value, InputUnit = request.FromUnit.ToString(),
            ResultBytes = bytes, ConvertedAt = DateTime.UtcNow
        });
        _context.SaveChanges();

        return Ok(result);
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}

private long ConvertToBytes(double value, SizeUnit unit) => unit switch
{
    SizeUnit.Byte => (long)value, SizeUnit.KB => (long)(value * 1024),
    SizeUnit.MB => (long)(value * 1024 * 1024), SizeUnit.GB => (long)(value * 1024 * 1024 * 1024),
    _ => throw new ArgumentException("Invalid unit")
};
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 24
```python
def convert_file_size(value, from_unit):
    try:
        unit = SizeUnit(from_unit.lower())
        bytes_value = convert_to_bytes(value, unit)

        result = {
            'bytes': int(bytes_value), 'kb': round(bytes_value / 1024, 2),
            'mb': round(bytes_value / (1024 ** 2), 2), 'gb': round(bytes_value / (1024 ** 3), 4)
        }

        cursor.execute('INSERT INTO file_size_conversions (input_value, input_unit, result_bytes, converted_at) VALUES (?, ?, ?, ?)',
                      (value, from_unit, bytes_value, datetime.now()))
        conn.commit()

        return result
    except Exception as e:
        raise Exception(f"Conversion failed: {str(e)}")

def convert_to_bytes(value, unit):
    multipliers = {SizeUnit.BYTE: 1, SizeUnit.KB: 1024, SizeUnit.MB: 1024 ** 2, SizeUnit.GB: 1024 ** 3}
    return value * multipliers[unit]

class SizeUnit(Enum):
    BYTE, KB, MB, GB = "byte", "kb", "mb", "gb"
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 32
```typescript
export function convertFileSize(value: number, fromUnit: string): Promise<any> {
    return new Promise((resolve, reject) => {
        try {
            const unit = validateUnit(fromUnit);
            const bytesValue = convertToBytes(value, unit);

            const result = {
                bytes: Math.round(bytesValue), kb: Math.round((bytesValue / 1024) * 100) / 100,
                mb: Math.round((bytesValue / (1024 ** 2)) * 100) / 100, gb: Math.round((bytesValue / (1024 ** 3)) * 10000) / 10000
            };

            db.run('INSERT INTO file_size_conversions (input_value, input_unit, result_bytes, converted_at) VALUES (?, ?, ?, ?)',
                [value, fromUnit, bytesValue, new Date().toISOString()],
                (err) => err ? reject(err) : resolve(result));
        } catch (error) {
            reject(new Error(`Conversion failed: ${error.message}`));
        }
    });
}

function validateUnit(unit: string): SizeUnit {
    const normalizedUnit = unit.toLowerCase() as SizeUnit;
    if (!Object.values(SizeUnit).includes(normalizedUnit)) throw new Error(`Invalid unit: ${unit}`);
    return normalizedUnit;
}

function convertToBytes(value: number, unit: SizeUnit): number {
    const multipliers = {[SizeUnit.BYTE]: 1, [SizeUnit.KB]: 1024, [SizeUnit.MB]: 1024 ** 2, [SizeUnit.GB]: 1024 ** 3};
    return value * multipliers[unit];
}

enum SizeUnit { BYTE = 'byte', KB = 'kb', MB = 'mb', GB = 'gb' }
```

### ðŸ§ª Senaryo 4: Bir zaman takip uygulamasÄ±nda saat bilgileri farklÄ± formatlarda girilir. KullanÄ±cÄ±lar dakika, saat ve gÃ¼n deÄŸerleri girebilir. Sistem bu deÄŸerleri standart zaman formatÄ±na Ã§evirir. Zaman hesaplamalarÄ± bu verilerle yapÄ±lÄ±r.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 30
```csharp
[HttpPost("log-time")]
public IActionResult LogTimeEntry([FromBody] TimeEntryRequest request)
{
    try
    {
        int totalMinutes = ConvertToMinutes(request.Value, request.Unit);
        var entry = new TimeEntry {
            ProjectId = request.ProjectId, TotalMinutes = totalMinutes,
            OriginalValue = request.Value, OriginalUnit = request.Unit.ToString(),
            EntryDate = DateTime.UtcNow, UserId = request.UserId
        };

        _context.TimeEntries.Add(entry);
        _context.SaveChanges();

        return Ok(new {
            Id = entry.Id, TotalMinutes = totalMinutes, FormattedTime = FormatTime(totalMinutes),
            OriginalInput = new { Value = request.Value, Unit = request.Unit.ToString() }
        });
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}

private int ConvertToMinutes(double value, TimeUnit unit) => unit switch
{
    TimeUnit.Minutes => (int)value, TimeUnit.Hours => (int)(value * 60),
    TimeUnit.Days => (int)(value * 24 * 60), _ => throw new ArgumentException("Invalid time unit")
};

private string FormatTime(int totalMinutes) => $"{totalMinutes / (24 * 60)}d {(totalMinutes % (24 * 60)) / 60}h {totalMinutes % 60}m";
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 28
```python
def log_time_entry(value, unit, project_id, user_id):
    try:
        time_unit = TimeUnit(unit.lower())
        total_minutes = convert_to_minutes(value, time_unit)

        cursor.execute('''INSERT INTO time_entries (project_id, user_id, total_minutes, original_value, original_unit, entry_date)
                         VALUES (?, ?, ?, ?, ?, ?)''',
                      (project_id, user_id, total_minutes, value, unit, datetime.now()))
        entry_id = cursor.lastrowid
        conn.commit()

        return {
            'id': entry_id, 'total_minutes': total_minutes,
            'formatted_time': format_time(total_minutes), 'original_input': {'value': value, 'unit': unit}
        }
    except Exception as e:
        raise Exception(f"Failed to log time entry: {str(e)}")

def convert_to_minutes(value, unit):
    multipliers = {TimeUnit.MINUTES: 1, TimeUnit.HOURS: 60, TimeUnit.DAYS: 24 * 60}
    return int(value * multipliers[unit])

def format_time(total_minutes):
    days, hours, minutes = total_minutes // (24 * 60), (total_minutes % (24 * 60)) // 60, total_minutes % 60
    return f"{days}d {hours}h {minutes}m"

class TimeUnit(Enum):
    MINUTES, HOURS, DAYS = "minutes", "hours", "days"
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 38
```typescript
export function logTimeEntry(value: number, unit: string, projectId: string, userId: string): Promise<any> {
    return new Promise((resolve, reject) => {
        try {
            const timeUnit = validateTimeUnit(unit);
            const totalMinutes = convertToMinutes(value, timeUnit);

            db.run('INSERT INTO time_entries (project_id, user_id, total_minutes, original_value, original_unit, entry_date) VALUES (?, ?, ?, ?, ?, ?)',
                [projectId, userId, totalMinutes, value, unit, new Date().toISOString()],
                function(err) {
                    if (err) reject(err);
                    else resolve({
                        id: this.lastID, totalMinutes, formattedTime: formatTime(totalMinutes),
                        originalInput: { value, unit }
                    });
                });
        } catch (error) {
            reject(new Error(`Failed to log time entry: ${error.message}`));
        }
    });
}

function validateTimeUnit(unit: string): TimeUnit {
    const normalizedUnit = unit.toLowerCase() as TimeUnit;
    if (!Object.values(TimeUnit).includes(normalizedUnit)) throw new Error(`Invalid time unit: ${unit}`);
    return normalizedUnit;
}

function convertToMinutes(value: number, unit: TimeUnit): number {
    const multipliers = {[TimeUnit.MINUTES]: 1, [TimeUnit.HOURS]: 60, [TimeUnit.DAYS]: 24 * 60};
    return Math.round(value * multipliers[unit]);
}

function formatTime(totalMinutes: number): string {
    const days = Math.floor(totalMinutes / (24 * 60)), hours = Math.floor((totalMinutes % (24 * 60)) / 60), minutes = totalMinutes % 60;
    return `${days}d ${hours}h ${minutes}m`;
}

enum TimeUnit { MINUTES = 'minutes', HOURS = 'hours', DAYS = 'days' }
```

### ðŸ§ª Senaryo 5: Bir finansal hesaplama uygulamasÄ±nda para miktarlarÄ± iÅŸlenir. KullanÄ±cÄ±lar ondalÄ±klÄ± ve tam sayÄ± formatlarÄ±nda deÄŸer girebilir. Sistem bu deÄŸerleri hesaplama tÃ¼rÃ¼ne gÃ¶re dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. Finansal sonuÃ§lar uygun formatta gÃ¶sterilir.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 26
```csharp
[HttpPost("calculate-finance")]
public IActionResult CalculateFinance([FromBody] FinanceCalculationRequest request)
{
    try
    {
        decimal amount = Convert.ToDecimal(request.Amount);
        decimal rate = Convert.ToDecimal(request.InterestRate) / 100;

        decimal result = request.CalculationType switch
        {
            "simple_interest" => amount * rate * request.Periods,
            "compound_interest" => amount * (decimal)Math.Pow((double)(1 + rate), request.Periods) - amount,
            "future_value" => amount * (decimal)Math.Pow((double)(1 + rate), request.Periods),
            _ => throw new ArgumentException("Invalid calculation type")
        };

        _context.FinanceCalculations.Add(new FinanceCalculation {
            Amount = amount, InterestRate = request.InterestRate, Periods = request.Periods,
            CalculationType = request.CalculationType, Result = result, CalculatedAt = DateTime.UtcNow
        });
        _context.SaveChanges();

        return Ok(new { Result = result.ToString("C2", new CultureInfo("tr-TR")), CalculationType = request.CalculationType });
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 23
```python
def calculate_finance(amount, interest_rate, periods, calculation_type):
    try:
        amount_decimal, rate_decimal = Decimal(str(amount)), Decimal(str(interest_rate)) / Decimal('100')

        if calculation_type == "simple_interest":
            result = amount_decimal * rate_decimal * Decimal(str(periods))
        elif calculation_type == "compound_interest":
            result = amount_decimal * (Decimal('1') + rate_decimal) ** periods - amount_decimal
        elif calculation_type == "future_value":
            result = amount_decimal * (Decimal('1') + rate_decimal) ** periods
        else:
            raise ValueError("Invalid calculation type")

        cursor.execute('''INSERT INTO finance_calculations (amount, interest_rate, periods, calculation_type, result, calculated_at)
                         VALUES (?, ?, ?, ?, ?, ?)''',
                      (float(amount_decimal), interest_rate, periods, calculation_type, float(result), datetime.now()))
        conn.commit()

        return {'result': f"â‚º{result:,.2f}", 'calculation_type': calculation_type}
    except Exception as e:
        raise Exception(f"Finance calculation failed: {str(e)}")

getcontext().prec = 10
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 27
```typescript
export function calculateFinance(amount: number, interestRate: number, periods: number, calculationType: string): Promise<any> {
    return new Promise((resolve, reject) => {
        try {
            const rate = interestRate / 100;
            let result: number;

            switch (calculationType) {
                case 'simple_interest': result = amount * rate * periods; break;
                case 'compound_interest': result = amount * Math.pow(1 + rate, periods) - amount; break;
                case 'future_value': result = amount * Math.pow(1 + rate, periods); break;
                default: throw new Error('Invalid calculation type');
            }

            db.run('INSERT INTO finance_calculations (amount, interest_rate, periods, calculation_type, result, calculated_at) VALUES (?, ?, ?, ?, ?, ?)',
                [amount, interestRate, periods, calculationType, result, new Date().toISOString()],
                function(err) {
                    if (err) reject(err);
                    else resolve({
                        result: new Intl.NumberFormat('tr-TR', { style: 'currency', currency: 'TRY' }).format(result),
                        calculationType
                    });
                });
        } catch (error) {
            reject(new Error(`Finance calculation failed: ${error.message}`));
        }
    });
}
```

### ðŸ§ª Senaryo 6: Bir veri analiz aracÄ±nda sayÄ±sal deÄŸerler farklÄ± tÃ¼rlerde alÄ±nÄ±r. Ä°statistiksel hesaplamalar iÃ§in veriler uygun formatlara Ã§evrilir. Sistem integer ve float deÄŸerleri iÅŸleyebilir. Analiz sonuÃ§larÄ± grafiklerle sunulur.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 28
```csharp
[HttpPost("analyze-data")]
public IActionResult AnalyzeData([FromBody] DataAnalysisRequest request)
{
    try
    {
        var numericData = request.Data.Select(item => double.Parse(item.ToString())).ToArray();
        Array.Sort(numericData);

        var stats = new {
            Mean = numericData.Average(), Median = numericData.Length % 2 == 0
                ? (numericData[numericData.Length / 2 - 1] + numericData[numericData.Length / 2]) / 2
                : numericData[numericData.Length / 2],
            StdDev = Math.Sqrt(numericData.Select(x => Math.Pow(x - numericData.Average(), 2)).Average()),
            Min = numericData.Min(), Max = numericData.Max(), Count = numericData.Length
        };

        _context.DataAnalyses.Add(new DataAnalysis {
            DatasetName = request.DatasetName, DataCount = numericData.Length,
            Mean = stats.Mean, Median = stats.Median, StandardDeviation = stats.StdDev, AnalyzedAt = DateTime.UtcNow
        });
        _context.SaveChanges();

        return Ok(new { Statistics = stats, ChartData = PrepareChartData(numericData) });
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}

private object[] PrepareChartData(double[] data) => data.GroupBy(x => Math.Floor(x / 10) * 10).Select(g => new { Range = g.Key, Count = g.Count() }).ToArray();
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 25
```python
def analyze_data(data, dataset_name):
    try:
        numeric_data = [float(item) for item in data]

        stats = {
            'mean': statistics.mean(numeric_data), 'median': statistics.median(numeric_data),
            'std_dev': statistics.stdev(numeric_data) if len(numeric_data) > 1 else 0,
            'min': min(numeric_data), 'max': max(numeric_data), 'count': len(numeric_data)
        }

        cursor.execute('''INSERT INTO data_analyses (dataset_name, data_count, mean, median, standard_deviation, analyzed_at)
                         VALUES (?, ?, ?, ?, ?, ?)''',
                      (dataset_name, len(numeric_data), stats['mean'], stats['median'], stats['std_dev'], datetime.now()))
        conn.commit()

        # Chart data preparation
        bins = {}
        for value in numeric_data:
            bin_key = int(value // 10) * 10
            bins[bin_key] = bins.get(bin_key, 0) + 1

        chart_data = [{'range': k, 'count': v} for k, v in bins.items()]
        return {'statistics': stats, 'chart_data': chart_data}
    except Exception as e:
        raise Exception(f"Data analysis failed: {str(e)}")
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 32
```typescript
export function analyzeData(data: (string | number)[], datasetName: string): Promise<any> {
    return new Promise((resolve, reject) => {
        try {
            const numericData = data.map(item => {
                const num = typeof item === 'number' ? item : parseFloat(item.toString());
                if (isNaN(num)) throw new Error(`Cannot convert '${item}' to numeric value`);
                return num;
            });

            const sorted = [...numericData].sort((a, b) => a - b);
            const mean = numericData.reduce((sum, val) => sum + val, 0) / numericData.length;
            const median = sorted.length % 2 === 0 ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2 : sorted[Math.floor(sorted.length / 2)];
            const variance = numericData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / numericData.length;

            const stats = { mean: Math.round(mean * 100) / 100, median, stdDev: Math.round(Math.sqrt(variance) * 100) / 100, min: Math.min(...numericData), max: Math.max(...numericData), count: numericData.length };

            // Chart data
            const bins: { [key: number]: number } = {};
            numericData.forEach(value => {
                const binKey = Math.floor(value / 10) * 10;
                bins[binKey] = (bins[binKey] || 0) + 1;
            });
            const chartData = Object.entries(bins).map(([range, count]) => ({ range: parseInt(range), count }));

            db.run('INSERT INTO data_analyses (dataset_name, data_count, mean, median, standard_deviation, analyzed_at) VALUES (?, ?, ?, ?, ?, ?)',
                [datasetName, stats.count, stats.mean, stats.median, stats.stdDev, new Date().toISOString()],
                (err) => err ? reject(err) : resolve({ statistics: stats, chartData }));
        } catch (error) {
            reject(new Error(`Data analysis failed: ${error.message}`));
        }
    });
}
```

### ðŸ§ª Senaryo 7: Bir oyun skorlama sisteminde puanlar farklÄ± tÃ¼rlerde tutulur. Oyuncu performansÄ±na gÃ¶re puanlar hesaplanÄ±r. Sistem bu deÄŸerleri leaderboard iÃ§in formatlar. Skorlar kullanÄ±cÄ±lar arasÄ± kÄ±yaslamada kullanÄ±lÄ±r.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 32
```csharp
[HttpPost("update-score")]
public IActionResult UpdatePlayerScore([FromBody] ScoreUpdateRequest request)
{
    try
    {
        int normalizedScore = NormalizeScore(request.Score, request.ScoreType);
        decimal multiplier = CalculateMultiplier(request.PerformanceMetrics);
        int finalScore = (int)(normalizedScore * multiplier);

        var playerScore = _context.PlayerScores.FirstOrDefault(ps => ps.PlayerId == request.PlayerId && ps.GameMode == request.GameMode)
            ?? new PlayerScore { PlayerId = request.PlayerId, GameMode = request.GameMode, HighScore = 0, TotalScore = 0, GamesPlayed = 0 };

        playerScore.HighScore = Math.Max(playerScore.HighScore, finalScore);
        playerScore.TotalScore += finalScore;
        playerScore.GamesPlayed++;
        playerScore.LastUpdated = DateTime.UtcNow;

        if (playerScore.Id == Guid.Empty) { playerScore.Id = Guid.NewGuid(); _context.PlayerScores.Add(playerScore); }
        _context.SaveChanges();

        return Ok(new { FinalScore = finalScore.ToString("N0"), HighScore = playerScore.HighScore.ToString("N0"), Multiplier = multiplier.ToString("F2") });
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}

private int NormalizeScore(object score, string scoreType) => scoreType.ToLower() switch
{
    "percentage" => (int)(Convert.ToDouble(score) * 1000), "time" => (int)(120000 - Convert.ToDouble(score) * 1000),
    "points" => Convert.ToInt32(score), _ => throw new ArgumentException("Invalid score type")
};

private decimal CalculateMultiplier(PerformanceMetrics metrics) => Math.Min(1.0m + (metrics.Accuracy > 90 ? 0.2m : 0) + (metrics.Speed > 80 ? 0.15m : 0) + (metrics.Combo > 50 ? 0.1m : 0), 2.0m);
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 30
```python
def update_player_score(player_id, score, score_type, game_mode, performance_metrics):
    try:
        normalized_score = normalize_score(score, score_type)
        multiplier = calculate_multiplier(performance_metrics)
        final_score = int(normalized_score * multiplier)

        cursor.execute('SELECT * FROM player_scores WHERE player_id = ? AND game_mode = ?', (player_id, game_mode))
        existing = cursor.fetchone()

        if existing is None:
            cursor.execute('''INSERT INTO player_scores (player_id, game_mode, high_score, total_score, games_played, last_updated)
                             VALUES (?, ?, ?, ?, ?, ?)''', (player_id, game_mode, final_score, final_score, 1, datetime.now()))
            high_score = final_score
        else:
            high_score = max(existing[2], final_score)
            cursor.execute('''UPDATE player_scores SET high_score = ?, total_score = ?, games_played = ?, last_updated = ?
                             WHERE player_id = ? AND game_mode = ?''',
                          (high_score, existing[3] + final_score, existing[4] + 1, datetime.now(), player_id, game_mode))

        conn.commit()
        return {'final_score': f"{final_score:,}", 'high_score': f"{high_score:,}", 'multiplier': f"{multiplier:.2f}x"}
    except Exception as e:
        raise Exception(f"Score update failed: {str(e)}")

def normalize_score(score, score_type):
    score_float = float(score)
    return {"percentage": int(score_float * 1000), "time": int(120000 - score_float * 1000), "points": int(score_float)}[score_type.lower()]

def calculate_multiplier(metrics):
    return min(1.0 + (0.2 if metrics.get('accuracy', 0) > 90 else 0) + (0.15 if metrics.get('speed', 0) > 80 else 0) + (0.1 if metrics.get('combo', 0) > 50 else 0), 2.0)
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 35
```typescript
export function updatePlayerScore(playerId: string, score: number, scoreType: string, gameMode: string, performanceMetrics: any): Promise<any> {
    return new Promise((resolve, reject) => {
        try {
            const normalizedScore = normalizeScore(score, scoreType);
            const multiplier = calculateMultiplier(performanceMetrics);
            const finalScore = Math.floor(normalizedScore * multiplier);

            db.get('SELECT * FROM player_scores WHERE player_id = ? AND game_mode = ?', [playerId, gameMode], (err, row: any) => {
                if (err) { reject(err); return; }

                if (!row) {
                    db.run('INSERT INTO player_scores (player_id, game_mode, high_score, total_score, games_played, last_updated) VALUES (?, ?, ?, ?, ?, ?)',
                        [playerId, gameMode, finalScore, finalScore, 1, new Date().toISOString()],
                        () => resolve({ finalScore: finalScore.toLocaleString(), highScore: finalScore.toLocaleString(), multiplier: `${multiplier.toFixed(2)}x` }));
                } else {
                    const highScore = Math.max(row.high_score, finalScore);
                    db.run('UPDATE player_scores SET high_score = ?, total_score = ?, games_played = ?, last_updated = ? WHERE player_id = ? AND game_mode = ?',
                        [highScore, row.total_score + finalScore, row.games_played + 1, new Date().toISOString(), playerId, gameMode],
                        () => resolve({ finalScore: finalScore.toLocaleString(), highScore: highScore.toLocaleString(), multiplier: `${multiplier.toFixed(2)}x` }));
                }
            });
        } catch (error) {
            reject(new Error(`Score update failed: ${error.message}`));
        }
    });
}

function normalizeScore(score: number, scoreType: string): number {
    const scoreTypes = { 'percentage': score * 1000, 'time': 120000 - score * 1000, 'points': score };
    return Math.floor(scoreTypes[scoreType.toLowerCase()] || 0);
}

function calculateMultiplier(metrics: any): number {
    return Math.min(1.0 + ((metrics.accuracy || 0) > 90 ? 0.2 : 0) + ((metrics.speed || 0) > 80 ? 0.15 : 0) + ((metrics.combo || 0) > 50 ? 0.1 : 0), 2.0);
}
```

### ðŸ§ª Senaryo 8: Bir Ã¶lÃ§Ã¼m uygulamasÄ±nda fiziksel deÄŸerler iÅŸlenir. KullanÄ±cÄ±lar mesafe, aÄŸÄ±rlÄ±k ve hacim girebilir. Sistem bu deÄŸerleri hesaplamalar iÃ§in Ã§evirir. Ã–lÃ§Ã¼m sonuÃ§larÄ± uygun birimlerle gÃ¶sterilir.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 34
```csharp
[HttpPost("convert-measurement")]
public IActionResult ConvertMeasurement([FromBody] MeasurementRequest request)
{
    try
    {
        double baseValue = ConvertToBaseUnit(request.Value, request.FromUnit, request.MeasurementType);
        var conversions = GenerateConversions(baseValue, request.MeasurementType);

        _context.MeasurementRecords.Add(new MeasurementRecord {
            OriginalValue = request.Value, OriginalUnit = request.FromUnit, BaseValue = baseValue,
            MeasurementType = request.MeasurementType.ToString(), CreatedAt = DateTime.UtcNow, UserId = request.UserId
        });
        _context.SaveChanges();

        return Ok(new { BaseValue = Math.Round(baseValue, 4), Conversions = conversions });
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}

private double ConvertToBaseUnit(double value, string unit, MeasurementType type) => type switch
{
    MeasurementType.Distance => unit.ToLower() switch { "mm" => value / 1000, "cm" => value / 100, "m" => value, "km" => value * 1000, _ => throw new ArgumentException("Invalid unit") },
    MeasurementType.Weight => unit.ToLower() switch { "g" => value / 1000, "kg" => value, "lb" => value * 0.453592, _ => throw new ArgumentException("Invalid unit") },
    MeasurementType.Volume => unit.ToLower() switch { "ml" => value / 1000, "l" => value, "gal" => value * 3.78541, _ => throw new ArgumentException("Invalid unit") },
    _ => throw new ArgumentException("Invalid measurement type")
};

private Dictionary<string, string> GenerateConversions(double baseValue, MeasurementType type) => type switch
{
    MeasurementType.Distance => new() { ["Meters"] = baseValue.ToString("F2"), ["Kilometers"] = (baseValue / 1000).ToString("F4"), ["Feet"] = (baseValue * 3.28084).ToString("F2") },
    MeasurementType.Weight => new() { ["Kilograms"] = baseValue.ToString("F2"), ["Pounds"] = (baseValue * 2.20462).ToString("F2") },
    MeasurementType.Volume => new() { ["Liters"] = baseValue.ToString("F2"), ["Gallons"] = (baseValue / 3.78541).ToString("F4") },
    _ => new()
};
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 35
```python
def convert_measurement(value, from_unit, measurement_type, user_id):
    try:
        mtype = MeasurementType(measurement_type.lower())
        base_value = convert_to_base_unit(value, from_unit, mtype)
        conversions = generate_conversions(base_value, mtype)

        cursor.execute('''INSERT INTO measurement_records (original_value, original_unit, base_value, measurement_type, user_id, created_at)
                         VALUES (?, ?, ?, ?, ?, ?)''',
                      (value, from_unit, base_value, measurement_type, user_id, datetime.now()))
        conn.commit()

        return {'base_value': round(base_value, 4), 'conversions': conversions}
    except Exception as e:
        raise Exception(f"Measurement conversion failed: {str(e)}")

def convert_to_base_unit(value, unit, mtype):
    factors = {
        MeasurementType.DISTANCE: {'mm': 0.001, 'cm': 0.01, 'm': 1, 'km': 1000},
        MeasurementType.WEIGHT: {'g': 0.001, 'kg': 1, 'lb': 0.453592},
        MeasurementType.VOLUME: {'ml': 0.001, 'l': 1, 'gal': 3.78541}
    }

    if unit.lower() not in factors[mtype]: raise ValueError(f"Invalid unit: {unit}")
    return value * factors[mtype][unit.lower()]

def generate_conversions(base_value, mtype):
    conversions = {
        MeasurementType.DISTANCE: {'Meters': f"{base_value:.2f}", 'Kilometers': f"{base_value/1000:.4f}", 'Feet': f"{base_value*3.28084:.2f}"},
        MeasurementType.WEIGHT: {'Kilograms': f"{base_value:.2f}", 'Pounds': f"{base_value*2.20462:.2f}"},
        MeasurementType.VOLUME: {'Liters': f"{base_value:.2f}", 'Gallons': f"{base_value/3.78541:.4f}"}
    }
    return conversions.get(mtype, {})

class MeasurementType(Enum):
    DISTANCE, WEIGHT, VOLUME = "distance", "weight", "volume"
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 44
```typescript
export function convertMeasurement(value: number, fromUnit: string, measurementType: string, userId: string): Promise<any> {
    return new Promise((resolve, reject) => {
        try {
            const mType = validateMeasurementType(measurementType);
            const baseValue = convertToBaseUnit(value, fromUnit, mType);
            const conversions = generateConversions(baseValue, mType);

            db.run('INSERT INTO measurement_records (original_value, original_unit, base_value, measurement_type, user_id, created_at) VALUES (?, ?, ?, ?, ?, ?)',
                [value, fromUnit, baseValue, measurementType, userId, new Date().toISOString()],
                (err) => err ? reject(err) : resolve({ baseValue: Math.round(baseValue * 10000) / 10000, conversions }));
        } catch (error) {
            reject(new Error(`Measurement conversion failed: ${error.message}`));
        }
    });
}

function validateMeasurementType(type: string): MeasurementType {
    const normalizedType = type.toLowerCase() as MeasurementType;
    if (!Object.values(MeasurementType).includes(normalizedType)) throw new Error(`Invalid measurement type: ${type}`);
    return normalizedType;
}

function convertToBaseUnit(value: number, unit: string, type: MeasurementType): number {
    const factors = {
        [MeasurementType.DISTANCE]: { 'mm': 0.001, 'cm': 0.01, 'm': 1, 'km': 1000 },
        [MeasurementType.WEIGHT]: { 'g': 0.001, 'kg': 1, 'lb': 0.453592 },
        [MeasurementType.VOLUME]: { 'ml': 0.001, 'l': 1, 'gal': 3.78541 }
    };

    const unitLower = unit.toLowerCase();
    if (!(unitLower in factors[type])) throw new Error(`Invalid unit: ${unit}`);
    return value * factors[type][unitLower];
}

function generateConversions(baseValue: number, type: MeasurementType): any {
    const conversions = {
        [MeasurementType.DISTANCE]: { 'Meters': baseValue.toFixed(2), 'Kilometers': (baseValue / 1000).toFixed(4), 'Feet': (baseValue * 3.28084).toFixed(2) },
        [MeasurementType.WEIGHT]: { 'Kilograms': baseValue.toFixed(2), 'Pounds': (baseValue * 2.20462).toFixed(2) },
        [MeasurementType.VOLUME]: { 'Liters': baseValue.toFixed(2), 'Gallons': (baseValue / 3.78541).toFixed(4) }
    };
    return conversions[type] || {};
}

enum MeasurementType { DISTANCE = 'distance', WEIGHT = 'weight', VOLUME = 'volume' }
```

### ðŸ§ª Senaryo 9: Bir rezervasyon sisteminde tarih ve saat bilgileri alÄ±nÄ±r. FarklÄ± formatlardan gelen veriler standart hale getirilir. Sistem timestamp deÄŸerleri hesaplamalar iÃ§in kullanÄ±r. Rezervasyon zamanlamalarÄ± bu verilerle yapÄ±lÄ±r.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 39
```csharp
[HttpPost("create-reservation")]
public IActionResult CreateReservation([FromBody] ReservationRequest request)
{
    try
    {
        DateTime reservationDateTime = ParseDateTime(request.DateTime, request.TimeZone);
        if (reservationDateTime <= DateTime.UtcNow) throw new ArgumentException("Reservation time must be in the future");

        long timestamp = new DateTimeOffset(reservationDateTime).ToUnixTimeSeconds();

        var reservation = new Reservation {
            CustomerId = request.CustomerId, ResourceId = request.ResourceId, ReservationDateTime = reservationDateTime,
            Timestamp = timestamp, Duration = request.Duration, Status = "Confirmed", CreatedAt = DateTime.UtcNow
        };

        if (HasConflictingReservation(reservation)) return Conflict(new { Error = "Time slot already reserved" });

        _context.Reservations.Add(reservation);
        _context.SaveChanges();

        return Ok(new { ReservationId = reservation.Id, DateTime = reservationDateTime.ToString("yyyy-MM-dd HH:mm:ss"), Timestamp = timestamp });
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}

private DateTime ParseDateTime(string dateTimeInput, string timeZone)
{
    var formats = new[] { "yyyy-MM-dd HH:mm:ss", "MM/dd/yyyy HH:mm", "dd.MM.yyyy HH:mm", "yyyy-MM-ddTHH:mm:ss" };

    foreach (var format in formats)
        if (DateTime.TryParseExact(dateTimeInput, format, CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime result))
            return string.IsNullOrEmpty(timeZone) ? result : TimeZoneInfo.ConvertTimeToUtc(result, TimeZoneInfo.FindSystemTimeZoneById(timeZone));

    throw new ArgumentException("Invalid datetime format");
}

private bool HasConflictingReservation(Reservation newReservation) => _context.Reservations.Any(r => r.ResourceId == newReservation.ResourceId && r.Status == "Confirmed" &&
    ((r.ReservationDateTime <= newReservation.ReservationDateTime && r.ReservationDateTime.AddMinutes(r.Duration) > newReservation.ReservationDateTime) ||
     (newReservation.ReservationDateTime <= r.ReservationDateTime && newReservation.ReservationDateTime.AddMinutes(newReservation.Duration) > r.ReservationDateTime)));
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 38
```python
def create_reservation(customer_id, resource_id, datetime_input, duration, timezone="UTC"):
    try:
        reservation_datetime = parse_datetime(datetime_input, timezone)
        if reservation_datetime <= datetime.now(pytz.UTC): raise ValueError("Reservation time must be in the future")

        timestamp = int(reservation_datetime.timestamp())

        if has_conflicting_reservation(resource_id, reservation_datetime, duration):
            raise ValueError("Time slot already reserved")

        cursor.execute('''INSERT INTO reservations (customer_id, resource_id, reservation_datetime, timestamp, duration, status, created_at)
                         VALUES (?, ?, ?, ?, ?, ?, ?)''',
                      (customer_id, resource_id, reservation_datetime.isoformat(), timestamp, duration, 'Confirmed', datetime.now()))
        reservation_id = cursor.lastrowid
        conn.commit()

        return {'reservation_id': reservation_id, 'datetime': reservation_datetime.strftime("%Y-%m-%d %H:%M:%S"), 'timestamp': timestamp}
    except Exception as e:
        raise Exception(f"Reservation creation failed: {str(e)}")

def parse_datetime(datetime_input, timezone):
    formats = ["%Y-%m-%d %H:%M:%S", "%m/%d/%Y %H:%M", "%d.%m.%Y %H:%M", "%Y-%m-%dT%H:%M:%S"]

    for fmt in formats:
        try:
            dt = datetime.strptime(datetime_input, fmt)
            return pytz.UTC.localize(dt) if timezone == "UTC" else pytz.timezone(timezone).localize(dt).astimezone(pytz.UTC)
        except ValueError:
            continue
    raise ValueError("Invalid datetime format")

def has_conflicting_reservation(resource_id, start_time, duration):
    end_time = start_time + timedelta(minutes=duration)
    cursor.execute('''SELECT COUNT(*) FROM reservations WHERE resource_id = ? AND status = 'Confirmed'
                     AND ((reservation_datetime <= ? AND datetime(reservation_datetime, '+' || duration || ' minutes') > ?)
                     OR (? <= reservation_datetime AND ? > reservation_datetime))''',
                  (resource_id, start_time.isoformat(), start_time.isoformat(), start_time.isoformat(), end_time.isoformat()))
    return cursor.fetchone()[0] > 0
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 57
```typescript
export function createReservation(customerId: string, resourceId: string, dateTime: string, duration: number, timeZone = 'UTC'): Promise<any> {
    return new Promise((resolve, reject) => {
        try {
            const reservationDateTime = parseDateTime(dateTime, timeZone);
            if (reservationDateTime <= new Date()) throw new Error('Reservation time must be in the future');

            const timestamp = Math.floor(reservationDateTime.getTime() / 1000);

            hasConflictingReservation(resourceId, reservationDateTime, duration)
                .then(hasConflict => {
                    if (hasConflict) throw new Error('Time slot already reserved');

                    db.run('INSERT INTO reservations (customer_id, resource_id, reservation_datetime, timestamp, duration, status, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)',
                        [customerId, resourceId, reservationDateTime.toISOString(), timestamp, duration, 'Confirmed', new Date().toISOString()],
                        function(err) {
                            if (err) reject(err);
                            else resolve({
                                reservationId: this.lastID,
                                dateTime: reservationDateTime.toISOString().slice(0, 19).replace('T', ' '),
                                timestamp
                            });
                        });
                })
                .catch(reject);
        } catch (error) {
            reject(new Error(`Reservation creation failed: ${error.message}`));
        }
    });
}

function parseDateTime(dateTimeInput: string, timeZone: string): Date {
    const formats = [/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/, /^\d{2}\/\d{2}\/\d{4} \d{2}:\d{2}$/, /^\d{2}\.\d{2}\.\d{4} \d{2}:\d{2}$/, /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/];

    if (formats[0].test(dateTimeInput)) return new Date(dateTimeInput.replace(' ', 'T'));
    if (formats[1].test(dateTimeInput)) {
        const [datePart, timePart] = dateTimeInput.split(' ');
        const [month, day, year] = datePart.split('/');
        return new Date(`${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T${timePart}:00`);
    }
    if (formats[2].test(dateTimeInput)) {
        const [datePart, timePart] = dateTimeInput.split(' ');
        const [day, month, year] = datePart.split('.');
        return new Date(`${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T${timePart}:00`);
    }
    if (formats[3].test(dateTimeInput)) return new Date(dateTimeInput);

    throw new Error('Invalid datetime format');
}

function hasConflictingReservation(resourceId: string, startTime: Date, duration: number): Promise<boolean> {
    return new Promise((resolve, reject) => {
        const endTime = new Date(startTime.getTime() + (duration * 60 * 1000));
        db.get('SELECT COUNT(*) as count FROM reservations WHERE resource_id = ? AND status = ? AND ((reservation_datetime <= ? AND datetime(reservation_datetime, ? || " minutes") > ?) OR (? <= reservation_datetime AND ? > reservation_datetime))',
            [resourceId, 'Confirmed', startTime.toISOString(), `+${duration}`, startTime.toISOString(), startTime.toISOString(), endTime.toISOString()],
            (err, row: any) => err ? reject(err) : resolve(row.count > 0));
    });
}
```

### ðŸ§ª Senaryo 10: Bir inventory yÃ¶netim uygulamasÄ±nda stok miktarlarÄ± tutulur. GiriÅŸ ve Ã§Ä±kÄ±ÅŸ deÄŸerleri farklÄ± tÃ¼rlerde olabilir. Sistem bu deÄŸerleri toplam hesaplamalarÄ±nda kullanÄ±r. Stok durumu gÃ¼ncel verilerle gÃ¶sterilir.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 42
```csharp
[HttpPost("update-inventory")]
public IActionResult UpdateInventory([FromBody] InventoryUpdateRequest request)
{
    try
    {
        decimal quantity = ConvertToDecimal(request.Quantity);
        var inventory = _context.Inventories.FirstOrDefault(i => i.ProductId == request.ProductId) ?? new Inventory
        {
            ProductId = request.ProductId, CurrentStock = 0, MinimumStock = request.MinimumStock ?? 0, LastUpdated = DateTime.UtcNow
        };

        decimal newStock = CalculateNewStock(inventory.CurrentStock, quantity, request.TransactionType);
        if (newStock < 0) throw new InvalidOperationException("Insufficient stock");

        _context.InventoryTransactions.Add(new InventoryTransaction {
            ProductId = request.ProductId, TransactionType = request.TransactionType.ToString(),
            Quantity = quantity, PreviousStock = inventory.CurrentStock, NewStock = newStock, CreatedAt = DateTime.UtcNow
        });

        inventory.CurrentStock = newStock;
        inventory.LastUpdated = DateTime.UtcNow;
        if (inventory.Id == Guid.Empty) { inventory.Id = Guid.NewGuid(); _context.Inventories.Add(inventory); }
        _context.SaveChanges();

        return Ok(new { ProductId = request.ProductId, CurrentStock = newStock.ToString("F2"), StockStatus = GetStockStatus(inventory) });
    }
    catch (Exception ex) { return BadRequest(new { Error = ex.Message }); }
}

private decimal ConvertToDecimal(object quantity) => quantity switch
{
    string str => decimal.Parse(str.Replace(",", ".")), int intVal => intVal, double doubleVal => (decimal)doubleVal,
    decimal decVal => decVal, _ => Convert.ToDecimal(quantity)
};

private decimal CalculateNewStock(decimal currentStock, decimal quantity, TransactionType type) => type switch
{
    TransactionType.StockIn => currentStock + quantity, TransactionType.StockOut => currentStock - quantity,
    TransactionType.Adjustment => quantity, _ => throw new ArgumentException("Invalid transaction type")
};

private string GetStockStatus(Inventory inventory) => inventory.CurrentStock <= 0 ? "Out of Stock" : inventory.CurrentStock <= inventory.MinimumStock ? "Low Stock" : "In Stock";
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 39
```python
def update_inventory(product_id, quantity, transaction_type, reference=None, user_id=None, minimum_stock=0):
    try:
        decimal_quantity = convert_to_decimal(quantity)
        trans_type = TransactionType(transaction_type.lower())

        cursor.execute('SELECT * FROM inventories WHERE product_id = ?', (product_id,))
        inventory_row = cursor.fetchone()
        current_stock = Decimal(str(inventory_row[1])) if inventory_row else Decimal('0')

        new_stock = calculate_new_stock(current_stock, decimal_quantity, trans_type)
        if new_stock < 0: raise ValueError("Insufficient stock")

        cursor.execute('''INSERT INTO inventory_transactions (product_id, transaction_type, quantity, previous_stock, new_stock, reference, user_id, created_at)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?)''',
                      (product_id, transaction_type, float(decimal_quantity), float(current_stock), float(new_stock), reference, user_id, datetime.now()))

        if inventory_row is None:
            cursor.execute('INSERT INTO inventories (product_id, current_stock, minimum_stock, last_updated) VALUES (?, ?, ?, ?)',
                          (product_id, float(new_stock), minimum_stock, datetime.now()))
        else:
            cursor.execute('UPDATE inventories SET current_stock = ?, last_updated = ? WHERE product_id = ?',
                          (float(new_stock), datetime.now(), product_id))

        conn.commit()

        stock_status = "Out of Stock" if new_stock <= 0 else "Low Stock" if new_stock <= minimum_stock else "In Stock"
        return {'product_id': product_id, 'current_stock': f"{new_stock:.2f}", 'stock_status': stock_status}
    except Exception as e:
        raise Exception(f"Inventory update failed: {str(e)}")

def convert_to_decimal(quantity):
    if isinstance(quantity, str): return Decimal(quantity.replace(',', '.'))
    return Decimal(str(quantity))

def calculate_new_stock(current_stock, quantity, trans_type):
    return {TransactionType.STOCK_IN: current_stock + quantity, TransactionType.STOCK_OUT: current_stock - quantity, TransactionType.ADJUSTMENT: quantity}[trans_type]

class TransactionType(Enum):
    STOCK_IN, STOCK_OUT, ADJUSTMENT = "stock_in", "stock_out", "adjustment"
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude

**SatÄ±r SayÄ±sÄ±:** 52
```typescript
export function updateInventory(productId: string, quantity: string | number, transactionType: string, reference?: string, userId?: string, minimumStock = 0): Promise<any> {
    return new Promise((resolve, reject) => {
        try {
            const quantityNum = convertToNumber(quantity);
            const tType = validateTransactionType(transactionType);

            db.get('SELECT * FROM inventories WHERE product_id = ?', [productId], (err, row: any) => {
                if (err) { reject(err); return; }

                const currentStock = row ? row.current_stock : 0;
                const newStock = calculateNewStock(currentStock, quantityNum, tType);
                if (newStock < 0) { reject(new Error("Insufficient stock")); return; }

                db.run('INSERT INTO inventory_transactions (product_id, transaction_type, quantity, previous_stock, new_stock, reference, user_id, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
                    [productId, transactionType, quantityNum, currentStock, newStock, reference, userId, new Date().toISOString()],
                    function(transErr) {
                        if (transErr) { reject(transErr); return; }

                        const updateQuery = row ? 'UPDATE inventories SET current_stock = ?, last_updated = ? WHERE product_id = ?' : 'INSERT INTO inventories (current_stock, last_updated, product_id, minimum_stock) VALUES (?, ?, ?, ?)';
                        const updateParams = row ? [newStock, new Date().toISOString(), productId] : [newStock, new Date().toISOString(), productId, minimumStock];

                        db.run(updateQuery, updateParams, (updateErr) => {
                            if (updateErr) reject(updateErr);
                            else {
                                const stockStatus = newStock <= 0 ? "Out of Stock" : newStock <= minimumStock ? "Low Stock" : "In Stock";
                                resolve({ productId, currentStock: newStock.toFixed(2), stockStatus });
                            }
                        });
                    });
            });
        } catch (error) {
            reject(new Error(`Inventory update failed: ${error.message}`));
        }
    });
}

function convertToNumber(quantity: string | number): number {
    return typeof quantity === 'number' ? quantity : parseFloat(quantity.toString().replace(',', '.'));
}

function validateTransactionType(type: string): TransactionType {
    const normalizedType = type.toLowerCase() as TransactionType;
    if (!Object.values(TransactionType).includes(normalizedType)) throw new Error(`Invalid transaction type: ${type}`);
    return normalizedType;
}

function calculateNewStock(currentStock: number, quantity: number, transactionType: TransactionType): number {
    const calculations = {[TransactionType.STOCK_IN]: currentStock + quantity, [TransactionType.STOCK_OUT]: currentStock - quantity, [TransactionType.ADJUSTMENT]: quantity};
    return calculations[transactionType];
}

enum TransactionType { STOCK_IN = 'stock_in', STOCK_OUT = 'stock_out', ADJUSTMENT = 'adjustment' }
```