### ðŸ§ª Senaryo 1: Bir hesap makinesi uygulamasÄ±nda kullanÄ±cÄ±lar farklÄ± sayÄ± tÃ¼rleri girebiliyor. Sistem ondalÄ±klÄ± ve tam sayÄ±larÄ± iÅŸleyebilir. GiriÅŸ verileri hesaplama sÄ±rasÄ±nda uygun formatlara dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r. SonuÃ§lar kullanÄ±cÄ±ya gÃ¶sterilir.

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 30
```csharp
[HttpPost("calculate")]
public IActionResult Calculate([FromBody] CalculationRequest request)
{
    try
    {
        // Convert input strings to appropriate numeric types
        decimal number1 = Convert.ToDecimal(request.Number1);
        decimal number2 = Convert.ToDecimal(request.Number2);
        
        decimal result = request.Operation switch
        {
            "add" => number1 + number2,
            "subtract" => number1 - number2,
            "multiply" => number1 * number2,
            "divide" => number2 != 0 ? number1 / number2 : throw new DivideByZeroException(),
            _ => throw new ArgumentException("Invalid operation")
        };
        
        // Format result based on decimal places
        string formattedResult = result % 1 == 0 ? 
            ((long)result).ToString() : 
            result.ToString("F2");
            
        return Ok(new { Result = formattedResult, Type = result % 1 == 0 ? "integer" : "decimal" });
    }
    catch (Exception ex)
    {
        return BadRequest(new { Error = ex.Message });
    }
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 46
```python
from decimal import Decimal, InvalidOperation
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/calculate', methods=['POST'])
def calculate():
    try:
        data = request.get_json()
        
        # Convert inputs to Decimal for precise calculation
        number1 = Decimal(str(data['number1']))
        number2 = Decimal(str(data['number2']))
        operation = data['operation']
        
        # Perform calculation
        operations = {
            'add': lambda x, y: x + y,
            'subtract': lambda x, y: x - y,
            'multiply': lambda x, y: x * y,
            'divide': lambda x, y: x / y if y != 0 else None
        }
        
        if operation not in operations:
            return jsonify({'error': 'Invalid operation'}), 400
            
        result = operations[operation](number1, number2)
        
        if result is None:
            return jsonify({'error': 'Division by zero'}), 400
        
        # Format result based on type
        if result % 1 == 0:
            formatted_result = str(int(result))
            result_type = "integer"
        else:
            formatted_result = f"{result:.2f}"
            result_type = "decimal"
            
        return jsonify({
            'result': formatted_result,
            'type': result_type
        })
        
    except (InvalidOperation, ValueError, KeyError) as e:
        return jsonify({'error': 'Invalid input format'}), 400
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 56
```typescript
interface CalculationRequest {
    number1: string | number;
    number2: string | number;
    operation: 'add' | 'subtract' | 'multiply' | 'divide';
}

interface CalculationResult {
    result: string;
    type: 'integer' | 'decimal';
}

export const calculateNumbers = (request: CalculationRequest): CalculationResult => {
    try {
        // Convert inputs to numbers with precision handling
        const num1 = parseFloat(request.number1.toString());
        const num2 = parseFloat(request.number2.toString());
        
        if (isNaN(num1) || isNaN(num2)) {
            throw new Error('Invalid number format');
        }
        
        let result: number;
        
        switch (request.operation) {
            case 'add':
                result = num1 + num2;
                break;
            case 'subtract':
                result = num1 - num2;
                break;
            case 'multiply':
                result = num1 * num2;
                break;
            case 'divide':
                if (num2 === 0) throw new Error('Division by zero');
                result = num1 / num2;
                break;
            default:
                throw new Error('Invalid operation');
        }
        
        // Determine result type and format
        const isInteger = Number.isInteger(result);
        const formattedResult = isInteger ? 
            result.toString() : 
            parseFloat(result.toFixed(2)).toString();
            
        return {
            result: formattedResult,
            type: isInteger ? 'integer' : 'decimal'
        };
        
    } catch (error) {
        throw new Error(`Calculation error: ${error.message}`);
    }
};
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 53
```csharp
public class CoordinateConverter
{
    [HttpPost("create-graphic-object")]
    public IActionResult CreateGraphicObject([FromBody] GraphicObjectRequest request)
    {
        try
        {
            // Convert various coordinate formats to standard float coordinates
            var coordinates = ConvertToCoordinates(request.Position);
            
            var graphicObject = new GraphicObject
            {
                Id = Guid.NewGuid(),
                X = coordinates.X,
                Y = coordinates.Y,
                Type = request.ObjectType,
                CreatedAt = DateTime.UtcNow
            };
            
            // Save to database
            _context.GraphicObjects.Add(graphicObject);
            _context.SaveChanges();
            
            return Ok(new { 
                Id = graphicObject.Id, 
                Position = new { X = coordinates.X, Y = coordinates.Y },
                Type = graphicObject.Type 
            });
        }
        catch (Exception ex)
        {
            return BadRequest(new { Error = ex.Message });
        }
    }
    
    private Coordinates ConvertToCoordinates(dynamic position)
    {
        // Handle different input formats: string, object, array
        if (position is string posStr)
        {
            var parts = posStr.Split(',');
            return new Coordinates(float.Parse(parts[0]), float.Parse(parts[1]));
        }
        else if (position.x != null && position.y != null)
        {
            return new Coordinates(Convert.ToSingle(position.x), Convert.ToSingle(position.y));
        }
        
        throw new ArgumentException("Invalid coordinate format");
    }
}

public record Coordinates(float X, float Y);
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 54
```python
from dataclasses import dataclass
from typing import Union, Dict, List, Tuple
import json

@dataclass
class Coordinates:
    x: float
    y: float

class GraphicObjectManager:
    def __init__(self):
        self.objects = []
    
    def create_graphic_object(self, position_data: Union[str, Dict, List], object_type: str) -> Dict:
        try:
            # Convert various input formats to standard coordinates
            coordinates = self._convert_to_coordinates(position_data)
            
            graphic_object = {
                'id': len(self.objects) + 1,
                'x': coordinates.x,
                'y': coordinates.y,
                'type': object_type,
                'created_at': 'timestamp'
            }
            
            # Save to storage (database simulation)
            self.objects.append(graphic_object)
            
            return {
                'id': graphic_object['id'],
                'position': {'x': coordinates.x, 'y': coordinates.y},
                'type': object_type
            }
            
        except Exception as e:
            raise ValueError(f"Failed to create graphic object: {str(e)}")
    
    def _convert_to_coordinates(self, position_data) -> Coordinates:
        # Handle string format: "x,y"
        if isinstance(position_data, str):
            x_str, y_str = position_data.split(',')
            return Coordinates(float(x_str.strip()), float(y_str.strip()))
        
        # Handle dictionary format: {"x": value, "y": value}
        elif isinstance(position_data, dict):
            return Coordinates(float(position_data['x']), float(position_data['y']))
        
        # Handle list/tuple format: [x, y]
        elif isinstance(position_data, (list, tuple)):
            return Coordinates(float(position_data[0]), float(position_data[1]))
        
        else:
            raise ValueError("Unsupported coordinate format")
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 71
```typescript
interface Coordinates {
    x: number;
    y: number;
}

interface GraphicObject {
    id: string;
    x: number;
    y: number;
    type: string;
    createdAt: Date;
}

type PositionInput = string | { x: number | string; y: number | string } | [number | string, number | string];

export class GraphicObjectManager {
    private objects: GraphicObject[] = [];
    
    createGraphicObject(positionData: PositionInput, objectType: string): { id: string; position: Coordinates; type: string } {
        try {
            // Convert various input formats to standard coordinates
            const coordinates = this.convertToCoordinates(positionData);
            
            const graphicObject: GraphicObject = {
                id: crypto.randomUUID(),
                x: coordinates.x,
                y: coordinates.y,
                type: objectType,
                createdAt: new Date()
            };
            
            // Save to storage
            this.objects.push(graphicObject);
            
            return {
                id: graphicObject.id,
                position: { x: coordinates.x, y: coordinates.y },
                type: objectType
            };
            
        } catch (error) {
            throw new Error(`Failed to create graphic object: ${error.message}`);
        }
    }
    
    private convertToCoordinates(positionData: PositionInput): Coordinates {
        // Handle string format: "x,y"
        if (typeof positionData === 'string') {
            const [xStr, yStr] = positionData.split(',');
            return { x: parseFloat(xStr.trim()), y: parseFloat(yStr.trim()) };
        }
        
        // Handle object format: {x: value, y: value}
        if (typeof positionData === 'object' && !Array.isArray(positionData)) {
            return { 
                x: parseFloat(positionData.x.toString()), 
                y: parseFloat(positionData.y.toString()) 
            };
        }
        
        // Handle array format: [x, y]
        if (Array.isArray(positionData)) {
            return { 
                x: parseFloat(positionData[0].toString()), 
                y: parseFloat(positionData[1].toString()) 
            };
        }
        
        throw new Error('Unsupported coordinate format');
    }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 51
```csharp
public enum SizeUnit { Byte, KB, MB, GB }

[HttpPost("convert-file-size")]
public IActionResult ConvertFileSize([FromBody] FileSizeRequest request)
{
    try
    {
        // Convert input to bytes first
        long bytes = ConvertToBytes(request.Value, request.FromUnit);
        
        // Convert to all units for display
        var result = new
        {
            Bytes = bytes,
            KB = Math.Round(bytes / 1024.0, 2),
            MB = Math.Round(bytes / (1024.0 * 1024.0), 2),
            GB = Math.Round(bytes / (1024.0 * 1024.0 * 1024.0), 4),
            OriginalInput = new { Value = request.Value, Unit = request.FromUnit.ToString() }
        };
        
        // Save conversion log to database
        var conversionLog = new FileSizeConversion
        {
            InputValue = request.Value,
            InputUnit = request.FromUnit.ToString(),
            ResultBytes = bytes,
            ConvertedAt = DateTime.UtcNow
        };
        
        _context.FileSizeConversions.Add(conversionLog);
        _context.SaveChanges();
        
        return Ok(result);
    }
    catch (Exception ex)
    {
        return BadRequest(new { Error = ex.Message });
    }
}

private long ConvertToBytes(double value, SizeUnit unit)
{
    return unit switch
    {
        SizeUnit.Byte => (long)value,
        SizeUnit.KB => (long)(value * 1024),
        SizeUnit.MB => (long)(value * 1024 * 1024),
        SizeUnit.GB => (long)(value * 1024 * 1024 * 1024),
        _ => throw new ArgumentException("Invalid unit")
    };
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 60
```python
from enum import Enum
from datetime import datetime
import math

class SizeUnit(Enum):
    BYTE = "byte"
    KB = "kb"
    MB = "mb"
    GB = "gb"

class FileSizeConverter:
    def __init__(self):
        self.conversion_history = []
    
    def convert_file_size(self, value: float, from_unit: str) -> dict:
        try:
            # Validate and convert unit string to enum
            unit = SizeUnit(from_unit.lower())
            
            # Convert input to bytes first
            bytes_value = self._convert_to_bytes(value, unit)
            
            # Convert to all units
            result = {
                'bytes': int(bytes_value),
                'kb': round(bytes_value / 1024, 2),
                'mb': round(bytes_value / (1024 ** 2), 2),
                'gb': round(bytes_value / (1024 ** 3), 4),
                'original_input': {
                    'value': value,
                    'unit': from_unit
                }
            }
            
            # Log conversion to storage
            conversion_record = {
                'input_value': value,
                'input_unit': from_unit,
                'result_bytes': bytes_value,
                'converted_at': datetime.now().isoformat()
            }
            
            self.conversion_history.append(conversion_record)
            
            return result
            
        except ValueError as e:
            raise ValueError(f"Invalid unit: {from_unit}")
        except Exception as e:
            raise Exception(f"Conversion failed: {str(e)}")
    
    def _convert_to_bytes(self, value: float, unit: SizeUnit) -> float:
        multipliers = {
            SizeUnit.BYTE: 1,
            SizeUnit.KB: 1024,
            SizeUnit.MB: 1024 ** 2,
            SizeUnit.GB: 1024 ** 3
        }
        
        return value * multipliers[unit]
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 86
```typescript
enum SizeUnit {
    BYTE = 'byte',
    KB = 'kb',
    MB = 'mb',
    GB = 'gb'
}

interface FileSizeRequest {
    value: number;
    fromUnit: SizeUnit;
}

interface ConversionResult {
    bytes: number;
    kb: number;
    mb: number;
    gb: number;
    originalInput: {
        value: number;
        unit: string;
    };
}

export class FileSizeConverter {
    private conversionHistory: any[] = [];
    
    convertFileSize(value: number, fromUnit: string): ConversionResult {
        try {
            // Validate unit
            const unit = this.validateUnit(fromUnit);
            
            // Convert input to bytes first
            const bytesValue = this.convertToBytes(value, unit);
            
            // Convert to all units for display
            const result: ConversionResult = {
                bytes: Math.round(bytesValue),
                kb: Math.round((bytesValue / 1024) * 100) / 100,
                mb: Math.round((bytesValue / (1024 ** 2)) * 100) / 100,
                gb: Math.round((bytesValue / (1024 ** 3)) * 10000) / 10000,
                originalInput: {
                    value,
                    unit: fromUnit
                }
            };
            
            // Save conversion log
            this.logConversion(value, fromUnit, bytesValue);
            
            return result;
            
        } catch (error) {
            throw new Error(`File size conversion failed: ${error.message}`);
        }
    }
    
    private validateUnit(unit: string): SizeUnit {
        const normalizedUnit = unit.toLowerCase() as SizeUnit;
        if (!Object.values(SizeUnit).includes(normalizedUnit)) {
            throw new Error(`Invalid unit: ${unit}`);
        }
        return normalizedUnit;
    }
    
    private convertToBytes(value: number, unit: SizeUnit): number {
        const multipliers = {
            [SizeUnit.BYTE]: 1,
            [SizeUnit.KB]: 1024,
            [SizeUnit.MB]: 1024 ** 2,
            [SizeUnit.GB]: 1024 ** 3
        };
        
        return value * multipliers[unit];
    }
    
    private logConversion(inputValue: number, inputUnit: string, resultBytes: number): void {
        const conversionRecord = {
            inputValue,
            inputUnit,
            resultBytes,
            convertedAt: new Date().toISOString()
        };
        
        this.conversionHistory.push(conversionRecord);
    }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 61
```csharp
public enum TimeUnit { Minutes, Hours, Days }

[HttpPost("log-time")]
public IActionResult LogTimeEntry([FromBody] TimeEntryRequest request)
{
    try
    {
        // Convert all inputs to total minutes for standardization
        int totalMinutes = ConvertToMinutes(request.Value, request.Unit);
        
        var timeEntry = new TimeEntry
        {
            Id = Guid.NewGuid(),
            ProjectId = request.ProjectId,
            TotalMinutes = totalMinutes,
            OriginalValue = request.Value,
            OriginalUnit = request.Unit.ToString(),
            EntryDate = DateTime.UtcNow,
            UserId = request.UserId
        };
        
        // Save to database
        _context.TimeEntries.Add(timeEntry);
        _context.SaveChanges();
        
        // Return formatted time display
        var formatted = FormatTime(totalMinutes);
        
        return Ok(new
        {
            Id = timeEntry.Id,
            TotalMinutes = totalMinutes,
            FormattedTime = formatted,
            OriginalInput = new { Value = request.Value, Unit = request.Unit.ToString() }
        });
    }
    catch (Exception ex)
    {
        return BadRequest(new { Error = ex.Message });
    }
}

private int ConvertToMinutes(double value, TimeUnit unit)
{
    return unit switch
    {
        TimeUnit.Minutes => (int)value,
        TimeUnit.Hours => (int)(value * 60),
        TimeUnit.Days => (int)(value * 24 * 60),
        _ => throw new ArgumentException("Invalid time unit")
    };
}

private string FormatTime(int totalMinutes)
{
    int days = totalMinutes / (24 * 60);
    int hours = (totalMinutes % (24 * 60)) / 60;
    int minutes = totalMinutes % 60;
    
    return $"{days}d {hours}h {minutes}m";
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 67
```python
from datetime import datetime, timedelta
from enum import Enum

class TimeUnit(Enum):
    MINUTES = "minutes"
    HOURS = "hours"
    DAYS = "days"

class TimeTracker:
    def __init__(self):
        self.time_entries = []
    
    def log_time_entry(self, value: float, unit: str, project_id: str, user_id: str) -> dict:
        try:
            # Validate and convert unit
            time_unit = TimeUnit(unit.lower())
            
            # Convert to standard minutes
            total_minutes = self._convert_to_minutes(value, time_unit)
            
            # Create time entry record
            time_entry = {
                'id': len(self.time_entries) + 1,
                'project_id': project_id,
                'user_id': user_id,
                'total_minutes': total_minutes,
                'original_value': value,
                'original_unit': unit,
                'entry_date': datetime.now().isoformat()
            }
            
            # Save to storage
            self.time_entries.append(time_entry)
            
            # Format time for display
            formatted_time = self._format_time(total_minutes)
            
            return {
                'id': time_entry['id'],
                'total_minutes': total_minutes,
                'formatted_time': formatted_time,
                'original_input': {
                    'value': value,
                    'unit': unit
                }
            }
            
        except ValueError:
            raise ValueError(f"Invalid time unit: {unit}")
        except Exception as e:
            raise Exception(f"Failed to log time entry: {str(e)}")
    
    def _convert_to_minutes(self, value: float, unit: TimeUnit) -> int:
        multipliers = {
            TimeUnit.MINUTES: 1,
            TimeUnit.HOURS: 60,
            TimeUnit.DAYS: 24 * 60
        }
        
        return int(value * multipliers[unit])
    
    def _format_time(self, total_minutes: int) -> str:
        days = total_minutes // (24 * 60)
        hours = (total_minutes % (24 * 60)) // 60
        minutes = total_minutes % 60
        
        return f"{days}d {hours}h {minutes}m"
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 92
```typescript
enum TimeUnit {
    MINUTES = 'minutes',
    HOURS = 'hours',
    DAYS = 'days'
}

interface TimeEntryRequest {
    value: number;
    unit: TimeUnit;
    projectId: string;
    userId: string;
}

interface TimeEntry {
    id: string;
    projectId: string;
    userId: string;
    totalMinutes: number;
    originalValue: number;
    originalUnit: string;
    entryDate: Date;
}

export class TimeTracker {
    private timeEntries: TimeEntry[] = [];
    
    logTimeEntry(value: number, unit: string, projectId: string, userId: string) {
        try {
            // Validate unit
            const timeUnit = this.validateTimeUnit(unit);
            
            // Convert to standard minutes
            const totalMinutes = this.convertToMinutes(value, timeUnit);
            
            // Create time entry
            const timeEntry: TimeEntry = {
                id: crypto.randomUUID(),
                projectId,
                userId,
                totalMinutes,
                originalValue: value,
                originalUnit: unit,
                entryDate: new Date()
            };
            
            // Save to storage
            this.timeEntries.push(timeEntry);
            
            // Format time for display
            const formattedTime = this.formatTime(totalMinutes);
            
            return {
                id: timeEntry.id,
                totalMinutes,
                formattedTime,
                originalInput: {
                    value,
                    unit
                }
            };
            
        } catch (error) {
            throw new Error(`Failed to log time entry: ${error.message}`);
        }
    }
    
    private validateTimeUnit(unit: string): TimeUnit {
        const normalizedUnit = unit.toLowerCase() as TimeUnit;
        if (!Object.values(TimeUnit).includes(normalizedUnit)) {
            throw new Error(`Invalid time unit: ${unit}`);
        }
        return normalizedUnit;
    }
    
    private convertToMinutes(value: number, unit: TimeUnit): number {
        const multipliers = {
            [TimeUnit.MINUTES]: 1,
            [TimeUnit.HOURS]: 60,
            [TimeUnit.DAYS]: 24 * 60
        };
        
        return Math.round(value * multipliers[unit]);
    }
    
    private formatTime(totalMinutes: number): string {
        const days = Math.floor(totalMinutes / (24 * 60));
        const hours = Math.floor((totalMinutes % (24 * 60)) / 60);
        const minutes = totalMinutes % 60;
        
        return `${days}d ${hours}h ${minutes}m`;
    }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 61
```csharp
[HttpPost("calculate-finance")]
public IActionResult CalculateFinance([FromBody] FinanceCalculationRequest request)
{
    try
    {
        // Use decimal for precise financial calculations
        decimal amount = Convert.ToDecimal(request.Amount);
        decimal rate = Convert.ToDecimal(request.InterestRate) / 100;
        int periods = request.Periods;
        
        decimal result = request.CalculationType switch
        {
            "simple_interest" => amount * rate * periods,
            "compound_interest" => amount * (decimal)Math.Pow((double)(1 + rate), periods) - amount,
            "monthly_payment" => CalculateMonthlyPayment(amount, rate / 12, periods),
            "future_value" => amount * (decimal)Math.Pow((double)(1 + rate), periods),
            _ => throw new ArgumentException("Invalid calculation type")
        };
        
        // Format currency based on calculation type
        var formattedResult = FormatCurrency(result);
        
        // Save calculation to database
        var calculation = new FinanceCalculation
        {
            Id = Guid.NewGuid(),
            Amount = amount,
            InterestRate = request.InterestRate,
            Periods = periods,
            CalculationType = request.CalculationType,
            Result = result,
            CalculatedAt = DateTime.UtcNow
        };
        
        _context.FinanceCalculations.Add(calculation);
        _context.SaveChanges();
        
        return Ok(new
        {
            Result = formattedResult,
            CalculationType = request.CalculationType,
            InputAmount = FormatCurrency(amount)
        });
    }
    catch (Exception ex)
    {
        return BadRequest(new { Error = ex.Message });
    }
}

private string FormatCurrency(decimal amount)
{
    return amount.ToString("C2", new CultureInfo("tr-TR"));
}

private decimal CalculateMonthlyPayment(decimal principal, decimal monthlyRate, int periods)
{
    if (monthlyRate == 0) return principal / periods;
    return principal * monthlyRate * (decimal)Math.Pow((double)(1 + monthlyRate), periods) /
           ((decimal)Math.Pow((double)(1 + monthlyRate), periods) - 1);
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 66
```python
from decimal import Decimal, getcontext
import math
from datetime import datetime

# Set precision for financial calculations
getcontext().prec = 10

class FinanceCalculator:
    def __init__(self):
        self.calculations = []
    
    def calculate_finance(self, amount, interest_rate, periods, calculation_type):
        try:
            # Convert to Decimal for precise calculations
            amount_decimal = Decimal(str(amount))
            rate_decimal = Decimal(str(interest_rate)) / Decimal('100')
            periods_int = int(periods)
            
            # Perform calculation based on type
            if calculation_type == "simple_interest":
                result = amount_decimal * rate_decimal * Decimal(str(periods_int))
            elif calculation_type == "compound_interest":
                result = amount_decimal * (Decimal('1') + rate_decimal) ** periods_int - amount_decimal
            elif calculation_type == "monthly_payment":
                monthly_rate = rate_decimal / Decimal('12')
                result = self._calculate_monthly_payment(amount_decimal, monthly_rate, periods_int)
            elif calculation_type == "future_value":
                result = amount_decimal * (Decimal('1') + rate_decimal) ** periods_int
            else:
                raise ValueError("Invalid calculation type")
            
            # Format currency
            formatted_result = self._format_currency(result)
            formatted_amount = self._format_currency(amount_decimal)
            
            # Save calculation record
            calculation_record = {
                'id': len(self.calculations) + 1,
                'amount': float(amount_decimal),
                'interest_rate': interest_rate,
                'periods': periods_int,
                'calculation_type': calculation_type,
                'result': float(result),
                'calculated_at': datetime.now().isoformat()
            }
            
            self.calculations.append(calculation_record)
            
            return {
                'result': formatted_result,
                'calculation_type': calculation_type,
                'input_amount': formatted_amount
            }
            
        except Exception as e:
            raise Exception(f"Finance calculation failed: {str(e)}")
    
    def _calculate_monthly_payment(self, principal, monthly_rate, periods):
        if monthly_rate == 0:
            return principal / Decimal(str(periods))
        
        return (principal * monthly_rate * (Decimal('1') + monthly_rate) ** periods) / \
               ((Decimal('1') + monthly_rate) ** periods - Decimal('1'))
    
    def _format_currency(self, amount):
        return f"â‚º{amount:,.2f}"
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 94
```typescript
interface FinanceCalculationRequest {
    amount: number | string;
    interestRate: number | string;
    periods: number;
    calculationType: 'simple_interest' | 'compound_interest' | 'monthly_payment' | 'future_value';
}

interface CalculationResult {
    result: string;
    calculationType: string;
    inputAmount: string;
}

export class FinanceCalculator {
    private calculations: any[] = [];
    
    calculateFinance(request: FinanceCalculationRequest): CalculationResult {
        try {
            // Convert inputs to precise numbers
            const amount = parseFloat(request.amount.toString());
            const rate = parseFloat(request.interestRate.toString()) / 100;
            const periods = request.periods;
            
            if (isNaN(amount) || isNaN(rate) || periods <= 0) {
                throw new Error('Invalid input values');
            }
            
            let result: number;
            
            switch (request.calculationType) {
                case 'simple_interest':
                    result = amount * rate * periods;
                    break;
                case 'compound_interest':
                    result = amount * Math.pow(1 + rate, periods) - amount;
                    break;
                case 'monthly_payment':
                    const monthlyRate = rate / 12;
                    result = this.calculateMonthlyPayment(amount, monthlyRate, periods);
                    break;
                case 'future_value':
                    result = amount * Math.pow(1 + rate, periods);
                    break;
                default:
                    throw new Error('Invalid calculation type');
            }
            
            // Format results
            const formattedResult = this.formatCurrency(result);
            const formattedAmount = this.formatCurrency(amount);
            
            // Save calculation record
            this.saveCalculation(request, result);
            
            return {
                result: formattedResult,
                calculationType: request.calculationType,
                inputAmount: formattedAmount
            };
            
        } catch (error) {
            throw new Error(`Finance calculation failed: ${error.message}`);
        }
    }
    
    private calculateMonthlyPayment(principal: number, monthlyRate: number, periods: number): number {
        if (monthlyRate === 0) return principal / periods;
        
        return (principal * monthlyRate * Math.pow(1 + monthlyRate, periods)) /
               (Math.pow(1 + monthlyRate, periods) - 1);
    }
    
    private formatCurrency(amount: number): string {
        return new Intl.NumberFormat('tr-TR', {
            style: 'currency',
            currency: 'TRY',
            minimumFractionDigits: 2
        }).format(amount);
    }
    
    private saveCalculation(request: FinanceCalculationRequest, result: number): void {
        const calculationRecord = {
            id: this.calculations.length + 1,
            amount: parseFloat(request.amount.toString()),
            interestRate: parseFloat(request.interestRate.toString()),
            periods: request.periods,
            calculationType: request.calculationType,
            result,
            calculatedAt: new Date().toISOString()
        };
        
        this.calculations.push(calculationRecord);
    }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 77
```csharp
[HttpPost("analyze-data")]
public IActionResult AnalyzeData([FromBody] DataAnalysisRequest request)
{
    try
    {
        // Convert mixed data types to doubles for analysis
        var numericData = ConvertToNumericArray(request.Data);
        
        // Perform statistical calculations
        var statistics = CalculateStatistics(numericData);
        
        // Save analysis results
        var analysis = new DataAnalysis
        {
            Id = Guid.NewGuid(),
            DatasetName = request.DatasetName,
            DataCount = numericData.Length,
            Mean = statistics.Mean,
            Median = statistics.Median,
            StandardDeviation = statistics.StandardDeviation,
            AnalyzedAt = DateTime.UtcNow
        };
        
        _context.DataAnalyses.Add(analysis);
        _context.SaveChanges();
        
        return Ok(new
        {
            Statistics = statistics,
            ChartData = PrepareChartData(numericData),
            DataTypes = AnalyzeDataTypes(request.Data)
        });
    }
    catch (Exception ex)
    {
        return BadRequest(new { Error = ex.Message });
    }
}

private double[] ConvertToNumericArray(object[] data)
{
    return data.Select(item => 
    {
        if (double.TryParse(item.ToString(), out double result))
            return result;
        throw new ArgumentException($"Cannot convert '{item}' to numeric value");
    }).ToArray();
}

private StatisticsResult CalculateStatistics(double[] data)
{
    Array.Sort(data);
    
    return new StatisticsResult
    {
        Mean = data.Average(),
        Median = data.Length % 2 == 0 
            ? (data[data.Length / 2 - 1] + data[data.Length / 2]) / 2 
            : data[data.Length / 2],
        StandardDeviation = Math.Sqrt(data.Select(x => Math.Pow(x - data.Average(), 2)).Average()),
        Min = data.Min(),
        Max = data.Max(),
        Count = data.Length
    };
}

private object[] PrepareChartData(double[] data)
{
    // Create histogram bins for chart
    var binCount = Math.Min(10, data.Length);
    var range = data.Max() - data.Min();
    var binSize = range / binCount;
    
    return data.GroupBy(x => Math.Floor((x - data.Min()) / binSize))
               .Select(g => new { Bin = g.Key, Count = g.Count() })
               .ToArray();
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 91
```python
import statistics
import math
from datetime import datetime
from typing import List, Union, Dict, Any

class DataAnalyzer:
    def __init__(self):
        self.analyses = []
    
    def analyze_data(self, data: List[Union[str, int, float]], dataset_name: str) -> Dict[str, Any]:
        try:
            # Convert mixed data types to floats
            numeric_data = self._convert_to_numeric(data)
            
            # Calculate statistics
            stats = self._calculate_statistics(numeric_data)
            
            # Prepare chart data
            chart_data = self._prepare_chart_data(numeric_data)
            
            # Analyze data types
            data_types = self._analyze_data_types(data)
            
            # Save analysis record
            analysis_record = {
                'id': len(self.analyses) + 1,
                'dataset_name': dataset_name,
                'data_count': len(numeric_data),
                'mean': stats['mean'],
                'median': stats['median'],
                'standard_deviation': stats['std_dev'],
                'analyzed_at': datetime.now().isoformat()
            }
            
            self.analyses.append(analysis_record)
            
            return {
                'statistics': stats,
                'chart_data': chart_data,
                'data_types': data_types
            }
            
        except Exception as e:
            raise Exception(f"Data analysis failed: {str(e)}")
    
    def _convert_to_numeric(self, data: List[Union[str, int, float]]) -> List[float]:
        numeric_data = []
        for item in data:
            try:
                numeric_data.append(float(item))
            except (ValueError, TypeError):
                raise ValueError(f"Cannot convert '{item}' to numeric value")
        
        return numeric_data
    
    def _calculate_statistics(self, data: List[float]) -> Dict[str, float]:
        return {
            'mean': statistics.mean(data),
            'median': statistics.median(data),
            'std_dev': statistics.stdev(data) if len(data) > 1 else 0,
            'min': min(data),
            'max': max(data),
            'count': len(data)
        }
    
    def _prepare_chart_data(self, data: List[float]) -> List[Dict[str, Any]]:
        # Create histogram bins
        bin_count = min(10, len(data))
        data_range = max(data) - min(data)
        bin_size = data_range / bin_count if data_range > 0 else 1
        
        bins = {}
        for value in data:
            bin_index = int((value - min(data)) // bin_size)
            bin_index = min(bin_index, bin_count - 1)  # Handle edge case
            bins[bin_index] = bins.get(bin_index, 0) + 1
        
        return [{'bin': bin_idx, 'count': count} for bin_idx, count in bins.items()]
    
    def _analyze_data_types(self, data: List[Union[str, int, float]]) -> Dict[str, int]:
        type_counts = {'integer': 0, 'float': 0, 'string': 0}
        
        for item in data:
            if isinstance(item, int):
                type_counts['integer'] += 1
            elif isinstance(item, float):
                type_counts['float'] += 1
            else:
                type_counts['string'] += 1
        
        return type_counts
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 131
```typescript
interface DataAnalysisRequest {
    data: (string | number)[];
    datasetName: string;
}

interface StatisticsResult {
    mean: number;
    median: number;
    stdDev: number;
    min: number;
    max: number;
    count: number;
}

interface ChartDataPoint {
    bin: number;
    count: number;
}

export class DataAnalyzer {
    private analyses: any[] = [];
    
    analyzeData(data: (string | number)[], datasetName: string) {
        try {
            // Convert mixed data types to numbers
            const numericData = this.convertToNumeric(data);
            
            // Calculate statistics
            const statistics = this.calculateStatistics(numericData);
            
            // Prepare chart data
            const chartData = this.prepareChartData(numericData);
            
            // Analyze data types
            const dataTypes = this.analyzeDataTypes(data);
            
            // Save analysis record
            this.saveAnalysis(datasetName, statistics);
            
            return {
                statistics,
                chartData,
                dataTypes
            };
            
        } catch (error) {
            throw new Error(`Data analysis failed: ${error.message}`);
        }
    }
    
    private convertToNumeric(data: (string | number)[]): number[] {
        return data.map(item => {
            const num = typeof item === 'number' ? item : parseFloat(item.toString());
            if (isNaN(num)) {
                throw new Error(`Cannot convert '${item}' to numeric value`);
            }
            return num;
        });
    }
    
    private calculateStatistics(data: number[]): StatisticsResult {
        const sorted = [...data].sort((a, b) => a - b);
        const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
        
        // Calculate median
        const median = sorted.length % 2 === 0
            ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2
            : sorted[Math.floor(sorted.length / 2)];
        
        // Calculate standard deviation
        const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
        const stdDev = Math.sqrt(variance);
        
        return {
            mean: Math.round(mean * 100) / 100,
            median: Math.round(median * 100) / 100,
            stdDev: Math.round(stdDev * 100) / 100,
            min: Math.min(...data),
            max: Math.max(...data),
            count: data.length
        };
    }
    
    private prepareChartData(data: number[]): ChartDataPoint[] {
        const binCount = Math.min(10, data.length);
        const range = Math.max(...data) - Math.min(...data);
        const binSize = range / binCount || 1;
        const minValue = Math.min(...data);
        
        const bins: { [key: number]: number } = {};
        
        data.forEach(value => {
            const binIndex = Math.min(Math.floor((value - minValue) / binSize), binCount - 1);
            bins[binIndex] = (bins[binIndex] || 0) + 1;
        });
        
        return Object.entries(bins).map(([bin, count]) => ({
            bin: parseInt(bin),
            count
        }));
    }
    
    private analyzeDataTypes(data: (string | number)[]): { [key: string]: number } {
        return data.reduce((counts, item) => {
            if (typeof item === 'number') {
                if (Number.isInteger(item)) {
                    counts.integer = (counts.integer || 0) + 1;
                } else {
                    counts.float = (counts.float || 0) + 1;
                }
            } else {
                counts.string = (counts.string || 0) + 1;
            }
            return counts;
        }, {} as { [key: string]: number });
    }
    
    private saveAnalysis(datasetName: string, statistics: StatisticsResult): void {
        const analysisRecord = {
            id: this.analyses.length + 1,
            datasetName,
            dataCount: statistics.count,
            mean: statistics.mean,
            median: statistics.median,
            standardDeviation: statistics.stdDev,
            analyzedAt: new Date().toISOString()
        };
        
        this.analyses.push(analysisRecord);
    }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 78
```csharp
[HttpPost("update-score")]
public IActionResult UpdatePlayerScore([FromBody] ScoreUpdateRequest request)
{
    try
    {
        // Convert score to standard integer format
        int normalizedScore = NormalizeScore(request.Score, request.ScoreType);
        
        // Calculate bonus multiplier based on performance
        decimal multiplier = CalculateMultiplier(request.PerformanceMetrics);
        int finalScore = (int)(normalizedScore * multiplier);
        
        // Update or create player score record
        var playerScore = _context.PlayerScores
            .FirstOrDefault(ps => ps.PlayerId == request.PlayerId && ps.GameMode == request.GameMode);
            
        if (playerScore == null)
        {
            playerScore = new PlayerScore
            {
                Id = Guid.NewGuid(),
                PlayerId = request.PlayerId,
                GameMode = request.GameMode,
                HighScore = finalScore,
                TotalScore = finalScore,
                GamesPlayed = 1,
                LastUpdated = DateTime.UtcNow
            };
            _context.PlayerScores.Add(playerScore);
        }
        else
        {
            playerScore.HighScore = Math.Max(playerScore.HighScore, finalScore);
            playerScore.TotalScore += finalScore;
            playerScore.GamesPlayed++;
            playerScore.LastUpdated = DateTime.UtcNow;
        }
        
        _context.SaveChanges();
        
        // Get updated leaderboard position
        var position = GetLeaderboardPosition(playerScore.PlayerId, request.GameMode);
        
        return Ok(new
        {
            FinalScore = finalScore.ToString("N0"),
            HighScore = playerScore.HighScore.ToString("N0"),
            LeaderboardPosition = position,
            Multiplier = multiplier.ToString("F2")
        });
    }
    catch (Exception ex)
    {
        return BadRequest(new { Error = ex.Message });
    }
}

private int NormalizeScore(object score, string scoreType)
{
    return scoreType.ToLower() switch
    {
        "percentage" => (int)(Convert.ToDouble(score) * 1000), // Convert percentage to points
        "time" => (int)(120000 - Convert.ToDouble(score) * 1000), // Convert time to points (faster = more points)
        "points" => Convert.ToInt32(score),
        _ => throw new ArgumentException("Invalid score type")
    };
}

private decimal CalculateMultiplier(PerformanceMetrics metrics)
{
    decimal multiplier = 1.0m;
    
    if (metrics.Accuracy > 90) multiplier += 0.2m;
    if (metrics.Speed > 80) multiplier += 0.15m;
    if (metrics.Combo > 50) multiplier += 0.1m;
    
    return Math.Min(multiplier, 2.0m); // Cap at 2x multiplier
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 98
```python
from datetime import datetime
from typing import Union, Dict, Any

class GameScoreManager:
    def __init__(self):
        self.player_scores = {}
        self.leaderboards = {}
    
    def update_player_score(self, player_id: str, score: Union[int, float], 
                           score_type: str, game_mode: str, 
                           performance_metrics: Dict[str, float]) -> Dict[str, Any]:
        try:
            # Normalize score to standard integer format
            normalized_score = self._normalize_score(score, score_type)
            
            # Calculate performance multiplier
            multiplier = self._calculate_multiplier(performance_metrics)
            final_score = int(normalized_score * multiplier)
            
            # Update player score record
            score_key = f"{player_id}_{game_mode}"
            
            if score_key not in self.player_scores:
                self.player_scores[score_key] = {
                    'player_id': player_id,
                    'game_mode': game_mode,
                    'high_score': final_score,
                    'total_score': final_score,
                    'games_played': 1,
                    'last_updated': datetime.now().isoformat()
                }
            else:
                player_data = self.player_scores[score_key]
                player_data['high_score'] = max(player_data['high_score'], final_score)
                player_data['total_score'] += final_score
                player_data['games_played'] += 1
                player_data['last_updated'] = datetime.now().isoformat()
            
            # Update leaderboard
            self._update_leaderboard(game_mode)
            
            # Get leaderboard position
            position = self._get_leaderboard_position(player_id, game_mode)
            
            return {
                'final_score': f"{final_score:,}",
                'high_score': f"{self.player_scores[score_key]['high_score']:,}",
                'leaderboard_position': position,
                'multiplier': f"{multiplier:.2f}x"
            }
            
        except Exception as e:
            raise Exception(f"Score update failed: {str(e)}")
    
    def _normalize_score(self, score: Union[int, float], score_type: str) -> int:
        score_float = float(score)
        
        if score_type.lower() == "percentage":
            return int(score_float * 1000)  # Convert percentage to points
        elif score_type.lower() == "time":
            return int(120000 - score_float * 1000)  # Convert time to points (faster = more)
        elif score_type.lower() == "points":
            return int(score_float)
        else:
            raise ValueError("Invalid score type")
    
    def _calculate_multiplier(self, metrics: Dict[str, float]) -> float:
        multiplier = 1.0
        
        if metrics.get('accuracy', 0) > 90:
            multiplier += 0.2
        if metrics.get('speed', 0) > 80:
            multiplier += 0.15
        if metrics.get('combo', 0) > 50:
            multiplier += 0.1
        
        return min(multiplier, 2.0)  # Cap at 2x multiplier
    
    def _update_leaderboard(self, game_mode: str):
        # Filter and sort scores for the game mode
        mode_scores = [(key, data) for key, data in self.player_scores.items() 
                      if data['game_mode'] == game_mode]
        
        self.leaderboards[game_mode] = sorted(
            mode_scores, 
            key=lambda x: x[1]['high_score'], 
            reverse=True
        )
    
    def _get_leaderboard_position(self, player_id: str, game_mode: str) -> int:
        if game_mode not in self.leaderboards:
            return 1
        
        for i, (key, data) in enumerate(self.leaderboards[game_mode]):
            if data['player_id'] == player_id:
                return i + 1
        
        return len(self.leaderboards[game_mode]) + 1
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 113
```typescript
interface ScoreUpdateRequest {
    playerId: string;
    score: number | string;
    scoreType: 'percentage' | 'time' | 'points';
    gameMode: string;
    performanceMetrics: {
        accuracy?: number;
        speed?: number;
        combo?: number;
    };
}

interface PlayerScore {
    playerId: string;
    gameMode: string;
    highScore: number;
    totalScore: number;
    gamesPlayed: number;
    lastUpdated: Date;
}

export class GameScoreManager {
    private playerScores: Map<string, PlayerScore> = new Map();
    private leaderboards: Map<string, PlayerScore[]> = new Map();
    
    updatePlayerScore(request: ScoreUpdateRequest) {
        try {
            // Normalize score to standard integer format
            const normalizedScore = this.normalizeScore(request.score, request.scoreType);
            
            // Calculate performance multiplier
            const multiplier = this.calculateMultiplier(request.performanceMetrics);
            const finalScore = Math.floor(normalizedScore * multiplier);
            
            // Update or create player score record
            const scoreKey = `${request.playerId}_${request.gameMode}`;
            const existingScore = this.playerScores.get(scoreKey);
            
            if (!existingScore) {
                this.playerScores.set(scoreKey, {
                    playerId: request.playerId,
                    gameMode: request.gameMode,
                    highScore: finalScore,
                    totalScore: finalScore,
                    gamesPlayed: 1,
                    lastUpdated: new Date()
                });
            } else {
                existingScore.highScore = Math.max(existingScore.highScore, finalScore);
                existingScore.totalScore += finalScore;
                existingScore.gamesPlayed++;
                existingScore.lastUpdated = new Date();
            }
            
            // Update leaderboard
            this.updateLeaderboard(request.gameMode);
            
            // Get leaderboard position
            const position = this.getLeaderboardPosition(request.playerId, request.gameMode);
            const playerData = this.playerScores.get(scoreKey)!;
            
            return {
                finalScore: finalScore.toLocaleString(),
                highScore: playerData.highScore.toLocaleString(),
                leaderboardPosition: position,
                multiplier: `${multiplier.toFixed(2)}x`
            };
            
        } catch (error) {
            throw new Error(`Score update failed: ${error.message}`);
        }
    }
    
    private normalizeScore(score: number | string, scoreType: string): number {
        const scoreNum = typeof score === 'string' ? parseFloat(score) : score;
        
        switch (scoreType.toLowerCase()) {
            case 'percentage':
                return Math.floor(scoreNum * 1000); // Convert percentage to points
            case 'time':
                return Math.floor(120000 - scoreNum * 1000); // Convert time to points
            case 'points':
                return Math.floor(scoreNum);
            default:
                throw new Error('Invalid score type');
        }
    }
    
    private calculateMultiplier(metrics: { accuracy?: number; speed?: number; combo?: number }): number {
        let multiplier = 1.0;
        
        if ((metrics.accuracy || 0) > 90) multiplier += 0.2;
        if ((metrics.speed || 0) > 80) multiplier += 0.15;
        if ((metrics.combo || 0) > 50) multiplier += 0.1;
        
        return Math.min(multiplier, 2.0); // Cap at 2x multiplier
    }
    
    private updateLeaderboard(gameMode: string): void {
        const modeScores = Array.from(this.playerScores.values())
            .filter(score => score.gameMode === gameMode)
            .sort((a, b) => b.highScore - a.highScore);
        
        this.leaderboards.set(gameMode, modeScores);
    }
    
    private getLeaderboardPosition(playerId: string, gameMode: string): number {
        const leaderboard = this.leaderboards.get(gameMode) || [];
        
        const position = leaderboard.findIndex(score => score.playerId === playerId);
        return position >= 0 ? position + 1 : leaderboard.length + 1;
    }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 105
```csharp
public enum MeasurementType { Distance, Weight, Volume }

[HttpPost("convert-measurement")]
public IActionResult ConvertMeasurement([FromBody] MeasurementRequest request)
{
    try
    {
        // Convert to base unit (meters, kilograms, liters)
        double baseValue = ConvertToBaseUnit(request.Value, request.FromUnit, request.MeasurementType);
        
        // Convert to all relevant units for display
        var conversions = GenerateConversions(baseValue, request.MeasurementType);
        
        // Save measurement record
        var measurement = new MeasurementRecord
        {
            Id = Guid.NewGuid(),
            OriginalValue = request.Value,
            OriginalUnit = request.FromUnit,
            BaseValue = baseValue,
            MeasurementType = request.MeasurementType.ToString(),
            CreatedAt = DateTime.UtcNow,
            UserId = request.UserId
        };
        
        _context.MeasurementRecords.Add(measurement);
        _context.SaveChanges();
        
        return Ok(new
        {
            BaseValue = Math.Round(baseValue, 4),
            Conversions = conversions,
            OriginalInput = new { Value = request.Value, Unit = request.FromUnit }
        });
    }
    catch (Exception ex)
    {
        return BadRequest(new { Error = ex.Message });
    }
}

private double ConvertToBaseUnit(double value, string unit, MeasurementType type)
{
    return type switch
    {
        MeasurementType.Distance => unit.ToLower() switch
        {
            "mm" => value / 1000,
            "cm" => value / 100,
            "m" => value,
            "km" => value * 1000,
            "inch" => value * 0.0254,
            "ft" => value * 0.3048,
            _ => throw new ArgumentException("Invalid distance unit")
        },
        MeasurementType.Weight => unit.ToLower() switch
        {
            "g" => value / 1000,
            "kg" => value,
            "lb" => value * 0.453592,
            "oz" => value * 0.0283495,
            _ => throw new ArgumentException("Invalid weight unit")
        },
        MeasurementType.Volume => unit.ToLower() switch
        {
            "ml" => value / 1000,
            "l" => value,
            "gal" => value * 3.78541,
            "qt" => value * 0.946353,
            _ => throw new ArgumentException("Invalid volume unit")
        },
        _ => throw new ArgumentException("Invalid measurement type")
    };
}

private Dictionary<string, string> GenerateConversions(double baseValue, MeasurementType type)
{
    return type switch
    {
        MeasurementType.Distance => new Dictionary<string, string>
        {
            ["Millimeters"] = (baseValue * 1000).ToString("F2"),
            ["Centimeters"] = (baseValue * 100).ToString("F2"),
            ["Meters"] = baseValue.ToString("F2"),
            ["Kilometers"] = (baseValue / 1000).ToString("F4"),
            ["Feet"] = (baseValue * 3.28084).ToString("F2"),
            ["Inches"] = (baseValue * 39.3701).ToString("F2")
        },
        MeasurementType.Weight => new Dictionary<string, string>
        {
            ["Grams"] = (baseValue * 1000).ToString("F2"),
            ["Kilograms"] = baseValue.ToString("F2"),
            ["Pounds"] = (baseValue * 2.20462).ToString("F2"),
            ["Ounces"] = (baseValue * 35.274).ToString("F2")
        },
        MeasurementType.Volume => new Dictionary<string, string>
        {
            ["Milliliters"] = (baseValue * 1000).ToString("F2"),
            ["Liters"] = baseValue.ToString("F2"),
            ["Gallons"] = (baseValue / 3.78541).ToString("F4"),
            ["Quarts"] = (baseValue * 1.05669).ToString("F2")
        },
        _ => new Dictionary<string, string>()
    };
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 112
```python
from enum import Enum
from datetime import datetime
from typing import Dict, Union

class MeasurementType(Enum):
    DISTANCE = "distance"
    WEIGHT = "weight"
    VOLUME = "volume"

class MeasurementConverter:
    def __init__(self):
        self.measurement_records = []
        
        # Conversion factors to base units (meters, kg, liters)
        self.distance_factors = {
            'mm': 0.001, 'cm': 0.01, 'm': 1, 'km': 1000,
            'inch': 0.0254, 'ft': 0.3048
        }
        
        self.weight_factors = {
            'g': 0.001, 'kg': 1, 'lb': 0.453592, 'oz': 0.0283495
        }
        
        self.volume_factors = {
            'ml': 0.001, 'l': 1, 'gal': 3.78541, 'qt': 0.946353
        }
    
    def convert_measurement(self, value: float, from_unit: str, 
                          measurement_type: str, user_id: str) -> Dict[str, Union[float, Dict]]:
        try:
            # Validate measurement type
            mtype = MeasurementType(measurement_type.lower())
            
            # Convert to base unit
            base_value = self._convert_to_base_unit(value, from_unit, mtype)
            
            # Generate all conversions
            conversions = self._generate_conversions(base_value, mtype)
            
            # Save measurement record
            record = {
                'id': len(self.measurement_records) + 1,
                'original_value': value,
                'original_unit': from_unit,
                'base_value': base_value,
                'measurement_type': measurement_type,
                'user_id': user_id,
                'created_at': datetime.now().isoformat()
            }
            
            self.measurement_records.append(record)
            
            return {
                'base_value': round(base_value, 4),
                'conversions': conversions,
                'original_input': {'value': value, 'unit': from_unit}
            }
            
        except ValueError as e:
            raise ValueError(f"Invalid measurement type: {measurement_type}")
        except Exception as e:
            raise Exception(f"Measurement conversion failed: {str(e)}")
    
    def _convert_to_base_unit(self, value: float, unit: str, mtype: MeasurementType) -> float:
        unit_lower = unit.lower()
        
        if mtype == MeasurementType.DISTANCE:
            if unit_lower not in self.distance_factors:
                raise ValueError(f"Invalid distance unit: {unit}")
            return value * self.distance_factors[unit_lower]
        
        elif mtype == MeasurementType.WEIGHT:
            if unit_lower not in self.weight_factors:
                raise ValueError(f"Invalid weight unit: {unit}")
            return value * self.weight_factors[unit_lower]
        
        elif mtype == MeasurementType.VOLUME:
            if unit_lower not in self.volume_factors:
                raise ValueError(f"Invalid volume unit: {unit}")
            return value * self.volume_factors[unit_lower]
        
        else:
            raise ValueError("Invalid measurement type")
    
    def _generate_conversions(self, base_value: float, mtype: MeasurementType) -> Dict[str, str]:
        if mtype == MeasurementType.DISTANCE:
            return {
                'Millimeters': f"{base_value * 1000:.2f}",
                'Centimeters': f"{base_value * 100:.2f}",
                'Meters': f"{base_value:.2f}",
                'Kilometers': f"{base_value / 1000:.4f}",
                'Feet': f"{base_value * 3.28084:.2f}",
                'Inches': f"{base_value * 39.3701:.2f}"
            }
        
        elif mtype == MeasurementType.WEIGHT:
            return {
                'Grams': f"{base_value * 1000:.2f}",
                'Kilograms': f"{base_value:.2f}",
                'Pounds': f"{base_value * 2.20462:.2f}",
                'Ounces': f"{base_value * 35.274:.2f}"
            }
        
        elif mtype == MeasurementType.VOLUME:
            return {
                'Milliliters': f"{base_value * 1000:.2f}",
                'Liters': f"{base_value:.2f}",
                'Gallons': f"{base_value / 3.78541:.4f}",
                'Quarts': f"{base_value * 1.05669:.2f}"
            }
        
        return {}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 143
```typescript
enum MeasurementType {
    DISTANCE = 'distance',
    WEIGHT = 'weight',
    VOLUME = 'volume'
}

interface MeasurementRequest {
    value: number;
    fromUnit: string;
    measurementType: MeasurementType;
    userId: string;
}

interface ConversionResult {
    baseValue: number;
    conversions: { [key: string]: string };
    originalInput: { value: number; unit: string };
}

export class MeasurementConverter {
    private measurementRecords: any[] = [];
    
    private readonly distanceFactors: { [key: string]: number } = {
        'mm': 0.001, 'cm': 0.01, 'm': 1, 'km': 1000,
        'inch': 0.0254, 'ft': 0.3048
    };
    
    private readonly weightFactors: { [key: string]: number } = {
        'g': 0.001, 'kg': 1, 'lb': 0.453592, 'oz': 0.0283495
    };
    
    private readonly volumeFactors: { [key: string]: number } = {
        'ml': 0.001, 'l': 1, 'gal': 3.78541, 'qt': 0.946353
    };
    
    convertMeasurement(value: number, fromUnit: string, measurementType: string, userId: string): ConversionResult {
        try {
            // Validate measurement type
            const mType = this.validateMeasurementType(measurementType);
            
            // Convert to base unit
            const baseValue = this.convertToBaseUnit(value, fromUnit, mType);
            
            // Generate all conversions
            const conversions = this.generateConversions(baseValue, mType);
            
            // Save measurement record
            this.saveMeasurementRecord(value, fromUnit, baseValue, measurementType, userId);
            
            return {
                baseValue: Math.round(baseValue * 10000) / 10000,
                conversions,
                originalInput: { value, unit: fromUnit }
            };
            
        } catch (error) {
            throw new Error(`Measurement conversion failed: ${error.message}`);
        }
    }
    
    private validateMeasurementType(type: string): MeasurementType {
        const normalizedType = type.toLowerCase() as MeasurementType;
        if (!Object.values(MeasurementType).includes(normalizedType)) {
            throw new Error(`Invalid measurement type: ${type}`);
        }
        return normalizedType;
    }
    
    private convertToBaseUnit(value: number, unit: string, type: MeasurementType): number {
        const unitLower = unit.toLowerCase();
        
        switch (type) {
            case MeasurementType.DISTANCE:
                if (!(unitLower in this.distanceFactors)) {
                    throw new Error(`Invalid distance unit: ${unit}`);
                }
                return value * this.distanceFactors[unitLower];
                
            case MeasurementType.WEIGHT:
                if (!(unitLower in this.weightFactors)) {
                    throw new Error(`Invalid weight unit: ${unit}`);
                }
                return value * this.weightFactors[unitLower];
                
            case MeasurementType.VOLUME:
                if (!(unitLower in this.volumeFactors)) {
                    throw new Error(`Invalid volume unit: ${unit}`);
                }
                return value * this.volumeFactors[unitLower];
                
            default:
                throw new Error('Invalid measurement type');
        }
    }
    
    private generateConversions(baseValue: number, type: MeasurementType): { [key: string]: string } {
        switch (type) {
            case MeasurementType.DISTANCE:
                return {
                    'Millimeters': (baseValue * 1000).toFixed(2),
                    'Centimeters': (baseValue * 100).toFixed(2),
                    'Meters': baseValue.toFixed(2),
                    'Kilometers': (baseValue / 1000).toFixed(4),
                    'Feet': (baseValue * 3.28084).toFixed(2),
                    'Inches': (baseValue * 39.3701).toFixed(2)
                };
                
            case MeasurementType.WEIGHT:
                return {
                    'Grams': (baseValue * 1000).toFixed(2),
                    'Kilograms': baseValue.toFixed(2),
                    'Pounds': (baseValue * 2.20462).toFixed(2),
                    'Ounces': (baseValue * 35.274).toFixed(2)
                };
                
            case MeasurementType.VOLUME:
                return {
                    'Milliliters': (baseValue * 1000).toFixed(2),
                    'Liters': baseValue.toFixed(2),
                    'Gallons': (baseValue / 3.78541).toFixed(4),
                    'Quarts': (baseValue * 1.05669).toFixed(2)
                };
                
            default:
                return {};
        }
    }
    
    private saveMeasurementRecord(value: number, fromUnit: string, baseValue: number, 
                                measurementType: string, userId: string): void {
        const record = {
            id: this.measurementRecords.length + 1,
            originalValue: value,
            originalUnit: fromUnit,
            baseValue,
            measurementType,
            userId,
            createdAt: new Date().toISOString()
        };
        
        this.measurementRecords.push(record);
    }
}
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 177
```typescript
interface ReservationRequest {
    customerId: string;
    resourceId: string;
    dateTime: string;
    duration: number;
    timeZone?: string;
}

interface Reservation {
    id: string;
    customerId: string;
    resourceId: string;
    reservationDateTime: Date;
    timestamp: number;
    duration: number;
    status: string;
    createdAt: Date;
    timeZone: string;
}

export class ReservationSystem {
    private reservations: Reservation[] = [];
    
    private readonly dateTimeFormats = [
        /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/,           // 2024-12-25 14:30:00
        /^\d{2}\/\d{2}\/\d{4} \d{2}:\d{2}$/,               // 12/25/2024 14:30
        /^\d{2}\.\d{2}\.\d{4} \d{2}:\d{2}$/,               // 25.12.2024 14:30
        /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/,           // 2024-12-25T14:30:00
        /^\d{1,2}\/\d{1,2}\/\d{4} \d{1,2}:\d{2} (AM|PM)$/i // 12/25/2024 2:30 PM
    ];
    
    createReservation(request: ReservationRequest) {
        try {
            // Parse and standardize datetime
            const reservationDateTime = this.parseDateTime(request.dateTime, request.timeZone || 'UTC');
            
            // Validate reservation time
            this.validateReservationTime(reservationDateTime);
            
            // Calculate timestamp
            const timestamp = Math.floor(reservationDateTime.getTime() / 1000);
            
            // Create reservation
            const reservation: Reservation = {
                id: crypto.randomUUID(),
                customerId: request.customerId,
                resourceId: request.resourceId,
                reservationDateTime,
                timestamp,
                duration: request.duration,
                status: 'Confirmed',
                createdAt: new Date(),
                timeZone: request.timeZone || 'UTC'
            };
            
            // Check for conflicts
            if (this.hasConflictingReservation(reservation)) {
                throw new Error('Time slot already reserved');
            }
            
            // Save reservation
            this.reservations.push(reservation);
            
            return {
                reservationId: reservation.id,
                dateTime: reservationDateTime.toISOString().slice(0, 19).replace('T', ' '),
                timestamp,
                formattedDateTime: this.formatDateTime(reservationDateTime, request.timeZone || 'UTC'),
                duration: `${request.duration} minutes`
            };
            
        } catch (error) {
            throw new Error(`Reservation creation failed: ${error.message}`);
        }
    }
    
    private parseDateTime(dateTimeInput: string, timeZone: string): Date {
        // Remove extra whitespace
        const cleanInput = dateTimeInput.trim();
        
        // Try parsing different formats
        let date: Date;
        
        if (this.dateTimeFormats[0].test(cleanInput)) {
            // 2024-12-25 14:30:00
            date = new Date(cleanInput.replace(' ', 'T'));
        } else if (this.dateTimeFormats[1].test(cleanInput)) {
            // 12/25/2024 14:30
            const [datePart, timePart] = cleanInput.split(' ');
            const [month, day, year] = datePart.split('/');
            date = new Date(`${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T${timePart}:00`);
        } else if (this.dateTimeFormats[2].test(cleanInput)) {
            // 25.12.2024 14:30
            const [datePart, timePart] = cleanInput.split(' ');
            const [day, month, year] = datePart.split('.');
            date = new Date(`${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T${timePart}:00`);
        } else if (this.dateTimeFormats[3].test(cleanInput)) {
            // 2024-12-25T14:30:00
            date = new Date(cleanInput);
        } else if (this.dateTimeFormats[4].test(cleanInput)) {
            // 12/25/2024 2:30 PM
            date = new Date(cleanInput);
        } else {
            throw new Error('Invalid datetime format');
        }
        
        if (isNaN(date.getTime())) {
            throw new Error('Invalid datetime value');
        }
        
        // Handle timezone conversion if needed
        if (timeZone !== 'UTC') {
            // Simplified timezone handling - in production, use a library like date-fns-tz
            const offsetHours = this.getTimezoneOffset(timeZone);
            date = new Date(date.getTime() - (offsetHours * 60 * 60 * 1000));
        }
        
        return date;
    }
    
    private validateReservationTime(dateTime: Date): void {
        const now = new Date();
        
        if (dateTime <= now) {
            throw new Error('Reservation time must be in the future');
        }
        
        const maxAdvanceTime = new Date();
        maxAdvanceTime.setDate(maxAdvanceTime.getDate() + 90);
        
        if (dateTime > maxAdvanceTime) {
            throw new Error('Reservation cannot be more than 90 days in advance');
        }
    }
    
    private hasConflictingReservation(newReservation: Reservation): boolean {
        const newStart = newReservation.reservationDateTime;
        const newEnd = new Date(newStart.getTime() + (newReservation.duration * 60 * 1000));
        
        return this.reservations.some(existing => {
            if (existing.resourceId !== newReservation.resourceId || existing.status !== 'Confirmed') {
                return false;
            }
            
            const existingStart = existing.reservationDateTime;
            const existingEnd = new Date(existingStart.getTime() + (existing.duration * 60 * 1000));
            
            // Check for overlap
            return (existingStart <= newStart && existingEnd > newStart) ||
                   (newStart <= existingStart && newEnd > existingStart);
        });
    }
    
    private formatDateTime(dateTime: Date, timeZone: string): string {
        const options: Intl.DateTimeFormatOptions = {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            timeZone: timeZone === 'UTC' ? 'UTC' : timeZone
        };
        
        return new Intl.DateTimeFormat('en-US', options).format(dateTime);
    }
    
    private getTimezoneOffset(timeZone: string): number {
        // Simplified timezone offset mapping
        const timezoneOffsets: { [key: string]: number } = {
            'EST': -5, 'PST': -8, 'CET': 1, 'JST': 9,
            'Turkey': 3, 'Europe/Istanbul': 3
        };
        
        return timezoneOffsets[timeZone] || 0;
    }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 131
```csharp
public enum TransactionType { StockIn, StockOut, Adjustment }

[HttpPost("update-inventory")]
public IActionResult UpdateInventory([FromBody] InventoryUpdateRequest request)
{
    try
    {
        // Convert quantity to standard decimal format
        decimal quantity = ConvertToDecimal(request.Quantity);
        
        // Validate transaction
        ValidateTransaction(request.ProductId, quantity, request.TransactionType);
        
        // Get or create inventory record
        var inventory = _context.Inventories
            .FirstOrDefault(i => i.ProductId == request.ProductId);
            
        if (inventory == null)
        {
            inventory = new Inventory
            {
                Id = Guid.NewGuid(),
                ProductId = request.ProductId,
                CurrentStock = 0,
                ReservedStock = 0,
                MinimumStock = request.MinimumStock ?? 0,
                LastUpdated = DateTime.UtcNow
            };
            _context.Inventories.Add(inventory);
        }
        
        // Calculate new stock level
        decimal newStock = CalculateNewStock(inventory.CurrentStock, quantity, request.TransactionType);
        
        // Create transaction record
        var transaction = new InventoryTransaction
        {
            Id = Guid.NewGuid(),
            ProductId = request.ProductId,
            TransactionType = request.TransactionType.ToString(),
            Quantity = quantity,
            PreviousStock = inventory.CurrentStock,
            NewStock = newStock,
            Reference = request.Reference,
            CreatedAt = DateTime.UtcNow,
            UserId = request.UserId
        };
        
        // Update inventory
        inventory.CurrentStock = newStock;
        inventory.LastUpdated = DateTime.UtcNow;
        
        _context.InventoryTransactions.Add(transaction);
        _context.SaveChanges();
        
        // Check stock alerts
        var stockAlert = CheckStockAlert(inventory);
        
        return Ok(new
        {
            ProductId = request.ProductId,
            CurrentStock = inventory.CurrentStock.ToString("F2"),
            TransactionId = transaction.Id,
            StockStatus = GetStockStatus(inventory),
            Alert = stockAlert
        });
    }
    catch (Exception ex)
    {
        return BadRequest(new { Error = ex.Message });
    }
}

private decimal ConvertToDecimal(object quantity)
{
    if (quantity == null) throw new ArgumentNullException(nameof(quantity));
    
    return quantity switch
    {
        string str => decimal.Parse(str.Replace(",", ".")),
        int intVal => intVal,
        double doubleVal => (decimal)doubleVal,
        decimal decVal => decVal,
        _ => Convert.ToDecimal(quantity)
    };
}

private decimal CalculateNewStock(decimal currentStock, decimal quantity, TransactionType type)
{
    return type switch
    {
        TransactionType.StockIn => currentStock + quantity,
        TransactionType.StockOut => currentStock - quantity,
        TransactionType.Adjustment => quantity, // Direct adjustment to specific amount
        _ => throw new ArgumentException("Invalid transaction type")
    };
}

private void ValidateTransaction(string productId, decimal quantity, TransactionType type)
{
    if (quantity <= 0 && type != TransactionType.Adjustment)
        throw new ArgumentException("Quantity must be positive");
        
    if (type == TransactionType.StockOut)
    {
        var currentStock = _context.Inventories
            .Where(i => i.ProductId == productId)
            .Select(i => i.CurrentStock)
            .FirstOrDefault();
            
        if (currentStock < quantity)
            throw new InvalidOperationException("Insufficient stock for this transaction");
    }
}

private string GetStockStatus(Inventory inventory)
{
    if (inventory.CurrentStock <= 0) return "Out of Stock";
    if (inventory.CurrentStock <= inventory.MinimumStock) return "Low Stock";
    if (inventory.CurrentStock <= inventory.MinimumStock * 2) return "Warning";
    return "In Stock";
}

private string CheckStockAlert(Inventory inventory)
{
    if (inventory.CurrentStock <= 0) 
        return "CRITICAL: Product is out of stock";
    if (inventory.CurrentStock <= inventory.MinimumStock)
        return "WARNING: Stock below minimum level";
    return null;
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 134
```python
from enum import Enum
from decimal import Decimal, InvalidOperation
from datetime import datetime
from typing import Union, Optional, Dict, Any

class TransactionType(Enum):
    STOCK_IN = "stock_in"
    STOCK_OUT = "stock_out"
    ADJUSTMENT = "adjustment"

class InventoryManager:
    def __init__(self):
        self.inventories = {}
        self.transactions = []
    
    def update_inventory(self, product_id: str, quantity: Union[str, int, float], 
                        transaction_type: str, reference: str = None, 
                        user_id: str = None, minimum_stock: float = 0) -> Dict[str, Any]:
        try:
            # Convert quantity to standard decimal format
            decimal_quantity = self._convert_to_decimal(quantity)
            
            # Validate transaction type
            trans_type = TransactionType(transaction_type.lower())
            
            # Validate transaction
            self._validate_transaction(product_id, decimal_quantity, trans_type)
            
            # Get or create inventory record
            if product_id not in self.inventories:
                self.inventories[product_id] = {
                    'product_id': product_id,
                    'current_stock': Decimal('0'),
                    'reserved_stock': Decimal('0'),
                    'minimum_stock': Decimal(str(minimum_stock)),
                    'last_updated': datetime.now().isoformat()
                }
            
            inventory = self.inventories[product_id]
            previous_stock = inventory['current_stock']
            
            # Calculate new stock level
            new_stock = self._calculate_new_stock(previous_stock, decimal_quantity, trans_type)
            
            # Create transaction record
            transaction = {
                'id': len(self.transactions) + 1,
                'product_id': product_id,
                'transaction_type': transaction_type,
                'quantity': float(decimal_quantity),
                'previous_stock': float(previous_stock),
                'new_stock': float(new_stock),
                'reference': reference,
                'user_id': user_id,
                'created_at': datetime.now().isoformat()
            }
            
            # Update inventory
            inventory['current_stock'] = new_stock
            inventory['last_updated'] = datetime.now().isoformat()
            
            self.transactions.append(transaction)
            
            # Check stock alerts
            stock_alert = self._check_stock_alert(inventory)
            
            return {
                'product_id': product_id,
                'current_stock': f"{new_stock:.2f}",
                'transaction_id': transaction['id'],
                'stock_status': self._get_stock_status(inventory),
                'alert': stock_alert
            }
            
        except Exception as e:
            raise Exception(f"Inventory update failed: {str(e)}")
    
    def _convert_to_decimal(self, quantity: Union[str, int, float]) -> Decimal:
        try:
            if isinstance(quantity, str):
                # Handle comma as decimal separator
                cleaned = quantity.replace(',', '.')
                return Decimal(cleaned)
            else:
                return Decimal(str(quantity))
        except (InvalidOperation, ValueError):
            raise ValueError(f"Cannot convert '{quantity}' to decimal")
    
    def _calculate_new_stock(self, current_stock: Decimal, 
                           quantity: Decimal, trans_type: TransactionType) -> Decimal:
        if trans_type == TransactionType.STOCK_IN:
            return current_stock + quantity
        elif trans_type == TransactionType.STOCK_OUT:
            return current_stock - quantity
        elif trans_type == TransactionType.ADJUSTMENT:
            return quantity  # Direct adjustment to specific amount
        else:
            raise ValueError("Invalid transaction type")
    
    def _validate_transaction(self, product_id: str, quantity: Decimal, trans_type: TransactionType):
        if quantity <= 0 and trans_type != TransactionType.ADJUSTMENT:
            raise ValueError("Quantity must be positive")
        
        if trans_type == TransactionType.STOCK_OUT:
            current_stock = Decimal('0')
            if product_id in self.inventories:
                current_stock = self.inventories[product_id]['current_stock']
            
            if current_stock < quantity:
                raise ValueError("Insufficient stock for this transaction")
    
    def _get_stock_status(self, inventory: Dict) -> str:
        current = inventory['current_stock']
        minimum = inventory['minimum_stock']
        
        if current <= 0:
            return "Out of Stock"
        elif current <= minimum:
            return "Low Stock"
        elif current <= minimum * 2:
            return "Warning"
        else:
            return "In Stock"
    
    def _check_stock_alert(self, inventory: Dict) -> Optional[str]:
        current = inventory['current_stock']
        minimum = inventory['minimum_stock']
        
        if current <= 0:
            return "CRITICAL: Product is out of stock"
        elif current <= minimum:
            return "WARNING: Stock below minimum level"
        
        return None
```

**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 186
```typescript
enum TransactionType {
    STOCK_IN = 'stock_in',
    STOCK_OUT = 'stock_out',
    ADJUSTMENT = 'adjustment'
}

interface InventoryUpdateRequest {
    productId: string;
    quantity: string | number;
    transactionType: TransactionType;
    reference?: string;
    userId?: string;
    minimumStock?: number;
}

interface Inventory {
    productId: string;
    currentStock: number;
    reservedStock: number;
    minimumStock: number;
    lastUpdated: Date;
}

interface InventoryTransaction {
    id: string;
    productId: string;
    transactionType: string;
    quantity: number;
    previousStock: number;
    newStock: number;
    reference?: string;
    userId?: string;
    createdAt: Date;
}

export class InventoryManager {
    private inventories: Map<string, Inventory> = new Map();
    private transactions: InventoryTransaction[] = [];
    
    updateInventory(request: InventoryUpdateRequest) {
        try {
            // Convert quantity to standard number format
            const quantity = this.convertToNumber(request.quantity);
            
            // Validate transaction
            this.validateTransaction(request.productId, quantity, request.transactionType);
            
            // Get or create inventory record
            let inventory = this.inventories.get(request.productId);
            
            if (!inventory) {
                inventory = {
                    productId: request.productId,
                    currentStock: 0,
                    reservedStock: 0,
                    minimumStock: request.minimumStock || 0,
                    lastUpdated: new Date()
                };
                this.inventories.set(request.productId, inventory);
            }
            
            const previousStock = inventory.currentStock;
            
            // Calculate new stock level
            const newStock = this.calculateNewStock(previousStock, quantity, request.transactionType);
            
            // Create transaction record
            const transaction: InventoryTransaction = {
                id: crypto.randomUUID(),
                productId: request.productId,
                transactionType: request.transactionType,
                quantity,
                previousStock,
                newStock,
                reference: request.reference,
                userId: request.userId,
                createdAt: new Date()
            };
            
            // Update inventory
            inventory.currentStock = newStock;
            inventory.lastUpdated = new Date();
            
            this.transactions.push(transaction);
            
            // Check stock alerts
            const stockAlert = this.checkStockAlert(inventory);
            
            return {
                productId: request.productId,
                currentStock: newStock.toFixed(2),
                transactionId: transaction.id,
                stockStatus: this.getStockStatus(inventory),
                alert: stockAlert
            };
            
        } catch (error) {
            throw new Error(`Inventory update failed: ${error.message}`);
        }
    }
    
    private convertToNumber(quantity: string | number): number {
        if (typeof quantity === 'number') {
            return quantity;
        }
        
        // Handle comma as decimal separator
        const cleaned = quantity.toString().replace(',', '.');
        const result = parseFloat(cleaned);
        
        if (isNaN(result)) {
            throw new Error(`Cannot convert '${quantity}' to number`);
        }
        
        return result;
    }
    
    private calculateNewStock(currentStock: number, quantity: number, transactionType: TransactionType): number {
        switch (transactionType) {
            case TransactionType.STOCK_IN:
                return currentStock + quantity;
            case TransactionType.STOCK_OUT:
                return currentStock - quantity;
            case TransactionType.ADJUSTMENT:
                return quantity; // Direct adjustment to specific amount
            default:
                throw new Error('Invalid transaction type');
        }
    }
    
    private validateTransaction(productId: string, quantity: number, transactionType: TransactionType): void {
        if (quantity <= 0 && transactionType !== TransactionType.ADJUSTMENT) {
            throw new Error('Quantity must be positive');
        }
        
        if (transactionType === TransactionType.STOCK_OUT) {
            const inventory = this.inventories.get(productId);
            const currentStock = inventory ? inventory.currentStock : 0;
            
            if (currentStock < quantity) {
                throw new Error('Insufficient stock for this transaction');
            }
        }
    }
    
    private getStockStatus(inventory: Inventory): string {
        const { currentStock, minimumStock } = inventory;
        
        if (currentStock <= 0) return 'Out of Stock';
        if (currentStock <= minimumStock) return 'Low Stock';
        if (currentStock <= minimumStock * 2) return 'Warning';
        return 'In Stock';
    }
    
    private checkStockAlert(inventory: Inventory): string | null {
        const { currentStock, minimumStock } = inventory;
        
        if (currentStock <= 0) {
            return 'CRITICAL: Product is out of stock';
        }
        if (currentStock <= minimumStock) {
            return 'WARNING: Stock below minimum level';
        }
        
        return null;
    }
    
    // Additional utility methods
    getInventoryReport(productId: string) {
        const inventory = this.inventories.get(productId);
        if (!inventory) {
            throw new Error('Product not found');
        }
        
        const productTransactions = this.transactions
            .filter(t => t.productId === productId)
            .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        
        return {
            inventory,
            recentTransactions: productTransactions.slice(0, 10),
            stockStatus: this.getStockStatus(inventory),
            alert: this.checkStockAlert(inventory)
        };
    }
}
```

**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 114
```csharp
[HttpPost("create-reservation")]
public IActionResult CreateReservation([FromBody] ReservationRequest request)
{
    try
    {
        // Parse and standardize datetime from various formats
        DateTime reservationDateTime = ParseDateTime(request.DateTime, request.TimeZone);
        
        // Validate reservation time
        ValidateReservationTime(reservationDateTime);
        
        // Calculate timestamp for database storage
        long timestamp = new DateTimeOffset(reservationDateTime).ToUnixTimeSeconds();
        
        var reservation = new Reservation
        {
            Id = Guid.NewGuid(),
            CustomerId = request.CustomerId,
            ResourceId = request.ResourceId,
            ReservationDateTime = reservationDateTime,
            Timestamp = timestamp,
            Duration = request.Duration,
            Status = "Confirmed",
            CreatedAt = DateTime.UtcNow,
            TimeZone = request.TimeZone
        };
        
        // Check for conflicts
        if (HasConflictingReservation(reservation))
        {
            return Conflict(new { Error = "Time slot already reserved" });
        }
        
        _context.Reservations.Add(reservation);
        _context.SaveChanges();
        
        return Ok(new
        {
            ReservationId = reservation.Id,
            DateTime = reservationDateTime.ToString("yyyy-MM-dd HH:mm:ss"),
            Timestamp = timestamp,
            FormattedDateTime = FormatDateTime(reservationDateTime, request.TimeZone),
            Duration = $"{request.Duration} minutes"
        });
    }
    catch (Exception ex)
    {
        return BadRequest(new { Error = ex.Message });
    }
}

private DateTime ParseDateTime(string dateTimeInput, string timeZone)
{
    // Handle various datetime formats
    var formats = new[]
    {
        "yyyy-MM-dd HH:mm:ss",
        "MM/dd/yyyy HH:mm",
        "dd.MM.yyyy HH:mm",
        "yyyy-MM-ddTHH:mm:ss",
        "M/d/yyyy h:mm tt"
    };
    
    foreach (var format in formats)
    {
        if (DateTime.TryParseExact(dateTimeInput, format, CultureInfo.InvariantCulture, 
            DateTimeStyles.None, out DateTime result))
        {
            // Convert to UTC if timezone is provided
            if (!string.IsNullOrEmpty(timeZone))
            {
                var timeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(timeZone);
                return TimeZoneInfo.ConvertTimeToUtc(result, timeZoneInfo);
            }
            return result;
        }
    }
    
    throw new ArgumentException("Invalid datetime format");
}

private void ValidateReservationTime(DateTime dateTime)
{
    if (dateTime <= DateTime.UtcNow)
        throw new ArgumentException("Reservation time must be in the future");
        
    if (dateTime > DateTime.UtcNow.AddDays(90))
        throw new ArgumentException("Reservation cannot be more than 90 days in advance");
}

private bool HasConflictingReservation(Reservation newReservation)
{
    var endTime = newReservation.ReservationDateTime.AddMinutes(newReservation.Duration);
    
    return _context.Reservations.Any(r => 
        r.ResourceId == newReservation.ResourceId &&
        r.Status == "Confirmed" &&
        ((r.ReservationDateTime <= newReservation.ReservationDateTime && 
          r.ReservationDateTime.AddMinutes(r.Duration) > newReservation.ReservationDateTime) ||
         (newReservation.ReservationDateTime <= r.ReservationDateTime && 
          endTime > r.ReservationDateTime)));
}

private string FormatDateTime(DateTime dateTime, string timeZone)
{
    if (!string.IsNullOrEmpty(timeZone))
    {
        var timeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(timeZone);
        var localTime = TimeZoneInfo.ConvertTimeFromUtc(dateTime, timeZoneInfo);
        return localTime.ToString("dddd, MMMM dd, yyyy 'at' HH:mm");
    }
    
    return dateTime.ToString("dddd, MMMM dd, yyyy 'at' HH:mm UTC");
}
```

**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Claude
**SatÄ±r SayÄ±sÄ±:** 117
```python
from datetime import datetime, timedelta
import pytz
import re
from typing import Optional, Dict, Any

class ReservationSystem:
    def __init__(self):
        self.reservations = []
        
        # Supported datetime formats
        self.datetime_formats = [
            "%Y-%m-%d %H:%M:%S",
            "%m/%d/%Y %H:%M",
            "%d.%m.%Y %H:%M",
            "%Y-%m-%dT%H:%M:%S",
            "%m/%d/%Y %I:%M %p"
        ]
    
    def create_reservation(self, customer_id: str, resource_id: str, 
                         datetime_input: str, duration: int, 
                         timezone: str = "UTC") -> Dict[str, Any]:
        try:
            # Parse and standardize datetime
            reservation_datetime = self._parse_datetime(datetime_input, timezone)
            
            # Validate reservation time
            self._validate_reservation_time(reservation_datetime)
            
            # Calculate timestamp
            timestamp = int(reservation_datetime.timestamp())
            
            # Create reservation object
            reservation = {
                'id': len(self.reservations) + 1,
                'customer_id': customer_id,
                'resource_id': resource_id,
                'reservation_datetime': reservation_datetime.isoformat(),
                'timestamp': timestamp,
                'duration': duration,
                'status': 'Confirmed',
                'created_at': datetime.utcnow().isoformat(),
                'timezone': timezone
            }
            
            # Check for conflicts
            if self._has_conflicting_reservation(reservation):
                raise ValueError("Time slot already reserved")
            
            # Save reservation
            self.reservations.append(reservation)
            
            return {
                'reservation_id': reservation['id'],
                'datetime': reservation_datetime.strftime("%Y-%m-%d %H:%M:%S"),
                'timestamp': timestamp,
                'formatted_datetime': self._format_datetime(reservation_datetime, timezone),
                'duration': f"{duration} minutes"
            }
            
        except Exception as e:
            raise Exception(f"Reservation creation failed: {str(e)}")
    
    def _parse_datetime(self, datetime_input: str, timezone: str) -> datetime:
        # Try parsing with different formats
        for fmt in self.datetime_formats:
            try:
                dt = datetime.strptime(datetime_input, fmt)
                
                # Handle timezone conversion
                if timezone != "UTC":
                    tz = pytz.timezone(timezone)
                    dt = tz.localize(dt)
                    dt = dt.astimezone(pytz.UTC)
                else:
                    dt = pytz.UTC.localize(dt)
                
                return dt
                
            except ValueError:
                continue
        
        raise ValueError("Invalid datetime format")
    
    def _validate_reservation_time(self, dt: datetime):
        now = datetime.now(pytz.UTC)
        
        if dt <= now:
            raise ValueError("Reservation time must be in the future")
        
        if dt > now + timedelta(days=90):
            raise ValueError("Reservation cannot be more than 90 days in advance")
    
    def _has_conflicting_reservation(self, new_reservation: Dict) -> bool:
        new_start = datetime.fromisoformat(new_reservation['reservation_datetime'].replace('Z', '+00:00'))
        new_end = new_start + timedelta(minutes=new_reservation['duration'])
        
        for existing in self.reservations:
            if (existing['resource_id'] == new_reservation['resource_id'] and 
                existing['status'] == 'Confirmed'):
                
                existing_start = datetime.fromisoformat(existing['reservation_datetime'].replace('Z', '+00:00'))
                existing_end = existing_start + timedelta(minutes=existing['duration'])
                
                # Check for overlap
                if (existing_start <= new_start < existing_end or
                    new_start <= existing_start < new_end):
                    return True
        
        return False
    
    def _format_datetime(self, dt: datetime, timezone: str) -> str:
        if timezone != "UTC":
            tz = pytz.timezone(timezone)
            local_dt = dt.astimezone(tz)
            return local_dt.strftime("%A, %B %d, %Y at %H:%M")
        
        return dt.strftime("%A, %B %d, %Y at %H:%M UTC")
```