----
### ğŸ§ª Senaryo 1: Bir metin dÃ¼zenleyici uygulamasÄ±nda kullanÄ±cÄ±lar Ã§ok satÄ±rlÄ± metinleri dÃ¼zenleyebiliyor. Her satÄ±r uygulama iÃ§inde bellekte tutuluyor ve dizin bilgisiyle eriÅŸiliyor. KullanÄ±cÄ± metne ekleme yaptÄ±ÄŸÄ±nda sistem belirli bir tampon belleÄŸe veri yazÄ±yor. Bu belleÄŸin boyutu kullanÄ±cÄ± girdisine gÃ¶re ayarlanÄ±yor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("update-text")]
public IActionResult UpdateText([FromBody] TextUpdateModel model)
{{
    if (string.IsNullOrWhiteSpace(model.Text))
        return BadRequest("Text is empty");

    var buffer = new char[model.Text.Length * 2];
    model.Text.CopyTo(0, buffer, 0, model.Text.Length);

    _dbContext.TextEntries.Add(new TextEntry
    {{
        Content = model.Text,
        LineCount = model.Text.Split('\n').Length
    }});
    _dbContext.SaveChanges();

    return Ok("Text updated");
}}

public class TextUpdateModel
{{
    public string Text {{ get; set; }}
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

class TextUpdateModel(BaseModel):
    text: str

@app.post("/update-text")
def update_text(model: TextUpdateModel):
    if not model.text:
        raise HTTPException(status_code=400, detail="Empty text")
    buffer = model.text * 2  # simulate buffer
    return {"message": "Text updated"}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

app.post('/update-text', (req, res) => {
    const text = req.body.text;
    if (!text) return res.status(400).send("Text is empty");
    const buffer = text.repeat(2);
    res.send("Text updated");
});
```

----
### ğŸ§ª Senaryo 2: Bir ses iÅŸleme yazÄ±lÄ±mÄ± gelen mikrofon verilerini belirli aralÄ±klarda buffer'a alÄ±yor. KullanÄ±cÄ± farklÄ± Ã¶rnekleme oranlarÄ± seÃ§erek kaydÄ± baÅŸlatabiliyor. Bu veri buffer'a sabit aralÄ±kla ekleniyor. Uzun kayÄ±tlar iÃ§in sistem bellek boyutlarÄ±nÄ± yÃ¶netiyor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("start-recording")]
public IActionResult StartRecording([FromBody] RecordingSettings settings)
{{
    int bufferSize = settings.SampleRate * 2;
    byte[] buffer = new byte[bufferSize];

    var session = new RecordingSession
    {{
        SampleRate = settings.SampleRate,
        CreatedAt = DateTime.UtcNow
    }};
    _dbContext.RecordingSessions.Add(session);
    _dbContext.SaveChanges();

    return Ok("Recording started");
}}

public class RecordingSettings
{{
    public int SampleRate {{ get; set; }}
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class RecordingSettings(BaseModel):
    sample_rate: int

@app.post("/start-recording")
def start_recording(settings: RecordingSettings):
    buffer = bytearray(settings.sample_rate * 2)
    return {"message": "Recording started"}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

app.post('/start-recording', (req, res) => {
    const { sampleRate } = req.body;
    const buffer = Buffer.alloc(sampleRate * 2);
    res.send("Recording started");
});
```

----
### ğŸ§ª Senaryo 3: Bir gÃ¶rÃ¼ntÃ¼ dÃ¼zenleme programÄ±nda kullanÄ±cÄ± bir resmi kÄ±rptÄ±ÄŸÄ±nda sistem seÃ§ilen koordinatlara gÃ¶re iÅŸlem yapÄ±yor. KÄ±rpÄ±lacak alan bellekteki pikseller Ã¼zerinden hesaplanarak yeni buffer'a aktarÄ±lÄ±yor. Bu alanlarÄ±n sÄ±nÄ±rlarÄ± iÅŸlem sÄ±rasÄ±nda belirleniyor. Sistem seÃ§ilen alanÄ± iÅŸleyerek sonuÃ§ Ã¼retiyor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("crop-image")]
public IActionResult CropImage([FromBody] CropRequest req)
{{
    var width = req.X2 - req.X1;
    var height = req.Y2 - req.Y1;
    byte[] croppedImage = new byte[width * height * 3]; // assume RGB

    _dbContext.CropLogs.Add(new CropLog
    {{
        X1 = req.X1,
        X2 = req.X2,
        Y1 = req.Y1,
        Y2 = req.Y2,
        CreatedAt = DateTime.UtcNow
    }});
    _dbContext.SaveChanges();

    return Ok("Image cropped");
}}

public class CropRequest
{{
    public int X1 {{ get; set; }}
    public int Y1 {{ get; set; }}
    public int X2 {{ get; set; }}
    public int Y2 {{ get; set; }}
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class CropRequest(BaseModel):
    x1: int
    y1: int
    x2: int
    y2: int

@app.post("/crop-image")
def crop_image(req: CropRequest):
    width = req.x2 - req.x1
    height = req.y2 - req.y1
    cropped = [[0]*width for _ in range(height)]
    return {"message": "Image cropped"}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

app.post('/crop-image', (req, res) => {
    const { x1, y1, x2, y2 } = req.body;
    const width = x2 - x1;
    const height = y2 - y1;
    res.send(`Cropped area: ${width}x${height}`);
});
```

----
### ğŸ§ª Senaryo 4: Bir aÄŸ protokolÃ¼ uygulamasÄ±nda gelen veri paketleri byte dizisine aktarÄ±lÄ±yor. Paket uzunluÄŸu dÄ±ÅŸarÄ±dan geldiÄŸi iÃ§in sistem bu deÄŸeri referans alarak yazma iÅŸlemi gerÃ§ekleÅŸtiriyor. Paket boyutlarÄ± deÄŸiÅŸken olabildiÄŸinden tampon bellek bu duruma gÃ¶re ayarlanÄ±yor. Bellek sÄ±nÄ±rlarÄ± uygulamayla yÃ¶netiliyor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("receive-packet")]
public IActionResult ReceivePacket([FromBody] byte[] packet)
{{
    if (packet.Length > 4096)
        return BadRequest("Packet too large");

    byte[] buffer = new byte[packet.Length];
    Array.Copy(packet, buffer, packet.Length);

    _dbContext.PacketLogs.Add(new PacketLog
    {{
        Length = packet.Length,
        ReceivedAt = DateTime.UtcNow
    }});
    _dbContext.SaveChanges();

    return Ok("Packet received");
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.post("/receive-packet")
def receive_packet(packet: bytes):
    if len(packet) > 4096:
        raise HTTPException(status_code=400, detail="Too large")
    buffer = bytearray(packet)
    return {"message": "Packet received"}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

app.post('/receive-packet', (req, res) => {
    const packet = req.body.packet;
    if (packet.length > 4096) return res.status(400).send("Too large");
    const buffer = Buffer.from(packet);
    res.send("Packet received");
});
```

----
### ğŸ§ª Senaryo 5: Bir oyun motoru karakter animasyonlarÄ±nÄ± bellekteki belirli diziler Ã¼zerinden kontrol ediyor. Animasyonlar kare dizisi olarak tutuluyor ve karakterin hareketine gÃ¶re gÃ¼ncelleniyor. KullanÄ±cÄ± eylemleri bu dizinin aralÄ±ÄŸÄ±nÄ± deÄŸiÅŸtirebiliyor. Sistem hareket aralÄ±ÄŸÄ±nÄ± animasyon sÄ±rasÄ±nda ayarlÄ±yor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("update-animation")]
public IActionResult UpdateAnimation([FromBody] FrameData data)
{{
    var frameRange = data.CurrentFrame + data.Speed;
    int[] frames = Enumerable.Range(data.CurrentFrame, data.Speed).ToArray();

    _dbContext.Animations.Add(new AnimationLog
    {{
        CharacterId = data.CharacterId,
        FrameStart = data.CurrentFrame,
        FrameEnd = frameRange
    }});
    _dbContext.SaveChanges();

    return Ok("Animation updated");
}}

public class FrameData
{{
    public int CharacterId {{ get; set; }}
    public int CurrentFrame {{ get; set; }}
    public int Speed {{ get; set; }}
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class FrameData(BaseModel):
    current_frame: int
    speed: int

@app.post("/update-animation")
def update_animation(data: FrameData):
    frames = list(range(data.current_frame, data.current_frame + data.speed))
    return {"frames": frames}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

app.post('/update-animation', (req, res) => {
    const { currentFrame, speed } = req.body;
    const frames = Array.from({length: speed}, (_, i) => i + currentFrame);
    res.json({ frames });
});
```

----
### ğŸ§ª Senaryo 6: Bir veritabanÄ± motorunda dizinleme iÅŸlemleri sÄ±rasÄ±nda kayÄ±tlar bellekte bloklar halinde tutuluyor. Arama sÄ±rasÄ±nda kullanÄ±cÄ± girdisiyle bu bloklara eriÅŸim yapÄ±lÄ±yor. Sistem gelen deÄŸerin blok aralÄ±ÄŸÄ±nda olup olmadÄ±ÄŸÄ±nÄ± deÄŸerlendiriyor. Okuma ve yazma sÄ±rasÄ±nda blok sÄ±nÄ±rlarÄ± kontrol ediliyor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("search-index")]
public IActionResult SearchIndex([FromBody] IndexSearchRequest req)
{{
    int blockId = req.Key % 100;

    _dbContext.IndexSearches.Add(new IndexSearch
    {{
        Key = req.Key,
        BlockId = blockId
    }});
    _dbContext.SaveChanges();

    return Ok($"Searched block {blockId}");
}}

public class IndexSearchRequest
{{
    public int Key {{ get; set; }}
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class IndexSearchRequest(BaseModel):
    key: int

@app.post("/search-index")
def search_index(req: IndexSearchRequest):
    block_id = req.key % 100
    return {"block_id": block_id}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

app.post('/search-index', (req, res) => {
    const { key } = req.body;
    const blockId = key % 100;
    res.json({ blockId });
});
```

----
### ğŸ§ª Senaryo 7: Bir terminal uygulamasÄ±nda komut geÃ§miÅŸi sÄ±nÄ±rlÄ± sayÄ±da kayÄ±tla tutuluyor. KullanÄ±cÄ± daha fazla komut girdiÄŸinde eski kayÄ±tlar bellekte kaydÄ±rÄ±larak yenileri ekleniyor. Komutlar farklÄ± uzunlukta olabildiÄŸi iÃ§in buffer boyutu dinamik ayarlanÄ±yor. Sistem gelen komutun uzunluÄŸuna gÃ¶re alan oluÅŸturuyor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("add-command")]
public IActionResult AddCommand([FromBody] CommandInput input)
{{
    string[] history = _cacheService.GetHistory();
    if (history.Length >= 100)
        history = history.Skip(1).ToArray();

    history = history.Append(input.Command).ToArray();
    _cacheService.SaveHistory(history);

    return Ok("Command added to history");
}}

public class CommandInput
{{
    public string Command {{ get; set; }}
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

history = []

class CommandInput(BaseModel):
    command: str

@app.post("/add-command")
def add_command(input: CommandInput):
    global history
    history.append(input.command)
    if len(history) > 100:
        history.pop(0)
    return {"history_size": len(history)}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

let history: string[] = [];

app.post('/add-command', (req, res) => {
    const { command } = req.body;
    history.push(command);
    if (history.length > 100) history.shift();
    res.json({ size: history.length });
});
```

----
### ğŸ§ª Senaryo 8: Bir gÃ¶rÃ¼ntÃ¼ iÅŸleme kÃ¼tÃ¼phanesi gelen kamera verilerini kare kare analiz ediyor. Her kare belleÄŸe tampon aracÄ±lÄ±ÄŸÄ±yla alÄ±nÄ±yor. Kamera Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ deÄŸiÅŸtiÄŸinde buffer boyutu bu duruma gÃ¶re ayarlanÄ±yor. Bu sayede bellek sÄ±nÄ±rlarÄ± iÃ§inde iÅŸlem yapÄ±lÄ±yor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("analyze-frame")]
public IActionResult AnalyzeFrame([FromBody] FrameModel frame)
{{
    var bufferSize = frame.Width * frame.Height * 3;
    byte[] buffer = new byte[bufferSize];

    _dbContext.FrameLogs.Add(new FrameLog
    {{
        Resolution = $"{frame.Width}x{frame.Height}",
        Timestamp = DateTime.UtcNow
    }});
    _dbContext.SaveChanges();

    return Ok("Frame processed");
}}

public class FrameModel
{{
    public int Width {{ get; set; }}
    public int Height {{ get; set; }}
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class FrameModel(BaseModel):
    width: int
    height: int

@app.post("/analyze-frame")
def analyze_frame(frame: FrameModel):
    buffer = bytearray(frame.width * frame.height * 3)
    return {"message": "Frame processed"}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

app.post('/analyze-frame', (req, res) => {
    const { width, height } = req.body;
    const bufferSize = width * height * 3;
    res.send(`Processed buffer size: ${bufferSize}`);
});
```

----
### ğŸ§ª Senaryo 9: Bir hesaplama aracÄ± kullanÄ±cÄ±dan alÄ±nan sayÄ± dizisini bir diziye aktarÄ±yor ve iÅŸlem yapÄ±yor. KullanÄ±cÄ±nÄ±n girdiÄŸi eleman sayÄ±sÄ± sistemdeki diziden farklÄ± olabiliyor. Sistem bu sayÄ±yÄ± deÄŸerlendirerek dizi boyutunu ayarlÄ±yor. Bu ÅŸekilde bellekte uygun bÃ¶lgelere eriÅŸim saÄŸlanÄ±yor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("process-numbers")]
public IActionResult ProcessNumbers([FromBody] int[] numbers)
{{
    int[] dataArray = new int[numbers.Length];
    Array.Copy(numbers, dataArray, numbers.Length);

    _dbContext.NumberLogs.Add(new NumberLog
    {{
        Count = numbers.Length,
        CreatedAt = DateTime.UtcNow
    }});
    _dbContext.SaveChanges();

    return Ok("Numbers processed");
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI

app = FastAPI()

@app.post("/process-numbers")
def process_numbers(numbers: list[int]):
    return {"sum": sum(numbers)}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

app.post('/process-numbers', (req, res) => {
    const numbers: number[] = req.body;
    const sum = numbers.reduce((a, b) => a + b, 0);
    res.json({ sum });
});
```

----
### ğŸ§ª Senaryo 10: Bir video oynatÄ±cÄ± yazÄ±lÄ±mÄ± oynatma sÄ±rasÄ±nda ses ve video karelerini farklÄ± tamponlara alÄ±yor. Video Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ bÃ¼yÃ¼dÃ¼kÃ§e tampon alan gereksinimleri artÄ±yor. Sistem Ã§Ã¶zÃ¼nÃ¼rlÃ¼k deÄŸiÅŸimini belleÄŸe yansÄ±tÄ±yor. Bu durum tampon boyutu sorunlarÄ±nÄ± Ã¶nleyecek ÅŸekilde yÃ¶netiliyor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** ChatGPT

```csharp
[HttpPost("configure-playback")]
public IActionResult ConfigurePlayback([FromBody] PlaybackConfig config)
{{
    int videoBufferSize = config.VideoResolution * 2;
    int audioBufferSize = 4096;

    _dbContext.PlaybackSettings.Add(new PlaybackSetting
    {{
        VideoResolution = config.VideoResolution,
        CreatedAt = DateTime.UtcNow
    }});
    _dbContext.SaveChanges();

    return Ok("Playback configured");
}}

public class PlaybackConfig
{{
    public int VideoResolution {{ get; set; }}
}}
```

**ğŸ’» Dil:** `Python`  
**ğŸ¤– AI:** ChatGPT

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class PlaybackConfig(BaseModel):
    resolution: int

@app.post("/configure-playback")
def configure_playback(config: PlaybackConfig):
    buffer = bytearray(config.resolution * 2)
    return {"message": "Playback configured"}
```

**ğŸ’» Dil:** `TypeScript`  
**ğŸ¤– AI:** ChatGPT

```ts
import express from 'express';

const app = express();
app.use(express.json());

app.post('/configure-playback', (req, res) => {
    const { resolution } = req.body;
    const buffer = Buffer.alloc(resolution * 2);
    res.send("Playback configured");
});
```
