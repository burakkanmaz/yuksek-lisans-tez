 
----

### ðŸ§ª Senaryo 1: KullanÄ±cÄ± Profili GÃ¼ncelleme
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

```csharp
using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;

[ApiController]
[Route("api/[controller]")]
public class UserController : ControllerBase
{
    private readonly IUserRepository _userRepository;

    public UserController(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }

    [HttpPost("update-profile")]
    public async Task<IActionResult> UpdateProfile([FromBody] UserProfileUpdateDto userProfileUpdate)
    {
        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        var user = await _userRepository.GetUserByIdAsync(userProfileUpdate.UserId);
        if (user == null)
        {
            return NotFound("User not found.");
        }

        user.DisplayName = userProfileUpdate.DisplayName;
        user.Bio = userProfileUpdate.Bio;
        user.ProfilePictureUrl = userProfileUpdate.ProfilePictureUrl;

        await _userRepository.UpdateUserAsync(user);

        return Ok("Profile updated successfully.");
    }
}

public class UserProfileUpdateDto
{
    public int UserId { get; set; }
    public string DisplayName { get; set; }
    public string Bio { get; set; }
    public string ProfilePictureUrl { get; set; }
}

public interface IUserRepository
{
    Task<User> GetUserByIdAsync(int userId);
    Task UpdateUserAsync(User user);
}

public class User
{
    public int Id { get; set; }
    public string DisplayName { get; set; }
    public string Bio { get; set; }
    public string ProfilePictureUrl { get; set; }
}
ðŸ§ª Senaryo 1: KullanÄ±cÄ± Profili GÃ¼ncelleme
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
db = SQLAlchemy(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    display_name = db.Column(db.String(80), nullable=True)
    bio = db.Column(db.String(200), nullable=True)
    profile_picture_url = db.Column(db.String(200), nullable=True)

    def __repr__(self):
        return f'<User {self.display_name}>'

@app.route('/api/user/update-profile', methods=['POST'])
def update_profile():
    data = request.get_json()
    user_id = data.get('userId')
    display_name = data.get('displayName')
    bio = data.get('bio')
    profile_picture_url = data.get('profilePictureUrl')

    if not user_id:
        return jsonify({"message": "User ID is required"}), 400

    user = User.query.get(user_id)
    if not user:
        return jsonify({"message": "User not found"}), 404

    user.display_name = display_name
    user.bio = bio
    user.profile_picture_url = profile_picture_url

    db.session.commit()

    return jsonify({"message": "Profile updated successfully"}), 200

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 1: KullanÄ±cÄ± Profili GÃ¼ncelleme
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import { PrismaClient } from '@prisma/client';

const app = express();
const prisma = new PrismaClient();
app.use(express.json());

interface UserProfileUpdateDto {
    userId: number;
    displayName?: string;
    bio?: string;
    profilePictureUrl?: string;
}

app.post('/api/user/update-profile', async (req, res) => {
    const { userId, displayName, bio, profilePictureUrl }: UserProfileUpdateDto = req.body;

    if (!userId) {
        return res.status(400).json({ message: 'User ID is required' });
    }

    try {
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: {
                displayName: displayName,
                bio: bio,
                profilePictureUrl: profilePictureUrl,
            },
        });
        res.status(200).json({ message: 'Profile updated successfully', user: updatedUser });
    } catch (error: any) {
        if (error.code === 'P2025') { // Prisma's "record not found" error code
            return res.status(404).json({ message: 'User not found' });
        }
        console.error('Error updating profile:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// To set up Prisma and the database, you would typically run:
// npx prisma init
// npx prisma migrate dev --name init

// Example Prisma schema (schema.prisma):
/*
model User {
  id                Int       @id @default(autoincrement())
  displayName       String?
  bio               String?
  profilePictureUrl String?
}
*/
```
ðŸ§ª Senaryo 2: KullanÄ±cÄ±larÄ±n Ã‡alÄ±ÅŸmalarÄ±nÄ± YÃ¼klemesi
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

```csharp

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;
using System;

[ApiController]
[Route("api/[controller]")]
public class PortfolioController : ControllerBase
{
    private readonly IFileStorageService _fileStorageService;
    private readonly IPortfolioRepository _portfolioRepository;

    public PortfolioController(IFileStorageService fileStorageService, IPortfolioRepository portfolioRepository)
    {
        _fileStorageService = fileStorageService;
        _portfolioRepository = portfolioRepository;
    }

    [HttpPost("upload-work/{userId}")]
    public async Task<IActionResult> UploadWork(int userId, IFormFile file)
    {
        if (file == null || file.Length == 0)
        {
            return BadRequest("No file uploaded.");
        }

        // Validate file type (simplified for example)
        var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif", ".mp4", ".mov", ".pdf", ".doc", ".docx" };
        var fileExtension = Path.GetExtension(file.FileName).ToLowerInvariant();
        if (!Array.Exists(allowedExtensions, ext => ext == fileExtension))
        {
            return BadRequest("Unsupported file type.");
        }

        try
        {
            var fileName = $"{Guid.NewGuid()}{fileExtension}";
            var filePath = await _fileStorageService.SaveFileAsync(file, "portfolio", fileName);

            var portfolioItem = new PortfolioItem
            {
                UserId = userId,
                FileName = fileName,
                FilePath = filePath,
                FileType = file.ContentType,
                UploadDate = DateTime.UtcNow
            };

            await _portfolioRepository.AddPortfolioItemAsync(portfolioItem);

            return Ok(new { Message = "Work uploaded successfully", FilePath = filePath });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}

public interface IFileStorageService
{
    Task<string> SaveFileAsync(IFormFile file, string category, string fileName);
}

public class LocalFileStorageService : IFileStorageService
{
    private readonly string _uploadDirectory = Path.Combine(Directory.GetCurrentDirectory(), "Uploads");

    public LocalFileStorageService()
    {
        if (!Directory.Exists(_uploadDirectory))
        {
            Directory.CreateDirectory(_uploadDirectory);
        }
    }

    public async Task<string> SaveFileAsync(IFormFile file, string category, string fileName)
    {
        var categoryPath = Path.Combine(_uploadDirectory, category);
        if (!Directory.Exists(categoryPath))
        {
            Directory.CreateDirectory(categoryPath);
        }

        var filePath = Path.Combine(categoryPath, fileName);
        using (var stream = new FileStream(filePath, FileMode.Create))
        {
            await file.CopyToAsync(stream);
        }
        return $"/{category}/{fileName}"; // Return a URL path
    }
}

public interface IPortfolioRepository
{
    Task AddPortfolioItemAsync(PortfolioItem item);
}

public class PortfolioItem
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public string FileName { get; set; }
    public string FilePath { get; set; }
    public string FileType { get; set; }
    public DateTime UploadDate { get; set; }
}
```
ðŸ§ª Senaryo 2: KullanÄ±cÄ±larÄ±n Ã‡alÄ±ÅŸmalarÄ±nÄ± YÃ¼klemesi
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import uuid
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads/portfolio'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB limit
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///portfolio.db'
db = SQLAlchemy(app)

ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'mp4', 'mov', 'pdf', 'doc', 'docx'}

class PortfolioItem(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    file_name = db.Column(db.String(255), nullable=False)
    file_path = db.Column(db.String(255), nullable=False)
    file_type = db.Column(db.String(100), nullable=False)
    upload_date = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<PortfolioItem {self.file_name}>'

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/api/portfolio/upload-work/<int:user_id>', methods=['POST'])
def upload_work(user_id):
    if 'file' not in request.files:
        return jsonify({"message": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"message": "No selected file"}), 400
    if file and allowed_file(file.filename):
        try:
            if not os.path.exists(app.config['UPLOAD_FOLDER']):
                os.makedirs(app.config['UPLOAD_FOLDER'])

            original_filename, file_extension = os.path.splitext(file.filename)
            unique_filename = str(uuid.uuid4()) + file_extension
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(unique_filename))
            file.save(filepath)

            new_portfolio_item = PortfolioItem(
                user_id=user_id,
                file_name=unique_filename,
                file_path=f"/{app.config['UPLOAD_FOLDER']}/{unique_filename}",
                file_type=file.content_type
            )
            db.session.add(new_portfolio_item)
            db.session.commit()

            return jsonify({"message": "Work uploaded successfully", "filePath": new_portfolio_item.file_path}), 200
        except Exception as e:
            return jsonify({"message": f"Server error: {str(e)}"}), 500
    else:
        return jsonify({"message": "File type not allowed"}), 400

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 2: KullanÄ±cÄ±larÄ±n Ã‡alÄ±ÅŸmalarÄ±nÄ± YÃ¼klemesi
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

const app = express();
const prisma = new PrismaClient();

const uploadDir = path.join(__dirname, '../uploads/portfolio');
if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
}

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
        const fileExtension = path.extname(file.originalname);
        const uniqueFilename = `${uuidv4()}${fileExtension}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req: express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = /jpeg|jpg|png|gif|mp4|mov|pdf|doc|docx/;
    const mimetype = allowedTypes.test(file.mimetype);
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());

    if (mimetype && extname) {
        return cb(null, true);
    }
    cb(new Error('Unsupported file type!'));
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 10 }, // 10MB limit
    fileFilter: fileFilter
}).single('file');

app.post('/api/portfolio/upload-work/:userId', (req, res) => {
    upload(req, res, async (err) => {
        if (err instanceof multer.MulterError) {
            return res.status(400).json({ message: err.message });
        } else if (err) {
            return res.status(400).json({ message: err.message });
        }

        if (!req.file) {
            return res.status(400).json({ message: 'No file uploaded.' });
        }

        const userId = parseInt(req.params.userId);
        if (isNaN(userId)) {
            return res.status(400).json({ message: 'Invalid User ID.' });
        }

        try {
            const portfolioItem = await prisma.portfolioItem.create({
                data: {
                    userId: userId,
                    fileName: req.file.filename,
                    filePath: `/uploads/portfolio/${req.file.filename}`,
                    fileType: req.file.mimetype,
                    uploadDate: new Date(),
                },
            });
            res.status(200).json({ message: 'Work uploaded successfully', filePath: portfolioItem.filePath });
        } catch (error) {
            console.error('Error saving portfolio item to database:', error);
            res.status(500).json({ message: 'Internal server error.' });
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Example Prisma schema (schema.prisma):
/*
model PortfolioItem {
  id        Int      @id @default(autoincrement())
  userId    Int
  fileName  String
  filePath  String
  fileType  String
  uploadDate DateTime @default(now())
}
*/
```
ðŸ§ª Senaryo 3: SanatÃ§Ä±larÄ±n Eserlerini YÃ¼klemesi
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

```csharp

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;
using System;

[ApiController]
[Route("api/[controller]")]
public class MusicController : ControllerBase
{
    private readonly IFileStorageService _fileStorageService;
    private readonly IMusicRepository _musicRepository;

    public MusicController(IFileStorageService fileStorageService, IMusicRepository musicRepository)
    {
        _fileStorageService = fileStorageService;
        _musicRepository = musicRepository;
    }

    [HttpPost("upload-track/{artistId}")]
    public async Task<IActionResult> UploadTrack(int artistId, IFormFile audioFile, IFormFile albumCover)
    {
        if (audioFile == null || audioFile.Length == 0)
        {
            return BadRequest("Audio file is required.");
        }

        var allowedAudioExtensions = new[] { ".mp3", ".wav", ".aac", ".flac" };
        var audioExtension = Path.GetExtension(audioFile.FileName).ToLowerInvariant();
        if (!Array.Exists(allowedAudioExtensions, ext => ext == audioExtension))
        {
            return BadRequest("Unsupported audio file type.");
        }

        string audioFilePath = null;
        string coverImagePath = null;

        try
        {
            var audioFileName = $"{Guid.NewGuid()}{audioExtension}";
            audioFilePath = await _fileStorageService.SaveFileAsync(audioFile, "music/audio", audioFileName);

            if (albumCover != null && albumCover.Length > 0)
            {
                var allowedImageExtensions = new[] { ".jpg", ".jpeg", ".png" };
                var imageExtension = Path.GetExtension(albumCover.FileName).ToLowerInvariant();
                if (!Array.Exists(allowedImageExtensions, ext => ext == imageExtension))
                {
                    // Allow upload of audio, but inform about unsupported cover
                    Console.WriteLine("Unsupported album cover file type, proceeding without cover.");
                }
                else
                {
                    var coverImageName = $"{Guid.NewGuid()}{imageExtension}";
                    coverImagePath = await _fileStorageService.SaveFileAsync(albumCover, "music/covers", coverImageName);
                }
            }

            var track = new MusicTrack
            {
                ArtistId = artistId,
                Title = Path.GetFileNameWithoutExtension(audioFile.FileName),
                AudioFilePath = audioFilePath,
                CoverImagePath = coverImagePath,
                UploadDate = DateTime.UtcNow
            };

            await _musicRepository.AddMusicTrackAsync(track);

            return Ok(new { Message = "Track uploaded successfully", AudioPath = audioFilePath, CoverPath = coverImagePath });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}

// IFileStorageService is assumed to be defined as in Scenario 2
// (omitted for brevity as per instructions not to repeat code)

public interface IMusicRepository
{
    Task AddMusicTrackAsync(MusicTrack track);
}

public class MusicTrack
{
    public int Id { get; set; }
    public int ArtistId { get; set; }
    public string Title { get; set; }
    public string AudioFilePath { get; set; }
    public string CoverImagePath { get; set; }
    public DateTime UploadDate { get; set; }
}
```
ðŸ§ª Senaryo 3: SanatÃ§Ä±larÄ±n Eserlerini YÃ¼klemesi
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import uuid
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['UPLOAD_FOLDER_AUDIO'] = 'uploads/music/audio'
app.config['UPLOAD_FOLDER_COVERS'] = 'uploads/music/covers'
app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50 MB limit
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///music.db'
db = SQLAlchemy(app)

ALLOWED_AUDIO_EXTENSIONS = {'mp3', 'wav', 'aac', 'flac'}
ALLOWED_IMAGE_EXTENSIONS = {'png', 'jpg', 'jpeg'}

class MusicTrack(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    artist_id = db.Column(db.Integer, nullable=False)
    title = db.Column(db.String(255), nullable=False)
    audio_file_path = db.Column(db.String(255), nullable=False)
    cover_image_path = db.Column(db.String(255), nullable=True)
    upload_date = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<MusicTrack {self.title}>'

def allowed_file(filename, allowed_extensions):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in allowed_extensions

@app.route('/api/music/upload-track/<int:artist_id>', methods=['POST'])
def upload_track(artist_id):
    if 'audioFile' not in request.files:
        return jsonify({"message": "No audio file part"}), 400
    audio_file = request.files['audioFile']
    album_cover = request.files.get('albumCover')

    if audio_file.filename == '':
        return jsonify({"message": "No selected audio file"}), 400

    if not allowed_file(audio_file.filename, ALLOWED_AUDIO_EXTENSIONS):
        return jsonify({"message": "Unsupported audio file type"}), 400

    audio_filepath = None
    cover_image_filepath = None

    try:
        # Save audio file
        if not os.path.exists(app.config['UPLOAD_FOLDER_AUDIO']):
            os.makedirs(app.config['UPLOAD_FOLDER_AUDIO'])
        original_audio_filename, audio_extension = os.path.splitext(audio_file.filename)
        unique_audio_filename = str(uuid.uuid4()) + audio_extension
        audio_filepath = os.path.join(app.config['UPLOAD_FOLDER_AUDIO'], secure_filename(unique_audio_filename))
        audio_file.save(audio_filepath)

        # Save album cover if provided and allowed
        if album_cover and album_cover.filename != '':
            if allowed_file(album_cover.filename, ALLOWED_IMAGE_EXTENSIONS):
                if not os.path.exists(app.config['UPLOAD_FOLDER_COVERS']):
                    os.makedirs(app.config['UPLOAD_FOLDER_COVERS'])
                original_cover_filename, cover_extension = os.path.splitext(album_cover.filename)
                unique_cover_filename = str(uuid.uuid4()) + cover_extension
                cover_image_filepath = os.path.join(app.config['UPLOAD_FOLDER_COVERS'], secure_filename(unique_cover_filename))
                album_cover.save(cover_image_filepath)
            else:
                print("Unsupported album cover file type, proceeding without cover.")

        new_track = MusicTrack(
            artist_id=artist_id,
            title=original_audio_filename,
            audio_file_path=f"/{app.config['UPLOAD_FOLDER_AUDIO']}/{unique_audio_filename}",
            cover_image_path=f"/{app.config['UPLOAD_FOLDER_COVERS']}/{unique_cover_filename}" if cover_image_filepath else None
        )
        db.session.add(new_track)
        db.session.commit()

        return jsonify({
            "message": "Track uploaded successfully",
            "audioPath": new_track.audio_file_path,
            "coverPath": new_track.cover_image_path
        }), 200
    except Exception as e:
        return jsonify({"message": f"Server error: {str(e)}"}), 500

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 3: SanatÃ§Ä±larÄ±n Eserlerini YÃ¼klemesi
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

const app = express();
const prisma = new PrismaClient();

const audioUploadDir = path.join(__dirname, '../uploads/music/audio');
const coverUploadDir = path.join(__dirname, '../uploads/music/covers');

if (!fs.existsSync(audioUploadDir)) {
    fs.mkdirSync(audioUploadDir, { recursive: true });
}
if (!fs.existsSync(coverUploadDir)) {
    fs.mkdirSync(coverUploadDir, { recursive: true });
}

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        if (file.fieldname === 'audioFile') {
            cb(null, audioUploadDir);
        } else if (file.fieldname === 'albumCover') {
            cb(null, coverUploadDir);
        } else {
            cb(new Error('Invalid fieldname'), '');
        }
    },
    filename: (req, file, cb) => {
        const fileExtension = path.extname(file.originalname);
        const uniqueFilename = `${uuidv4()}${fileExtension}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req: express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    if (file.fieldname === 'audioFile') {
        const allowedAudioTypes = /mp3|wav|aac|flac/;
        const mimetype = allowedAudioTypes.test(file.mimetype);
        const extname = allowedAudioTypes.test(path.extname(file.originalname).toLowerCase());
        if (mimetype && extname) {
            return cb(null, true);
        }
        cb(new Error('Unsupported audio file type!'));
    } else if (file.fieldname === 'albumCover') {
        const allowedImageTypes = /jpeg|jpg|png/;
        const mimetype = allowedImageTypes.test(file.mimetype);
        const extname = allowedImageTypes.test(path.extname(file.originalname).toLowerCase());
        if (mimetype && extname) {
            return cb(null, true);
        }
        // Allow audio upload even if cover is unsupported
        console.warn('Unsupported album cover file type, proceeding without cover.');
        cb(null, false); // Reject the cover file, but don't stop the overall request
    } else {
        cb(new Error('Invalid fieldname'));
    }
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 50 }, // 50MB limit
    fileFilter: fileFilter
}).fields([{ name: 'audioFile', maxCount: 1 }, { name: 'albumCover', maxCount: 1 }]);

app.post('/api/music/upload-track/:artistId', (req, res) => {
    upload(req, res, async (err) => {
        if (err instanceof multer.MulterError) {
            return res.status(400).json({ message: err.message });
        } else if (err) {
            return res.status(400).json({ message: err.message });
        }

        const files = req.files as { [fieldname: string]: Express.Multer.File[] };
        const audioFile = files?.audioFile ? files.audioFile[0] : undefined;
        const albumCover = files?.albumCover ? files.albumCover[0] : undefined;

        if (!audioFile) {
            return res.status(400).json({ message: 'No audio file uploaded.' });
        }

        const artistId = parseInt(req.params.artistId);
        if (isNaN(artistId)) {
            return res.status(400).json({ message: 'Invalid Artist ID.' });
        }

        try {
            const track = await prisma.musicTrack.create({
                data: {
                    artistId: artistId,
                    title: path.parse(audioFile.originalname).name,
                    audioFilePath: `/uploads/music/audio/${audioFile.filename}`,
                    coverImagePath: albumCover ? `/uploads/music/covers/${albumCover.filename}` : null,
                    uploadDate: new Date(),
                },
            });
            res.status(200).json({
                message: 'Track uploaded successfully',
                audioPath: track.audioFilePath,
                coverPath: track.coverImagePath
            });
        } catch (error) {
            console.error('Error saving music track to database:', error);
            res.status(500).json({ message: 'Internal server error.' });
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Example Prisma schema (schema.prisma):
/*
model MusicTrack {
  id              Int       @id @default(autoincrement())
  artistId        Int
  title           String
  audioFilePath   String
  coverImagePath  String?
  uploadDate      DateTime  @default(now())
}
*/
```
ðŸ§ª Senaryo 4: EÄŸitmenlerin Ders Materyallerini YÃ¼klemesi
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

```csharp

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;
using System;

[ApiController]
[Route("api/[controller]")]
public class ELearningController : ControllerBase
{
    private readonly IFileStorageService _fileStorageService;
    private readonly ICourseMaterialRepository _courseMaterialRepository;

    public ELearningController(IFileStorageService fileStorageService, ICourseMaterialRepository courseMaterialRepository)
    {
        _fileStorageService = fileStorageService;
        _courseMaterialRepository = courseMaterialRepository;
    }

    [HttpPost("upload-material/{courseId}/{instructorId}")]
    public async Task<IActionResult> UploadCourseMaterial(int courseId, int instructorId, IFormFile file)
    {
        if (file == null || file.Length == 0)
        {
            return BadRequest("No file uploaded.");
        }

        var allowedExtensions = new[] { ".pdf", ".pptx", ".ppt", ".doc", ".docx", ".mp4", ".avi", ".mov" };
        var fileExtension = Path.GetExtension(file.FileName).ToLowerInvariant();
        if (!Array.Exists(allowedExtensions, ext => ext == fileExtension))
        {
            return BadRequest("Unsupported file type for course material.");
        }

        try
        {
            var fileName = $"{Guid.NewGuid()}{fileExtension}";
            var filePath = await _fileStorageService.SaveFileAsync(file, $"course-materials/{courseId}", fileName);

            var material = new CourseMaterial
            {
                CourseId = courseId,
                InstructorId = instructorId,
                FileName = fileName,
                FilePath = filePath,
                FileType = file.ContentType,
                UploadDate = DateTime.UtcNow
            };

            await _courseMaterialRepository.AddCourseMaterialAsync(material);

            return Ok(new { Message = "Course material uploaded successfully", FilePath = filePath });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}

// IFileStorageService is assumed to be defined as in Scenario 2
// (omitted for brevity as per instructions not to repeat code)

public interface ICourseMaterialRepository
{
    Task AddCourseMaterialAsync(CourseMaterial material);
}

public class CourseMaterial
{
    public int Id { get; set; }
    public int CourseId { get; set; }
    public int InstructorId { get; set; }
    public string FileName { get; set; }
    public string FilePath { get; set; }
    public string FileType { get; set; }
    public DateTime UploadDate { get; set; }
}
```
ðŸ§ª Senaryo 4: EÄŸitmenlerin Ders Materyallerini YÃ¼klemesi
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import uuid
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['UPLOAD_FOLDER_MATERIALS'] = 'uploads/course-materials'
app.config['MAX_CONTENT_LENGTH'] = 100 * 1024 * 1024  # 100 MB limit
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///elearning.db'
db = SQLAlchemy(app)

ALLOWED_MATERIAL_EXTENSIONS = {'pdf', 'pptx', 'ppt', 'doc', 'docx', 'mp4', 'avi', 'mov'}

class CourseMaterial(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    course_id = db.Column(db.Integer, nullable=False)
    instructor_id = db.Column(db.Integer, nullable=False)
    file_name = db.Column(db.String(255), nullable=False)
    file_path = db.Column(db.String(255), nullable=False)
    file_type = db.Column(db.String(100), nullable=False)
    upload_date = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<CourseMaterial {self.file_name}>'

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_MATERIAL_EXTENSIONS

@app.route('/api/elearning/upload-material/<int:course_id>/<int:instructor_id>', methods=['POST'])
def upload_material(course_id, instructor_id):
    if 'file' not in request.files:
        return jsonify({"message": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"message": "No selected file"}), 400
    
    if file and allowed_file(file.filename):
        try:
            course_upload_folder = os.path.join(app.config['UPLOAD_FOLDER_MATERIALS'], str(course_id))
            if not os.path.exists(course_upload_folder):
                os.makedirs(course_upload_folder)

            original_filename, file_extension = os.path.splitext(file.filename)
            unique_filename = str(uuid.uuid4()) + file_extension
            filepath = os.path.join(course_upload_folder, secure_filename(unique_filename))
            file.save(filepath)

            new_material = CourseMaterial(
                course_id=course_id,
                instructor_id=instructor_id,
                file_name=unique_filename,
                file_path=f"/{app.config['UPLOAD_FOLDER_MATERIALS']}/{course_id}/{unique_filename}",
                file_type=file.content_type
            )
            db.session.add(new_material)
            db.session.commit()

            return jsonify({"message": "Course material uploaded successfully", "filePath": new_material.file_path}), 200
        except Exception as e:
            return jsonify({"message": f"Server error: {str(e)}"}), 500
    else:
        return jsonify({"message": "File type not allowed for course materials"}), 400

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 4: EÄŸitmenlerin Ders Materyallerini YÃ¼klemesi
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

const app = express();
const prisma = new PrismaClient();

const uploadBaseDir = path.join(__dirname, '../uploads/course-materials');

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const courseId = req.params.courseId;
        const courseUploadDir = path.join(uploadBaseDir, courseId);
        if (!fs.existsSync(courseUploadDir)) {
            fs.mkdirSync(courseUploadDir, { recursive: true });
        }
        cb(null, courseUploadDir);
    },
    filename: (req, file, cb) => {
        const fileExtension = path.extname(file.originalname);
        const uniqueFilename = `${uuidv4()}${fileExtension}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req: express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = /pdf|pptx|ppt|doc|docx|mp4|avi|mov/;
    const mimetype = allowedTypes.test(file.mimetype);
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());

    if (mimetype && extname) {
        return cb(null, true);
    }
    cb(new Error('Unsupported file type for course material!'));
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 100 }, // 100MB limit
    fileFilter: fileFilter
}).single('file');

app.post('/api/elearning/upload-material/:courseId/:instructorId', (req, res) => {
    upload(req, res, async (err) => {
        if (err instanceof multer.MulterError) {
            return res.status(400).json({ message: err.message });
        } else if (err) {
            return res.status(400).json({ message: err.message });
        }

        if (!req.file) {
            return res.status(400).json({ message: 'No file uploaded.' });
        }

        const courseId = parseInt(req.params.courseId);
        const instructorId = parseInt(req.params.instructorId);

        if (isNaN(courseId) || isNaN(instructorId)) {
            return res.status(400).json({ message: 'Invalid Course ID or Instructor ID.' });
        }

        try {
            const material = await prisma.courseMaterial.create({
                data: {
                    courseId: courseId,
                    instructorId: instructorId,
                    fileName: req.file.filename,
                    filePath: `/uploads/course-materials/${courseId}/${req.file.filename}`,
                    fileType: req.file.mimetype,
                    uploadDate: new Date(),
                },
            });
            res.status(200).json({ message: 'Course material uploaded successfully', filePath: material.filePath });
        } catch (error) {
            console.error('Error saving course material to database:', error);
            res.status(500).json({ message: 'Internal server error.' });
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Example Prisma schema (schema.prisma):
/*
model CourseMaterial {
  id           Int      @id @default(autoincrement())
  courseId     Int
  instructorId Int
  fileName     String
  filePath     String
  fileType     String
  uploadDate   DateTime @default(now())
}
*/
```
ðŸ§ª Senaryo 5: Ekip Ãœyelerinin Dosya PaylaÅŸÄ±mÄ± YapmasÄ±
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

```csharp

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;
using System;

[ApiController]
[Route("api/[controller]")]
public class ProjectController : ControllerBase
{
    private readonly IFileStorageService _fileStorageService;
    private readonly IProjectFileRepository _projectFileRepository;

    public ProjectController(IFileStorageService fileStorageService, IProjectFileRepository projectFileRepository)
    {
        _fileStorageService = fileStorageService;
        _projectFileRepository = projectFileRepository;
    }

    [HttpPost("share-file/{projectId}/{teamMemberId}")]
    public async Task<IActionResult> ShareProjectFile(int projectId, int teamMemberId, IFormFile file)
    {
        if (file == null || file.Length == 0)
        {
            return BadRequest("No file uploaded.");
        }

        var allowedExtensions = new[] { ".zip", ".rar", ".7z", ".sketch", ".psd", ".ai", ".xd", ".code", ".js", ".ts", ".py", ".cs", ".java", ".md", ".pdf", ".xlsx", ".docx" };
        var fileExtension = Path.GetExtension(file.FileName).ToLowerInvariant();
        if (!Array.Exists(allowedExtensions, ext => ext == fileExtension))
        {
            return BadRequest("Unsupported file type for project sharing.");
        }

        try
        {
            var fileName = $"{Guid.NewGuid()}{fileExtension}";
            var filePath = await _fileStorageService.SaveFileAsync(file, $"project-files/{projectId}", fileName);

            var projectFile = new ProjectFile
            {
                ProjectId = projectId,
                UploadedByTeamMemberId = teamMemberId,
                FileName = fileName,
                FilePath = filePath,
                FileType = file.ContentType,
                UploadDate = DateTime.UtcNow
            };

            await _projectFileRepository.AddProjectFileAsync(projectFile);

            return Ok(new { Message = "Project file shared successfully", FilePath = filePath });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}

// IFileStorageService is assumed to be defined as in Scenario 2
// (omitted for brevity as per instructions not to repeat code)

public interface IProjectFileRepository
{
    Task AddProjectFileAsync(ProjectFile file);
}

public class ProjectFile
{
    public int Id { get; set; }
    public int ProjectId { get; set; }
    public int UploadedByTeamMemberId { get; set; }
    public string FileName { get; set; }
    public string FilePath { get; set; }
    public string FileType { get; set; }
    public DateTime UploadDate { get; set; }
}
```
ðŸ§ª Senaryo 5: Ekip Ãœyelerinin Dosya PaylaÅŸÄ±mÄ± YapmasÄ±
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import uuid
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['UPLOAD_FOLDER_PROJECT'] = 'uploads/project-files'
app.config['MAX_CONTENT_LENGTH'] = 200 * 1024 * 1024  # 200 MB limit
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///project.db'
db = SQLAlchemy(app)

ALLOWED_PROJECT_FILE_EXTENSIONS = {
    'zip', 'rar', '7z', 'sketch', 'psd', 'ai', 'xd', 'code',
    'js', 'ts', 'py', 'cs', 'java', 'md', 'pdf', 'xlsx', 'docx'
}

class ProjectFile(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    project_id = db.Column(db.Integer, nullable=False)
    uploaded_by_team_member_id = db.Column(db.Integer, nullable=False)
    file_name = db.Column(db.String(255), nullable=False)
    file_path = db.Column(db.String(255), nullable=False)
    file_type = db.Column(db.String(100), nullable=False)
    upload_date = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<ProjectFile {self.file_name}>'

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_PROJECT_FILE_EXTENSIONS

@app.route('/api/project/share-file/<int:project_id>/<int:team_member_id>', methods=['POST'])
def share_project_file(project_id, team_member_id):
    if 'file' not in request.files:
        return jsonify({"message": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"message": "No selected file"}), 400
    
    if file and allowed_file(file.filename):
        try:
            project_upload_folder = os.path.join(app.config['UPLOAD_FOLDER_PROJECT'], str(project_id))
            if not os.path.exists(project_upload_folder):
                os.makedirs(project_upload_folder)

            original_filename, file_extension = os.path.splitext(file.filename)
            unique_filename = str(uuid.uuid4()) + file_extension
            filepath = os.path.join(project_upload_folder, secure_filename(unique_filename))
            file.save(filepath)

            new_project_file = ProjectFile(
                project_id=project_id,
                uploaded_by_team_member_id=team_member_id,
                file_name=unique_filename,
                file_path=f"/{app.config['UPLOAD_FOLDER_PROJECT']}/{project_id}/{unique_filename}",
                file_type=file.content_type
            )
            db.session.add(new_project_file)
            db.session.commit()

            return jsonify({"message": "Project file shared successfully", "filePath": new_project_file.file_path}), 200
        except Exception as e:
            return jsonify({"message": f"Server error: {str(e)}"}), 500
    else:
        return jsonify({"message": "File type not allowed for project sharing"}), 400

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 5: Ekip Ãœyelerinin Dosya PaylaÅŸÄ±mÄ± YapmasÄ±
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

const app = express();
const prisma = new PrismaClient();

const uploadBaseDir = path.join(__dirname, '../uploads/project-files');

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const projectId = req.params.projectId;
        const projectUploadDir = path.join(uploadBaseDir, projectId);
        if (!fs.existsSync(projectUploadDir)) {
            fs.mkdirSync(projectUploadDir, { recursive: true });
        }
        cb(null, projectUploadDir);
    },
    filename: (req, file, cb) => {
        const fileExtension = path.extname(file.originalname);
        const uniqueFilename = `${uuidv4()}${fileExtension}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req: express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = /zip|rar|7z|sketch|psd|ai|xd|code|js|ts|py|cs|java|md|pdf|xlsx|docx/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());

    // For simplicity, we are checking extension only. Mime type check can be added.
    if (extname) {
        return cb(null, true);
    }
    cb(new Error('Unsupported file type for project sharing!'));
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 200 }, // 200MB limit
    fileFilter: fileFilter
}).single('file');

app.post('/api/project/share-file/:projectId/:teamMemberId', (req, res) => {
    upload(req, res, async (err) => {
        if (err instanceof multer.MulterError) {
            return res.status(400).json({ message: err.message });
        } else if (err) {
            return res.status(400).json({ message: err.message });
        }

        if (!req.file) {
            return res.status(400).json({ message: 'No file uploaded.' });
        }

        const projectId = parseInt(req.params.projectId);
        const teamMemberId = parseInt(req.params.teamMemberId);

        if (isNaN(projectId) || isNaN(teamMemberId)) {
            return res.status(400).json({ message: 'Invalid Project ID or Team Member ID.' });
        }

        try {
            const projectFile = await prisma.projectFile.create({
                data: {
                    projectId: projectId,
                    uploadedByTeamMemberId: teamMemberId,
                    fileName: req.file.filename,
                    filePath: `/uploads/project-files/${projectId}/${req.file.filename}`,
                    fileType: req.file.mimetype,
                    uploadDate: new Date(),
                },
            });
            res.status(200).json({ message: 'Project file shared successfully', filePath: projectFile.filePath });
        } catch (error) {
            console.error('Error saving project file to database:', error);
            res.status(500).json({ message: 'Internal server error.' });
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Example Prisma schema (schema.prisma):
/*
model ProjectFile {
  id                   Int      @id @default(autoincrement())
  projectId            Int
  uploadedByTeamMemberId Int
  fileName             String
  filePath             String
  fileType             String
  uploadDate           DateTime @default(now())
}
*/
```
ðŸ§ª Senaryo 6: KullanÄ±cÄ±larÄ±n Ä°Ã§erik PaylaÅŸÄ±mÄ± YapmasÄ±
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

```csharp

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;
using System;

[ApiController]
[Route("api/[controller]")]
public class SocialMediaController : ControllerBase
{
    private readonly IFileStorageService _fileStorageService;
    private readonly IPostRepository _postRepository;

    public SocialMediaController(IFileStorageService fileStorageService, IPostRepository postRepository)
    {
        _fileStorageService = fileStorageService;
        _postRepository = postRepository;
    }

    [HttpPost("create-post/{userId}")]
    public async Task<IActionResult> CreatePost(int userId, IFormFile mediaFile, [FromForm] string caption)
    {
        if (mediaFile == null || mediaFile.Length == 0)
        {
            return BadRequest("No media file uploaded.");
        }

        var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif", ".mp4", ".mov" };
        var fileExtension = Path.GetExtension(mediaFile.FileName).ToLowerInvariant();
        if (!Array.Exists(allowedExtensions, ext => ext == fileExtension))
        {
            return BadRequest("Unsupported media file type.");
        }

        try
        {
            var fileName = $"{Guid.NewGuid()}{fileExtension}";
            var filePath = await _fileStorageService.SaveFileAsync(mediaFile, $"user-posts/{userId}", fileName);

            var post = new Post
            {
                UserId = userId,
                MediaType = mediaFile.ContentType,
                MediaFilePath = filePath,
                Caption = caption,
                PostDate = DateTime.UtcNow
            };

            await _postRepository.AddPostAsync(post);

            return Ok(new { Message = "Post created successfully", MediaPath = filePath });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}

// IFileStorageService is assumed to be defined as in Scenario 2
// (omitted for brevity as per instructions not to repeat code)

public interface IPostRepository
{
    Task AddPostAsync(Post post);
}

public class Post
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public string MediaType { get; set; }
    public string MediaFilePath { get; set; }
    public string Caption { get; set; }
    public DateTime PostDate { get; set; }
}
```
ðŸ§ª Senaryo 6: KullanÄ±cÄ±larÄ±n Ä°Ã§erik PaylaÅŸÄ±mÄ± YapmasÄ±
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import uuid
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['UPLOAD_FOLDER_POSTS'] = 'uploads/user-posts'
app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50 MB limit
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///social_media.db'
db = SQLAlchemy(app)

ALLOWED_MEDIA_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'mp4', 'mov'}

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    media_type = db.Column(db.String(100), nullable=False)
    media_file_path = db.Column(db.String(255), nullable=False)
    caption = db.Column(db.Text, nullable=True)
    post_date = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<Post {self.id} by User {self.user_id}>'

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_MEDIA_EXTENSIONS

@app.route('/api/socialmedia/create-post/<int:user_id>', methods=['POST'])
def create_post(user_id):
    if 'mediaFile' not in request.files:
        return jsonify({"message": "No media file part"}), 400
    media_file = request.files['mediaFile']
    caption = request.form.get('caption', '')

    if media_file.filename == '':
        return jsonify({"message": "No selected media file"}), 400
    
    if media_file and allowed_file(media_file.filename):
        try:
            user_upload_folder = os.path.join(app.config['UPLOAD_FOLDER_POSTS'], str(user_id))
            if not os.path.exists(user_upload_folder):
                os.makedirs(user_upload_folder)

            original_filename, file_extension = os.path.splitext(media_file.filename)
            unique_filename = str(uuid.uuid4()) + file_extension
            filepath = os.path.join(user_upload_folder, secure_filename(unique_filename))
            media_file.save(filepath)

            new_post = Post(
                user_id=user_id,
                media_type=media_file.content_type,
                media_file_path=f"/{app.config['UPLOAD_FOLDER_POSTS']}/{user_id}/{unique_filename}",
                caption=caption
            )
            db.session.add(new_post)
            db.session.commit()

            return jsonify({"message": "Post created successfully", "mediaPath": new_post.media_file_path}), 200
        except Exception as e:
            return jsonify({"message": f"Server error: {str(e)}"}), 500
    else:
        return jsonify({"message": "Media file type not allowed"}), 400

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 6: KullanÄ±cÄ±larÄ±n Ä°Ã§erik PaylaÅŸÄ±mÄ± YapmasÄ±
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

const app = express();
const prisma = new PrismaClient();

const uploadBaseDir = path.join(__dirname, '../uploads/user-posts');

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const userId = req.params.userId;
        const userUploadDir = path.join(uploadBaseDir, userId);
        if (!fs.existsSync(userUploadDir)) {
            fs.mkdirSync(userUploadDir, { recursive: true });
        }
        cb(null, userUploadDir);
    },
    filename: (req, file, cb) => {
        const fileExtension = path.extname(file.originalname);
        const uniqueFilename = `${uuidv4()}${fileExtension}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req: express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = /jpeg|jpg|png|gif|mp4|mov/;
    const mimetype = allowedTypes.test(file.mimetype);
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());

    if (mimetype && extname) {
        return cb(null, true);
    }
    cb(new Error('Unsupported media file type!'));
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 50 }, // 50MB limit
    fileFilter: fileFilter
}).single('mediaFile');

app.post('/api/socialmedia/create-post/:userId', (req, res) => {
    upload(req, res, async (err) => {
        if (err instanceof multer.MulterError) {
            return res.status(400).json({ message: err.message });
        } else if (err) {
            return res.status(400).json({ message: err.message });
        }

        if (!req.file) {
            return res.status(400).json({ message: 'No media file uploaded.' });
        }

        const userId = parseInt(req.params.userId);
        if (isNaN(userId)) {
            return res.status(400).json({ message: 'Invalid User ID.' });
        }

        const caption = req.body.caption || '';

        try {
            const post = await prisma.post.create({
                data: {
                    userId: userId,
                    mediaType: req.file.mimetype,
                    mediaFilePath: `/uploads/user-posts/${userId}/${req.file.filename}`,
                    caption: caption,
                    postDate: new Date(),
                },
            });
            res.status(200).json({ message: 'Post created successfully', mediaPath: post.mediaFilePath });
        } catch (error) {
            console.error('Error saving post to database:', error);
            res.status(500).json({ message: 'Internal server error.' });
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Example Prisma schema (schema.prisma):
/*
model Post {
  id            Int      @id @default(autoincrement())
  userId        Int
  mediaType     String
  mediaFilePath String
  caption       String?
  postDate      DateTime @default(now())
}
*/
```
ðŸ§ª Senaryo 7: KullanÄ±cÄ±larÄ±n KiÅŸisel DosyalarÄ±nÄ± Yedeklemesi
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

```csharp

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;
using System;

[ApiController]
[Route("api/[controller]")]
public class CloudStorageController : ControllerBase
{
    private readonly IFileStorageService _fileStorageService;
    private readonly IBackupFileRepository _backupFileRepository;

    public CloudStorageController(IFileStorageService fileStorageService, IBackupFileRepository backupFileRepository)
    {
        _fileStorageService = fileStorageService;
        _backupFileRepository = backupFileRepository;
    }

    [HttpPost("upload-backup/{userId}")]
    public async Task<IActionResult> UploadBackupFile(int userId, IFormFile file)
    {
        if (file == null || file.Length == 0)
        {
            return BadRequest("No file uploaded.");
        }

        // For cloud storage, we often accept all types, but might want to limit by size.
        // Simplified for example, accepting any type.
        var fileExtension = Path.GetExtension(file.FileName).ToLowerInvariant();

        try
        {
            var fileName = $"{Guid.NewGuid()}{fileExtension}";
            var filePath = await _fileStorageService.SaveFileAsync(file, $"user-backups/{userId}", fileName);

            var backupFile = new BackupFile
            {
                UserId = userId,
                OriginalFileName = file.FileName,
                StoredFileName = fileName,
                FilePath = filePath,
                FileType = file.ContentType,
                UploadDate = DateTime.UtcNow,
                FileSizeKB = (int)(file.Length / 1024)
            };

            await _backupFileRepository.AddBackupFileAsync(backupFile);

            return Ok(new { Message = "File backed up successfully", FilePath = filePath });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}

// IFileStorageService is assumed to be defined as in Scenario 2
// (omitted for brevity as per instructions not to repeat code)

public interface IBackupFileRepository
{
    Task AddBackupFileAsync(BackupFile file);
}

public class BackupFile
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public string OriginalFileName { get; set; }
    public string StoredFileName { get; set; }
    public string FilePath { get; set; }
    public string FileType { get; set; }
    public DateTime UploadDate { get; set; }
    public int FileSizeKB { get; set; }
}
```
ðŸ§ª Senaryo 7: KullanÄ±cÄ±larÄ±n KiÅŸisel DosyalarÄ±nÄ± Yedeklemesi
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import uuid
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['UPLOAD_FOLDER_BACKUPS'] = 'uploads/user-backups'
app.config['MAX_CONTENT_LENGTH'] = 1024 * 1024 * 1024  # 1 GB limit
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///cloud_storage.db'
db = SQLAlchemy(app)

class BackupFile(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    original_file_name = db.Column(db.String(255), nullable=False)
    stored_file_name = db.Column(db.String(255), nullable=False)
    file_path = db.Column(db.String(255), nullable=False)
    file_type = db.Column(db.String(100), nullable=False)
    upload_date = db.Column(db.DateTime, default=datetime.utcnow)
    file_size_kb = db.Column(db.Integer, nullable=False)

    def __repr__(self):
        return f'<BackupFile {self.stored_file_name}>'

@app.route('/api/cloudstorage/upload-backup/<int:user_id>', methods=['POST'])
def upload_backup_file(user_id):
    if 'file' not in request.files:
        return jsonify({"message": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"message": "No selected file"}), 400
    
    try:
        user_backup_folder = os.path.join(app.config['UPLOAD_FOLDER_BACKUPS'], str(user_id))
        if not os.path.exists(user_backup_folder):
            os.makedirs(user_backup_folder)

        original_filename, file_extension = os.path.splitext(file.filename)
        unique_filename = str(uuid.uuid4()) + file_extension
        filepath = os.path.join(user_backup_folder, secure_filename(unique_filename))
        file.save(filepath)

        new_backup_file = BackupFile(
            user_id=user_id,
            original_file_name=file.filename,
            stored_file_name=unique_filename,
            file_path=f"/{app.config['UPLOAD_FOLDER_BACKUPS']}/{user_id}/{unique_filename}",
            file_type=file.content_type,
            file_size_kb=file.content_length // 1024
        )
        db.session.add(new_backup_file)
        db.session.commit()

        return jsonify({"message": "File backed up successfully", "filePath": new_backup_file.file_path}), 200
    except Exception as e:
        return jsonify({"message": f"Server error: {str(e)}"}), 500

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 7: KullanÄ±cÄ±larÄ±n KiÅŸisel DosyalarÄ±nÄ± Yedeklemesi
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

const app = express();
const prisma = new PrismaClient();

const uploadBaseDir = path.join(__dirname, '../uploads/user-backups');

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const userId = req.params.userId;
        const userUploadDir = path.join(uploadBaseDir, userId);
        if (!fs.existsSync(userUploadDir)) {
            fs.mkdirSync(userUploadDir, { recursive: true });
        }
        cb(null, userUploadDir);
    },
    filename: (req, file, cb) => {
        const fileExtension = path.extname(file.originalname);
        const uniqueFilename = `${uuidv4()}${fileExtension}`;
        cb(null, uniqueFilename);
    }
});

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 1024 } // 1GB limit
}).single('file');

app.post('/api/cloudstorage/upload-backup/:userId', (req, res) => {
    upload(req, res, async (err) => {
        if (err instanceof multer.MulterError) {
            return res.status(400).json({ message: err.message });
        } else if (err) {
            return res.status(400).json({ message: err.message });
        }

        if (!req.file) {
            return res.status(400).json({ message: 'No file uploaded.' });
        }

        const userId = parseInt(req.params.userId);
        if (isNaN(userId)) {
            return res.status(400).json({ message: 'Invalid User ID.' });
        }

        try {
            const backupFile = await prisma.backupFile.create({
                data: {
                    userId: userId,
                    originalFileName: req.file.originalname,
                    storedFileName: req.file.filename,
                    filePath: `/uploads/user-backups/${userId}/${req.file.filename}`,
                    fileType: req.file.mimetype,
                    uploadDate: new Date(),
                    fileSizeKB: Math.round(req.file.size / 1024),
                },
            });
            res.status(200).json({ message: 'File backed up successfully', filePath: backupFile.filePath });
        } catch (error) {
            console.error('Error saving backup file to database:', error);
            res.status(500).json({ message: 'Internal server error.' });
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Example Prisma schema (schema.prisma):
/*
model BackupFile {
  id               Int      @id @default(autoincrement())
  userId           Int
  originalFileName String
  storedFileName   String
  filePath         String
  fileType         String
  uploadDate       DateTime @default(now())
  fileSizeKB       Int
}
*/
```
ðŸ§ª Senaryo 8: EditÃ¶rlerin Haber Ä°Ã§erikleri YÃ¼klemesi
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

```csharp

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;
using System;

[ApiController]
[Route("api/[controller]")]
public class NewsController : ControllerBase
{
    private readonly IFileStorageService _fileStorageService;
    private readonly INewsArticleRepository _newsArticleRepository;

    public NewsController(IFileStorageService fileStorageService, INewsArticleRepository newsArticleRepository)
    {
        _fileStorageService = fileStorageService;
        _newsArticleRepository = newsArticleRepository;
    }

    [HttpPost("upload-news-content/{editorId}")]
    public async Task<IActionResult> UploadNewsContent(int editorId, IFormFile mediaFile, [FromForm] string title, [FromForm] string body)
    {
        if (mediaFile == null || mediaFile.Length == 0)
        {
            return BadRequest("Media file is required for news content.");
        }

        var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".mp4", ".mov", ".pdf" };
        var fileExtension = Path.GetExtension(mediaFile.FileName).ToLowerInvariant();
        if (!Array.Exists(allowedExtensions, ext => ext == fileExtension))
        {
            return BadRequest("Unsupported media file type for news content.");
        }

        try
        {
            var fileName = $"{Guid.NewGuid()}{fileExtension}";
            var filePath = await _fileStorageService.SaveFileAsync(mediaFile, $"news-media", fileName);

            var newsArticle = new NewsArticle
            {
                EditorId = editorId,
                Title = title,
                Body = body,
                MediaType = mediaFile.ContentType,
                MediaFilePath = filePath,
                UploadDate = DateTime.UtcNow
            };

            await _newsArticleRepository.AddNewsArticleAsync(newsArticle);

            return Ok(new { Message = "News content uploaded successfully", MediaPath = filePath });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}

// IFileStorageService is assumed to be defined as in Scenario 2
// (omitted for brevity as per instructions not to repeat code)

public interface INewsArticleRepository
{
    Task AddNewsArticleAsync(NewsArticle article);
}

public class NewsArticle
{
    public int Id { get; set; }
    public int EditorId { get; set; }
    public string Title { get; set; }
    public string Body { get; set; }
    public string MediaType { get; set; }
    public string MediaFilePath { get; set; }
    public DateTime UploadDate { get; set; }
}
```
ðŸ§ª Senaryo 8: EditÃ¶rlerin Haber Ä°Ã§erikleri YÃ¼klemesi
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import uuid
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['UPLOAD_FOLDER_NEWS'] = 'uploads/news-media'
app.config['MAX_CONTENT_LENGTH'] = 100 * 1024 * 1024  # 100 MB limit
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///news_portal.db'
db = SQLAlchemy(app)

ALLOWED_NEWS_MEDIA_EXTENSIONS = {'png', 'jpg', 'jpeg', 'mp4', 'mov', 'pdf'}

class NewsArticle(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    editor_id = db.Column(db.Integer, nullable=False)
    title = db.Column(db.String(255), nullable=False)
    body = db.Column(db.Text, nullable=True)
    media_type = db.Column(db.String(100), nullable=True)
    media_file_path = db.Column(db.String(255), nullable=True)
    upload_date = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<NewsArticle {self.title}>'

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_NEWS_MEDIA_EXTENSIONS

@app.route('/api/news/upload-news-content/<int:editor_id>', methods=['POST'])
def upload_news_content(editor_id):
    title = request.form.get('title')
    body = request.form.get('body')
    media_file = request.files.get('mediaFile')

    if not title:
        return jsonify({"message": "Title is required"}), 400

    media_file_path = None
    media_type = None

    if media_file and media_file.filename != '':
        if allowed_file(media_file.filename):
            try:
                if not os.path.exists(app.config['UPLOAD_FOLDER_NEWS']):
                    os.makedirs(app.config['UPLOAD_FOLDER_NEWS'])

                original_filename, file_extension = os.path.splitext(media_file.filename)
                unique_filename = str(uuid.uuid4()) + file_extension
                filepath = os.path.join(app.config['UPLOAD_FOLDER_NEWS'], secure_filename(unique_filename))
                media_file.save(filepath)
                media_file_path = f"/{app.config['UPLOAD_FOLDER_NEWS']}/{unique_filename}"
                media_type = media_file.content_type
            except Exception as e:
                return jsonify({"message": f"Error saving media file: {str(e)}"}), 500
        else:
            return jsonify({"message": "Media file type not allowed"}), 400

    try:
        new_article = NewsArticle(
            editor_id=editor_id,
            title=title,
            body=body,
            media_type=media_type,
            media_file_path=media_file_path
        )
        db.session.add(new_article)
        db.session.commit()

        return jsonify({"message": "News content uploaded successfully", "mediaPath": media_file_path}), 200
    except Exception as e:
        return jsonify({"message": f"Server error: {str(e)}"}), 500

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 8: EditÃ¶rlerin Haber Ä°Ã§erikleri YÃ¼klemesi
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

const app = express();
const prisma = new PrismaClient();

const uploadDir = path.join(__dirname, '../uploads/news-media');
if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
}

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
        const fileExtension = path.extname(file.originalname);
        const uniqueFilename = `${uuidv4()}${fileExtension}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req: express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = /jpeg|jpg|png|mp4|mov|pdf/;
    const mimetype = allowedTypes.test(file.mimetype);
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());

    if (mimetype && extname) {
        return cb(null, true);
    }
    cb(new Error('Unsupported media file type for news content!'));
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 100 }, // 100MB limit
    fileFilter: fileFilter
}).single('mediaFile');

app.post('/api/news/upload-news-content/:editorId', (req, res) => {
    upload(req, res, async (err) => {
        if (err instanceof multer.MulterError) {
            return res.status(400).json({ message: err.message });
        } else if (err) {
            return res.status(400).json({ message: err.message });
        }

        const editorId = parseInt(req.params.editorId);
        if (isNaN(editorId)) {
            return res.status(400).json({ message: 'Invalid Editor ID.' });
        }

        const { title, body } = req.body;
        if (!title) {
            return res.status(400).json({ message: 'Title is required.' });
        }

        let mediaFilePath: string | null = null;
        let mediaType: string | null = null;

        if (req.file) {
            mediaFilePath = `/uploads/news-media/${req.file.filename}`;
            mediaType = req.file.mimetype;
        }

        try {
            const newsArticle = await prisma.newsArticle.create({
                data: {
                    editorId: editorId,
                    title: title,
                    body: body,
                    mediaType: mediaType,
                    mediaFilePath: mediaFilePath,
                    uploadDate: new Date(),
                },
            });
            res.status(200).json({ message: 'News content uploaded successfully', mediaPath: newsArticle.mediaFilePath });
        } catch (error) {
            console.error('Error saving news article to database:', error);
            res.status(500).json({ message: 'Internal server error.' });
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Example Prisma schema (schema.prisma):
/*
model NewsArticle {
  id            Int      @id @default(autoincrement())
  editorId      Int
  title         String
  body          String?
  mediaType     String?
  mediaFilePath String?
  uploadDate    DateTime @default(now())
}
*/
```
ðŸ§ª Senaryo 9: SanatÃ§Ä±larÄ±n Eserlerini Sergilemesi
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

```csharp

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;
using System;

[ApiController]
[Route("api/[controller]")]
public class ArtGalleryController : ControllerBase
{
    private readonly IFileStorageService _fileStorageService;
    private readonly IArtworkRepository _artworkRepository;

    public ArtGalleryController(IFileStorageService fileStorageService, IArtworkRepository artworkRepository)
    {
        _fileStorageService = fileStorageService;
        _artworkRepository = artworkRepository;
    }

    [HttpPost("upload-artwork/{artistId}")]
    public async Task<IActionResult> UploadArtwork(int artistId, IFormFile imageFile, [FromForm] string title, [FromForm] string description)
    {
        if (imageFile == null || imageFile.Length == 0)
        {
            return BadRequest("Image file is required for artwork.");
        }

        var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".tif", ".tiff", ".bmp" }; // High-resolution formats
        var fileExtension = Path.GetExtension(imageFile.FileName).ToLowerInvariant();
        if (!Array.Exists(allowedExtensions, ext => ext == fileExtension))
        {
            return BadRequest("Unsupported image file type for artwork. Please upload high-resolution images.");
        }

        // Consider additional validation for image resolution/dimensions if needed for a gallery

        try
        {
            var fileName = $"{Guid.NewGuid()}{fileExtension}";
            var filePath = await _fileStorageService.SaveFileAsync(imageFile, $"artworks/{artistId}", fileName);

            var artwork = new Artwork
            {
                ArtistId = artistId,
                Title = title,
                Description = description,
                ImageFilePath = filePath,
                ImageType = imageFile.ContentType,
                UploadDate = DateTime.UtcNow
            };

            await _artworkRepository.AddArtworkAsync(artwork);

            return Ok(new { Message = "Artwork uploaded successfully", ImagePath = filePath });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}

// IFileStorageService is assumed to be defined as in Scenario 2
// (omitted for brevity as per instructions not to repeat code)

public interface IArtworkRepository
{
    Task AddArtworkAsync(Artwork artwork);
}

public class Artwork
{
    public int Id { get; set; }
    public int ArtistId { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public string ImageFilePath { get; set; }
    public string ImageType { get; set; }
    public DateTime UploadDate { get; set; }
}
```
ðŸ§ª Senaryo 9: SanatÃ§Ä±larÄ±n Eserlerini Sergilemesi
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import uuid
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['UPLOAD_FOLDER_ARTWORKS'] = 'uploads/artworks'
app.config['MAX_CONTENT_LENGTH'] = 100 * 1024 * 1024  # 100 MB limit for high-res images
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///art_gallery.db'
db = SQLAlchemy(app)

ALLOWED_IMAGE_EXTENSIONS = {'png', 'jpg', 'jpeg', 'tif', 'tiff', 'bmp'}

class Artwork(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    artist_id = db.Column(db.Integer, nullable=False)
    title = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=True)
    image_file_path = db.Column(db.String(255), nullable=False)
    image_type = db.Column(db.String(100), nullable=False)
    upload_date = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<Artwork {self.title}>'

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_IMAGE_EXTENSIONS

@app.route('/api/artgallery/upload-artwork/<int:artist_id>', methods=['POST'])
def upload_artwork(artist_id):
    title = request.form.get('title')
    description = request.form.get('description')
    image_file = request.files.get('imageFile')

    if not image_file:
        return jsonify({"message": "No image file part"}), 400
    if image_file.filename == '':
        return jsonify({"message": "No selected image file"}), 400
    
    if not title:
        return jsonify({"message": "Artwork title is required"}), 400

    if image_file and allowed_file(image_file.filename):
        try:
            artist_upload_folder = os.path.join(app.config['UPLOAD_FOLDER_ARTWORKS'], str(artist_id))
            if not os.path.exists(artist_upload_folder):
                os.makedirs(artist_upload_folder)

            original_filename, file_extension = os.path.splitext(image_file.filename)
            unique_filename = str(uuid.uuid4()) + file_extension
            filepath = os.path.join(artist_upload_folder, secure_filename(unique_filename))
            image_file.save(filepath)

            new_artwork = Artwork(
                artist_id=artist_id,
                title=title,
                description=description,
                image_file_path=f"/{app.config['UPLOAD_FOLDER_ARTWORKS']}/{artist_id}/{unique_filename}",
                image_type=image_file.content_type
            )
            db.session.add(new_artwork)
            db.session.commit()

            return jsonify({"message": "Artwork uploaded successfully", "imagePath": new_artwork.image_file_path}), 200
        except Exception as e:
            return jsonify({"message": f"Server error: {str(e)}"}), 500
    else:
        return jsonify({"message": "Image file type not allowed for artwork"}), 400

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 9: SanatÃ§Ä±larÄ±n Eserlerini Sergilemesi
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

const app = express();
const prisma = new PrismaClient();

const uploadBaseDir = path.join(__dirname, '../uploads/artworks');

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const artistId = req.params.artistId;
        const artistUploadDir = path.join(uploadBaseDir, artistId);
        if (!fs.existsSync(artistUploadDir)) {
            fs.mkdirSync(artistUploadDir, { recursive: true });
        }
        cb(null, artistUploadDir);
    },
    filename: (req, file, cb) => {
        const fileExtension = path.extname(file.originalname);
        const uniqueFilename = `${uuidv4()}${fileExtension}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req: express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = /jpeg|jpg|png|tif|tiff|bmp/;
    const mimetype = allowedTypes.test(file.mimetype);
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());

    if (mimetype && extname) {
        return cb(null, true);
    }
    cb(new Error('Unsupported image file type for artwork! Please upload high-resolution images.'));
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 100 }, // 100MB limit for high-res images
    fileFilter: fileFilter
}).single('imageFile');

app.post('/api/artgallery/upload-artwork/:artistId', (req, res) => {
    upload(req, res, async (err) => {
        if (err instanceof multer.MulterError) {
            return res.status(400).json({ message: err.message });
        } else if (err) {
            return res.status(400).json({ message: err.message });
        }

        if (!req.file) {
            return res.status(400).json({ message: 'No image file uploaded.' });
        }

        const artistId = parseInt(req.params.artistId);
        if (isNaN(artistId)) {
            return res.status(400).json({ message: 'Invalid Artist ID.' });
        }

        const { title, description } = req.body;
        if (!title) {
            return res.status(400).json({ message: 'Artwork title is required.' });
        }

        try {
            const artwork = await prisma.artwork.create({
                data: {
                    artistId: artistId,
                    title: title,
                    description: description,
                    imageFilePath: `/uploads/artworks/${artistId}/${req.file.filename}`,
                    imageType: req.file.mimetype,
                    uploadDate: new Date(),
                },
            });
            res.status(200).json({ message: 'Artwork uploaded successfully', imagePath: artwork.imageFilePath });
        } catch (error) {
            console.error('Error saving artwork to database:', error);
            res.status(500).json({ message: 'Internal server error.' });
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Example Prisma schema (schema.prisma):
/*
model Artwork {
  id            Int      @id @default(autoincrement())
  artistId      Int
  title         String
  description   String?
  imageFilePath String
  imageType     String
  uploadDate    DateTime @default(now())
}
*/
```
ðŸ§ª Senaryo 10: KullanÄ±cÄ±larÄ±n Kendi VideolarÄ±nÄ± YayÄ±nlamasÄ±
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

```csharp

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;
using System;

[ApiController]
[Route("api/[controller]")]
public class VideoPlatformController : ControllerBase
{
    private readonly IFileStorageService _fileStorageService;
    private readonly IVideoRepository _videoRepository;

    public VideoPlatformController(IFileStorageService fileStorageService, IVideoRepository videoRepository)
    {
        _fileStorageService = fileStorageService;
        _videoRepository = videoRepository;
    }

    [HttpPost("upload-video/{userId}")]
    public async Task<IActionResult> UploadVideo(int userId, IFormFile videoFile, [FromForm] string title, [FromForm] string description)
    {
        if (videoFile == null || videoFile.Length == 0)
        {
            return BadRequest("Video file is required.");
        }

        var allowedExtensions = new[] { ".mp4", ".mov", ".avi", ".wmv", ".flv" };
        var fileExtension = Path.GetExtension(videoFile.FileName).ToLowerInvariant();
        if (!Array.Exists(allowedExtensions, ext => ext == fileExtension))
        {
            return BadRequest("Unsupported video file type.");
        }

        try
        {
            var fileName = $"{Guid.NewGuid()}{fileExtension}";
            var filePath = await _fileStorageService.SaveFileAsync(videoFile, $"user-videos/{userId}", fileName);

            var video = new Video
            {
                UserId = userId,
                Title = title,
                Description = description,
                VideoFilePath = filePath,
                VideoType = videoFile.ContentType,
                UploadDate = DateTime.UtcNow,
                FileSizeMB = (int)(videoFile.Length / (1024 * 1024))
            };

            await _videoRepository.AddVideoAsync(video);

            return Ok(new { Message = "Video uploaded successfully", VideoPath = filePath });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}

// IFileStorageService is assumed to be defined as in Scenario 2
// (omitted for brevity as per instructions not to repeat code)

public interface IVideoRepository
{
    Task AddVideoAsync(Video video);
}

public class Video
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public string VideoFilePath { get; set; }
    public string VideoType { get; set; }
    public DateTime UploadDate { get; set; }
    public int FileSizeMB { get; set; }
}
```
ðŸ§ª Senaryo 10: KullanÄ±cÄ±larÄ±n Kendi VideolarÄ±nÄ± YayÄ±nlamasÄ±
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import uuid
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['UPLOAD_FOLDER_VIDEOS'] = 'uploads/user-videos'
app.config['MAX_CONTENT_LENGTH'] = 500 * 1024 * 1024  # 500 MB limit
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///video_platform.db'
db = SQLAlchemy(app)

ALLOWED_VIDEO_EXTENSIONS = {'mp4', 'mov', 'avi', 'wmv', 'flv'}

class Video(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    title = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=True)
    video_file_path = db.Column(db.String(255), nullable=False)
    video_type = db.Column(db.String(100), nullable=False)
    upload_date = db.Column(db.DateTime, default=datetime.utcnow)
    file_size_mb = db.Column(db.Integer, nullable=False)

    def __repr__(self):
        return f'<Video {self.title}>'

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_VIDEO_EXTENSIONS

@app.route('/api/videoplatform/upload-video/<int:user_id>', methods=['POST'])
def upload_video(user_id):
    title = request.form.get('title')
    description = request.form.get('description')
    video_file = request.files.get('videoFile')

    if not video_file:
        return jsonify({"message": "No video file part"}), 400
    if video_file.filename == '':
        return jsonify({"message": "No selected video file"}), 400
    
    if not title:
        return jsonify({"message": "Video title is required"}), 400

    if video_file and allowed_file(video_file.filename):
        try:
            user_upload_folder = os.path.join(app.config['UPLOAD_FOLDER_VIDEOS'], str(user_id))
            if not os.path.exists(user_upload_folder):
                os.makedirs(user_upload_folder)

            original_filename, file_extension = os.path.splitext(video_file.filename)
            unique_filename = str(uuid.uuid4()) + file_extension
            filepath = os.path.join(user_upload_folder, secure_filename(unique_filename))
            video_file.save(filepath)

            new_video = Video(
                user_id=user_id,
                title=title,
                description=description,
                video_file_path=f"/{app.config['UPLOAD_FOLDER_VIDEOS']}/{user_id}/{unique_filename}",
                video_type=video_file.content_type,
                file_size_mb=video_file.content_length // (1024 * 1024)
            )
            db.session.add(new_video)
            db.session.commit()

            return jsonify({"message": "Video uploaded successfully", "videoPath": new_video.video_file_path}), 200
        except Exception as e:
            return jsonify({"message": f"Server error: {str(e)}"}), 500
    else:
        return jsonify({"message": "Video file type not allowed"}), 400

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```
ðŸ§ª Senaryo 10: KullanÄ±cÄ±larÄ±n Kendi VideolarÄ±nÄ± YayÄ±nlamasÄ±
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import path from 'path';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

const app = express();
const prisma = new PrismaClient();

const uploadBaseDir = path.join(__dirname, '../uploads/user-videos');

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const userId = req.params.userId;
        const userUploadDir = path.join(uploadBaseDir, userId);
        if (!fs.existsSync(userUploadDir)) {
            fs.mkdirSync(userUploadDir, { recursive: true });
        }
        cb(null, userUploadDir);
    },
    filename: (req, file, cb) => {
        const fileExtension = path.extname(file.originalname);
        const uniqueFilename = `${uuidv4()}${fileExtension}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req: express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = /mp4|mov|avi|wmv|flv/;
    const mimetype = allowedTypes.test(file.mimetype);
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());

    if (mimetype && extname) {
        return cb(null, true);
    }
    cb(new Error('Unsupported video file type!'));
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 500 }, // 500MB limit
    fileFilter: fileFilter
}).single('videoFile');

app.post('/api/videoplatform/upload-video/:userId', (req, res) => {
    upload(req, res, async (err) => {
        if (err instanceof multer.MulterError) {
            return res.status(400).json({ message: err.message });
        } else if (err) {
            return res.status(400).json({ message: err.message });
        }

        if (!req.file) {
            return res.status(400).json({ message: 'No video file uploaded.' });
        }

        const userId = parseInt(req.params.userId);
        if (isNaN(userId)) {
            return res.status(400).json({ message: 'Invalid User ID.' });
        }

        const { title, description } = req.body;
        if (!title) {
            return res.status(400).json({ message: 'Video title is required.' });
        }

        try {
            const video = await prisma.video.create({
                data: {
                    userId: userId,
                    title: title,
                    description: description,
                    videoFilePath: `/uploads/user-videos/${userId}/${req.file.filename}`,
                    videoType: req.file.mimetype,
                    uploadDate: new Date(),
                    fileSizeMB: Math.round(req.file.size / (1024 * 1024)),
                },
            });
            res.status(200).json({ message: 'Video uploaded successfully', videoPath: video.videoFilePath });
        } catch (error) {
            console.error('Error saving video to database:', error);
            res.status(500).json({ message: 'Internal server error.' });
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Example Prisma schema (schema.prisma):
/*
model Video {
  id            Int      @id @default(autoincrement())
  userId        Int
  title         String
  description   String?
  videoFilePath String
  videoType     String
  uploadDate    DateTime @default(now())
  fileSizeMB    Int
}
```
*/