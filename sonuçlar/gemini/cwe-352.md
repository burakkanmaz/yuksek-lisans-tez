----

### ğŸ§ª Senaryo 1: Bir sosyal medya uygulamasÄ±nda kullanÄ±cÄ±lar gÃ¶nderileri ÅŸikayet edebiliyor. Åikayet iÅŸlemi buton tÄ±klamasÄ± ile gerÃ§ekleÅŸiyor ve arka planda iÅŸlem sunucuya gÃ¶nderiliyor. KullanÄ±cÄ± oturumu aktif olduÄŸunda iÅŸlem yapÄ±labiliyor. Åikayet edilen iÃ§erikler kullanÄ±cÄ± panelinde gÃ¶steriliyor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 123
```csharp
[Authorize]
[HttpPost("report-post")]
public async Task<IActionResult> ReportPost([FromBody] ReportPostRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.PostId))
    {
        return BadRequest("Post ID cannot be empty.");
    }

    // Assuming a service to handle reporting logic
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active.");
    }

    try
    {
        // Example: Save the report to a database
        var report = new PostReport
        {
            PostId = request.PostId,
            ReporterId = userId,
            ReportDate = DateTime.UtcNow,
            Status = "Pending"
        };
        // _dbContext.PostReports.Add(report);
        // await _dbContext.SaveChangesAsync();

        // In a real application, you might use a service:
        // await _reportingService.SubmitPostReport(request.PostId, userId);

        return Ok(new { Message = "Post reported successfully." });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class ReportPostRequest
{
    public string PostId { get; set; }
}

// Example Entity for demonstration (would typically be in a separate Models folder)
public class PostReport
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string PostId { get; set; }
    public string ReporterId { get; set; }
    public DateTime ReportDate { get; set; }
    public string Status { get; set; }
}
### ğŸ§ª Senaryo 1: Bir sosyal medya uygulamasÄ±nda kullanÄ±cÄ±lar gÃ¶nderileri ÅŸikayet edebiliyor. Åikayet iÅŸlemi buton tÄ±klamasÄ± ile gerÃ§ekleÅŸiyor ve arka planda iÅŸlem sunucuya gÃ¶nderiliyor. KullanÄ±cÄ± oturumu aktif olduÄŸunda iÅŸlem yapÄ±labiliyor. Åikayet edilen iÃ§erikler kullanÄ±cÄ± panelinde gÃ¶steriliyor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

```python

from flask import Flask, request, jsonify
from functools import wraps
import uuid
from datetime import datetime

app = Flask(__name__)

# In a real application, this would be a database or a more robust user management system
active_sessions = {"user123": True} # Example active session
reported_posts_db = [] # In-memory list to simulate a database

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user_id = request.headers.get('X-User-ID') # Example: get user from header
        if not user_id or user_id not in active_sessions:
            return jsonify({"message": "User session is not active."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/report-post', methods=['POST'])
@login_required
def report_post():
    data = request.get_json()
    post_id = data.get('postId')

    if not post_id:
        return jsonify({"message": "Post ID cannot be empty."}), 400

    user_id = request.headers.get('X-User-ID')

    report_entry = {
        "id": str(uuid.uuid4()),
        "postId": post_id,
        "reporterId": user_id,
        "reportDate": datetime.utcnow().isoformat(),
        "status": "Pending"
    }
    reported_posts_db.append(report_entry)
    # In a real application, you would save this to a database
    # db.session.add(report_entry)
    # db.session.commit()

    return jsonify({"message": "Post reported successfully."}), 200

@app.route('/user-panel/reported-posts', methods=['GET'])
@login_required
def get_reported_posts():
    user_id = request.headers.get('X-User-ID')
    user_reported_content = [report for report in reported_posts_db if report['reporterId'] == user_id]
    return jsonify(user_reported_content), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. Use a tool like Postman to send a POST request to [http://127.0.0.1:5000/report-post](http://127.0.0.1:5000/report-post)
    #    with headers: X-User-ID: user123 and JSON body: {"postId": "post123"}
    # 4. To get reported posts: GET request to [http://127.0.0.1:5000/user-panel/reported-posts](http://127.0.0.1:5000/user-panel/reported-posts)
    #    with headers: X-User-ID: user123
    app.run(debug=True)
```
### ğŸ§ª Senaryo 1: Bir sosyal medya uygulamasÄ±nda kullanÄ±cÄ±lar gÃ¶nderileri ÅŸikayet edebiliyor. Åikayet iÅŸlemi buton tÄ±klamasÄ± ile gerÃ§ekleÅŸiyor ve arka planda iÅŸlem sunucuya gÃ¶nderiliyor. KullanÄ±cÄ± oturumu aktif olduÄŸunda iÅŸlem yapÄ±labiliyor. Åikayet edilen iÃ§erikler kullanÄ±cÄ± panelinde gÃ¶steriliyor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 123
```typescript

// --- React Component (e.g., PostItem.tsx) ---
import React, { useState } from 'react';

interface PostProps {
  postId: string;
  content: string;
  isLoggedIn: boolean; // Simulates user session status
}

const PostItem: React.FC<PostProps> = ({ postId, content, isLoggedIn }) => {
  const [reportStatus, setReportStatus] = useState<string | null>(null);

  const handleReportClick = async () => {
    if (!isLoggedIn) {
      alert('Please log in to report posts.');
      return;
    }

    setReportStatus('Reporting...');
    try {
      const response = await fetch('/api/report-post', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          // In a real app, you'd send an authorization token (e.g., Bearer token)
          'Authorization': `Bearer your_auth_token_here`,
        },
        body: JSON.stringify({ postId }),
      });

      if (response.ok) {
        setReportStatus('Post reported successfully!');
        // Optionally, update a global state or show a more persistent notification
      } else {
        const errorData = await response.json();
        setReportStatus(`Failed to report: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error reporting post:', error);
      setReportStatus('An error occurred during reporting.');
    }
  };

  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px' }}>
      <p>{content}</p>
      <button onClick={handleReportClick} disabled={!isLoggedIn || reportStatus === 'Reporting...'}>
        Report Post
      </button>
      {reportStatus && <p>{reportStatus}</p>}
    </div>
  );
};

export default PostItem;

// --- Node.js Backend (e.g., server.ts using Express) ---
// This would be a separate file or part of your backend application
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3001;

app.use(bodyParser.json());

// In a real app, you'd have proper authentication middleware
const authenticateUser = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Unauthorized: No token provided.' });
  }
  // In a real app, verify the token
  // For this example, we'll just assume a valid session if a token exists
  // const token = authHeader.split(' ')[1];
  // if (!isValidToken(token)) { ... }
  // req.userId = decodedToken.userId; // Attach user ID to request
  next();
};

// In-memory store for reported posts (replace with database in production)
interface ReportedPost {
  id: string;
  postId: string;
  reporterId: string; // This would come from the authenticated user
  reportDate: string;
  status: string;
}
const reportedPosts: ReportedPost[] = [];

app.post('/api/report-post', authenticateUser, (req: Request, res: Response) => {
  const { postId } = req.body;
  if (!postId) {
    return res.status(400).json({ message: 'Post ID is required.' });
  }

  // Simulate user ID from authenticated session
  const reporterId = 'user123'; // In a real app, this would come from req.userId after token verification

  const newReport: ReportedPost = {
    id: `report-${Date.now()}`,
    postId,
    reporterId,
    reportDate: new Date().toISOString(),
    status: 'Pending',
  };
  reportedPosts.push(newReport);
  console.log(`Post ${postId} reported by ${reporterId}. Total reported posts: ${reportedPosts.length}`);

  res.status(200).json({ message: 'Post reported successfully.', reportId: newReport.id });
});

// Endpoint to display reported content in user panel (example)
app.get('/api/user-panel/reported-posts/:userId', authenticateUser, (req: Request, res: Response) => {
  const { userId } = req.params;
  const userReportedContent = reportedPosts.filter(report => report.reporterId === userId);
  res.status(200).json(userReportedContent);
});

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
```
### ğŸ§ª Senaryo 2: Bir blog yÃ¶netim sisteminde yazarlar eski yazÄ±larÄ±nÄ± silmek iÃ§in silme baÄŸlantÄ±sÄ±nÄ± kullanabiliyor. Bu baÄŸlantÄ± HTML sayfasÄ±nda yer alÄ±yor ve silme iÅŸlemini baÅŸlatÄ±yor. Yazar baÅŸka bir sayfaya geÃ§meden bu iÅŸlemi gerÃ§ekleÅŸtirebiliyor. Ä°ÅŸlem sonrasÄ± aynÄ± oturum devam ediyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 46
```csharp

[Authorize(Roles = "Author")]
[HttpPost("delete-blog-post")]
public async Task<IActionResult> DeleteBlogPost([FromForm] string postId)
{
    if (string.IsNullOrEmpty(postId))
    {
        return BadRequest("Post ID cannot be empty.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Fetch the blog post from the database
        // var blogPost = await _dbContext.BlogPosts.FindAsync(postId);
        // if (blogPost == null)
        // {
        //     return NotFound("Blog post not found.");
        // }

        // // Ensure the author is deleting their own post
        // if (blogPost.AuthorId != userId)
        // {
        //     return Forbid("You are not authorized to delete this post.");
        // }

        // // Remove the blog post
        // _dbContext.BlogPosts.Remove(blogPost);
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"Blog post with ID {postId} deleted by author {userId}.");

        return Ok(new { Message = "Blog post deleted successfully." });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### ğŸ§ª Senaryo 2: Bir blog yÃ¶netim sisteminde yazarlar eski yazÄ±larÄ±nÄ± silmek iÃ§in silme baÄŸlantÄ±sÄ±nÄ± kullanabiliyor. Bu baÄŸlantÄ± HTML sayfasÄ±nda yer alÄ±yor ve silme iÅŸlemini baÅŸlatÄ±yor. Yazar baÅŸka bir sayfaya geÃ§meden bu iÅŸlemi gerÃ§ekleÅŸtirebiliyor. Ä°ÅŸlem sonrasÄ± aynÄ± oturum devam ediyor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 81
```python

from flask import Flask, request, jsonify, session
from functools import wraps

app = Flask(__name__)
app.secret_key = 'your_secret_key' # Replace with a strong secret key

# In-memory database for blog posts (simulate)
blog_posts_db = {
    "post1": {"id": "post1", "title": "My First Post", "authorId": "author123", "content": "Hello world!"},
    "post2": {"id": "post2", "title": "Another Post", "authorId": "author123", "content": "More content."},
    "post3": {"id": "post3", "title": "Someone Else's Post", "authorId": "author456", "content": "Not mine."}
}

# Simulate user authentication
def author_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'author':
            return jsonify({"message": "Unauthorized: Author login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'author123' and password == 'password': # Simple mock login
        session['user_id'] = 'author123'
        session['role'] = 'author'
        return jsonify({"message": "Logged in successfully as author."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/logout', methods=['POST'])
def logout():
    session.pop('user_id', None)
    session.pop('role', None)
    return jsonify({"message": "Logged out."}), 200

@app.route('/delete-blog-post', methods=['POST'])
@author_login_required
def delete_blog_post():
    data = request.get_json()
    post_id = data.get('postId')

    if not post_id:
        return jsonify({"message": "Post ID cannot be empty."}), 400

    user_id = session.get('user_id')

    if post_id not in blog_posts_db:
        return jsonify({"message": "Blog post not found."}), 404

    if blog_posts_db[post_id]['authorId'] != user_id:
        return jsonify({"message": "You are not authorized to delete this post."}), 403

    del blog_posts_db[post_id]
    # In a real application, you would delete from the database
    # db.session.delete(post_object)
    # db.session.commit()
    print(f"Blog post {post_id} deleted by {user_id}. Remaining posts: {blog_posts_db}")

    return jsonify({"message": "Blog post deleted successfully."}), 200

@app.route('/my-posts', methods=['GET'])
@author_login_required
def get_my_posts():
    user_id = session.get('user_id')
    author_posts = [post for post_id, post in blog_posts_db.items() if post['authorId'] == user_id]
    return jsonify(author_posts), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "author123", "password": "password"}
    # 4. Then, delete a post: POST to [http://127.0.0.1:5000/delete-blog-post](http://127.0.0.1:5000/delete-blog-post) with {"postId": "post1"}
    #    The session cookie will maintain the login.
    app.run(debug=True)
```
### ğŸ§ª Senaryo 2: Bir blog yÃ¶netim sisteminde yazarlar eski yazÄ±larÄ±nÄ± silmek iÃ§in silme baÄŸlantÄ±sÄ±nÄ± kullanabiliyor. Bu baÄŸlantÄ± HTML sayfasÄ±nda yer alÄ±yor ve silme iÅŸlemini baÅŸlatÄ±yor. Yazar baÅŸka bir sayfaya geÃ§meden bu iÅŸlemi gerÃ§ekleÅŸtirebiliyor. Ä°ÅŸlem sonrasÄ± aynÄ± oturum devam ediyor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 184
```typescript

// --- React Component (e.g., AuthorDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface BlogPost {
  id: string;
  title: string;
  content: string;
  authorId: string;
}

const AuthorDashboard: React.FC = () => {
  const [blogPosts, setBlogPosts] = useState<BlogPost[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Simulate user authentication state
  const isLoggedIn = true; // In a real app, this would be managed by context/redux
  const currentAuthorId = 'author123'; // From authenticated user

  useEffect(() => {
    const fetchPosts = async () => {
      setLoading(true);
      try {
        // In a real app, fetch posts belonging to the logged-in author
        const response = await fetch(`/api/author/${currentAuthorId}/posts`, {
          headers: {
            'Authorization': `Bearer your_auth_token_here`,
          },
        });
        if (!response.ok) {
          throw new Error('Failed to fetch posts.');
        }
        const data: BlogPost[] = await response.json();
        setBlogPosts(data);
      } catch (err) {
        if (err instanceof Error) {
          setError(err.message);
        } else {
          setError('An unknown error occurred.');
        }
      } finally {
        setLoading(false);
      }
    };
    if (isLoggedIn) {
      fetchPosts();
    }
  }, [isLoggedIn, currentAuthorId]);

  const handleDeletePost = async (postId: string) => {
    if (!isLoggedIn) {
      alert('Please log in to delete posts.');
      return;
    }

    if (!window.confirm('Are you sure you want to delete this post?')) {
      return;
    }

    try {
      const response = await fetch('/api/delete-blog-post', {
        method: 'POST', // Using POST for deletion as it's an action, not just retrieving
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_auth_token_here`,
        },
        body: JSON.stringify({ postId }),
      });

      if (response.ok) {
        // Update the state to remove the deleted post from the UI
        setBlogPosts(prevPosts => prevPosts.filter(post => post.id !== postId));
        alert('Post deleted successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to delete post: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error deleting post:', error);
      alert('An error occurred during deletion.');
    }
  };

  if (!isLoggedIn) {
    return <p>Please log in to manage your blog posts.</p>;
  }

  if (loading) {
    return <p>Loading posts...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Blog Posts</h2>
      {blogPosts.length === 0 ? (
        <p>No posts found.</p>
      ) : (
        <ul>
          {blogPosts.map(post => (
            <li key={post.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px' }}>
              <h3>{post.title}</h3>
              <p>{post.content.substring(0, 100)}...</p>
              <button onClick={() => handleDeletePost(post.id)}>Delete</button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default AuthorDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3002;

app.use(bodyParser.json());

// In-memory data store for blog posts
interface BlogPostDB {
  [key: string]: BlogPost;
}

const blogPostsDB: BlogPostDB = {
  "post1": { id: "post1", title: "My First Article", content: "Content of my first article.", authorId: "author123" },
  "post2": { id: "post2", title: "Travel Guide", content: "Exploring new places...", authorId: "author123" },
  "post3": { id: "post3", title: "Recipe Ideas", content: "Delicious recipes...", authorId: "author456" },
};

// Middleware to simulate authentication and authorization for authors
const authorizeAuthor = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  // In a real app, this would involve JWT verification and role checking
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  // Simulate user ID from token
  req.body.userId = 'author123'; // This should come from a verified token
  next();
};

app.post('/api/delete-blog-post', authorizeAuthor, (req: Request, res: Response) => {
  const { postId } = req.body;
  const userId = req.body.userId; // User ID from authenticated session

  if (!postId) {
    return res.status(400).json({ message: 'Post ID is required.' });
  }

  const postToDelete = blogPostsDB[postId];

  if (!postToDelete) {
    return res.status(404).json({ message: 'Blog post not found.' });
  }

  // Check if the authenticated user is the author of the post
  if (postToDelete.authorId !== userId) {
    return res.status(403).json({ message: 'You are not authorized to delete this post.' });
  }

  delete blogPostsDB[postId];
  console.log(`Post ${postId} deleted by ${userId}. Remaining posts:`, blogPostsDB);
  res.status(200).json({ message: 'Blog post deleted successfully.' });
});

// Endpoint to get posts for a specific author (for dashboard loading)
app.get('/api/author/:authorId/posts', authorizeAuthor, (req: Request, res: Response) => {
  const { authorId } = req.params;
  const posts = Object.values(blogPostsDB).filter(post => post.authorId === authorId);
  res.status(200).json(posts);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 2 running on http://localhost:${PORT}`);
});
```
### ğŸ§ª Senaryo 3: Bir dosya paylaÅŸÄ±m platformunda kullanÄ±cÄ±lar paylaÅŸÄ±mlarÄ±nÄ± kaldÄ±rmak iÃ§in kaldÄ±r butonuna tÄ±klÄ±yor. Buton arka planda dosya silme iÅŸlemini gerÃ§ekleÅŸtiriyor. Dosyalar kullanÄ±cÄ±nÄ±n yÃ¶netim panelinde gÃ¼ncelleniyor. Ä°ÅŸlem doÄŸrudan gerÃ§ekleÅŸiyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 41
```csharp

[Authorize]
[HttpDelete("remove-shared-file")]
public async Task<IActionResult> RemoveSharedFile([FromQuery] string fileId)
{
    if (string.IsNullOrEmpty(fileId))
    {
        return BadRequest("File ID cannot be empty.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a FileService or direct database interaction
        // var file = await _dbContext.SharedFiles.FirstOrDefaultAsync(f => f.FileId == fileId && f.OwnerId == userId);
        // if (file == null)
        // {
        //     return NotFound("File not found or you do not have permission to remove it.");
        // }

        // // Simulate file deletion from storage and database
        // _fileStorageService.DeleteFile(file.StoragePath); // e.g., Azure Blob, AWS S3
        // _dbContext.SharedFiles.Remove(file);
        // await _dbContext.SaveChangesAsync();

        // Simulate successful deletion:
        Console.WriteLine($"File {fileId} removed by user {userId}.");

        return Ok(new { Message = "File removed successfully." });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### ğŸ§ª Senaryo 3: Bir dosya paylaÅŸÄ±m platformunda kullanÄ±cÄ±lar paylaÅŸÄ±mlarÄ±nÄ± kaldÄ±rmak iÃ§in kaldÄ±r butonuna tÄ±klÄ±yor. Buton arka planda dosya silme iÅŸlemini gerÃ§ekleÅŸtiriyor. Dosyalar kullanÄ±cÄ±nÄ±n yÃ¶netim panelinde gÃ¼ncelleniyor. Ä°ÅŸlem doÄŸrudan gerÃ§ekleÅŸiyor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 75
```python

from flask import Flask, request, jsonify, session
from functools import wraps
import uuid

app = Flask(__name__)
app.secret_key = 'another_secret_key' # Replace with a strong secret key

# In-memory database for shared files (simulate)
shared_files_db = {
    "file_abc": {"id": "file_abc", "name": "document.pdf", "ownerId": "user123", "path": "/uploads/doc.pdf"},
    "file_xyz": {"id": "file_xyz", "name": "image.jpg", "ownerId": "user123", "path": "/uploads/img.jpg"},
    "file_mno": {"id": "file_mno", "name": "video.mp4", "ownerId": "user456", "path": "/uploads/vid.mp4"}
}

# Simulate user authentication
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({"message": "Unauthorized: User login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    # For this example, we'll just set a user ID
    if username == 'user123':
        session['user_id'] = 'user123'
        return jsonify({"message": "Logged in successfully."}), 200
    return jsonify({"message": "Invalid username."}), 401

@app.route('/remove-shared-file', methods=['DELETE'])
@login_required
def remove_shared_file():
    file_id = request.args.get('fileId') # Get fileId from query parameters

    if not file_id:
        return jsonify({"message": "File ID cannot be empty."}), 400

    user_id = session.get('user_id')

    if file_id not in shared_files_db:
        return jsonify({"message": "File not found."}), 404

    if shared_files_db[file_id]['ownerId'] != user_id:
        return jsonify({"message": "You do not have permission to remove this file."}), 403

    # Simulate deleting the file from storage
    # os.remove(shared_files_db[file_id]['path']) # Example if actual files were stored
    del shared_files_db[file_id]
    # In a real application, you would delete from the database
    # db.session.delete(file_object)
    # db.session.commit()
    print(f"File {file_id} removed by user {user_id}. Remaining files: {shared_files_db}")

    return jsonify({"message": "File removed successfully."}), 200

@app.route('/my-files', methods=['GET'])
@login_required
def get_my_files():
    user_id = session.get('user_id')
    user_files = [file for file_id, file in shared_files_db.items() if file['ownerId'] == user_id]
    return jsonify(user_files), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "user123"}
    # 4. Then, remove a file: DELETE request to [http://127.0.0.1:5000/remove-shared-file?fileId=file_abc](http://127.0.0.1:5000/remove-shared-file?fileId=file_abc)
    #    The session cookie will maintain the login.
    app.run(debug=True)
```
### ğŸ§ª Senaryo 3: Bir dosya paylaÅŸÄ±m platformunda kullanÄ±cÄ±lar paylaÅŸÄ±mlarÄ±nÄ± kaldÄ±rmak iÃ§in kaldÄ±r butonuna tÄ±klÄ±yor. Buton arka planda dosya silme iÅŸlemini gerÃ§ekleÅŸtiriyor. Dosyalar kullanÄ±cÄ±nÄ±n yÃ¶netim panelinde gÃ¼ncelleniyor. Ä°ÅŸlem doÄŸrudan gerÃ§ekleÅŸiyor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 177
```typescript

// --- React Component (e.g., UserDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface SharedFile {
  id: string;
  name: string;
  ownerId: string;
  // Add other file properties as needed
}

const UserDashboard: React.FC = () => {
  const [userFiles, setUserFiles] = useState<SharedFile[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isLoggedIn = true; // Simulates user session status
  const currentUserId = 'user123'; // From authenticated user

  useEffect(() => {
    const fetchUserFiles = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/user/${currentUserId}/files`, {
          headers: {
            'Authorization': `Bearer your_auth_token_here`,
          },
        });
        if (!response.ok) {
          throw new Error('Failed to fetch user files.');
        }
        const data: SharedFile[] = await response.json();
        setUserFiles(data);
      } catch (err) {
        if (err instanceof Error) {
          setError(err.message);
        } else {
          setError('An unknown error occurred.');
        }
      } finally {
        setLoading(false);
      }
    };
    if (isLoggedIn) {
      fetchUserFiles();
    }
  }, [isLoggedIn, currentUserId]);

  const handleRemoveFile = async (fileId: string) => {
    if (!isLoggedIn) {
      alert('Please log in to remove files.');
      return;
    }

    if (!window.confirm('Are you sure you want to remove this file?')) {
      return;
    }

    try {
      const response = await fetch(`/api/remove-shared-file?fileId=${fileId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer your_auth_token_here`,
        },
      });

      if (response.ok) {
        // Update the state to remove the deleted file from the UI
        setUserFiles(prevFiles => prevFiles.filter(file => file.id !== fileId));
        alert('File removed successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to remove file: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error removing file:', error);
      alert('An error occurred during file removal.');
    }
  };

  if (!isLoggedIn) {
    return <p>Please log in to manage your shared files.</p>;
  }

  if (loading) {
    return <p>Loading files...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Shared Files</h2>
      {userFiles.length === 0 ? (
        <p>No files shared yet.</p>
      ) : (
        <ul>
          {userFiles.map(file => (
            <li key={file.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px' }}>
              <span>{file.name}</span>
              <button onClick={() => handleRemoveFile(file.id)} style={{ marginLeft: '20px' }}>Remove</button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default UserDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3003;

app.use(bodyParser.json());

// In-memory data store for shared files
interface SharedFileDB {
  [key: string]: SharedFile;
}

const sharedFilesDB: SharedFileDB = {
  "file_alpha": { id: "file_alpha", name: "Report_Q1.xlsx", ownerId: "user123" },
  "file_beta": { id: "file_beta", name: "Presentation.pptx", ownerId: "user123" },
  "file_gamma": { id: "file_gamma", name: "ProjectPlan.docx", ownerId: "user456" },
};

// Middleware to simulate authentication
const authenticateUser = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.userId = 'user123'; // Simulate user ID from token
  next();
};

app.delete('/api/remove-shared-file', authenticateUser, (req: Request, res: Response) => {
  const fileId = req.query.fileId as string;
  const userId = req.body.userId; // User ID from authenticated session

  if (!fileId) {
    return res.status(400).json({ message: 'File ID is required.' });
  }

  const fileToRemove = sharedFilesDB[fileId];

  if (!fileToRemove) {
    return res.status(404).json({ message: 'File not found.' });
  }

  // Check if the authenticated user is the owner of the file
  if (fileToRemove.ownerId !== userId) {
    return res.status(403).json({ message: 'You are not authorized to remove this file.' });
  }

  delete sharedFilesDB[fileId];
  console.log(`File ${fileId} removed by ${userId}. Remaining files:`, sharedFilesDB);
  res.status(200).json({ message: 'File removed successfully.' });
});

// Endpoint to get files for a specific user (for dashboard loading)
app.get('/api/user/:userId/files', authenticateUser, (req: Request, res: Response) => {
  const { userId } = req.params;
  const files = Object.values(sharedFilesDB).filter(file => file.ownerId === userId);
  res.status(200).json(files);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 3 running on http://localhost:${PORT}`);
});
```
### ğŸ§ª Senaryo 4: Bir Ã§evrimiÃ§i Ã¶deme sisteminde kullanÄ±cÄ±lar kayÄ±tlÄ± kartlarÄ±nÄ± silebiliyor. Kart silme iÅŸlemi kartÄ±n yanÄ±ndaki ikon ile yapÄ±lÄ±yor. Ä°ÅŸlem sonucunda kart listesi yenileniyor. KullanÄ±cÄ± oturumu aÃ§Ä±k olduÄŸunda iÅŸlem gerÃ§ekleÅŸebiliyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 42
```csharp

[Authorize]
[HttpDelete("delete-payment-card")]
public async Task<IActionResult> DeletePaymentCard([FromQuery] string cardId)
{
    if (string.IsNullOrEmpty(cardId))
    {
        return BadRequest("Card ID cannot be empty.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a PaymentService or direct database interaction for card management
        // var paymentCard = await _dbContext.PaymentCards.FirstOrDefaultAsync(pc => pc.CardId == cardId && pc.UserId == userId);
        // if (paymentCard == null)
        // {
        //     return NotFound("Payment card not found or you do not own this card.");
        // }

        // // In a real system, you might interact with a payment gateway to de-tokenize/delete the card reference
        // // _paymentGatewayService.DeleteCardToken(paymentCard.Token);

        // _dbContext.PaymentCards.Remove(paymentCard);
        // await _dbContext.SaveChangesAsync();

        // Simulate successful deletion:
        Console.WriteLine($"Payment card {cardId} deleted by user {userId}.");

        return Ok(new { Message = "Payment card deleted successfully.", DeletedCardId = cardId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### ğŸ§ª Senaryo 4: Bir Ã§evrimiÃ§i Ã¶deme sisteminde kullanÄ±cÄ±lar kayÄ±tlÄ± kartlarÄ±nÄ± silebiliyor. Kart silme iÅŸlemi kartÄ±n yanÄ±ndaki ikon ile yapÄ±lÄ±yor. Ä°ÅŸlem sonucunda kart listesi yenileniyor. KullanÄ±cÄ± oturumu aÃ§Ä±k olduÄŸunda iÅŸlem gerÃ§ekleÅŸebiliyor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 72
```python

from flask import Flask, request, jsonify, session
from functools import wraps
import uuid

app = Flask(__name__)
app.secret_key = 'payment_secret_key' # Replace with a strong secret key

# In-memory database for payment cards (simulate)
payment_cards_db = {
    "card_111": {"id": "card_111", "last4": "1111", "cardType": "Visa", "userId": "user_pay123"},
    "card_222": {"id": "card_222", "last4": "2222", "cardType": "MasterCard", "userId": "user_pay123"},
    "card_333": {"id": "card_333", "last4": "3333", "cardType": "Amex", "userId": "user_pay456"}
}

# Simulate user authentication
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({"message": "Unauthorized: User login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    if username == 'user_pay123':
        session['user_id'] = 'user_pay123'
        return jsonify({"message": "Logged in successfully to payment system."}), 200
    return jsonify({"message": "Invalid username."}), 401

@app.route('/delete-payment-card', methods=['DELETE'])
@login_required
def delete_payment_card():
    card_id = request.args.get('cardId')

    if not card_id:
        return jsonify({"message": "Card ID cannot be empty."}), 400

    user_id = session.get('user_id')

    if card_id not in payment_cards_db:
        return jsonify({"message": "Payment card not found."}), 404

    if payment_cards_db[card_id]['userId'] != user_id:
        return jsonify({"message": "You do not own this card."}), 403

    del payment_cards_db[card_id]
    # In a real system, you'd interact with a payment gateway and update your database
    print(f"Payment card {card_id} deleted by user {user_id}. Remaining cards: {payment_cards_db}")

    # Return the updated list of cards
    updated_card_list = [card for card_key, card in payment_cards_db.items() if card['userId'] == user_id]
    return jsonify({"message": "Payment card deleted successfully.", "updatedCardList": updated_card_list}), 200

@app.route('/my-cards', methods=['GET'])
@login_required
def get_my_cards():
    user_id = session.get('user_id')
    user_cards = [card for card_key, card in payment_cards_db.items() if card['userId'] == user_id]
    return jsonify(user_cards), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "user_pay123"}
    # 4. Then, delete a card: DELETE request to [http://127.0.0.1:5000/delete-payment-card?cardId=card_111](http://127.0.0.1:5000/delete-payment-card?cardId=card_111)
    #    The session cookie will maintain the login.
    app.run(debug=True)
```
### ğŸ§ª Senaryo 4: Bir Ã§evrimiÃ§i Ã¶deme sisteminde kullanÄ±cÄ±lar kayÄ±tlÄ± kartlarÄ±nÄ± silebiliyor. Kart silme iÅŸlemi kartÄ±n yanÄ±ndaki ikon ile yapÄ±lÄ±yor. Ä°ÅŸlem sonucunda kart listesi yenileniyor. KullanÄ±cÄ± oturumu aÃ§Ä±k olduÄŸunda iÅŸlem gerÃ§ekleÅŸebiliyor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 184
```typescript

// --- React Component (e.g., PaymentMethodSettings.tsx) ---
import React, { useState, useEffect } from 'react';

interface PaymentCard {
  id: string;
  last4: string;
  cardType: string;
  userId: string;
  // Add other card details you might display
}

const PaymentMethodSettings: React.FC = () => {
  const [paymentCards, setPaymentCards] = useState<PaymentCard[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isLoggedIn = true; // Simulates user session status
  const currentUserId = 'user_pay123'; // From authenticated user

  const fetchPaymentCards = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/user/${currentUserId}/payment-cards`, {
        headers: {
          'Authorization': `Bearer your_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch payment cards.');
      }
      const data: PaymentCard[] = await response.json();
      setPaymentCards(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isLoggedIn) {
      fetchPaymentCards();
    }
  }, [isLoggedIn, currentUserId]);

  const handleDeleteCard = async (cardId: string) => {
    if (!isLoggedIn) {
      alert('Please log in to manage payment methods.');
      return;
    }

    if (!window.confirm('Are you sure you want to delete this card? This action cannot be undone.')) {
      return;
    }

    try {
      const response = await fetch(`/api/delete-payment-card?cardId=${cardId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer your_auth_token_here',
        },
      });

      if (response.ok) {
        // Option 1: Re-fetch the entire list to ensure consistency
        await fetchPaymentCards();
        alert('Card deleted successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to delete card: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error deleting card:', error);
      alert('An error occurred during card deletion.');
    }
  };

  if (!isLoggedIn) {
    return <p>Please log in to manage your payment methods.</p>;
  }

  if (loading) {
    return <p>Loading payment cards...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Payment Methods</h2>
      {paymentCards.length === 0 ? (
        <p>No payment cards registered yet.</p>
      ) : (
        <ul>
          {paymentCards.map(card => (
            <li key={card.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <span>**** **** **** {card.last4} ({card.cardType})</span>
              <button onClick={() => handleDeleteCard(card.id)} style={{ background: 'none', border: 'none', cursor: 'pointer', color: 'red', fontSize: '1.2em' }}>
                ğŸ—‘ï¸ {/* Trash can icon */}
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default PaymentMethodSettings;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3004;

app.use(bodyParser.json());

// In-memory data store for payment cards
interface PaymentCardDB {
  [key: string]: PaymentCard;
}

const paymentCardsDB: PaymentCardDB = {
  "card_aaa": { id: "card_aaa", last4: "1234", cardType: "Visa", userId: "user_pay123" },
  "card_bbb": { id: "card_bbb", last4: "5678", cardType: "MasterCard", userId: "user_pay123" },
  "card_ccc": { id: "card_ccc", last4: "9012", cardType: "Amex", userId: "user_pay456" },
};

// Middleware to simulate authentication
const authenticateUser = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.userId = 'user_pay123'; // Simulate user ID from token
  next();
};

app.delete('/api/delete-payment-card', authenticateUser, (req: Request, res: Response) => {
  const cardId = req.query.cardId as string;
  const userId = req.body.userId; // User ID from authenticated session

  if (!cardId) {
    return res.status(400).json({ message: 'Card ID is required.' });
  }

  const cardToDelete = paymentCardsDB[cardId];

  if (!cardToDelete) {
    return res.status(404).json({ message: 'Payment card not found.' });
  }

  // Check if the authenticated user owns this card
  if (cardToDelete.userId !== userId) {
    return res.status(403).json({ message: 'You are not authorized to delete this card.' });
  }

  delete paymentCardsDB[cardId];
  console.log(`Payment card ${cardId} deleted by ${userId}. Remaining cards:`, paymentCardsDB);

  // Return updated list of cards for the user
  const updatedCardList = Object.values(paymentCardsDB).filter(card => card.userId === userId);
  res.status(200).json({ message: 'Payment card deleted successfully.', updatedCardList });
});

// Endpoint to get payment cards for a specific user (for dashboard loading)
app.get('/api/user/:userId/payment-cards', authenticateUser, (req: Request, res: Response) => {
  const { userId } = req.params;
  const cards = Object.values(paymentCardsDB).filter(card => card.userId === userId);
  res.status(200).json(cards);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 4 running on http://localhost:${PORT}`);
});
```
### ğŸ§ª Senaryo 5: Bir iÃ§erik yÃ¶netim sisteminde yÃ¶neticiler sayfa yayÄ±n durumunu deÄŸiÅŸtirebiliyor. YayÄ±ndan kaldÄ±rma iÅŸlemi baÄŸlantÄ± tÄ±klamasÄ± ile yapÄ±lÄ±yor. Sistem bu iÅŸlemi gerÃ§ekleÅŸtirip sayfa durumunu gÃ¼ncelliyor. YÃ¶neticiler iÅŸlem sonrasÄ± aynÄ± panelde kalÄ±yor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 45
```csharp

[Authorize(Roles = "Administrator")]
[HttpPost("change-page-publication-status")]
public async Task<IActionResult> ChangePagePublicationStatus([FromBody] ChangePageStatusRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.PageId))
    {
        return BadRequest("Page ID is required.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a PageService or direct database interaction
        // var page = await _dbContext.CmsPages.FindAsync(request.PageId);
        // if (page == null)
        // {
        //     return NotFound("Page not found.");
        // }

        // page.IsPublished = request.IsPublished;
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"Page {request.PageId} publication status changed to {request.IsPublished} by admin {userId}.");

        return Ok(new { Message = "Page publication status updated successfully.", PageId = request.PageId, IsPublished = request.IsPublished });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class ChangePageStatusRequest
{
    public string PageId { get; set; }
    public bool IsPublished { get; set; }
}
```
### ğŸ§ª Senaryo 5: Bir iÃ§erik yÃ¶netim sisteminde yÃ¶neticiler sayfa yayÄ±n durumunu deÄŸiÅŸtirebiliyor. YayÄ±ndan kaldÄ±rma iÅŸlemi baÄŸlantÄ± tÄ±klamasÄ± ile yapÄ±lÄ±yor. Sistem bu iÅŸlemi gerÃ§ekleÅŸtirip sayfa durumunu gÃ¼ncelliyor. YÃ¶neticiler iÅŸlem sonrasÄ± aynÄ± panelde kalÄ±yor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 69
```python

from flask import Flask, request, jsonify, session
from functools import wraps

app = Flask(__name__)
app.secret_key = 'cms_secret_key'

# In-memory database for CMS pages (simulate)
cms_pages_db = {
    "page_home": {"id": "page_home", "title": "Homepage", "isPublished": True},
    "page_about": {"id": "page_about", "title": "About Us", "isPublished": True},
    "page_draft": {"id": "page_draft", "title": "Draft Page", "isPublished": False}
}

# Simulate administrator authentication
def admin_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'admin':
            return jsonify({"message": "Unauthorized: Administrator login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'admin' and password == 'adminpass': # Mock admin login
        session['user_id'] = 'admin123'
        session['role'] = 'admin'
        return jsonify({"message": "Logged in successfully as admin."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/change-page-publication-status', methods=['POST'])
@admin_login_required
def change_page_publication_status():
    data = request.get_json()
    page_id = data.get('pageId')
    is_published = data.get('isPublished')

    if not page_id or is_published is None:
        return jsonify({"message": "Page ID and publication status are required."}), 400

    if page_id not in cms_pages_db:
        return jsonify({"message": "Page not found."}), 404

    cms_pages_db[page_id]['isPublished'] = is_published
    # In a real application, you would update the database
    # db.session.commit()
    print(f"Page {page_id} publication status changed to {is_published} by admin {session.get('user_id')}.")

    return jsonify({"message": "Page publication status updated successfully.",
                    "page": cms_pages_db[page_id]}), 200

@app.route('/admin/pages', methods=['GET'])
@admin_login_required
def get_admin_pages():
    return jsonify(list(cms_pages_db.values())), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "admin", "password": "adminpass"}
    # 4. Then, change page status: POST to [http://127.0.0.1:5000/change-page-publication-status](http://127.0.0.1:5000/change-page-publication-status)
    #    with {"pageId": "page_home", "isPublished": false}
    app.run(debug=True)
```
### ğŸ§ª Senaryo 5: Bir iÃ§erik yÃ¶netim sisteminde yÃ¶neticiler sayfa yayÄ±n durumunu deÄŸiÅŸtirebiliyor. YayÄ±ndan kaldÄ±rma iÅŸlemi baÄŸlantÄ± tÄ±klamasÄ± ile yapÄ±lÄ±yor. Sistem bu iÅŸlemi gerÃ§ekleÅŸtirip sayfa durumunu gÃ¼ncelliyor. YÃ¶neticiler iÅŸlem sonrasÄ± aynÄ± panelde kalÄ±yor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 183
```typescript

// --- React Component (e.g., AdminPageManagement.tsx) ---
import React, { useState, useEffect } from 'react';

interface CmsPage {
  id: string;
  title: string;
  isPublished: boolean;
  // Add other page properties as needed
}

const AdminPageManagement: React.FC = () => {
  const [pages, setPages] = useState<CmsPage[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isAdminLoggedIn = true; // Simulates admin session status

  const fetchPages = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/admin/pages', {
        headers: {
          'Authorization': `Bearer your_admin_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch pages.');
      }
      const data: CmsPage[] = await response.json();
      setPages(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isAdminLoggedIn) {
      fetchPages();
    }
  }, [isAdminLoggedIn]);

  const handleChangePublicationStatus = async (pageId: string, currentStatus: boolean) => {
    if (!isAdminLoggedIn) {
      alert('You must be logged in as an administrator to change page status.');
      return;
    }

    const newStatus = !currentStatus; // Toggle status
    const actionText = newStatus ? 'publish' : 'unpublish';

    if (!window.confirm(`Are you sure you want to ${actionText} this page?`)) {
      return;
    }

    try {
      const response = await fetch('/api/change-page-publication-status', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_admin_auth_token_here`,
        },
        body: JSON.stringify({ pageId, isPublished: newStatus }),
      });

      if (response.ok) {
        // Update the state to reflect the new status
        setPages(prevPages =>
          prevPages.map(page =>
            page.id === pageId ? { ...page, isPublished: newStatus } : page
          )
        );
        alert(`Page status updated successfully to ${newStatus ? 'Published' : 'Unpublished'}!`);
      } else {
        const errorData = await response.json();
        alert(`Failed to update page status: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error changing publication status:', error);
      alert('An error occurred during status update.');
    }
  };

  if (!isAdminLoggedIn) {
    return <p>Access denied. Please log in as an administrator.</p>;
  }

  if (loading) {
    return <p>Loading pages...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>CMS Page Management</h2>
      {pages.length === 0 ? (
        <p>No pages found.</p>
      ) : (
        <ul>
          {pages.map(page => (
            <li key={page.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <span>{page.title} - Status: {page.isPublished ? 'Published' : 'Unpublished'}</span>
              <button onClick={() => handleChangePublicationStatus(page.id, page.isPublished)}>
                {page.isPublished ? 'Unpublish' : 'Publish'}
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default AdminPageManagement;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3005;

app.use(bodyParser.json());

// In-memory data store for CMS pages
interface CmsPageDB {
  [key: string]: CmsPage;
}

const cmsPagesDB: CmsPageDB = {
  "page_A": { id: "page_A", title: "About Us", isPublished: true },
  "page_B": { id: "page_B", title: "Services", isPublished: true },
  "page_C": { id: "page_C", title: "Contact Us (Draft)", isPublished: false },
};

// Middleware to simulate administrator authentication
const authorizeAdmin = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  // In a real app, verify JWT and check for admin role
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  // Simulate admin user ID
  req.body.adminId = 'admin123';
  next();
};

app.post('/api/change-page-publication-status', authorizeAdmin, (req: Request, res: Response) => {
  const { pageId, isPublished } = req.body;
  const adminId = req.body.adminId; // Admin ID from authenticated session

  if (!pageId || typeof isPublished !== 'boolean') {
    return res.status(400).json({ message: 'Page ID and publication status are required.' });
  }

  const pageToUpdate = cmsPagesDB[pageId];

  if (!pageToUpdate) {
    return res.status(404).json({ message: 'Page not found.' });
  }

  pageToUpdate.isPublished = isPublished;
  console.log(`Page ${pageId} publication status set to ${isPublished} by admin ${adminId}.`);
  res.status(200).json({ message: 'Page publication status updated successfully.', page: pageToUpdate });
});

// Endpoint to get all CMS pages for admin panel
app.get('/api/admin/pages', authorizeAdmin, (req: Request, res: Response) => {
  res.status(200).json(Object.values(cmsPagesDB));
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 5 running on http://localhost:${PORT}`);
});
```
### ğŸ§ª Senaryo 6: Bir haber uygulamasÄ±nda editÃ¶rler kullanÄ±cÄ± yorumlarÄ±nÄ± gizleyebiliyor. Yorumun yanÄ±ndaki gizle baÄŸlantÄ±sÄ± ile yorum pasif hale getiriliyor. EditÃ¶r bu iÅŸlemi gerÃ§ekleÅŸtirerek yorum durumunu deÄŸiÅŸtiriyor. Ä°ÅŸlem sonucu yorum listesi gÃ¼ncelleniyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 47
```csharp

[Authorize(Roles = "Editor")]
[HttpPost("hide-user-comment")]
public async Task<IActionResult> HideUserComment([FromBody] HideCommentRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.CommentId))
    {
        return BadRequest("Comment ID is required.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a CommentService or direct database interaction
        // var comment = await _dbContext.NewsComments.FindAsync(request.CommentId);
        // if (comment == null)
        // {
        //     return NotFound("Comment not found.");
        // }

        // // Set the comment status to hidden/inactive
        // comment.IsHidden = true; // Or comment.Status = CommentStatus.Hidden;
        // comment.HiddenByEditorId = userId;
        // comment.HiddenDate = DateTime.UtcNow;
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"Comment {request.CommentId} hidden by editor {userId}.");

        return Ok(new { Message = "Comment hidden successfully.", CommentId = request.CommentId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class HideCommentRequest
{
    public string CommentId { get; set; }
}
```
### ğŸ§ª Senaryo 6: Bir haber uygulamasÄ±nda editÃ¶rler kullanÄ±cÄ± yorumlarÄ±nÄ± gizleyebiliyor. Yorumun yanÄ±ndaki gizle baÄŸlantÄ±sÄ± ile yorum pasif hale getiriliyor. EditÃ¶r bu iÅŸlemi gerÃ§ekleÅŸtirerek yorum durumunu deÄŸiÅŸtiriyor. Ä°ÅŸlem sonucu yorum listesi gÃ¼ncelleniyor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 68
```python

from flask import Flask, request, jsonify, session
from functools import wraps

app = Flask(__name__)
app.secret_key = 'news_app_secret'

# In-memory database for comments (simulate)
news_comments_db = {
    "comment_001": {"id": "comment_001", "text": "Great article!", "author": "userA", "isHidden": False},
    "comment_002": {"id": "comment_002", "text": "Spam comment.", "author": "userB", "isHidden": False},
    "comment_003": {"id": "comment_003", "text": "Interesting points.", "author": "userC", "isHidden": False}
}

# Simulate editor authentication
def editor_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'editor':
            return jsonify({"message": "Unauthorized: Editor login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'editor' and password == 'editorpass': # Mock editor login
        session['user_id'] = 'editor123'
        session['role'] = 'editor'
        return jsonify({"message": "Logged in successfully as editor."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/hide-user-comment', methods=['POST'])
@editor_login_required
def hide_user_comment():
    data = request.get_json()
    comment_id = data.get('commentId')

    if not comment_id:
        return jsonify({"message": "Comment ID is required."}), 400

    if comment_id not in news_comments_db:
        return jsonify({"message": "Comment not found."}), 404

    news_comments_db[comment_id]['isHidden'] = True
    # In a real application, you would update the database
    # db.session.commit()
    print(f"Comment {comment_id} hidden by editor {session.get('user_id')}.")

    # Return the updated list of comments for the editor panel
    return jsonify({"message": "Comment hidden successfully.",
                    "updatedCommentList": list(news_comments_db.values())}), 200

@app.route('/editor/comments', methods=['GET'])
@editor_login_required
def get_editor_comments():
    return jsonify(list(news_comments_db.values())), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "editor", "password": "editorpass"}
    # 4. Then, hide a comment: POST to [http://127.0.0.1:5000/hide-user-comment](http://127.0.0.1:5000/hide-user-comment) with {"commentId": "comment_002"}
    app.run(debug=True)
```
### ğŸ§ª Senaryo 6: Bir haber uygulamasÄ±nda editÃ¶rler kullanÄ±cÄ± yorumlarÄ±nÄ± gizleyebiliyor. Yorumun yanÄ±ndaki gizle baÄŸlantÄ±sÄ± ile yorum pasif hale getiriliyor. EditÃ¶r bu iÅŸlemi gerÃ§ekleÅŸtirerek yorum durumunu deÄŸiÅŸtiriyor. Ä°ÅŸlem sonucu yorum listesi gÃ¼ncelleniyor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 183
```typescript

// --- React Component (e.g., EditorCommentModeration.tsx) ---
import React, { useState, useEffect } from 'react';

interface UserComment {
  id: string;
  text: string;
  author: string;
  isHidden: boolean;
  // Add other comment properties
}

const EditorCommentModeration: React.FC = () => {
  const [comments, setComments] = useState<UserComment[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isEditorLoggedIn = true; // Simulates editor session status

  const fetchComments = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/editor/comments', {
        headers: {
          'Authorization': `Bearer your_editor_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch comments.');
      }
      const data: UserComment[] = await response.json();
      setComments(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isEditorLoggedIn) {
      fetchComments();
    }
  }, [isEditorLoggedIn]);

  const handleToggleCommentVisibility = async (commentId: string, currentStatus: boolean) => {
    if (!isEditorLoggedIn) {
      alert('You must be logged in as an editor to moderate comments.');
      return;
    }

    const actionText = currentStatus ? 'unhide' : 'hide'; // If currently hidden, we want to unhide
    if (!window.confirm(`Are you sure you want to ${actionText} this comment?`)) {
      return;
    }

    try {
      const response = await fetch('/api/toggle-comment-visibility', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_editor_auth_token_here`,
        },
        body: JSON.stringify({ commentId, isHidden: !currentStatus }), // Toggle the status
      });

      if (response.ok) {
        // Update the state to reflect the new visibility
        setComments(prevComments =>
          prevComments.map(comment =>
            comment.id === commentId ? { ...comment, isHidden: !currentStatus } : comment
          )
        );
        alert(`Comment status updated successfully!`);
      } else {
        const errorData = await response.json();
        alert(`Failed to update comment status: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error toggling comment visibility:', error);
      alert('An error occurred during status update.');
    }
  };

  if (!isEditorLoggedIn) {
    return <p>Access denied. Please log in as an editor.</p>;
  }

  if (loading) {
    return <p>Loading comments...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>User Comment Moderation</h2>
      {comments.length === 0 ? (
        <p>No comments to moderate.</p>
      ) : (
        <ul>
          {comments.map(comment => (
            <li key={comment.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', backgroundColor: comment.isHidden ? '#ffe0e0' : 'white' }}>
              <div>
                <p><strong>{comment.author}:</strong> {comment.text}</p>
                <small>Status: {comment.isHidden ? 'Hidden' : 'Visible'}</small>
              </div>
              <button onClick={() => handleToggleCommentVisibility(comment.id, comment.isHidden)}>
                {comment.isHidden ? 'Unhide' : 'Hide'}
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default EditorCommentModeration;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3006;

app.use(bodyParser.json());

// In-memory data store for user comments
interface UserCommentDB {
  [key: string]: UserComment;
}

const newsCommentsDB: UserCommentDB = {
  "comment_X": { id: "comment_X", text: "Great article!", author: "Alice", isHidden: false },
  "comment_Y": { id: "comment_Y", text: "This is spam.", author: "Bob", isHidden: false },
  "comment_Z": { id: "comment_Z", text: "Very insightful.", author: "Charlie", isHidden: true },
};

// Middleware to simulate editor authentication
const authorizeEditor = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.editorId = 'editor123'; // Simulate editor ID
  next();
};

app.post('/api/toggle-comment-visibility', authorizeEditor, (req: Request, res: Response) => {
  const { commentId, isHidden } = req.body;
  const editorId = req.body.editorId;

  if (!commentId || typeof isHidden !== 'boolean') {
    return res.status(400).json({ message: 'Comment ID and visibility status are required.' });
  }

  const commentToUpdate = newsCommentsDB[commentId];

  if (!commentToUpdate) {
    return res.status(404).json({ message: 'Comment not found.' });
  }

  commentToUpdate.isHidden = isHidden;
  console.log(`Comment ${commentId} visibility set to ${isHidden} by editor ${editorId}.`);
  res.status(200).json({ message: 'Comment visibility updated successfully.', comment: commentToUpdate });
});

// Endpoint to get all comments for editor panel
app.get('/api/editor/comments', authorizeEditor, (req: Request, res: Response) => {
  res.status(200).json(Object.values(newsCommentsDB));
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 6 running on http://localhost:${PORT}`);
});
```
### ğŸ§ª Senaryo 7: Bir mÃ¼zik paylaÅŸÄ±m platformunda sanatÃ§Ä±lar ÅŸarkÄ±larÄ±nÄ± kaldÄ±rmak iÃ§in sil butonunu kullanÄ±yor. Silme iÅŸlemi hÄ±zla gerÃ§ekleÅŸiyor ve yeni ekran aÃ§Ä±lmadan tamamlanÄ±yor. Oturum aÃ§Ä±k olduÄŸunda iÅŸlem yapÄ±labiliyor. Geri alma Ã¶zelliÄŸi sunulmuyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 42
```csharp

[Authorize(Roles = "Artist")]
[HttpDelete("delete-music-track")]
public async Task<IActionResult> DeleteMusicTrack([FromQuery] string trackId)
{
    if (string.IsNullOrEmpty(trackId))
    {
        return BadRequest("Track ID cannot be empty.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a MusicService or direct database interaction
        // var musicTrack = await _dbContext.MusicTracks.FirstOrDefaultAsync(t => t.TrackId == trackId && t.ArtistId == userId);
        // if (musicTrack == null)
        // {
        //     return NotFound("Music track not found or you are not the artist.");
        // }

        // // Simulate deletion from storage (e.g., S3, Blob Storage)
        // _fileStorageService.DeleteFile(musicTrack.FilePath);

        // _dbContext.MusicTracks.Remove(musicTrack);
        // await _dbContext.SaveChangesAsync();

        // Simulate successful deletion:
        Console.WriteLine($"Music track {trackId} deleted by artist {userId}. (No undo)");

        return Ok(new { Message = "Music track deleted successfully.", DeletedTrackId = trackId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### ğŸ§ª Senaryo 7: Bir mÃ¼zik paylaÅŸÄ±m platformunda sanatÃ§Ä±lar ÅŸarkÄ±larÄ±nÄ± kaldÄ±rmak iÃ§in sil butonunu kullanÄ±yor. Silme iÅŸlemi hÄ±zla gerÃ§ekleÅŸiyor ve yeni ekran aÃ§Ä±lmadan tamamlanÄ±yor. Oturum aÃ§Ä±k olduÄŸunda iÅŸlem yapÄ±labiliyor. Geri alma Ã¶zelliÄŸi sunulmuyor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 72
```python

from flask import Flask, request, jsonify, session
from functools import wraps
import uuid

app = Flask(__name__)
app.secret_key = 'music_secret_key'

# In-memory database for music tracks (simulate)
music_tracks_db = {
    "song_001": {"id": "song_001", "title": "My New Song", "artistId": "artist_a", "genre": "Pop"},
    "song_002": {"id": "song_002", "title": "Instrumental Peace", "artistId": "artist_a", "genre": "Relaxation"},
    "song_003": {"id": "song_003", "title": "Cover Tune", "artistId": "artist_b", "genre": "Rock"}
}

# Simulate artist authentication
def artist_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'artist':
            return jsonify({"message": "Unauthorized: Artist login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'artist_a' and password == 'musicpass': # Mock artist login
        session['user_id'] = 'artist_a'
        session['role'] = 'artist'
        return jsonify({"message": "Logged in successfully as artist."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/delete-music-track', methods=['DELETE'])
@artist_login_required
def delete_music_track():
    track_id = request.args.get('trackId')

    if not track_id:
        return jsonify({"message": "Track ID cannot be empty."}), 400

    user_id = session.get('user_id')

    if track_id not in music_tracks_db:
        return jsonify({"message": "Music track not found."}), 404

    if music_tracks_db[track_id]['artistId'] != user_id:
        return jsonify({"message": "You are not authorized to delete this track."}), 403

    del music_tracks_db[track_id]
    # In a real application, you would delete the file from storage and remove from database
    print(f"Music track {track_id} deleted by artist {user_id}. Remaining tracks: {music_tracks_db}")

    return jsonify({"message": "Music track deleted successfully."}), 200

@app.route('/my-tracks', methods=['GET'])
@artist_login_required
def get_my_tracks():
    user_id = session.get('user_id')
    artist_tracks = [track for track_id, track in music_tracks_db.items() if track['artistId'] == user_id]
    return jsonify(artist_tracks), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "artist_a", "password": "musicpass"}
    # 4. Then, delete a track: DELETE request to [http://127.0.0.1:5000/delete-music-track?trackId=song_001](http://127.0.0.1:5000/delete-music-track?trackId=song_001)
    app.run(debug=True)
```
### ğŸ§ª Senaryo 7: Bir mÃ¼zik paylaÅŸÄ±m platformunda sanatÃ§Ä±lar ÅŸarkÄ±larÄ±nÄ± kaldÄ±rmak iÃ§in sil butonunu kullanÄ±yor. Silme iÅŸlemi hÄ±zla gerÃ§ekleÅŸiyor ve yeni ekran aÃ§Ä±lmadan tamamlanÄ±yor. Oturum aÃ§Ä±k olduÄŸunda iÅŸlem yapÄ±labiliyor. Geri alma Ã¶zelliÄŸi sunulmuyor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 181
```typescript

// --- React Component (e.g., ArtistDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface MusicTrack {
  id: string;
  title: string;
  artistId: string;
  genre: string;
  // Add other track details
}

const ArtistDashboard: React.FC = () => {
  const [musicTracks, setMusicTracks] = useState<MusicTrack[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isArtistLoggedIn = true; // Simulates artist session status
  const currentArtistId = 'artist_a'; // From authenticated artist

  const fetchMusicTracks = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/artist/${currentArtistId}/tracks`, {
        headers: {
          'Authorization': `Bearer your_artist_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch music tracks.');
      }
      const data: MusicTrack[] = await response.json();
      setMusicTracks(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isArtistLoggedIn) {
      fetchMusicTracks();
    }
  }, [isArtistLoggedIn, currentArtistId]);

  const handleDeleteTrack = async (trackId: string) => {
    if (!isArtistLoggedIn) {
      alert('Please log in as an artist to delete tracks.');
      return;
    }

    if (!window.confirm('Are you sure you want to delete this track? This action cannot be undone.')) {
      return;
    }

    try {
      const response = await fetch(`/api/delete-music-track?trackId=${trackId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer your_artist_auth_token_here`,
        },
      });

      if (response.ok) {
        // Update the state to remove the deleted track from the UI
        setMusicTracks(prevTracks => prevTracks.filter(track => track.id !== trackId));
        alert('Music track deleted successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to delete track: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error deleting track:', error);
      alert('An error occurred during track deletion.');
    }
  };

  if (!isArtistLoggedIn) {
    return <p>Access denied. Please log in as an artist.</p>;
  }

  if (loading) {
    return <p>Loading music tracks...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Music Tracks</h2>
      {musicTracks.length === 0 ? (
        <p>No tracks uploaded yet.</p>
      ) : (
        <ul>
          {musicTracks.map(track => (
            <li key={track.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <span>{track.title} ({track.genre})</span>
              <button onClick={() => handleDeleteTrack(track.id)} style={{ background: 'none', border: 'none', cursor: 'pointer', color: 'red', fontSize: '1em' }}>
                Delete
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default ArtistDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3007;

app.use(bodyParser.json());

// In-memory data store for music tracks
interface MusicTrackDB {
  [key: string]: MusicTrack;
}

const musicTracksDB: MusicTrackDB = {
  "track_101": { id: "track_101", title: "Sunset Melodies", artistId: "artist_a", genre: "Chillwave" },
  "track_102": { id: "track_102", title: "City Lights", artistId: "artist_a", genre: "Electronic" },
  "track_103": { id: "track_103", title: "Acoustic Dreams", artistId: "artist_b", genre: "Acoustic" },
};

// Middleware to simulate artist authentication
const authorizeArtist = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.artistId = 'artist_a'; // Simulate artist ID from token
  next();
};

app.delete('/api/delete-music-track', authorizeArtist, (req: Request, res: Response) => {
  const trackId = req.query.trackId as string;
  const artistId = req.body.artistId; // Artist ID from authenticated session

  if (!trackId) {
    return res.status(400).json({ message: 'Track ID is required.' });
  }

  const trackToDelete = musicTracksDB[trackId];

  if (!trackToDelete) {
    return res.status(404).json({ message: 'Music track not found.' });
  }

  // Check if the authenticated artist owns this track
  if (trackToDelete.artistId !== artistId) {
    return res.status(403).json({ message: 'You are not authorized to delete this track.' });
  }

  delete musicTracksDB[trackId];
  console.log(`Music track ${trackId} deleted by artist ${artistId}. Remaining tracks:`, musicTracksDB);
  res.status(200).json({ message: 'Music track deleted successfully.' });
});

// Endpoint to get tracks for a specific artist (for dashboard loading)
app.get('/api/artist/:artistId/tracks', authorizeArtist, (req: Request, res: Response) => {
  const { artistId } = req.params;
  const tracks = Object.values(musicTracksDB).filter(track => track.artistId === artistId);
  res.status(200).json(tracks);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 7 running on http://localhost:${PORT}`);
});
```
### ğŸ§ª Senaryo 8: Bir forum uygulamasÄ±nda yÃ¶neticiler kullanÄ±cÄ± profillerini askÄ±ya alabiliyor. AskÄ±ya alma iÅŸlemi profildeki butonla tetikleniyor. Ä°ÅŸlem arka planda Ã§alÄ±ÅŸÄ±p yÃ¶netici panelini gÃ¼ncelliyor. Onay kutusu gÃ¶sterilmiyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 52
```csharp

[Authorize(Roles = "Moderator, Admin")]
[HttpPost("suspend-user-profile")]
public async Task<IActionResult> SuspendUserProfile([FromBody] SuspendUserRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.UserId))
    {
        return BadRequest("User ID is required.");
    }

    var moderatorId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(moderatorId))
    {
        return Unauthorized("User session is not active or moderator ID not found.");
    }

    try
    {
        // Assume a UserService or direct database interaction
        // var userProfile = await _dbContext.UserProfiles.FindAsync(request.UserId);
        // if (userProfile == null)
        // {
        //     return NotFound("User profile not found.");
        // }

        // // Prevent suspending an admin or self-suspension (important security consideration)
        // if (userProfile.Role == UserRole.Admin || userProfile.UserId == moderatorId)
        // {
        //     return Forbid("Cannot suspend this user.");
        // }

        // userProfile.IsSuspended = true;
        // userProfile.SuspendedBy = moderatorId;
        // userProfile.SuspensionDate = DateTime.UtcNow;
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"User profile {request.UserId} suspended by moderator {moderatorId}.");

        return Ok(new { Message = "User profile suspended successfully.", SuspendedUserId = request.UserId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class SuspendUserRequest
{
    public string UserId { get; set; }
}
```
### ğŸ§ª Senaryo 8: Bir forum uygulamasÄ±nda yÃ¶neticiler kullanÄ±cÄ± profillerini askÄ±ya alabiliyor. AskÄ±ya alma iÅŸlemi profildeki butonla tetikleniyor. Ä°ÅŸlem arka planda Ã§alÄ±ÅŸÄ±p yÃ¶netici panelini gÃ¼ncelliyor. Onay kutusu gÃ¶sterilmiyor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 82
```python

from flask import Flask, request, jsonify, session
from functools import wraps

app = Flask(__name__)
app.secret_key = 'forum_secret_key'

# In-memory database for user profiles (simulate)
user_profiles_db = {
    "user_alice": {"id": "user_alice", "username": "Alice", "role": "user", "isSuspended": False},
    "user_bob": {"id": "user_bob", "username": "Bob", "role": "user", "isSuspended": False},
    "admin_charlie": {"id": "admin_charlie", "username": "Charlie", "role": "admin", "isSuspended": False}
}

# Simulate moderator/admin authentication
def moderator_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') not in ['moderator', 'admin']:
            return jsonify({"message": "Unauthorized: Moderator/Admin login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'moderator' and password == 'modpass':
        session['user_id'] = 'mod123'
        session['role'] = 'moderator'
        return jsonify({"message": "Logged in successfully as moderator."}), 200
    if username == 'admin' and password == 'adminpass':
        session['user_id'] = 'admin456'
        session['role'] = 'admin'
        return jsonify({"message": "Logged in successfully as admin."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/suspend-user-profile', methods=['POST'])
@moderator_login_required
def suspend_user_profile():
    data = request.get_json()
    user_id_to_suspend = data.get('userId')

    if not user_id_to_suspend:
        return jsonify({"message": "User ID is required."}), 400

    moderator_id = session.get('user_id')

    if user_id_to_suspend not in user_profiles_db:
        return jsonify({"message": "User profile not found."}), 404

    target_user = user_profiles_db[user_id_to_suspend]

    # Prevent suspending an admin or self-suspension
    if target_user['role'] == 'admin' or target_user['id'] == moderator_id:
        return jsonify({"message": "Cannot suspend this user."}), 403

    target_user['isSuspended'] = True
    target_user['suspendedBy'] = moderator_id
    target_user['suspensionDate'] = datetime.utcnow().isoformat()
    # In a real application, you would update the database
    # db.session.commit()
    print(f"User {user_id_to_suspend} suspended by {moderator_id}. Profile: {target_user}")

    # Return the updated list of profiles for the admin/moderator panel
    return jsonify({"message": "User profile suspended successfully.",
                    "updatedUserProfile": target_user}), 200

@app.route('/admin/users', methods=['GET'])
@moderator_login_required
def get_admin_users():
    return jsonify(list(user_profiles_db.values())), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "moderator", "password": "modpass"}
    # 4. Then, suspend a user: POST to [http://127.0.0.1:5000/suspend-user-profile](http://127.0.0.1:5000/suspend-user-profile) with {"userId": "user_alice"}
    app.run(debug=True)
```
### ğŸ§ª Senaryo 8: Bir forum uygulamasÄ±nda yÃ¶neticiler kullanÄ±cÄ± profillerini askÄ±ya alabiliyor. AskÄ±ya alma iÅŸlemi profildeki butonla tetikleniyor. Ä°ÅŸlem arka planda Ã§alÄ±ÅŸÄ±p yÃ¶netici panelini gÃ¼ncelliyor. Onay kutusu gÃ¶sterilmiyor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 201
```typescript

// --- React Component (e.g., ModeratorDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface UserProfile {
  id: string;
  username: string;
  role: string;
  isSuspended: boolean;
  // Add other profile properties
}

const ModeratorDashboard: React.FC = () => {
  const [userProfiles, setUserProfiles] = useState<UserProfile[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isModeratorLoggedIn = true; // Simulates moderator/admin session
  const currentModeratorId = 'mod123'; // From authenticated moderator

  const fetchUserProfiles = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/admin/users', {
        headers: {
          'Authorization': `Bearer your_moderator_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch user profiles.');
      }
      const data: UserProfile[] = await response.json();
      setUserProfiles(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isModeratorLoggedIn) {
      fetchUserProfiles();
    }
  }, [isModeratorLoggedIn]);

  const handleToggleSuspension = async (userId: string, currentStatus: boolean, role: string) => {
    if (!isModeratorLoggedIn) {
      alert('You must be logged in as a moderator or administrator.');
      return;
    }

    if (role === 'admin' || userId === currentModeratorId) {
      alert('Cannot suspend an administrator or yourself.');
      return;
    }

    // No confirmation dialog as per scenario description ("Onay kutusu gÃ¶sterilmiyor")
    // If you wanted one, it would be:
    // if (!window.confirm(`Are you sure you want to ${currentStatus ? 'unsuspend' : 'suspend'} this user?`)) { return; }

    const newStatus = !currentStatus; // Toggle suspension status

    try {
      const response = await fetch('/api/toggle-user-suspension', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_moderator_auth_token_here`,
        },
        body: JSON.stringify({ userId, isSuspended: newStatus }),
      });

      if (response.ok) {
        // Update the state to reflect the new suspension status
        setUserProfiles(prevProfiles =>
          prevProfiles.map(profile =>
            profile.id === userId ? { ...profile, isSuspended: newStatus } : profile
          )
        );
        alert(`User ${userId} suspension status updated!`);
      } else {
        const errorData = await response.json();
        alert(`Failed to update suspension status: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error toggling suspension:', error);
      alert('An error occurred during status update.');
    }
  };

  if (!isModeratorLoggedIn) {
    return <p>Access denied. Please log in as a moderator or administrator.</p>;
  }

  if (loading) {
    return <p>Loading user profiles...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>User Profile Management</h2>
      {userProfiles.length === 0 ? (
        <p>No user profiles found.</p>
      ) : (
        <ul>
          {userProfiles.map(profile => (
            <li key={profile.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', backgroundColor: profile.isSuspended ? '#ffdddd' : 'white' }}>
              <div>
                <p><strong>{profile.username}</strong> ({profile.role})</p>
                <small>Status: {profile.isSuspended ? 'Suspended' : 'Active'}</small>
              </div>
              {profile.role !== 'admin' && profile.id !== currentModeratorId && ( // Cannot suspend admin or self
                <button onClick={() => handleToggleSuspension(profile.id, profile.isSuspended, profile.role)}>
                  {profile.isSuspended ? 'Activate' : 'Suspend'}
                </button>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default ModeratorDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3008;

app.use(bodyParser.json());

// In-memory data store for user profiles
interface UserProfileDB {
  [key: string]: UserProfile;
}

const userProfilesDB: UserProfileDB = {
  "user_1": { id: "user_1", username: "Alice", role: "user", isSuspended: false },
  "user_2": { id: "user_2", username: "Bob", role: "user", isSuspended: false },
  "user_3": { id: "user_3", username: "Charlie", role: "user", isSuspended: true }, // Example: already suspended
  "admin_1": { id: "admin_1", username: "AdminUser", role: "admin", isSuspended: false },
};

// Middleware to simulate moderator/admin authentication
const authorizeModerator = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  // In a real app, verify token and check for 'moderator' or 'admin' role
  req.body.actingUserId = 'mod123'; // Simulate the ID of the moderator/admin performing the action
  req.body.actingUserRole = 'moderator'; // Simulate the role
  next();
};

app.post('/api/toggle-user-suspension', authorizeModerator, (req: Request, res: Response) => {
  const { userId, isSuspended } = req.body;
  const actingUserId = req.body.actingUserId;
  const actingUserRole = req.body.actingUserRole;

  if (!userId || typeof isSuspended !== 'boolean') {
    return res.status(400).json({ message: 'User ID and suspension status are required.' });
  }

  const userToUpdate = userProfilesDB[userId];

  if (!userToUpdate) {
    return res.status(404).json({ message: 'User profile not found.' });
  }

  // Prevent suspending an admin or self-suspension
  if (userToUpdate.role === 'admin' || userToUpdate.id === actingUserId) {
    return res.status(403).json({ message: 'Cannot suspend this user.' });
  }

  userToUpdate.isSuspended = isSuspended;
  console.log(`User ${userId} suspension status set to ${isSuspended} by ${actingUserRole} ${actingUserId}.`);
  res.status(200).json({ message: 'User suspension status updated successfully.', user: userToUpdate });
});

// Endpoint to get all user profiles for moderator panel
app.get('/api/admin/users', authorizeModerator, (req: Request, res: Response) => {
  res.status(200).json(Object.values(userProfilesDB));
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 8 running on http://localhost:${PORT}`);
});
```
### ğŸ§ª Senaryo 9: Bir gÃ¶rev yÃ¶netim aracÄ±nda ekip lideri gÃ¶revleri iptal edebiliyor. Ä°ptal iÅŸlemi gÃ¶rev detay ekranÄ±nda tek tÄ±klamayla yapÄ±lÄ±yor. GÃ¶revler listesinden gÃ¶rev kaldÄ±rÄ±lÄ±yor. Ek doÄŸrulama istenmeden iÅŸlem gerÃ§ekleÅŸiyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 46
```csharp

[Authorize(Roles = "TeamLeader")]
[HttpPost("cancel-task")]
public async Task<IActionResult> CancelTask([FromBody] CancelTaskRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.TaskId))
    {
        return BadRequest("Task ID is required.");
    }

    var teamLeaderId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(teamLeaderId))
    {
        return Unauthorized("User session is not active or team leader ID not found.");
    }

    try
    {
        // Assume a TaskService or direct database interaction
        // var task = await _dbContext.Tasks.FirstOrDefaultAsync(t => t.TaskId == request.TaskId && t.TeamLeaderId == teamLeaderId);
        // if (task == null)
        // {
        //     return NotFound("Task not found or you are not the team leader for this task.");
        // }

        // task.Status = TaskStatus.Cancelled;
        // task.CancellationDate = DateTime.UtcNow;
        // task.CancelledBy = teamLeaderId;
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"Task {request.TaskId} cancelled by team leader {teamLeaderId}.");

        return Ok(new { Message = "Task cancelled successfully.", CancelledTaskId = request.TaskId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class CancelTaskRequest
{
    public string TaskId { get; set; }
}
```
### ğŸ§ª Senaryo 9: Bir gÃ¶rev yÃ¶netim aracÄ±nda ekip lideri gÃ¶revleri iptal edebiliyor. Ä°ptal iÅŸlemi gÃ¶rev detay ekranÄ±nda tek tÄ±klamayla yapÄ±lÄ±yor. GÃ¶revler listesinden gÃ¶rev kaldÄ±rÄ±lÄ±yor. Ek doÄŸrulama istenmeden iÅŸlem gerÃ§ekleÅŸiyor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 83
```python

from flask import Flask, request, jsonify, session
from functools import wraps
from datetime import datetime

app = Flask(__name__)
app.secret_key = 'task_manager_secret'

# In-memory database for tasks (simulate)
tasks_db = {
    "task_101": {"id": "task_101", "name": "Prepare report", "assignedTo": "userX", "status": "Pending", "teamLeaderId": "leader_alpha"},
    "task_102": {"id": "task_102", "name": "Review code", "assignedTo": "userY", "status": "InProgress", "teamLeaderId": "leader_alpha"},
    "task_103": {"id": "task_103", "name": "Client meeting", "assignedTo": "userZ", "status": "Completed", "teamLeaderId": "leader_beta"}
}

# Simulate team leader authentication
def team_leader_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'team_leader':
            return jsonify({"message": "Unauthorized: Team leader login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'leader_alpha' and password == 'leaderpass': # Mock team leader login
        session['user_id'] = 'leader_alpha'
        session['role'] = 'team_leader'
        return jsonify({"message": "Logged in successfully as team leader."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/cancel-task', methods=['POST'])
@team_leader_login_required
def cancel_task():
    data = request.get_json()
    task_id = data.get('taskId')

    if not task_id:
        return jsonify({"message": "Task ID is required."}), 400

    team_leader_id = session.get('user_id')

    if task_id not in tasks_db:
        return jsonify({"message": "Task not found."}), 404

    target_task = tasks_db[task_id]

    if target_task['teamLeaderId'] != team_leader_id:
        return jsonify({"message": "You are not authorized to cancel this task."}), 403

    target_task['status'] = 'Cancelled'
    target_task['cancellationDate'] = datetime.utcnow().isoformat()
    target_task['cancelledBy'] = team_leader_id
    # In a real application, you would update the database
    # db.session.commit()
    print(f"Task {task_id} cancelled by team leader {team_leader_id}. Task status: {target_task['status']}")

    # Optionally, remove from the active list if 'cancelled' means removal
    # del tasks_db[task_id]
    # For this scenario, we keep it but update status, so it will be filtered on frontend.

    return jsonify({"message": "Task cancelled successfully.",
                    "cancelledTask": target_task}), 200

@app.route('/leader/tasks', methods=['GET'])
@team_leader_login_required
def get_leader_tasks():
    team_leader_id = session.get('user_id')
    leader_tasks = [task for task_id, task in tasks_db.items() if task['teamLeaderId'] == team_leader_id]
    return jsonify(leader_tasks), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "leader_alpha", "password": "leaderpass"}
    # 4. Then, cancel a task: POST to [http://127.0.0.1:5000/cancel-task](http://127.0.0.1:5000/cancel-task) with {"taskId": "task_101"}
    app.run(debug=True)
```
### ğŸ§ª Senaryo 9: Bir gÃ¶rev yÃ¶netim aracÄ±nda ekip lideri gÃ¶revleri iptal edebiliyor. Ä°ptal iÅŸlemi gÃ¶rev detay ekranÄ±nda tek tÄ±klamayla yapÄ±lÄ±yor. GÃ¶revler listesinden gÃ¶rev kaldÄ±rÄ±lÄ±yor. Ek doÄŸrulama istenmeden iÅŸlem gerÃ§ekleÅŸiyor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 211
```typescript

// --- React Component (e.g., TaskLeaderDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface Task {
  id: string;
  name: string;
  assignedTo: string;
  status: 'Pending' | 'InProgress' | 'Completed' | 'Cancelled';
  teamLeaderId: string;
}

const TaskLeaderDashboard: React.FC = () => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isTeamLeaderLoggedIn = true; // Simulates team leader session status
  const currentTeamLeaderId = 'leader_alpha'; // From authenticated team leader

  const fetchTasks = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/leader/${currentTeamLeaderId}/tasks`, {
        headers: {
          'Authorization': `Bearer your_teamleader_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch tasks.');
      }
      const data: Task[] = await response.json();
      setTasks(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isTeamLeaderLoggedIn) {
      fetchTasks();
    }
  }, [isTeamLeaderLoggedIn, currentTeamLeaderId]);

  const handleCancelTask = async (taskId: string, currentStatus: string) => {
    if (!isTeamLeaderLoggedIn) {
      alert('You must be logged in as a team leader to cancel tasks.');
      return;
    }

    if (currentStatus === 'Cancelled') {
        alert('This task is already cancelled.');
        return;
    }

    // No additional confirmation box as per scenario (tek tÄ±klamayla yapÄ±lÄ±yor)
    try {
      const response = await fetch('/api/cancel-task', {
        method: 'POST', // Using POST for state change
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_teamleader_auth_token_here`,
        },
        body: JSON.stringify({ taskId }),
      });

      if (response.ok) {
        // Update the state to reflect the cancelled task (remove from list if applicable, or change status)
        setTasks(prevTasks =>
          prevTasks.map(task =>
            task.id === taskId ? { ...task, status: 'Cancelled' } : task
          ).filter(task => task.id !== taskId) // Filter out the cancelled task from the list
        );
        alert('Task cancelled successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to cancel task: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error cancelling task:', error);
      alert('An error occurred during task cancellation.');
    }
  };

  if (!isTeamLeaderLoggedIn) {
    return <p>Access denied. Please log in as a team leader.</p>;
  }

  if (loading) {
    return <p>Loading tasks...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  const activeTasks = tasks.filter(task => task.status !== 'Cancelled');

  return (
    <div>
      <h2>My Team's Tasks</h2>
      {activeTasks.length === 0 ? (
        <p>No active tasks found.</p>
      ) : (
        <ul>
          {activeTasks.map(task => (
            <li key={task.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <div>
                <p><strong>{task.name}</strong> - Assigned to: {task.assignedTo}</p>
                <small>Status: {task.status}</small>
              </div>
              <button onClick={() => handleCancelTask(task.id, task.status)} disabled={task.status === 'Cancelled'}>
                Cancel Task
              </button>
            </li>
          ))}
        </ul>
      )}

      <h3>Cancelled Tasks</h3>
      {tasks.filter(task => task.status === 'Cancelled').length === 0 ? (
          <p>No cancelled tasks.</p>
      ) : (
          <ul>
              {tasks.filter(task => task.status === 'Cancelled').map(task => (
                  <li key={task.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', backgroundColor: '#f0f0f0' }}>
                      <p><strong>{task.name}</strong> (Cancelled)</p>
                  </li>
              ))}
          </ul>
      )}
    </div>
  );
};

export default TaskLeaderDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3009;

app.use(bodyParser.json());

// In-memory data store for tasks
interface TaskDB {
  [key: string]: Task;
}

const tasksDB: TaskDB = {
  "task_alpha": { id: "task_alpha", name: "Deploy new feature", assignedTo: "dev1", status: "InProgress", teamLeaderId: "leader_alpha" },
  "task_beta": { id: "task_beta", name: "Write documentation", assignedTo: "techwriter", status: "Pending", teamLeaderId: "leader_alpha" },
  "task_gamma": { id: "task_gamma", name: "QA testing", assignedTo: "qa_engineer", status: "Completed", teamLeaderId: "leader_beta" },
};

// Middleware to simulate team leader authentication
const authorizeTeamLeader = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.teamLeaderId = 'leader_alpha'; // Simulate team leader ID
  next();
};

app.post('/api/cancel-task', authorizeTeamLeader, (req: Request, res: Response) => {
  const { taskId } = req.body;
  const teamLeaderId = req.body.teamLeaderId;

  if (!taskId) {
    return res.status(400).json({ message: 'Task ID is required.' });
  }

  const taskToUpdate = tasksDB[taskId];

  if (!taskToUpdate) {
    return res.status(404).json({ message: 'Task not found.' });
  }

  // Check if the authenticated team leader owns this task
  if (taskToUpdate.teamLeaderId !== teamLeaderId) {
    return res.status(403).json({ message: 'You are not authorized to cancel this task.' });
  }

  if (taskToUpdate.status === 'Cancelled') {
    return res.status(400).json({ message: 'Task is already cancelled.' });
  }

  taskToUpdate.status = 'Cancelled';
  console.log(`Task ${taskId} cancelled by team leader ${teamLeaderId}.`);
  res.status(200).json({ message: 'Task cancelled successfully.', task: taskToUpdate });
});

// Endpoint to get tasks for a specific team leader (for dashboard loading)
app.get('/api/leader/:teamLeaderId/tasks', authorizeTeamLeader, (req: Request, res: Response) => {
  const { teamLeaderId } = req.params;
  const tasks = Object.values(tasksDB).filter(task => task.teamLeaderId === teamLeaderId);
  res.status(200).json(tasks);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 9 running on http://localhost:${PORT}`);
});
```
### ğŸ§ª Senaryo 10: Bir eÄŸitim yÃ¶netim sisteminde Ã¶ÄŸretmenler duyurularÄ± silebiliyor. Silme iÅŸlemi duyuru baÅŸlÄ±ÄŸÄ±nÄ±n yanÄ±ndaki baÄŸlantÄ± ile yapÄ±lÄ±yor. Bu baÄŸlantÄ± sunucuya istek gÃ¶ndererek duyuruyu kaldÄ±rÄ±yor. Ã–ÄŸretmen iÅŸlem sonrasÄ± aynÄ± sayfada kalÄ±yor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 39
```csharp

[Authorize(Roles = "Teacher")]
[HttpDelete("delete-announcement")]
public async Task<IActionResult> DeleteAnnouncement([FromQuery] string announcementId)
{
    if (string.IsNullOrEmpty(announcementId))
    {
        return BadRequest("Announcement ID cannot be empty.");
    }

    var teacherId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(teacherId))
    {
        return Unauthorized("User session is not active or teacher ID not found.");
    }

    try
    {
        // Assume an AnnouncementService or direct database interaction
        // var announcement = await _dbContext.Announcements.FirstOrDefaultAsync(a => a.AnnouncementId == announcementId && a.TeacherId == teacherId);
        // if (announcement == null)
        // {
        //     return NotFound("Announcement not found or you are not the creator of this announcement.");
        // }

        // _dbContext.Announcements.Remove(announcement);
        // await _dbContext.SaveChangesAsync();

        // Simulate successful deletion:
        Console.WriteLine($"Announcement {announcementId} deleted by teacher {teacherId}.");

        return Ok(new { Message = "Announcement deleted successfully.", DeletedAnnouncementId = announcementId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### ğŸ§ª Senaryo 10: Bir eÄŸitim yÃ¶netim sisteminde Ã¶ÄŸretmenler duyurularÄ± silebiliyor. Silme iÅŸlemi duyuru baÅŸlÄ±ÄŸÄ±nÄ±n yanÄ±ndaki baÄŸlantÄ± ile yapÄ±lÄ±yor. Bu baÄŸlantÄ± sunucuya istek gÃ¶ndererek duyuruyu kaldÄ±rÄ±yor. Ã–ÄŸretmen iÅŸlem sonrasÄ± aynÄ± sayfada kalÄ±yor.
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 76
```python

from flask import Flask, request, jsonify, session
from functools import wraps
import uuid

app = Flask(__name__)
app.secret_key = 'edu_app_secret'

# In-memory database for announcements (simulate)
announcements_db = {
    "ann_001": {"id": "ann_001", "title": "Class Schedule Update", "content": "Classes will be online.", "teacherId": "teacher_mary"},
    "ann_002": {"id": "ann_002", "title": "Exam Date Change", "content": "Exam moved to Friday.", "teacherId": "teacher_mary"},
    "ann_003": {"id": "ann_003", "title": "New Course Available", "content": "Check out the new course.", "teacherId": "teacher_john"}
}

# Simulate teacher authentication
def teacher_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'teacher':
            return jsonify({"message": "Unauthorized: Teacher login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'teacher_mary' and password == 'teachpass': # Mock teacher login
        session['user_id'] = 'teacher_mary'
        session['role'] = 'teacher'
        return jsonify({"message": "Logged in successfully as teacher."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/delete-announcement', methods=['DELETE'])
@teacher_login_required
def delete_announcement():
    announcement_id = request.args.get('announcementId')

    if not announcement_id:
        return jsonify({"message": "Announcement ID cannot be empty."}), 400

    teacher_id = session.get('user_id')

    if announcement_id not in announcements_db:
        return jsonify({"message": "Announcement not found."}), 404

    if announcements_db[announcement_id]['teacherId'] != teacher_id:
        return jsonify({"message": "You are not authorized to delete this announcement."}), 403

    del announcements_db[announcement_id]
    # In a real application, you would delete from the database
    # db.session.delete(announcement_object)
    # db.session.commit()
    print(f"Announcement {announcement_id} deleted by teacher {teacher_id}. Remaining announcements: {announcements_db}")

    # Return the updated list of announcements for the teacher to stay on the same page
    updated_announcement_list = [ann for ann_id, ann in announcements_db.items() if ann['teacherId'] == teacher_id]
    return jsonify({"message": "Announcement deleted successfully.", "updatedAnnouncementList": updated_announcement_list}), 200

@app.route('/my-announcements', methods=['GET'])
@teacher_login_required
def get_my_announcements():
    teacher_id = session.get('user_id')
    teacher_announcements = [ann for ann_id, ann in announcements_db.items() if ann['teacherId'] == teacher_id]
    return jsonify(teacher_announcements), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "teacher_mary", "password": "teachpass"}
    # 4. Then, delete an announcement: DELETE request to [http://127.0.0.1:5000/delete-announcement?announcementId=ann_001](http://127.0.0.1:5000/delete-announcement?announcementId=ann_001)
    app.run(debug=True)
```
### ğŸ§ª Senaryo 10: Bir eÄŸitim yÃ¶netim sisteminde Ã¶ÄŸretmenler duyurularÄ± silebiliyor. Silme iÅŸlemi duyuru baÅŸlÄ±ÄŸÄ±nÄ±n yanÄ±ndaki baÄŸlantÄ± ile yapÄ±lÄ±yor. Bu baÄŸlantÄ± sunucuya istek gÃ¶ndererek duyuruyu kaldÄ±rÄ±yor. Ã–ÄŸretmen iÅŸlem sonrasÄ± aynÄ± sayfada kalÄ±yor.
**ğŸ’» Dil:** `TypeScript (ReactJS)`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 183
```typescript

// --- React Component (e.g., TeacherAnnouncements.tsx) ---
import React, { useState, useEffect } from 'react';

interface Announcement {
  id: string;
  title: string;
  content: string;
  teacherId: string;
}

const TeacherAnnouncements: React.FC = () => {
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isTeacherLoggedIn = true; // Simulates teacher session status
  const currentTeacherId = 'teacher_mary'; // From authenticated teacher

  const fetchAnnouncements = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/teacher/${currentTeacherId}/announcements`, {
        headers: {
          'Authorization': `Bearer your_teacher_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch announcements.');
      }
      const data: Announcement[] = await response.json();
      setAnnouncements(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isTeacherLoggedIn) {
      fetchAnnouncements();
    }
  }, [isTeacherLoggedIn, currentTeacherId]);

  const handleDeleteAnnouncement = async (announcementId: string) => {
    if (!isTeacherLoggedIn) {
      alert('Please log in as a teacher to delete announcements.');
      return;
    }

    if (!window.confirm('Are you sure you want to delete this announcement?')) {
      return;
    }

    try {
      const response = await fetch(`/api/delete-announcement?announcementId=${announcementId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer your_teacher_auth_token_here`,
        },
      });

      if (response.ok) {
        // Update the state to remove the deleted announcement from the UI
        setAnnouncements(prevAnnouncements => prevAnnouncements.filter(ann => ann.id !== announcementId));
        alert('Announcement deleted successfully!');
        // The teacher stays on the same page, as the list updates.
      } else {
        const errorData = await response.json();
        alert(`Failed to delete announcement: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error deleting announcement:', error);
      alert('An error occurred during announcement deletion.');
    }
  };

  if (!isTeacherLoggedIn) {
    return <p>Access denied. Please log in as a teacher.</p>;
  }

  if (loading) {
    return <p>Loading announcements...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Announcements</h2>
      {announcements.length === 0 ? (
        <p>No announcements found.</p>
      ) : (
        <ul>
          {announcements.map(ann => (
            <li key={ann.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <div>
                <h3>{ann.title}</h3>
                <p>{ann.content.substring(0, 100)}...</p>
              </div>
              <button onClick={() => handleDeleteAnnouncement(ann.id)} style={{ background: 'none', border: 'none', cursor: 'pointer', color: 'red', fontSize: '1em' }}>
                Delete
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default TeacherAnnouncements;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3010;

app.use(bodyParser.json());

// In-memory data store for announcements
interface AnnouncementDB {
  [key: string]: Announcement;
}

const announcementsDB: AnnouncementDB = {
  "ann_A": { id: "ann_A", title: "Holiday Break Notice", content: "School will be closed...", teacherId: "teacher_mary" },
  "ann_B": { id: "ann_B", title: "Parent-Teacher Conference", content: "Sign up for slots...", teacherId: "teacher_mary" },
  "ann_C": { id: "ann_C", title: "New Assignment Posted", content: "Check your portal...", teacherId: "teacher_john" },
};

// Middleware to simulate teacher authentication
const authorizeTeacher = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.teacherId = 'teacher_mary'; // Simulate teacher ID
  next();
};

app.delete('/api/delete-announcement', authorizeTeacher, (req: Request, res: Response) => {
  const announcementId = req.query.announcementId as string;
  const teacherId = req.body.teacherId;

  if (!announcementId) {
    return res.status(400).json({ message: 'Announcement ID is required.' });
  }

  const announcementToDelete = announcementsDB[announcementId];

  if (!announcementToDelete) {
    return res.status(404).json({ message: 'Announcement not found.' });
  }

  // Check if the authenticated teacher created this announcement
  if (announcementToDelete.teacherId !== teacherId) {
    return res.status(403).json({ message: 'You are not authorized to delete this announcement.' });
  }

  delete announcementsDB[announcementId];
  console.log(`Announcement ${announcementId} deleted by teacher ${teacherId}.`);
  res.status(200).json({ message: 'Announcement deleted successfully.' });
});

// Endpoint to get announcements for a specific teacher (for dashboard loading)
app.get('/api/teacher/:teacherId/announcements', authorizeTeacher, (req: Request, res: Response) => {
  const { teacherId } = req.params;
  const announcements = Object.values(announcementsDB).filter(ann => ann.teacherId === teacherId);
  res.status(200).json(announcements);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 10 running on http://localhost:${PORT}`);
```
});