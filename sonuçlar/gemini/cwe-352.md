----

### 🧪 Senaryo 1: Bir sosyal medya uygulamasında kullanıcılar gönderileri şikayet edebiliyor. Şikayet işlemi buton tıklaması ile gerçekleşiyor ve arka planda işlem sunucuya gönderiliyor. Kullanıcı oturumu aktif olduğunda işlem yapılabiliyor. Şikayet edilen içerikler kullanıcı panelinde gösteriliyor.
**💻 Dil:** `C#`  
**🤖 AI:** Gemini

**Satır Sayısı:** 123
```csharp
[Authorize]
[HttpPost("report-post")]
public async Task<IActionResult> ReportPost([FromBody] ReportPostRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.PostId))
    {
        return BadRequest("Post ID cannot be empty.");
    }

    // Assuming a service to handle reporting logic
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active.");
    }

    try
    {
        // Example: Save the report to a database
        var report = new PostReport
        {
            PostId = request.PostId,
            ReporterId = userId,
            ReportDate = DateTime.UtcNow,
            Status = "Pending"
        };
        // _dbContext.PostReports.Add(report);
        // await _dbContext.SaveChangesAsync();

        // In a real application, you might use a service:
        // await _reportingService.SubmitPostReport(request.PostId, userId);

        return Ok(new { Message = "Post reported successfully." });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class ReportPostRequest
{
    public string PostId { get; set; }
}

// Example Entity for demonstration (would typically be in a separate Models folder)
public class PostReport
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string PostId { get; set; }
    public string ReporterId { get; set; }
    public DateTime ReportDate { get; set; }
    public string Status { get; set; }
}
### 🧪 Senaryo 1: Bir sosyal medya uygulamasında kullanıcılar gönderileri şikayet edebiliyor. Şikayet işlemi buton tıklaması ile gerçekleşiyor ve arka planda işlem sunucuya gönderiliyor. Kullanıcı oturumu aktif olduğunda işlem yapılabiliyor. Şikayet edilen içerikler kullanıcı panelinde gösteriliyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

```python

from flask import Flask, request, jsonify
from functools import wraps
import uuid
from datetime import datetime

app = Flask(__name__)

# In a real application, this would be a database or a more robust user management system
active_sessions = {"user123": True} # Example active session
reported_posts_db = [] # In-memory list to simulate a database

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user_id = request.headers.get('X-User-ID') # Example: get user from header
        if not user_id or user_id not in active_sessions:
            return jsonify({"message": "User session is not active."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/report-post', methods=['POST'])
@login_required
def report_post():
    data = request.get_json()
    post_id = data.get('postId')

    if not post_id:
        return jsonify({"message": "Post ID cannot be empty."}), 400

    user_id = request.headers.get('X-User-ID')

    report_entry = {
        "id": str(uuid.uuid4()),
        "postId": post_id,
        "reporterId": user_id,
        "reportDate": datetime.utcnow().isoformat(),
        "status": "Pending"
    }
    reported_posts_db.append(report_entry)
    # In a real application, you would save this to a database
    # db.session.add(report_entry)
    # db.session.commit()

    return jsonify({"message": "Post reported successfully."}), 200

@app.route('/user-panel/reported-posts', methods=['GET'])
@login_required
def get_reported_posts():
    user_id = request.headers.get('X-User-ID')
    user_reported_content = [report for report in reported_posts_db if report['reporterId'] == user_id]
    return jsonify(user_reported_content), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. Use a tool like Postman to send a POST request to [http://127.0.0.1:5000/report-post](http://127.0.0.1:5000/report-post)
    #    with headers: X-User-ID: user123 and JSON body: {"postId": "post123"}
    # 4. To get reported posts: GET request to [http://127.0.0.1:5000/user-panel/reported-posts](http://127.0.0.1:5000/user-panel/reported-posts)
    #    with headers: X-User-ID: user123
    app.run(debug=True)
```
### 🧪 Senaryo 1: Bir sosyal medya uygulamasında kullanıcılar gönderileri şikayet edebiliyor. Şikayet işlemi buton tıklaması ile gerçekleşiyor ve arka planda işlem sunucuya gönderiliyor. Kullanıcı oturumu aktif olduğunda işlem yapılabiliyor. Şikayet edilen içerikler kullanıcı panelinde gösteriliyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 123
```typescript

// --- React Component (e.g., PostItem.tsx) ---
import React, { useState } from 'react';

interface PostProps {
  postId: string;
  content: string;
  isLoggedIn: boolean; // Simulates user session status
}

const PostItem: React.FC<PostProps> = ({ postId, content, isLoggedIn }) => {
  const [reportStatus, setReportStatus] = useState<string | null>(null);

  const handleReportClick = async () => {
    if (!isLoggedIn) {
      alert('Please log in to report posts.');
      return;
    }

    setReportStatus('Reporting...');
    try {
      const response = await fetch('/api/report-post', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          // In a real app, you'd send an authorization token (e.g., Bearer token)
          'Authorization': `Bearer your_auth_token_here`,
        },
        body: JSON.stringify({ postId }),
      });

      if (response.ok) {
        setReportStatus('Post reported successfully!');
        // Optionally, update a global state or show a more persistent notification
      } else {
        const errorData = await response.json();
        setReportStatus(`Failed to report: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error reporting post:', error);
      setReportStatus('An error occurred during reporting.');
    }
  };

  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px' }}>
      <p>{content}</p>
      <button onClick={handleReportClick} disabled={!isLoggedIn || reportStatus === 'Reporting...'}>
        Report Post
      </button>
      {reportStatus && <p>{reportStatus}</p>}
    </div>
  );
};

export default PostItem;

// --- Node.js Backend (e.g., server.ts using Express) ---
// This would be a separate file or part of your backend application
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3001;

app.use(bodyParser.json());

// In a real app, you'd have proper authentication middleware
const authenticateUser = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Unauthorized: No token provided.' });
  }
  // In a real app, verify the token
  // For this example, we'll just assume a valid session if a token exists
  // const token = authHeader.split(' ')[1];
  // if (!isValidToken(token)) { ... }
  // req.userId = decodedToken.userId; // Attach user ID to request
  next();
};

// In-memory store for reported posts (replace with database in production)
interface ReportedPost {
  id: string;
  postId: string;
  reporterId: string; // This would come from the authenticated user
  reportDate: string;
  status: string;
}
const reportedPosts: ReportedPost[] = [];

app.post('/api/report-post', authenticateUser, (req: Request, res: Response) => {
  const { postId } = req.body;
  if (!postId) {
    return res.status(400).json({ message: 'Post ID is required.' });
  }

  // Simulate user ID from authenticated session
  const reporterId = 'user123'; // In a real app, this would come from req.userId after token verification

  const newReport: ReportedPost = {
    id: `report-${Date.now()}`,
    postId,
    reporterId,
    reportDate: new Date().toISOString(),
    status: 'Pending',
  };
  reportedPosts.push(newReport);
  console.log(`Post ${postId} reported by ${reporterId}. Total reported posts: ${reportedPosts.length}`);

  res.status(200).json({ message: 'Post reported successfully.', reportId: newReport.id });
});

// Endpoint to display reported content in user panel (example)
app.get('/api/user-panel/reported-posts/:userId', authenticateUser, (req: Request, res: Response) => {
  const { userId } = req.params;
  const userReportedContent = reportedPosts.filter(report => report.reporterId === userId);
  res.status(200).json(userReportedContent);
});

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
```
### 🧪 Senaryo 2: Bir blog yönetim sisteminde yazarlar eski yazılarını silmek için silme bağlantısını kullanabiliyor. Bu bağlantı HTML sayfasında yer alıyor ve silme işlemini başlatıyor. Yazar başka bir sayfaya geçmeden bu işlemi gerçekleştirebiliyor. İşlem sonrası aynı oturum devam ediyor.
**💻 Dil:** `C#`

**🤖 AI:** Gemini

**Satır Sayısı:** 46
```csharp

[Authorize(Roles = "Author")]
[HttpPost("delete-blog-post")]
public async Task<IActionResult> DeleteBlogPost([FromForm] string postId)
{
    if (string.IsNullOrEmpty(postId))
    {
        return BadRequest("Post ID cannot be empty.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Fetch the blog post from the database
        // var blogPost = await _dbContext.BlogPosts.FindAsync(postId);
        // if (blogPost == null)
        // {
        //     return NotFound("Blog post not found.");
        // }

        // // Ensure the author is deleting their own post
        // if (blogPost.AuthorId != userId)
        // {
        //     return Forbid("You are not authorized to delete this post.");
        // }

        // // Remove the blog post
        // _dbContext.BlogPosts.Remove(blogPost);
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"Blog post with ID {postId} deleted by author {userId}.");

        return Ok(new { Message = "Blog post deleted successfully." });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### 🧪 Senaryo 2: Bir blog yönetim sisteminde yazarlar eski yazılarını silmek için silme bağlantısını kullanabiliyor. Bu bağlantı HTML sayfasında yer alıyor ve silme işlemini başlatıyor. Yazar başka bir sayfaya geçmeden bu işlemi gerçekleştirebiliyor. İşlem sonrası aynı oturum devam ediyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

**Satır Sayısı:** 81
```python

from flask import Flask, request, jsonify, session
from functools import wraps

app = Flask(__name__)
app.secret_key = 'your_secret_key' # Replace with a strong secret key

# In-memory database for blog posts (simulate)
blog_posts_db = {
    "post1": {"id": "post1", "title": "My First Post", "authorId": "author123", "content": "Hello world!"},
    "post2": {"id": "post2", "title": "Another Post", "authorId": "author123", "content": "More content."},
    "post3": {"id": "post3", "title": "Someone Else's Post", "authorId": "author456", "content": "Not mine."}
}

# Simulate user authentication
def author_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'author':
            return jsonify({"message": "Unauthorized: Author login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'author123' and password == 'password': # Simple mock login
        session['user_id'] = 'author123'
        session['role'] = 'author'
        return jsonify({"message": "Logged in successfully as author."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/logout', methods=['POST'])
def logout():
    session.pop('user_id', None)
    session.pop('role', None)
    return jsonify({"message": "Logged out."}), 200

@app.route('/delete-blog-post', methods=['POST'])
@author_login_required
def delete_blog_post():
    data = request.get_json()
    post_id = data.get('postId')

    if not post_id:
        return jsonify({"message": "Post ID cannot be empty."}), 400

    user_id = session.get('user_id')

    if post_id not in blog_posts_db:
        return jsonify({"message": "Blog post not found."}), 404

    if blog_posts_db[post_id]['authorId'] != user_id:
        return jsonify({"message": "You are not authorized to delete this post."}), 403

    del blog_posts_db[post_id]
    # In a real application, you would delete from the database
    # db.session.delete(post_object)
    # db.session.commit()
    print(f"Blog post {post_id} deleted by {user_id}. Remaining posts: {blog_posts_db}")

    return jsonify({"message": "Blog post deleted successfully."}), 200

@app.route('/my-posts', methods=['GET'])
@author_login_required
def get_my_posts():
    user_id = session.get('user_id')
    author_posts = [post for post_id, post in blog_posts_db.items() if post['authorId'] == user_id]
    return jsonify(author_posts), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "author123", "password": "password"}
    # 4. Then, delete a post: POST to [http://127.0.0.1:5000/delete-blog-post](http://127.0.0.1:5000/delete-blog-post) with {"postId": "post1"}
    #    The session cookie will maintain the login.
    app.run(debug=True)
```
### 🧪 Senaryo 2: Bir blog yönetim sisteminde yazarlar eski yazılarını silmek için silme bağlantısını kullanabiliyor. Bu bağlantı HTML sayfasında yer alıyor ve silme işlemini başlatıyor. Yazar başka bir sayfaya geçmeden bu işlemi gerçekleştirebiliyor. İşlem sonrası aynı oturum devam ediyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 184
```typescript

// --- React Component (e.g., AuthorDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface BlogPost {
  id: string;
  title: string;
  content: string;
  authorId: string;
}

const AuthorDashboard: React.FC = () => {
  const [blogPosts, setBlogPosts] = useState<BlogPost[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Simulate user authentication state
  const isLoggedIn = true; // In a real app, this would be managed by context/redux
  const currentAuthorId = 'author123'; // From authenticated user

  useEffect(() => {
    const fetchPosts = async () => {
      setLoading(true);
      try {
        // In a real app, fetch posts belonging to the logged-in author
        const response = await fetch(`/api/author/${currentAuthorId}/posts`, {
          headers: {
            'Authorization': `Bearer your_auth_token_here`,
          },
        });
        if (!response.ok) {
          throw new Error('Failed to fetch posts.');
        }
        const data: BlogPost[] = await response.json();
        setBlogPosts(data);
      } catch (err) {
        if (err instanceof Error) {
          setError(err.message);
        } else {
          setError('An unknown error occurred.');
        }
      } finally {
        setLoading(false);
      }
    };
    if (isLoggedIn) {
      fetchPosts();
    }
  }, [isLoggedIn, currentAuthorId]);

  const handleDeletePost = async (postId: string) => {
    if (!isLoggedIn) {
      alert('Please log in to delete posts.');
      return;
    }

    if (!window.confirm('Are you sure you want to delete this post?')) {
      return;
    }

    try {
      const response = await fetch('/api/delete-blog-post', {
        method: 'POST', // Using POST for deletion as it's an action, not just retrieving
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_auth_token_here`,
        },
        body: JSON.stringify({ postId }),
      });

      if (response.ok) {
        // Update the state to remove the deleted post from the UI
        setBlogPosts(prevPosts => prevPosts.filter(post => post.id !== postId));
        alert('Post deleted successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to delete post: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error deleting post:', error);
      alert('An error occurred during deletion.');
    }
  };

  if (!isLoggedIn) {
    return <p>Please log in to manage your blog posts.</p>;
  }

  if (loading) {
    return <p>Loading posts...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Blog Posts</h2>
      {blogPosts.length === 0 ? (
        <p>No posts found.</p>
      ) : (
        <ul>
          {blogPosts.map(post => (
            <li key={post.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px' }}>
              <h3>{post.title}</h3>
              <p>{post.content.substring(0, 100)}...</p>
              <button onClick={() => handleDeletePost(post.id)}>Delete</button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default AuthorDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3002;

app.use(bodyParser.json());

// In-memory data store for blog posts
interface BlogPostDB {
  [key: string]: BlogPost;
}

const blogPostsDB: BlogPostDB = {
  "post1": { id: "post1", title: "My First Article", content: "Content of my first article.", authorId: "author123" },
  "post2": { id: "post2", title: "Travel Guide", content: "Exploring new places...", authorId: "author123" },
  "post3": { id: "post3", title: "Recipe Ideas", content: "Delicious recipes...", authorId: "author456" },
};

// Middleware to simulate authentication and authorization for authors
const authorizeAuthor = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  // In a real app, this would involve JWT verification and role checking
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  // Simulate user ID from token
  req.body.userId = 'author123'; // This should come from a verified token
  next();
};

app.post('/api/delete-blog-post', authorizeAuthor, (req: Request, res: Response) => {
  const { postId } = req.body;
  const userId = req.body.userId; // User ID from authenticated session

  if (!postId) {
    return res.status(400).json({ message: 'Post ID is required.' });
  }

  const postToDelete = blogPostsDB[postId];

  if (!postToDelete) {
    return res.status(404).json({ message: 'Blog post not found.' });
  }

  // Check if the authenticated user is the author of the post
  if (postToDelete.authorId !== userId) {
    return res.status(403).json({ message: 'You are not authorized to delete this post.' });
  }

  delete blogPostsDB[postId];
  console.log(`Post ${postId} deleted by ${userId}. Remaining posts:`, blogPostsDB);
  res.status(200).json({ message: 'Blog post deleted successfully.' });
});

// Endpoint to get posts for a specific author (for dashboard loading)
app.get('/api/author/:authorId/posts', authorizeAuthor, (req: Request, res: Response) => {
  const { authorId } = req.params;
  const posts = Object.values(blogPostsDB).filter(post => post.authorId === authorId);
  res.status(200).json(posts);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 2 running on http://localhost:${PORT}`);
});
```
### 🧪 Senaryo 3: Bir dosya paylaşım platformunda kullanıcılar paylaşımlarını kaldırmak için kaldır butonuna tıklıyor. Buton arka planda dosya silme işlemini gerçekleştiriyor. Dosyalar kullanıcının yönetim panelinde güncelleniyor. İşlem doğrudan gerçekleşiyor.
**💻 Dil:** `C#`

**🤖 AI:** Gemini

**Satır Sayısı:** 41
```csharp

[Authorize]
[HttpDelete("remove-shared-file")]
public async Task<IActionResult> RemoveSharedFile([FromQuery] string fileId)
{
    if (string.IsNullOrEmpty(fileId))
    {
        return BadRequest("File ID cannot be empty.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a FileService or direct database interaction
        // var file = await _dbContext.SharedFiles.FirstOrDefaultAsync(f => f.FileId == fileId && f.OwnerId == userId);
        // if (file == null)
        // {
        //     return NotFound("File not found or you do not have permission to remove it.");
        // }

        // // Simulate file deletion from storage and database
        // _fileStorageService.DeleteFile(file.StoragePath); // e.g., Azure Blob, AWS S3
        // _dbContext.SharedFiles.Remove(file);
        // await _dbContext.SaveChangesAsync();

        // Simulate successful deletion:
        Console.WriteLine($"File {fileId} removed by user {userId}.");

        return Ok(new { Message = "File removed successfully." });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### 🧪 Senaryo 3: Bir dosya paylaşım platformunda kullanıcılar paylaşımlarını kaldırmak için kaldır butonuna tıklıyor. Buton arka planda dosya silme işlemini gerçekleştiriyor. Dosyalar kullanıcının yönetim panelinde güncelleniyor. İşlem doğrudan gerçekleşiyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

**Satır Sayısı:** 75
```python

from flask import Flask, request, jsonify, session
from functools import wraps
import uuid

app = Flask(__name__)
app.secret_key = 'another_secret_key' # Replace with a strong secret key

# In-memory database for shared files (simulate)
shared_files_db = {
    "file_abc": {"id": "file_abc", "name": "document.pdf", "ownerId": "user123", "path": "/uploads/doc.pdf"},
    "file_xyz": {"id": "file_xyz", "name": "image.jpg", "ownerId": "user123", "path": "/uploads/img.jpg"},
    "file_mno": {"id": "file_mno", "name": "video.mp4", "ownerId": "user456", "path": "/uploads/vid.mp4"}
}

# Simulate user authentication
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({"message": "Unauthorized: User login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    # For this example, we'll just set a user ID
    if username == 'user123':
        session['user_id'] = 'user123'
        return jsonify({"message": "Logged in successfully."}), 200
    return jsonify({"message": "Invalid username."}), 401

@app.route('/remove-shared-file', methods=['DELETE'])
@login_required
def remove_shared_file():
    file_id = request.args.get('fileId') # Get fileId from query parameters

    if not file_id:
        return jsonify({"message": "File ID cannot be empty."}), 400

    user_id = session.get('user_id')

    if file_id not in shared_files_db:
        return jsonify({"message": "File not found."}), 404

    if shared_files_db[file_id]['ownerId'] != user_id:
        return jsonify({"message": "You do not have permission to remove this file."}), 403

    # Simulate deleting the file from storage
    # os.remove(shared_files_db[file_id]['path']) # Example if actual files were stored
    del shared_files_db[file_id]
    # In a real application, you would delete from the database
    # db.session.delete(file_object)
    # db.session.commit()
    print(f"File {file_id} removed by user {user_id}. Remaining files: {shared_files_db}")

    return jsonify({"message": "File removed successfully."}), 200

@app.route('/my-files', methods=['GET'])
@login_required
def get_my_files():
    user_id = session.get('user_id')
    user_files = [file for file_id, file in shared_files_db.items() if file['ownerId'] == user_id]
    return jsonify(user_files), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "user123"}
    # 4. Then, remove a file: DELETE request to [http://127.0.0.1:5000/remove-shared-file?fileId=file_abc](http://127.0.0.1:5000/remove-shared-file?fileId=file_abc)
    #    The session cookie will maintain the login.
    app.run(debug=True)
```
### 🧪 Senaryo 3: Bir dosya paylaşım platformunda kullanıcılar paylaşımlarını kaldırmak için kaldır butonuna tıklıyor. Buton arka planda dosya silme işlemini gerçekleştiriyor. Dosyalar kullanıcının yönetim panelinde güncelleniyor. İşlem doğrudan gerçekleşiyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 177
```typescript

// --- React Component (e.g., UserDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface SharedFile {
  id: string;
  name: string;
  ownerId: string;
  // Add other file properties as needed
}

const UserDashboard: React.FC = () => {
  const [userFiles, setUserFiles] = useState<SharedFile[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isLoggedIn = true; // Simulates user session status
  const currentUserId = 'user123'; // From authenticated user

  useEffect(() => {
    const fetchUserFiles = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/user/${currentUserId}/files`, {
          headers: {
            'Authorization': `Bearer your_auth_token_here`,
          },
        });
        if (!response.ok) {
          throw new Error('Failed to fetch user files.');
        }
        const data: SharedFile[] = await response.json();
        setUserFiles(data);
      } catch (err) {
        if (err instanceof Error) {
          setError(err.message);
        } else {
          setError('An unknown error occurred.');
        }
      } finally {
        setLoading(false);
      }
    };
    if (isLoggedIn) {
      fetchUserFiles();
    }
  }, [isLoggedIn, currentUserId]);

  const handleRemoveFile = async (fileId: string) => {
    if (!isLoggedIn) {
      alert('Please log in to remove files.');
      return;
    }

    if (!window.confirm('Are you sure you want to remove this file?')) {
      return;
    }

    try {
      const response = await fetch(`/api/remove-shared-file?fileId=${fileId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer your_auth_token_here`,
        },
      });

      if (response.ok) {
        // Update the state to remove the deleted file from the UI
        setUserFiles(prevFiles => prevFiles.filter(file => file.id !== fileId));
        alert('File removed successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to remove file: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error removing file:', error);
      alert('An error occurred during file removal.');
    }
  };

  if (!isLoggedIn) {
    return <p>Please log in to manage your shared files.</p>;
  }

  if (loading) {
    return <p>Loading files...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Shared Files</h2>
      {userFiles.length === 0 ? (
        <p>No files shared yet.</p>
      ) : (
        <ul>
          {userFiles.map(file => (
            <li key={file.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px' }}>
              <span>{file.name}</span>
              <button onClick={() => handleRemoveFile(file.id)} style={{ marginLeft: '20px' }}>Remove</button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default UserDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3003;

app.use(bodyParser.json());

// In-memory data store for shared files
interface SharedFileDB {
  [key: string]: SharedFile;
}

const sharedFilesDB: SharedFileDB = {
  "file_alpha": { id: "file_alpha", name: "Report_Q1.xlsx", ownerId: "user123" },
  "file_beta": { id: "file_beta", name: "Presentation.pptx", ownerId: "user123" },
  "file_gamma": { id: "file_gamma", name: "ProjectPlan.docx", ownerId: "user456" },
};

// Middleware to simulate authentication
const authenticateUser = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.userId = 'user123'; // Simulate user ID from token
  next();
};

app.delete('/api/remove-shared-file', authenticateUser, (req: Request, res: Response) => {
  const fileId = req.query.fileId as string;
  const userId = req.body.userId; // User ID from authenticated session

  if (!fileId) {
    return res.status(400).json({ message: 'File ID is required.' });
  }

  const fileToRemove = sharedFilesDB[fileId];

  if (!fileToRemove) {
    return res.status(404).json({ message: 'File not found.' });
  }

  // Check if the authenticated user is the owner of the file
  if (fileToRemove.ownerId !== userId) {
    return res.status(403).json({ message: 'You are not authorized to remove this file.' });
  }

  delete sharedFilesDB[fileId];
  console.log(`File ${fileId} removed by ${userId}. Remaining files:`, sharedFilesDB);
  res.status(200).json({ message: 'File removed successfully.' });
});

// Endpoint to get files for a specific user (for dashboard loading)
app.get('/api/user/:userId/files', authenticateUser, (req: Request, res: Response) => {
  const { userId } = req.params;
  const files = Object.values(sharedFilesDB).filter(file => file.ownerId === userId);
  res.status(200).json(files);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 3 running on http://localhost:${PORT}`);
});
```
### 🧪 Senaryo 4: Bir çevrimiçi ödeme sisteminde kullanıcılar kayıtlı kartlarını silebiliyor. Kart silme işlemi kartın yanındaki ikon ile yapılıyor. İşlem sonucunda kart listesi yenileniyor. Kullanıcı oturumu açık olduğunda işlem gerçekleşebiliyor.
**💻 Dil:** `C#`

**🤖 AI:** Gemini

**Satır Sayısı:** 42
```csharp

[Authorize]
[HttpDelete("delete-payment-card")]
public async Task<IActionResult> DeletePaymentCard([FromQuery] string cardId)
{
    if (string.IsNullOrEmpty(cardId))
    {
        return BadRequest("Card ID cannot be empty.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a PaymentService or direct database interaction for card management
        // var paymentCard = await _dbContext.PaymentCards.FirstOrDefaultAsync(pc => pc.CardId == cardId && pc.UserId == userId);
        // if (paymentCard == null)
        // {
        //     return NotFound("Payment card not found or you do not own this card.");
        // }

        // // In a real system, you might interact with a payment gateway to de-tokenize/delete the card reference
        // // _paymentGatewayService.DeleteCardToken(paymentCard.Token);

        // _dbContext.PaymentCards.Remove(paymentCard);
        // await _dbContext.SaveChangesAsync();

        // Simulate successful deletion:
        Console.WriteLine($"Payment card {cardId} deleted by user {userId}.");

        return Ok(new { Message = "Payment card deleted successfully.", DeletedCardId = cardId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### 🧪 Senaryo 4: Bir çevrimiçi ödeme sisteminde kullanıcılar kayıtlı kartlarını silebiliyor. Kart silme işlemi kartın yanındaki ikon ile yapılıyor. İşlem sonucunda kart listesi yenileniyor. Kullanıcı oturumu açık olduğunda işlem gerçekleşebiliyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

**Satır Sayısı:** 72
```python

from flask import Flask, request, jsonify, session
from functools import wraps
import uuid

app = Flask(__name__)
app.secret_key = 'payment_secret_key' # Replace with a strong secret key

# In-memory database for payment cards (simulate)
payment_cards_db = {
    "card_111": {"id": "card_111", "last4": "1111", "cardType": "Visa", "userId": "user_pay123"},
    "card_222": {"id": "card_222", "last4": "2222", "cardType": "MasterCard", "userId": "user_pay123"},
    "card_333": {"id": "card_333", "last4": "3333", "cardType": "Amex", "userId": "user_pay456"}
}

# Simulate user authentication
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({"message": "Unauthorized: User login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    if username == 'user_pay123':
        session['user_id'] = 'user_pay123'
        return jsonify({"message": "Logged in successfully to payment system."}), 200
    return jsonify({"message": "Invalid username."}), 401

@app.route('/delete-payment-card', methods=['DELETE'])
@login_required
def delete_payment_card():
    card_id = request.args.get('cardId')

    if not card_id:
        return jsonify({"message": "Card ID cannot be empty."}), 400

    user_id = session.get('user_id')

    if card_id not in payment_cards_db:
        return jsonify({"message": "Payment card not found."}), 404

    if payment_cards_db[card_id]['userId'] != user_id:
        return jsonify({"message": "You do not own this card."}), 403

    del payment_cards_db[card_id]
    # In a real system, you'd interact with a payment gateway and update your database
    print(f"Payment card {card_id} deleted by user {user_id}. Remaining cards: {payment_cards_db}")

    # Return the updated list of cards
    updated_card_list = [card for card_key, card in payment_cards_db.items() if card['userId'] == user_id]
    return jsonify({"message": "Payment card deleted successfully.", "updatedCardList": updated_card_list}), 200

@app.route('/my-cards', methods=['GET'])
@login_required
def get_my_cards():
    user_id = session.get('user_id')
    user_cards = [card for card_key, card in payment_cards_db.items() if card['userId'] == user_id]
    return jsonify(user_cards), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "user_pay123"}
    # 4. Then, delete a card: DELETE request to [http://127.0.0.1:5000/delete-payment-card?cardId=card_111](http://127.0.0.1:5000/delete-payment-card?cardId=card_111)
    #    The session cookie will maintain the login.
    app.run(debug=True)
```
### 🧪 Senaryo 4: Bir çevrimiçi ödeme sisteminde kullanıcılar kayıtlı kartlarını silebiliyor. Kart silme işlemi kartın yanındaki ikon ile yapılıyor. İşlem sonucunda kart listesi yenileniyor. Kullanıcı oturumu açık olduğunda işlem gerçekleşebiliyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 184
```typescript

// --- React Component (e.g., PaymentMethodSettings.tsx) ---
import React, { useState, useEffect } from 'react';

interface PaymentCard {
  id: string;
  last4: string;
  cardType: string;
  userId: string;
  // Add other card details you might display
}

const PaymentMethodSettings: React.FC = () => {
  const [paymentCards, setPaymentCards] = useState<PaymentCard[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isLoggedIn = true; // Simulates user session status
  const currentUserId = 'user_pay123'; // From authenticated user

  const fetchPaymentCards = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/user/${currentUserId}/payment-cards`, {
        headers: {
          'Authorization': `Bearer your_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch payment cards.');
      }
      const data: PaymentCard[] = await response.json();
      setPaymentCards(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isLoggedIn) {
      fetchPaymentCards();
    }
  }, [isLoggedIn, currentUserId]);

  const handleDeleteCard = async (cardId: string) => {
    if (!isLoggedIn) {
      alert('Please log in to manage payment methods.');
      return;
    }

    if (!window.confirm('Are you sure you want to delete this card? This action cannot be undone.')) {
      return;
    }

    try {
      const response = await fetch(`/api/delete-payment-card?cardId=${cardId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer your_auth_token_here',
        },
      });

      if (response.ok) {
        // Option 1: Re-fetch the entire list to ensure consistency
        await fetchPaymentCards();
        alert('Card deleted successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to delete card: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error deleting card:', error);
      alert('An error occurred during card deletion.');
    }
  };

  if (!isLoggedIn) {
    return <p>Please log in to manage your payment methods.</p>;
  }

  if (loading) {
    return <p>Loading payment cards...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Payment Methods</h2>
      {paymentCards.length === 0 ? (
        <p>No payment cards registered yet.</p>
      ) : (
        <ul>
          {paymentCards.map(card => (
            <li key={card.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <span>**** **** **** {card.last4} ({card.cardType})</span>
              <button onClick={() => handleDeleteCard(card.id)} style={{ background: 'none', border: 'none', cursor: 'pointer', color: 'red', fontSize: '1.2em' }}>
                🗑️ {/* Trash can icon */}
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default PaymentMethodSettings;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3004;

app.use(bodyParser.json());

// In-memory data store for payment cards
interface PaymentCardDB {
  [key: string]: PaymentCard;
}

const paymentCardsDB: PaymentCardDB = {
  "card_aaa": { id: "card_aaa", last4: "1234", cardType: "Visa", userId: "user_pay123" },
  "card_bbb": { id: "card_bbb", last4: "5678", cardType: "MasterCard", userId: "user_pay123" },
  "card_ccc": { id: "card_ccc", last4: "9012", cardType: "Amex", userId: "user_pay456" },
};

// Middleware to simulate authentication
const authenticateUser = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.userId = 'user_pay123'; // Simulate user ID from token
  next();
};

app.delete('/api/delete-payment-card', authenticateUser, (req: Request, res: Response) => {
  const cardId = req.query.cardId as string;
  const userId = req.body.userId; // User ID from authenticated session

  if (!cardId) {
    return res.status(400).json({ message: 'Card ID is required.' });
  }

  const cardToDelete = paymentCardsDB[cardId];

  if (!cardToDelete) {
    return res.status(404).json({ message: 'Payment card not found.' });
  }

  // Check if the authenticated user owns this card
  if (cardToDelete.userId !== userId) {
    return res.status(403).json({ message: 'You are not authorized to delete this card.' });
  }

  delete paymentCardsDB[cardId];
  console.log(`Payment card ${cardId} deleted by ${userId}. Remaining cards:`, paymentCardsDB);

  // Return updated list of cards for the user
  const updatedCardList = Object.values(paymentCardsDB).filter(card => card.userId === userId);
  res.status(200).json({ message: 'Payment card deleted successfully.', updatedCardList });
});

// Endpoint to get payment cards for a specific user (for dashboard loading)
app.get('/api/user/:userId/payment-cards', authenticateUser, (req: Request, res: Response) => {
  const { userId } = req.params;
  const cards = Object.values(paymentCardsDB).filter(card => card.userId === userId);
  res.status(200).json(cards);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 4 running on http://localhost:${PORT}`);
});
```
### 🧪 Senaryo 5: Bir içerik yönetim sisteminde yöneticiler sayfa yayın durumunu değiştirebiliyor. Yayından kaldırma işlemi bağlantı tıklaması ile yapılıyor. Sistem bu işlemi gerçekleştirip sayfa durumunu güncelliyor. Yöneticiler işlem sonrası aynı panelde kalıyor.
**💻 Dil:** `C#`

**🤖 AI:** Gemini

**Satır Sayısı:** 45
```csharp

[Authorize(Roles = "Administrator")]
[HttpPost("change-page-publication-status")]
public async Task<IActionResult> ChangePagePublicationStatus([FromBody] ChangePageStatusRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.PageId))
    {
        return BadRequest("Page ID is required.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a PageService or direct database interaction
        // var page = await _dbContext.CmsPages.FindAsync(request.PageId);
        // if (page == null)
        // {
        //     return NotFound("Page not found.");
        // }

        // page.IsPublished = request.IsPublished;
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"Page {request.PageId} publication status changed to {request.IsPublished} by admin {userId}.");

        return Ok(new { Message = "Page publication status updated successfully.", PageId = request.PageId, IsPublished = request.IsPublished });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class ChangePageStatusRequest
{
    public string PageId { get; set; }
    public bool IsPublished { get; set; }
}
```
### 🧪 Senaryo 5: Bir içerik yönetim sisteminde yöneticiler sayfa yayın durumunu değiştirebiliyor. Yayından kaldırma işlemi bağlantı tıklaması ile yapılıyor. Sistem bu işlemi gerçekleştirip sayfa durumunu güncelliyor. Yöneticiler işlem sonrası aynı panelde kalıyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

**Satır Sayısı:** 69
```python

from flask import Flask, request, jsonify, session
from functools import wraps

app = Flask(__name__)
app.secret_key = 'cms_secret_key'

# In-memory database for CMS pages (simulate)
cms_pages_db = {
    "page_home": {"id": "page_home", "title": "Homepage", "isPublished": True},
    "page_about": {"id": "page_about", "title": "About Us", "isPublished": True},
    "page_draft": {"id": "page_draft", "title": "Draft Page", "isPublished": False}
}

# Simulate administrator authentication
def admin_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'admin':
            return jsonify({"message": "Unauthorized: Administrator login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'admin' and password == 'adminpass': # Mock admin login
        session['user_id'] = 'admin123'
        session['role'] = 'admin'
        return jsonify({"message": "Logged in successfully as admin."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/change-page-publication-status', methods=['POST'])
@admin_login_required
def change_page_publication_status():
    data = request.get_json()
    page_id = data.get('pageId')
    is_published = data.get('isPublished')

    if not page_id or is_published is None:
        return jsonify({"message": "Page ID and publication status are required."}), 400

    if page_id not in cms_pages_db:
        return jsonify({"message": "Page not found."}), 404

    cms_pages_db[page_id]['isPublished'] = is_published
    # In a real application, you would update the database
    # db.session.commit()
    print(f"Page {page_id} publication status changed to {is_published} by admin {session.get('user_id')}.")

    return jsonify({"message": "Page publication status updated successfully.",
                    "page": cms_pages_db[page_id]}), 200

@app.route('/admin/pages', methods=['GET'])
@admin_login_required
def get_admin_pages():
    return jsonify(list(cms_pages_db.values())), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "admin", "password": "adminpass"}
    # 4. Then, change page status: POST to [http://127.0.0.1:5000/change-page-publication-status](http://127.0.0.1:5000/change-page-publication-status)
    #    with {"pageId": "page_home", "isPublished": false}
    app.run(debug=True)
```
### 🧪 Senaryo 5: Bir içerik yönetim sisteminde yöneticiler sayfa yayın durumunu değiştirebiliyor. Yayından kaldırma işlemi bağlantı tıklaması ile yapılıyor. Sistem bu işlemi gerçekleştirip sayfa durumunu güncelliyor. Yöneticiler işlem sonrası aynı panelde kalıyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 183
```typescript

// --- React Component (e.g., AdminPageManagement.tsx) ---
import React, { useState, useEffect } from 'react';

interface CmsPage {
  id: string;
  title: string;
  isPublished: boolean;
  // Add other page properties as needed
}

const AdminPageManagement: React.FC = () => {
  const [pages, setPages] = useState<CmsPage[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isAdminLoggedIn = true; // Simulates admin session status

  const fetchPages = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/admin/pages', {
        headers: {
          'Authorization': `Bearer your_admin_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch pages.');
      }
      const data: CmsPage[] = await response.json();
      setPages(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isAdminLoggedIn) {
      fetchPages();
    }
  }, [isAdminLoggedIn]);

  const handleChangePublicationStatus = async (pageId: string, currentStatus: boolean) => {
    if (!isAdminLoggedIn) {
      alert('You must be logged in as an administrator to change page status.');
      return;
    }

    const newStatus = !currentStatus; // Toggle status
    const actionText = newStatus ? 'publish' : 'unpublish';

    if (!window.confirm(`Are you sure you want to ${actionText} this page?`)) {
      return;
    }

    try {
      const response = await fetch('/api/change-page-publication-status', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_admin_auth_token_here`,
        },
        body: JSON.stringify({ pageId, isPublished: newStatus }),
      });

      if (response.ok) {
        // Update the state to reflect the new status
        setPages(prevPages =>
          prevPages.map(page =>
            page.id === pageId ? { ...page, isPublished: newStatus } : page
          )
        );
        alert(`Page status updated successfully to ${newStatus ? 'Published' : 'Unpublished'}!`);
      } else {
        const errorData = await response.json();
        alert(`Failed to update page status: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error changing publication status:', error);
      alert('An error occurred during status update.');
    }
  };

  if (!isAdminLoggedIn) {
    return <p>Access denied. Please log in as an administrator.</p>;
  }

  if (loading) {
    return <p>Loading pages...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>CMS Page Management</h2>
      {pages.length === 0 ? (
        <p>No pages found.</p>
      ) : (
        <ul>
          {pages.map(page => (
            <li key={page.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <span>{page.title} - Status: {page.isPublished ? 'Published' : 'Unpublished'}</span>
              <button onClick={() => handleChangePublicationStatus(page.id, page.isPublished)}>
                {page.isPublished ? 'Unpublish' : 'Publish'}
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default AdminPageManagement;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3005;

app.use(bodyParser.json());

// In-memory data store for CMS pages
interface CmsPageDB {
  [key: string]: CmsPage;
}

const cmsPagesDB: CmsPageDB = {
  "page_A": { id: "page_A", title: "About Us", isPublished: true },
  "page_B": { id: "page_B", title: "Services", isPublished: true },
  "page_C": { id: "page_C", title: "Contact Us (Draft)", isPublished: false },
};

// Middleware to simulate administrator authentication
const authorizeAdmin = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  // In a real app, verify JWT and check for admin role
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  // Simulate admin user ID
  req.body.adminId = 'admin123';
  next();
};

app.post('/api/change-page-publication-status', authorizeAdmin, (req: Request, res: Response) => {
  const { pageId, isPublished } = req.body;
  const adminId = req.body.adminId; // Admin ID from authenticated session

  if (!pageId || typeof isPublished !== 'boolean') {
    return res.status(400).json({ message: 'Page ID and publication status are required.' });
  }

  const pageToUpdate = cmsPagesDB[pageId];

  if (!pageToUpdate) {
    return res.status(404).json({ message: 'Page not found.' });
  }

  pageToUpdate.isPublished = isPublished;
  console.log(`Page ${pageId} publication status set to ${isPublished} by admin ${adminId}.`);
  res.status(200).json({ message: 'Page publication status updated successfully.', page: pageToUpdate });
});

// Endpoint to get all CMS pages for admin panel
app.get('/api/admin/pages', authorizeAdmin, (req: Request, res: Response) => {
  res.status(200).json(Object.values(cmsPagesDB));
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 5 running on http://localhost:${PORT}`);
});
```
### 🧪 Senaryo 6: Bir haber uygulamasında editörler kullanıcı yorumlarını gizleyebiliyor. Yorumun yanındaki gizle bağlantısı ile yorum pasif hale getiriliyor. Editör bu işlemi gerçekleştirerek yorum durumunu değiştiriyor. İşlem sonucu yorum listesi güncelleniyor.
**💻 Dil:** `C#`

**🤖 AI:** Gemini

**Satır Sayısı:** 47
```csharp

[Authorize(Roles = "Editor")]
[HttpPost("hide-user-comment")]
public async Task<IActionResult> HideUserComment([FromBody] HideCommentRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.CommentId))
    {
        return BadRequest("Comment ID is required.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a CommentService or direct database interaction
        // var comment = await _dbContext.NewsComments.FindAsync(request.CommentId);
        // if (comment == null)
        // {
        //     return NotFound("Comment not found.");
        // }

        // // Set the comment status to hidden/inactive
        // comment.IsHidden = true; // Or comment.Status = CommentStatus.Hidden;
        // comment.HiddenByEditorId = userId;
        // comment.HiddenDate = DateTime.UtcNow;
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"Comment {request.CommentId} hidden by editor {userId}.");

        return Ok(new { Message = "Comment hidden successfully.", CommentId = request.CommentId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class HideCommentRequest
{
    public string CommentId { get; set; }
}
```
### 🧪 Senaryo 6: Bir haber uygulamasında editörler kullanıcı yorumlarını gizleyebiliyor. Yorumun yanındaki gizle bağlantısı ile yorum pasif hale getiriliyor. Editör bu işlemi gerçekleştirerek yorum durumunu değiştiriyor. İşlem sonucu yorum listesi güncelleniyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

**Satır Sayısı:** 68
```python

from flask import Flask, request, jsonify, session
from functools import wraps

app = Flask(__name__)
app.secret_key = 'news_app_secret'

# In-memory database for comments (simulate)
news_comments_db = {
    "comment_001": {"id": "comment_001", "text": "Great article!", "author": "userA", "isHidden": False},
    "comment_002": {"id": "comment_002", "text": "Spam comment.", "author": "userB", "isHidden": False},
    "comment_003": {"id": "comment_003", "text": "Interesting points.", "author": "userC", "isHidden": False}
}

# Simulate editor authentication
def editor_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'editor':
            return jsonify({"message": "Unauthorized: Editor login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'editor' and password == 'editorpass': # Mock editor login
        session['user_id'] = 'editor123'
        session['role'] = 'editor'
        return jsonify({"message": "Logged in successfully as editor."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/hide-user-comment', methods=['POST'])
@editor_login_required
def hide_user_comment():
    data = request.get_json()
    comment_id = data.get('commentId')

    if not comment_id:
        return jsonify({"message": "Comment ID is required."}), 400

    if comment_id not in news_comments_db:
        return jsonify({"message": "Comment not found."}), 404

    news_comments_db[comment_id]['isHidden'] = True
    # In a real application, you would update the database
    # db.session.commit()
    print(f"Comment {comment_id} hidden by editor {session.get('user_id')}.")

    # Return the updated list of comments for the editor panel
    return jsonify({"message": "Comment hidden successfully.",
                    "updatedCommentList": list(news_comments_db.values())}), 200

@app.route('/editor/comments', methods=['GET'])
@editor_login_required
def get_editor_comments():
    return jsonify(list(news_comments_db.values())), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "editor", "password": "editorpass"}
    # 4. Then, hide a comment: POST to [http://127.0.0.1:5000/hide-user-comment](http://127.0.0.1:5000/hide-user-comment) with {"commentId": "comment_002"}
    app.run(debug=True)
```
### 🧪 Senaryo 6: Bir haber uygulamasında editörler kullanıcı yorumlarını gizleyebiliyor. Yorumun yanındaki gizle bağlantısı ile yorum pasif hale getiriliyor. Editör bu işlemi gerçekleştirerek yorum durumunu değiştiriyor. İşlem sonucu yorum listesi güncelleniyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 183
```typescript

// --- React Component (e.g., EditorCommentModeration.tsx) ---
import React, { useState, useEffect } from 'react';

interface UserComment {
  id: string;
  text: string;
  author: string;
  isHidden: boolean;
  // Add other comment properties
}

const EditorCommentModeration: React.FC = () => {
  const [comments, setComments] = useState<UserComment[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isEditorLoggedIn = true; // Simulates editor session status

  const fetchComments = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/editor/comments', {
        headers: {
          'Authorization': `Bearer your_editor_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch comments.');
      }
      const data: UserComment[] = await response.json();
      setComments(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isEditorLoggedIn) {
      fetchComments();
    }
  }, [isEditorLoggedIn]);

  const handleToggleCommentVisibility = async (commentId: string, currentStatus: boolean) => {
    if (!isEditorLoggedIn) {
      alert('You must be logged in as an editor to moderate comments.');
      return;
    }

    const actionText = currentStatus ? 'unhide' : 'hide'; // If currently hidden, we want to unhide
    if (!window.confirm(`Are you sure you want to ${actionText} this comment?`)) {
      return;
    }

    try {
      const response = await fetch('/api/toggle-comment-visibility', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_editor_auth_token_here`,
        },
        body: JSON.stringify({ commentId, isHidden: !currentStatus }), // Toggle the status
      });

      if (response.ok) {
        // Update the state to reflect the new visibility
        setComments(prevComments =>
          prevComments.map(comment =>
            comment.id === commentId ? { ...comment, isHidden: !currentStatus } : comment
          )
        );
        alert(`Comment status updated successfully!`);
      } else {
        const errorData = await response.json();
        alert(`Failed to update comment status: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error toggling comment visibility:', error);
      alert('An error occurred during status update.');
    }
  };

  if (!isEditorLoggedIn) {
    return <p>Access denied. Please log in as an editor.</p>;
  }

  if (loading) {
    return <p>Loading comments...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>User Comment Moderation</h2>
      {comments.length === 0 ? (
        <p>No comments to moderate.</p>
      ) : (
        <ul>
          {comments.map(comment => (
            <li key={comment.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', backgroundColor: comment.isHidden ? '#ffe0e0' : 'white' }}>
              <div>
                <p><strong>{comment.author}:</strong> {comment.text}</p>
                <small>Status: {comment.isHidden ? 'Hidden' : 'Visible'}</small>
              </div>
              <button onClick={() => handleToggleCommentVisibility(comment.id, comment.isHidden)}>
                {comment.isHidden ? 'Unhide' : 'Hide'}
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default EditorCommentModeration;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3006;

app.use(bodyParser.json());

// In-memory data store for user comments
interface UserCommentDB {
  [key: string]: UserComment;
}

const newsCommentsDB: UserCommentDB = {
  "comment_X": { id: "comment_X", text: "Great article!", author: "Alice", isHidden: false },
  "comment_Y": { id: "comment_Y", text: "This is spam.", author: "Bob", isHidden: false },
  "comment_Z": { id: "comment_Z", text: "Very insightful.", author: "Charlie", isHidden: true },
};

// Middleware to simulate editor authentication
const authorizeEditor = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.editorId = 'editor123'; // Simulate editor ID
  next();
};

app.post('/api/toggle-comment-visibility', authorizeEditor, (req: Request, res: Response) => {
  const { commentId, isHidden } = req.body;
  const editorId = req.body.editorId;

  if (!commentId || typeof isHidden !== 'boolean') {
    return res.status(400).json({ message: 'Comment ID and visibility status are required.' });
  }

  const commentToUpdate = newsCommentsDB[commentId];

  if (!commentToUpdate) {
    return res.status(404).json({ message: 'Comment not found.' });
  }

  commentToUpdate.isHidden = isHidden;
  console.log(`Comment ${commentId} visibility set to ${isHidden} by editor ${editorId}.`);
  res.status(200).json({ message: 'Comment visibility updated successfully.', comment: commentToUpdate });
});

// Endpoint to get all comments for editor panel
app.get('/api/editor/comments', authorizeEditor, (req: Request, res: Response) => {
  res.status(200).json(Object.values(newsCommentsDB));
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 6 running on http://localhost:${PORT}`);
});
```
### 🧪 Senaryo 7: Bir müzik paylaşım platformunda sanatçılar şarkılarını kaldırmak için sil butonunu kullanıyor. Silme işlemi hızla gerçekleşiyor ve yeni ekran açılmadan tamamlanıyor. Oturum açık olduğunda işlem yapılabiliyor. Geri alma özelliği sunulmuyor.
**💻 Dil:** `C#`

**🤖 AI:** Gemini

**Satır Sayısı:** 42
```csharp

[Authorize(Roles = "Artist")]
[HttpDelete("delete-music-track")]
public async Task<IActionResult> DeleteMusicTrack([FromQuery] string trackId)
{
    if (string.IsNullOrEmpty(trackId))
    {
        return BadRequest("Track ID cannot be empty.");
    }

    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        return Unauthorized("User session is not active or user ID not found.");
    }

    try
    {
        // Assume a MusicService or direct database interaction
        // var musicTrack = await _dbContext.MusicTracks.FirstOrDefaultAsync(t => t.TrackId == trackId && t.ArtistId == userId);
        // if (musicTrack == null)
        // {
        //     return NotFound("Music track not found or you are not the artist.");
        // }

        // // Simulate deletion from storage (e.g., S3, Blob Storage)
        // _fileStorageService.DeleteFile(musicTrack.FilePath);

        // _dbContext.MusicTracks.Remove(musicTrack);
        // await _dbContext.SaveChangesAsync();

        // Simulate successful deletion:
        Console.WriteLine($"Music track {trackId} deleted by artist {userId}. (No undo)");

        return Ok(new { Message = "Music track deleted successfully.", DeletedTrackId = trackId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### 🧪 Senaryo 7: Bir müzik paylaşım platformunda sanatçılar şarkılarını kaldırmak için sil butonunu kullanıyor. Silme işlemi hızla gerçekleşiyor ve yeni ekran açılmadan tamamlanıyor. Oturum açık olduğunda işlem yapılabiliyor. Geri alma özelliği sunulmuyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

**Satır Sayısı:** 72
```python

from flask import Flask, request, jsonify, session
from functools import wraps
import uuid

app = Flask(__name__)
app.secret_key = 'music_secret_key'

# In-memory database for music tracks (simulate)
music_tracks_db = {
    "song_001": {"id": "song_001", "title": "My New Song", "artistId": "artist_a", "genre": "Pop"},
    "song_002": {"id": "song_002", "title": "Instrumental Peace", "artistId": "artist_a", "genre": "Relaxation"},
    "song_003": {"id": "song_003", "title": "Cover Tune", "artistId": "artist_b", "genre": "Rock"}
}

# Simulate artist authentication
def artist_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'artist':
            return jsonify({"message": "Unauthorized: Artist login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'artist_a' and password == 'musicpass': # Mock artist login
        session['user_id'] = 'artist_a'
        session['role'] = 'artist'
        return jsonify({"message": "Logged in successfully as artist."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/delete-music-track', methods=['DELETE'])
@artist_login_required
def delete_music_track():
    track_id = request.args.get('trackId')

    if not track_id:
        return jsonify({"message": "Track ID cannot be empty."}), 400

    user_id = session.get('user_id')

    if track_id not in music_tracks_db:
        return jsonify({"message": "Music track not found."}), 404

    if music_tracks_db[track_id]['artistId'] != user_id:
        return jsonify({"message": "You are not authorized to delete this track."}), 403

    del music_tracks_db[track_id]
    # In a real application, you would delete the file from storage and remove from database
    print(f"Music track {track_id} deleted by artist {user_id}. Remaining tracks: {music_tracks_db}")

    return jsonify({"message": "Music track deleted successfully."}), 200

@app.route('/my-tracks', methods=['GET'])
@artist_login_required
def get_my_tracks():
    user_id = session.get('user_id')
    artist_tracks = [track for track_id, track in music_tracks_db.items() if track['artistId'] == user_id]
    return jsonify(artist_tracks), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "artist_a", "password": "musicpass"}
    # 4. Then, delete a track: DELETE request to [http://127.0.0.1:5000/delete-music-track?trackId=song_001](http://127.0.0.1:5000/delete-music-track?trackId=song_001)
    app.run(debug=True)
```
### 🧪 Senaryo 7: Bir müzik paylaşım platformunda sanatçılar şarkılarını kaldırmak için sil butonunu kullanıyor. Silme işlemi hızla gerçekleşiyor ve yeni ekran açılmadan tamamlanıyor. Oturum açık olduğunda işlem yapılabiliyor. Geri alma özelliği sunulmuyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 181
```typescript

// --- React Component (e.g., ArtistDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface MusicTrack {
  id: string;
  title: string;
  artistId: string;
  genre: string;
  // Add other track details
}

const ArtistDashboard: React.FC = () => {
  const [musicTracks, setMusicTracks] = useState<MusicTrack[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isArtistLoggedIn = true; // Simulates artist session status
  const currentArtistId = 'artist_a'; // From authenticated artist

  const fetchMusicTracks = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/artist/${currentArtistId}/tracks`, {
        headers: {
          'Authorization': `Bearer your_artist_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch music tracks.');
      }
      const data: MusicTrack[] = await response.json();
      setMusicTracks(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isArtistLoggedIn) {
      fetchMusicTracks();
    }
  }, [isArtistLoggedIn, currentArtistId]);

  const handleDeleteTrack = async (trackId: string) => {
    if (!isArtistLoggedIn) {
      alert('Please log in as an artist to delete tracks.');
      return;
    }

    if (!window.confirm('Are you sure you want to delete this track? This action cannot be undone.')) {
      return;
    }

    try {
      const response = await fetch(`/api/delete-music-track?trackId=${trackId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer your_artist_auth_token_here`,
        },
      });

      if (response.ok) {
        // Update the state to remove the deleted track from the UI
        setMusicTracks(prevTracks => prevTracks.filter(track => track.id !== trackId));
        alert('Music track deleted successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to delete track: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error deleting track:', error);
      alert('An error occurred during track deletion.');
    }
  };

  if (!isArtistLoggedIn) {
    return <p>Access denied. Please log in as an artist.</p>;
  }

  if (loading) {
    return <p>Loading music tracks...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Music Tracks</h2>
      {musicTracks.length === 0 ? (
        <p>No tracks uploaded yet.</p>
      ) : (
        <ul>
          {musicTracks.map(track => (
            <li key={track.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <span>{track.title} ({track.genre})</span>
              <button onClick={() => handleDeleteTrack(track.id)} style={{ background: 'none', border: 'none', cursor: 'pointer', color: 'red', fontSize: '1em' }}>
                Delete
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default ArtistDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3007;

app.use(bodyParser.json());

// In-memory data store for music tracks
interface MusicTrackDB {
  [key: string]: MusicTrack;
}

const musicTracksDB: MusicTrackDB = {
  "track_101": { id: "track_101", title: "Sunset Melodies", artistId: "artist_a", genre: "Chillwave" },
  "track_102": { id: "track_102", title: "City Lights", artistId: "artist_a", genre: "Electronic" },
  "track_103": { id: "track_103", title: "Acoustic Dreams", artistId: "artist_b", genre: "Acoustic" },
};

// Middleware to simulate artist authentication
const authorizeArtist = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.artistId = 'artist_a'; // Simulate artist ID from token
  next();
};

app.delete('/api/delete-music-track', authorizeArtist, (req: Request, res: Response) => {
  const trackId = req.query.trackId as string;
  const artistId = req.body.artistId; // Artist ID from authenticated session

  if (!trackId) {
    return res.status(400).json({ message: 'Track ID is required.' });
  }

  const trackToDelete = musicTracksDB[trackId];

  if (!trackToDelete) {
    return res.status(404).json({ message: 'Music track not found.' });
  }

  // Check if the authenticated artist owns this track
  if (trackToDelete.artistId !== artistId) {
    return res.status(403).json({ message: 'You are not authorized to delete this track.' });
  }

  delete musicTracksDB[trackId];
  console.log(`Music track ${trackId} deleted by artist ${artistId}. Remaining tracks:`, musicTracksDB);
  res.status(200).json({ message: 'Music track deleted successfully.' });
});

// Endpoint to get tracks for a specific artist (for dashboard loading)
app.get('/api/artist/:artistId/tracks', authorizeArtist, (req: Request, res: Response) => {
  const { artistId } = req.params;
  const tracks = Object.values(musicTracksDB).filter(track => track.artistId === artistId);
  res.status(200).json(tracks);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 7 running on http://localhost:${PORT}`);
});
```
### 🧪 Senaryo 8: Bir forum uygulamasında yöneticiler kullanıcı profillerini askıya alabiliyor. Askıya alma işlemi profildeki butonla tetikleniyor. İşlem arka planda çalışıp yönetici panelini güncelliyor. Onay kutusu gösterilmiyor.
**💻 Dil:** `C#`

**🤖 AI:** Gemini

**Satır Sayısı:** 52
```csharp

[Authorize(Roles = "Moderator, Admin")]
[HttpPost("suspend-user-profile")]
public async Task<IActionResult> SuspendUserProfile([FromBody] SuspendUserRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.UserId))
    {
        return BadRequest("User ID is required.");
    }

    var moderatorId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(moderatorId))
    {
        return Unauthorized("User session is not active or moderator ID not found.");
    }

    try
    {
        // Assume a UserService or direct database interaction
        // var userProfile = await _dbContext.UserProfiles.FindAsync(request.UserId);
        // if (userProfile == null)
        // {
        //     return NotFound("User profile not found.");
        // }

        // // Prevent suspending an admin or self-suspension (important security consideration)
        // if (userProfile.Role == UserRole.Admin || userProfile.UserId == moderatorId)
        // {
        //     return Forbid("Cannot suspend this user.");
        // }

        // userProfile.IsSuspended = true;
        // userProfile.SuspendedBy = moderatorId;
        // userProfile.SuspensionDate = DateTime.UtcNow;
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"User profile {request.UserId} suspended by moderator {moderatorId}.");

        return Ok(new { Message = "User profile suspended successfully.", SuspendedUserId = request.UserId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class SuspendUserRequest
{
    public string UserId { get; set; }
}
```
### 🧪 Senaryo 8: Bir forum uygulamasında yöneticiler kullanıcı profillerini askıya alabiliyor. Askıya alma işlemi profildeki butonla tetikleniyor. İşlem arka planda çalışıp yönetici panelini güncelliyor. Onay kutusu gösterilmiyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

**Satır Sayısı:** 82
```python

from flask import Flask, request, jsonify, session
from functools import wraps

app = Flask(__name__)
app.secret_key = 'forum_secret_key'

# In-memory database for user profiles (simulate)
user_profiles_db = {
    "user_alice": {"id": "user_alice", "username": "Alice", "role": "user", "isSuspended": False},
    "user_bob": {"id": "user_bob", "username": "Bob", "role": "user", "isSuspended": False},
    "admin_charlie": {"id": "admin_charlie", "username": "Charlie", "role": "admin", "isSuspended": False}
}

# Simulate moderator/admin authentication
def moderator_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') not in ['moderator', 'admin']:
            return jsonify({"message": "Unauthorized: Moderator/Admin login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'moderator' and password == 'modpass':
        session['user_id'] = 'mod123'
        session['role'] = 'moderator'
        return jsonify({"message": "Logged in successfully as moderator."}), 200
    if username == 'admin' and password == 'adminpass':
        session['user_id'] = 'admin456'
        session['role'] = 'admin'
        return jsonify({"message": "Logged in successfully as admin."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/suspend-user-profile', methods=['POST'])
@moderator_login_required
def suspend_user_profile():
    data = request.get_json()
    user_id_to_suspend = data.get('userId')

    if not user_id_to_suspend:
        return jsonify({"message": "User ID is required."}), 400

    moderator_id = session.get('user_id')

    if user_id_to_suspend not in user_profiles_db:
        return jsonify({"message": "User profile not found."}), 404

    target_user = user_profiles_db[user_id_to_suspend]

    # Prevent suspending an admin or self-suspension
    if target_user['role'] == 'admin' or target_user['id'] == moderator_id:
        return jsonify({"message": "Cannot suspend this user."}), 403

    target_user['isSuspended'] = True
    target_user['suspendedBy'] = moderator_id
    target_user['suspensionDate'] = datetime.utcnow().isoformat()
    # In a real application, you would update the database
    # db.session.commit()
    print(f"User {user_id_to_suspend} suspended by {moderator_id}. Profile: {target_user}")

    # Return the updated list of profiles for the admin/moderator panel
    return jsonify({"message": "User profile suspended successfully.",
                    "updatedUserProfile": target_user}), 200

@app.route('/admin/users', methods=['GET'])
@moderator_login_required
def get_admin_users():
    return jsonify(list(user_profiles_db.values())), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "moderator", "password": "modpass"}
    # 4. Then, suspend a user: POST to [http://127.0.0.1:5000/suspend-user-profile](http://127.0.0.1:5000/suspend-user-profile) with {"userId": "user_alice"}
    app.run(debug=True)
```
### 🧪 Senaryo 8: Bir forum uygulamasında yöneticiler kullanıcı profillerini askıya alabiliyor. Askıya alma işlemi profildeki butonla tetikleniyor. İşlem arka planda çalışıp yönetici panelini güncelliyor. Onay kutusu gösterilmiyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 201
```typescript

// --- React Component (e.g., ModeratorDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface UserProfile {
  id: string;
  username: string;
  role: string;
  isSuspended: boolean;
  // Add other profile properties
}

const ModeratorDashboard: React.FC = () => {
  const [userProfiles, setUserProfiles] = useState<UserProfile[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isModeratorLoggedIn = true; // Simulates moderator/admin session
  const currentModeratorId = 'mod123'; // From authenticated moderator

  const fetchUserProfiles = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/admin/users', {
        headers: {
          'Authorization': `Bearer your_moderator_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch user profiles.');
      }
      const data: UserProfile[] = await response.json();
      setUserProfiles(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isModeratorLoggedIn) {
      fetchUserProfiles();
    }
  }, [isModeratorLoggedIn]);

  const handleToggleSuspension = async (userId: string, currentStatus: boolean, role: string) => {
    if (!isModeratorLoggedIn) {
      alert('You must be logged in as a moderator or administrator.');
      return;
    }

    if (role === 'admin' || userId === currentModeratorId) {
      alert('Cannot suspend an administrator or yourself.');
      return;
    }

    // No confirmation dialog as per scenario description ("Onay kutusu gösterilmiyor")
    // If you wanted one, it would be:
    // if (!window.confirm(`Are you sure you want to ${currentStatus ? 'unsuspend' : 'suspend'} this user?`)) { return; }

    const newStatus = !currentStatus; // Toggle suspension status

    try {
      const response = await fetch('/api/toggle-user-suspension', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_moderator_auth_token_here`,
        },
        body: JSON.stringify({ userId, isSuspended: newStatus }),
      });

      if (response.ok) {
        // Update the state to reflect the new suspension status
        setUserProfiles(prevProfiles =>
          prevProfiles.map(profile =>
            profile.id === userId ? { ...profile, isSuspended: newStatus } : profile
          )
        );
        alert(`User ${userId} suspension status updated!`);
      } else {
        const errorData = await response.json();
        alert(`Failed to update suspension status: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error toggling suspension:', error);
      alert('An error occurred during status update.');
    }
  };

  if (!isModeratorLoggedIn) {
    return <p>Access denied. Please log in as a moderator or administrator.</p>;
  }

  if (loading) {
    return <p>Loading user profiles...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>User Profile Management</h2>
      {userProfiles.length === 0 ? (
        <p>No user profiles found.</p>
      ) : (
        <ul>
          {userProfiles.map(profile => (
            <li key={profile.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', backgroundColor: profile.isSuspended ? '#ffdddd' : 'white' }}>
              <div>
                <p><strong>{profile.username}</strong> ({profile.role})</p>
                <small>Status: {profile.isSuspended ? 'Suspended' : 'Active'}</small>
              </div>
              {profile.role !== 'admin' && profile.id !== currentModeratorId && ( // Cannot suspend admin or self
                <button onClick={() => handleToggleSuspension(profile.id, profile.isSuspended, profile.role)}>
                  {profile.isSuspended ? 'Activate' : 'Suspend'}
                </button>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default ModeratorDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3008;

app.use(bodyParser.json());

// In-memory data store for user profiles
interface UserProfileDB {
  [key: string]: UserProfile;
}

const userProfilesDB: UserProfileDB = {
  "user_1": { id: "user_1", username: "Alice", role: "user", isSuspended: false },
  "user_2": { id: "user_2", username: "Bob", role: "user", isSuspended: false },
  "user_3": { id: "user_3", username: "Charlie", role: "user", isSuspended: true }, // Example: already suspended
  "admin_1": { id: "admin_1", username: "AdminUser", role: "admin", isSuspended: false },
};

// Middleware to simulate moderator/admin authentication
const authorizeModerator = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  // In a real app, verify token and check for 'moderator' or 'admin' role
  req.body.actingUserId = 'mod123'; // Simulate the ID of the moderator/admin performing the action
  req.body.actingUserRole = 'moderator'; // Simulate the role
  next();
};

app.post('/api/toggle-user-suspension', authorizeModerator, (req: Request, res: Response) => {
  const { userId, isSuspended } = req.body;
  const actingUserId = req.body.actingUserId;
  const actingUserRole = req.body.actingUserRole;

  if (!userId || typeof isSuspended !== 'boolean') {
    return res.status(400).json({ message: 'User ID and suspension status are required.' });
  }

  const userToUpdate = userProfilesDB[userId];

  if (!userToUpdate) {
    return res.status(404).json({ message: 'User profile not found.' });
  }

  // Prevent suspending an admin or self-suspension
  if (userToUpdate.role === 'admin' || userToUpdate.id === actingUserId) {
    return res.status(403).json({ message: 'Cannot suspend this user.' });
  }

  userToUpdate.isSuspended = isSuspended;
  console.log(`User ${userId} suspension status set to ${isSuspended} by ${actingUserRole} ${actingUserId}.`);
  res.status(200).json({ message: 'User suspension status updated successfully.', user: userToUpdate });
});

// Endpoint to get all user profiles for moderator panel
app.get('/api/admin/users', authorizeModerator, (req: Request, res: Response) => {
  res.status(200).json(Object.values(userProfilesDB));
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 8 running on http://localhost:${PORT}`);
});
```
### 🧪 Senaryo 9: Bir görev yönetim aracında ekip lideri görevleri iptal edebiliyor. İptal işlemi görev detay ekranında tek tıklamayla yapılıyor. Görevler listesinden görev kaldırılıyor. Ek doğrulama istenmeden işlem gerçekleşiyor.
**💻 Dil:** `C#`

**🤖 AI:** Gemini

**Satır Sayısı:** 46
```csharp

[Authorize(Roles = "TeamLeader")]
[HttpPost("cancel-task")]
public async Task<IActionResult> CancelTask([FromBody] CancelTaskRequest request)
{
    if (request == null || string.IsNullOrEmpty(request.TaskId))
    {
        return BadRequest("Task ID is required.");
    }

    var teamLeaderId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(teamLeaderId))
    {
        return Unauthorized("User session is not active or team leader ID not found.");
    }

    try
    {
        // Assume a TaskService or direct database interaction
        // var task = await _dbContext.Tasks.FirstOrDefaultAsync(t => t.TaskId == request.TaskId && t.TeamLeaderId == teamLeaderId);
        // if (task == null)
        // {
        //     return NotFound("Task not found or you are not the team leader for this task.");
        // }

        // task.Status = TaskStatus.Cancelled;
        // task.CancellationDate = DateTime.UtcNow;
        // task.CancelledBy = teamLeaderId;
        // await _dbContext.SaveChangesAsync();

        // Simulate database operation:
        Console.WriteLine($"Task {request.TaskId} cancelled by team leader {teamLeaderId}.");

        return Ok(new { Message = "Task cancelled successfully.", CancelledTaskId = request.TaskId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}

public class CancelTaskRequest
{
    public string TaskId { get; set; }
}
```
### 🧪 Senaryo 9: Bir görev yönetim aracında ekip lideri görevleri iptal edebiliyor. İptal işlemi görev detay ekranında tek tıklamayla yapılıyor. Görevler listesinden görev kaldırılıyor. Ek doğrulama istenmeden işlem gerçekleşiyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

**Satır Sayısı:** 83
```python

from flask import Flask, request, jsonify, session
from functools import wraps
from datetime import datetime

app = Flask(__name__)
app.secret_key = 'task_manager_secret'

# In-memory database for tasks (simulate)
tasks_db = {
    "task_101": {"id": "task_101", "name": "Prepare report", "assignedTo": "userX", "status": "Pending", "teamLeaderId": "leader_alpha"},
    "task_102": {"id": "task_102", "name": "Review code", "assignedTo": "userY", "status": "InProgress", "teamLeaderId": "leader_alpha"},
    "task_103": {"id": "task_103", "name": "Client meeting", "assignedTo": "userZ", "status": "Completed", "teamLeaderId": "leader_beta"}
}

# Simulate team leader authentication
def team_leader_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'team_leader':
            return jsonify({"message": "Unauthorized: Team leader login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'leader_alpha' and password == 'leaderpass': # Mock team leader login
        session['user_id'] = 'leader_alpha'
        session['role'] = 'team_leader'
        return jsonify({"message": "Logged in successfully as team leader."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/cancel-task', methods=['POST'])
@team_leader_login_required
def cancel_task():
    data = request.get_json()
    task_id = data.get('taskId')

    if not task_id:
        return jsonify({"message": "Task ID is required."}), 400

    team_leader_id = session.get('user_id')

    if task_id not in tasks_db:
        return jsonify({"message": "Task not found."}), 404

    target_task = tasks_db[task_id]

    if target_task['teamLeaderId'] != team_leader_id:
        return jsonify({"message": "You are not authorized to cancel this task."}), 403

    target_task['status'] = 'Cancelled'
    target_task['cancellationDate'] = datetime.utcnow().isoformat()
    target_task['cancelledBy'] = team_leader_id
    # In a real application, you would update the database
    # db.session.commit()
    print(f"Task {task_id} cancelled by team leader {team_leader_id}. Task status: {target_task['status']}")

    # Optionally, remove from the active list if 'cancelled' means removal
    # del tasks_db[task_id]
    # For this scenario, we keep it but update status, so it will be filtered on frontend.

    return jsonify({"message": "Task cancelled successfully.",
                    "cancelledTask": target_task}), 200

@app.route('/leader/tasks', methods=['GET'])
@team_leader_login_required
def get_leader_tasks():
    team_leader_id = session.get('user_id')
    leader_tasks = [task for task_id, task in tasks_db.items() if task['teamLeaderId'] == team_leader_id]
    return jsonify(leader_tasks), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "leader_alpha", "password": "leaderpass"}
    # 4. Then, cancel a task: POST to [http://127.0.0.1:5000/cancel-task](http://127.0.0.1:5000/cancel-task) with {"taskId": "task_101"}
    app.run(debug=True)
```
### 🧪 Senaryo 9: Bir görev yönetim aracında ekip lideri görevleri iptal edebiliyor. İptal işlemi görev detay ekranında tek tıklamayla yapılıyor. Görevler listesinden görev kaldırılıyor. Ek doğrulama istenmeden işlem gerçekleşiyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 211
```typescript

// --- React Component (e.g., TaskLeaderDashboard.tsx) ---
import React, { useState, useEffect } from 'react';

interface Task {
  id: string;
  name: string;
  assignedTo: string;
  status: 'Pending' | 'InProgress' | 'Completed' | 'Cancelled';
  teamLeaderId: string;
}

const TaskLeaderDashboard: React.FC = () => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isTeamLeaderLoggedIn = true; // Simulates team leader session status
  const currentTeamLeaderId = 'leader_alpha'; // From authenticated team leader

  const fetchTasks = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/leader/${currentTeamLeaderId}/tasks`, {
        headers: {
          'Authorization': `Bearer your_teamleader_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch tasks.');
      }
      const data: Task[] = await response.json();
      setTasks(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isTeamLeaderLoggedIn) {
      fetchTasks();
    }
  }, [isTeamLeaderLoggedIn, currentTeamLeaderId]);

  const handleCancelTask = async (taskId: string, currentStatus: string) => {
    if (!isTeamLeaderLoggedIn) {
      alert('You must be logged in as a team leader to cancel tasks.');
      return;
    }

    if (currentStatus === 'Cancelled') {
        alert('This task is already cancelled.');
        return;
    }

    // No additional confirmation box as per scenario (tek tıklamayla yapılıyor)
    try {
      const response = await fetch('/api/cancel-task', {
        method: 'POST', // Using POST for state change
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer your_teamleader_auth_token_here`,
        },
        body: JSON.stringify({ taskId }),
      });

      if (response.ok) {
        // Update the state to reflect the cancelled task (remove from list if applicable, or change status)
        setTasks(prevTasks =>
          prevTasks.map(task =>
            task.id === taskId ? { ...task, status: 'Cancelled' } : task
          ).filter(task => task.id !== taskId) // Filter out the cancelled task from the list
        );
        alert('Task cancelled successfully!');
      } else {
        const errorData = await response.json();
        alert(`Failed to cancel task: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error cancelling task:', error);
      alert('An error occurred during task cancellation.');
    }
  };

  if (!isTeamLeaderLoggedIn) {
    return <p>Access denied. Please log in as a team leader.</p>;
  }

  if (loading) {
    return <p>Loading tasks...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  const activeTasks = tasks.filter(task => task.status !== 'Cancelled');

  return (
    <div>
      <h2>My Team's Tasks</h2>
      {activeTasks.length === 0 ? (
        <p>No active tasks found.</p>
      ) : (
        <ul>
          {activeTasks.map(task => (
            <li key={task.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <div>
                <p><strong>{task.name}</strong> - Assigned to: {task.assignedTo}</p>
                <small>Status: {task.status}</small>
              </div>
              <button onClick={() => handleCancelTask(task.id, task.status)} disabled={task.status === 'Cancelled'}>
                Cancel Task
              </button>
            </li>
          ))}
        </ul>
      )}

      <h3>Cancelled Tasks</h3>
      {tasks.filter(task => task.status === 'Cancelled').length === 0 ? (
          <p>No cancelled tasks.</p>
      ) : (
          <ul>
              {tasks.filter(task => task.status === 'Cancelled').map(task => (
                  <li key={task.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', backgroundColor: '#f0f0f0' }}>
                      <p><strong>{task.name}</strong> (Cancelled)</p>
                  </li>
              ))}
          </ul>
      )}
    </div>
  );
};

export default TaskLeaderDashboard;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3009;

app.use(bodyParser.json());

// In-memory data store for tasks
interface TaskDB {
  [key: string]: Task;
}

const tasksDB: TaskDB = {
  "task_alpha": { id: "task_alpha", name: "Deploy new feature", assignedTo: "dev1", status: "InProgress", teamLeaderId: "leader_alpha" },
  "task_beta": { id: "task_beta", name: "Write documentation", assignedTo: "techwriter", status: "Pending", teamLeaderId: "leader_alpha" },
  "task_gamma": { id: "task_gamma", name: "QA testing", assignedTo: "qa_engineer", status: "Completed", teamLeaderId: "leader_beta" },
};

// Middleware to simulate team leader authentication
const authorizeTeamLeader = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.teamLeaderId = 'leader_alpha'; // Simulate team leader ID
  next();
};

app.post('/api/cancel-task', authorizeTeamLeader, (req: Request, res: Response) => {
  const { taskId } = req.body;
  const teamLeaderId = req.body.teamLeaderId;

  if (!taskId) {
    return res.status(400).json({ message: 'Task ID is required.' });
  }

  const taskToUpdate = tasksDB[taskId];

  if (!taskToUpdate) {
    return res.status(404).json({ message: 'Task not found.' });
  }

  // Check if the authenticated team leader owns this task
  if (taskToUpdate.teamLeaderId !== teamLeaderId) {
    return res.status(403).json({ message: 'You are not authorized to cancel this task.' });
  }

  if (taskToUpdate.status === 'Cancelled') {
    return res.status(400).json({ message: 'Task is already cancelled.' });
  }

  taskToUpdate.status = 'Cancelled';
  console.log(`Task ${taskId} cancelled by team leader ${teamLeaderId}.`);
  res.status(200).json({ message: 'Task cancelled successfully.', task: taskToUpdate });
});

// Endpoint to get tasks for a specific team leader (for dashboard loading)
app.get('/api/leader/:teamLeaderId/tasks', authorizeTeamLeader, (req: Request, res: Response) => {
  const { teamLeaderId } = req.params;
  const tasks = Object.values(tasksDB).filter(task => task.teamLeaderId === teamLeaderId);
  res.status(200).json(tasks);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 9 running on http://localhost:${PORT}`);
});
```
### 🧪 Senaryo 10: Bir eğitim yönetim sisteminde öğretmenler duyuruları silebiliyor. Silme işlemi duyuru başlığının yanındaki bağlantı ile yapılıyor. Bu bağlantı sunucuya istek göndererek duyuruyu kaldırıyor. Öğretmen işlem sonrası aynı sayfada kalıyor.
**💻 Dil:** `C#`

**🤖 AI:** Gemini

**Satır Sayısı:** 39
```csharp

[Authorize(Roles = "Teacher")]
[HttpDelete("delete-announcement")]
public async Task<IActionResult> DeleteAnnouncement([FromQuery] string announcementId)
{
    if (string.IsNullOrEmpty(announcementId))
    {
        return BadRequest("Announcement ID cannot be empty.");
    }

    var teacherId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(teacherId))
    {
        return Unauthorized("User session is not active or teacher ID not found.");
    }

    try
    {
        // Assume an AnnouncementService or direct database interaction
        // var announcement = await _dbContext.Announcements.FirstOrDefaultAsync(a => a.AnnouncementId == announcementId && a.TeacherId == teacherId);
        // if (announcement == null)
        // {
        //     return NotFound("Announcement not found or you are not the creator of this announcement.");
        // }

        // _dbContext.Announcements.Remove(announcement);
        // await _dbContext.SaveChangesAsync();

        // Simulate successful deletion:
        Console.WriteLine($"Announcement {announcementId} deleted by teacher {teacherId}.");

        return Ok(new { Message = "Announcement deleted successfully.", DeletedAnnouncementId = announcementId });
    }
    catch (Exception ex)
    {
        // Log the exception
        return StatusCode(500, $"An error occurred: {ex.Message}");
    }
}
```
### 🧪 Senaryo 10: Bir eğitim yönetim sisteminde öğretmenler duyuruları silebiliyor. Silme işlemi duyuru başlığının yanındaki bağlantı ile yapılıyor. Bu bağlantı sunucuya istek göndererek duyuruyu kaldırıyor. Öğretmen işlem sonrası aynı sayfada kalıyor.
**💻 Dil:** `Python`

**🤖 AI:** Gemini

**Satır Sayısı:** 76
```python

from flask import Flask, request, jsonify, session
from functools import wraps
import uuid

app = Flask(__name__)
app.secret_key = 'edu_app_secret'

# In-memory database for announcements (simulate)
announcements_db = {
    "ann_001": {"id": "ann_001", "title": "Class Schedule Update", "content": "Classes will be online.", "teacherId": "teacher_mary"},
    "ann_002": {"id": "ann_002", "title": "Exam Date Change", "content": "Exam moved to Friday.", "teacherId": "teacher_mary"},
    "ann_003": {"id": "ann_003", "title": "New Course Available", "content": "Check out the new course.", "teacherId": "teacher_john"}
}

# Simulate teacher authentication
def teacher_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or session.get('role') != 'teacher':
            return jsonify({"message": "Unauthorized: Teacher login required."}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    if username == 'teacher_mary' and password == 'teachpass': # Mock teacher login
        session['user_id'] = 'teacher_mary'
        session['role'] = 'teacher'
        return jsonify({"message": "Logged in successfully as teacher."}), 200
    return jsonify({"message": "Invalid credentials."}), 401

@app.route('/delete-announcement', methods=['DELETE'])
@teacher_login_required
def delete_announcement():
    announcement_id = request.args.get('announcementId')

    if not announcement_id:
        return jsonify({"message": "Announcement ID cannot be empty."}), 400

    teacher_id = session.get('user_id')

    if announcement_id not in announcements_db:
        return jsonify({"message": "Announcement not found."}), 404

    if announcements_db[announcement_id]['teacherId'] != teacher_id:
        return jsonify({"message": "You are not authorized to delete this announcement."}), 403

    del announcements_db[announcement_id]
    # In a real application, you would delete from the database
    # db.session.delete(announcement_object)
    # db.session.commit()
    print(f"Announcement {announcement_id} deleted by teacher {teacher_id}. Remaining announcements: {announcements_db}")

    # Return the updated list of announcements for the teacher to stay on the same page
    updated_announcement_list = [ann for ann_id, ann in announcements_db.items() if ann['teacherId'] == teacher_id]
    return jsonify({"message": "Announcement deleted successfully.", "updatedAnnouncementList": updated_announcement_list}), 200

@app.route('/my-announcements', methods=['GET'])
@teacher_login_required
def get_my_announcements():
    teacher_id = session.get('user_id')
    teacher_announcements = [ann for ann_id, ann in announcements_db.items() if ann['teacherId'] == teacher_id]
    return jsonify(teacher_announcements), 200

if __name__ == '__main__':
    # To run this example:
    # 1. Save it as a .py file (e.g., app.py)
    # 2. Run: flask run
    # 3. First, log in: POST to [http://127.0.0.1:5000/login](http://127.0.0.1:5000/login) with {"username": "teacher_mary", "password": "teachpass"}
    # 4. Then, delete an announcement: DELETE request to [http://127.0.0.1:5000/delete-announcement?announcementId=ann_001](http://127.0.0.1:5000/delete-announcement?announcementId=ann_001)
    app.run(debug=True)
```
### 🧪 Senaryo 10: Bir eğitim yönetim sisteminde öğretmenler duyuruları silebiliyor. Silme işlemi duyuru başlığının yanındaki bağlantı ile yapılıyor. Bu bağlantı sunucuya istek göndererek duyuruyu kaldırıyor. Öğretmen işlem sonrası aynı sayfada kalıyor.
**💻 Dil:** `TypeScript (ReactJS)`

**🤖 AI:** Gemini

**Satır Sayısı:** 183
```typescript

// --- React Component (e.g., TeacherAnnouncements.tsx) ---
import React, { useState, useEffect } from 'react';

interface Announcement {
  id: string;
  title: string;
  content: string;
  teacherId: string;
}

const TeacherAnnouncements: React.FC = () => {
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const isTeacherLoggedIn = true; // Simulates teacher session status
  const currentTeacherId = 'teacher_mary'; // From authenticated teacher

  const fetchAnnouncements = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/teacher/${currentTeacherId}/announcements`, {
        headers: {
          'Authorization': `Bearer your_teacher_auth_token_here`,
        },
      });
      if (!response.ok) {
        throw new Error('Failed to fetch announcements.');
      }
      const data: Announcement[] = await response.json();
      setAnnouncements(data);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isTeacherLoggedIn) {
      fetchAnnouncements();
    }
  }, [isTeacherLoggedIn, currentTeacherId]);

  const handleDeleteAnnouncement = async (announcementId: string) => {
    if (!isTeacherLoggedIn) {
      alert('Please log in as a teacher to delete announcements.');
      return;
    }

    if (!window.confirm('Are you sure you want to delete this announcement?')) {
      return;
    }

    try {
      const response = await fetch(`/api/delete-announcement?announcementId=${announcementId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer your_teacher_auth_token_here`,
        },
      });

      if (response.ok) {
        // Update the state to remove the deleted announcement from the UI
        setAnnouncements(prevAnnouncements => prevAnnouncements.filter(ann => ann.id !== announcementId));
        alert('Announcement deleted successfully!');
        // The teacher stays on the same page, as the list updates.
      } else {
        const errorData = await response.json();
        alert(`Failed to delete announcement: ${errorData.message || response.statusText}`);
      }
    } catch (error) {
      console.error('Error deleting announcement:', error);
      alert('An error occurred during announcement deletion.');
    }
  };

  if (!isTeacherLoggedIn) {
    return <p>Access denied. Please log in as a teacher.</p>;
  }

  if (loading) {
    return <p>Loading announcements...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>My Announcements</h2>
      {announcements.length === 0 ? (
        <p>No announcements found.</p>
      ) : (
        <ul>
          {announcements.map(ann => (
            <li key={ann.id} style={{ marginBottom: '10px', border: '1px solid #eee', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <div>
                <h3>{ann.title}</h3>
                <p>{ann.content.substring(0, 100)}...</p>
              </div>
              <button onClick={() => handleDeleteAnnouncement(ann.id)} style={{ background: 'none', border: 'none', cursor: 'pointer', color: 'red', fontSize: '1em' }}>
                Delete
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default TeacherAnnouncements;

// --- Node.js Backend (e.g., server.ts using Express) ---
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
const PORT = 3010;

app.use(bodyParser.json());

// In-memory data store for announcements
interface AnnouncementDB {
  [key: string]: Announcement;
}

const announcementsDB: AnnouncementDB = {
  "ann_A": { id: "ann_A", title: "Holiday Break Notice", content: "School will be closed...", teacherId: "teacher_mary" },
  "ann_B": { id: "ann_B", title: "Parent-Teacher Conference", content: "Sign up for slots...", teacherId: "teacher_mary" },
  "ann_C": { id: "ann_C", title: "New Assignment Posted", content: "Check your portal...", teacherId: "teacher_john" },
};

// Middleware to simulate teacher authentication
const authorizeTeacher = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authentication token required.' });
  }
  req.body.teacherId = 'teacher_mary'; // Simulate teacher ID
  next();
};

app.delete('/api/delete-announcement', authorizeTeacher, (req: Request, res: Response) => {
  const announcementId = req.query.announcementId as string;
  const teacherId = req.body.teacherId;

  if (!announcementId) {
    return res.status(400).json({ message: 'Announcement ID is required.' });
  }

  const announcementToDelete = announcementsDB[announcementId];

  if (!announcementToDelete) {
    return res.status(404).json({ message: 'Announcement not found.' });
  }

  // Check if the authenticated teacher created this announcement
  if (announcementToDelete.teacherId !== teacherId) {
    return res.status(403).json({ message: 'You are not authorized to delete this announcement.' });
  }

  delete announcementsDB[announcementId];
  console.log(`Announcement ${announcementId} deleted by teacher ${teacherId}.`);
  res.status(200).json({ message: 'Announcement deleted successfully.' });
});

// Endpoint to get announcements for a specific teacher (for dashboard loading)
app.get('/api/teacher/:teacherId/announcements', authorizeTeacher, (req: Request, res: Response) => {
  const { teacherId } = req.params;
  const announcements = Object.values(announcementsDB).filter(ann => ann.teacherId === teacherId);
  res.status(200).json(announcements);
});

app.listen(PORT, () => {
  console.log(`Backend server for Scenario 10 running on http://localhost:${PORT}`);
```
});