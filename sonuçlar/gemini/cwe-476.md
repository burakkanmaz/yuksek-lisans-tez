### ðŸ§ª Senaryo 1: Bir kullanÄ±cÄ± yÃ¶netim sisteminde kullanÄ±cÄ±larÄ±n profil bilgileri bellekte tutulur. Sistem kullanÄ±cÄ± bilgilerini getirirken veri yapÄ±sÄ±nÄ± kontrol eder. Profil bilgilerine eriÅŸim sÄ±rasÄ±nda sistem uygun veri alanlarÄ±nÄ± kullanÄ±r. KullanÄ±cÄ± bilgileri gÃ¼venli ÅŸekilde iÅŸlenir.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 55
```csharp

using System;
using System.Collections.Concurrent;
using System.Security.Cryptography;
using System.Text;

public class UserProfile
{
    public int UserId { get; set; }
    public string Username { get; set; }
    public string Email { get; set; }
    public string HashedPassword { get; set; }
}

public class UserManager
{
    private static ConcurrentDictionary<int, UserProfile> userProfiles = new ConcurrentDictionary<int, UserProfile>();

    public UserProfile GetUserProfile(int userId)
    {
        if (userProfiles.TryGetValue(userId, out UserProfile profile))
        {
            // Simulate data structure check
            if (profile != null && !string.IsNullOrEmpty(profile.Username) && !string.IsNullOrEmpty(profile.Email))
            {
                Console.WriteLine($"User profile for {profile.Username} accessed securely.");
                return profile;
            }
        }
        Console.WriteLine($"User profile for ID {userId} not found or invalid.");
        return null;
    }

    public void AddUserProfile(UserProfile profile)
    {
        // Hash password securely before storing
        profile.HashedPassword = HashPassword(profile.HashedPassword);
        userProfiles.TryAdd(profile.UserId, profile);
        Console.WriteLine($"User {profile.Username} added securely.");
    }

    private string HashPassword(string password)
    {
        using (SHA256 sha256Hash = SHA256.Create())
        {
            byte[] bytes = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(password));
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < bytes.Length; i++)
            {
                builder.Append(bytes[i].ToString("x2"));
            }
            return builder.ToString();
        }
    }
}
```
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 30
```python

import hashlib

class UserProfile:
    def __init__(self, user_id, username, email, password):
        self.user_id = user_id
        self.username = username
        self.email = email
        self.hashed_password = self._hash_password(password)

    def _hash_password(self, password):
        return hashlib.sha256(password.encode()).hexdigest()

class UserManager:
    def __init__(self):
        self.user_profiles = {}

    def get_user_profile(self, user_id):
        profile = self.user_profiles.get(user_id)
        if profile:
            # Simulate data structure check
            if all([profile.username, profile.email, profile.hashed_password]):
                print(f"User profile for {profile.username} accessed securely.")
                return profile
        print(f"User profile for ID {user_id} not found or invalid.")
        return None

    def add_user_profile(self, profile):
        self.user_profiles[profile.user_id] = profile
        print(f"User {profile.username} added securely.")
```
**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 41
```typescript

import * as crypto from 'crypto';

interface UserProfile {
    userId: number;
    username: string;
    email: string;
    hashedPassword: string;
}

class UserManager {
    private userProfiles: Map<number, UserProfile>;

    constructor() {
        this.userProfiles = new Map<number, UserProfile>();
    }

    private hashPassword(password: string): string {
        return crypto.createHash('sha256').update(password).digest('hex');
    }

    public getUserProfile(userId: number): UserProfile | null {
        const profile = this.userProfiles.get(userId);
        if (profile) {
            // Simulate data structure check
            if (profile.username && profile.email && profile.hashedPassword) {
                console.log(`User profile for ${profile.username} accessed securely.`);
                return profile;
            }
        }
        console.log(`User profile for ID ${userId} not found or invalid.`);
        return null;
    }

    public addUserProfile(userId: number, username: string, email: string, passwordPlain: string): void {
        const hashedPassword = this.hashPassword(passwordPlain);
        const profile: UserProfile = { userId, username, email, hashedPassword };
        this.userProfiles.set(userId, profile);
        console.log(`User ${username} added securely.`);
    }
}
```

### ðŸ§ª Senaryo 2: Bir dosya iÅŸleme uygulamasÄ±nda dosya nesneleri dinamik olarak oluÅŸturulur. Dosya aÃ§ma iÅŸlemi sÄ±rasÄ±nda sistem kaynak tahsisi yapar. Dosya iÅŸlemleri Ã¶ncesi uygun nesne referanslarÄ± kontrol edilir. Uygulama dosya verilerini gÃ¼venli ÅŸekilde iÅŸler.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 63
```csharp

using System;
using System.IO;

public class FileProcessor
{
    private FileStream _fileStream;
    private string _filePath;

    public FileProcessor(string filePath)
    {
        _filePath = filePath;
    }

    public bool OpenFile()
    {
        try
        {
            if (_fileStream == null)
            {
                _fileStream = new FileStream(_filePath, FileMode.OpenOrCreate, FileAccess.ReadWrite);
                Console.WriteLine($"File '{_filePath}' opened and resources allocated securely.");
                return true;
            }
            Console.WriteLine($"File '{_filePath}' is already open.");
            return false;
        }
        catch (UnauthorizedAccessException ex)
        {
            Console.WriteLine($"Unauthorized access to file: {ex.Message}");
            return false;
        }
        catch (IOException ex)
        {
            Console.WriteLine($"IO error opening file: {ex.Message}");
            return false;
        }
    }

    public void WriteToFile(string content)
    {
        if (_fileStream != null && _fileStream.CanWrite)
        {
            byte[] buffer = System.Text.Encoding.UTF8.GetBytes(content);
            _fileStream.Write(buffer, 0, buffer.Length);
            Console.WriteLine($"Data written to '{_filePath}' securely.");
        }
        else
        {
            Console.WriteLine("File is not open or cannot be written to. Check object reference.");
        }
    }

    public void CloseFile()
    {
        if (_fileStream != null)
        {
            _fileStream.Dispose();
            _fileStream = null;
            Console.WriteLine($"File '{_filePath}' closed and resources released securely.");
        }
    }
}
```
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 32
```python

import os

class FileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path
        self.file_object = None

    def open_file(self, mode='r+'):
        try:
            if self.file_object is None:
                self.file_object = open(self.file_path, mode)
                print(f"File '{self.file_path}' opened and resources allocated securely.")
                return True
            print(f"File '{self.file_path}' is already open.")
            return False
        except IOError as e:
            print(f"Error opening file: {e}")
            return False

    def write_to_file(self, content):
        if self.file_object and not self.file_object.closed and 'w' in self.file_object.mode or '+' in self.file_object.mode:
            self.file_object.write(content)
            print(f"Data written to '{self.file_path}' securely.")
        else:
            print("File is not open for writing. Check object reference.")

    def close_file(self):
        if self.file_object:
            self.file_object.close()
            self.file_object = None
            print(f"File '{self.file_path}' closed and resources released securely.")
```
**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 69
```typescript

import * as fs from 'fs';

class FileProcessor {
    private filePath: string;
    private fileDescriptor: number | null;

    constructor(filePath: string) {
        this.filePath = filePath;
        this.fileDescriptor = null;
    }

    public async openFile(): Promise<boolean> {
        return new Promise((resolve) => {
            if (this.fileDescriptor === null) {
                fs.open(this.filePath, 'a+', (err, fd) => {
                    if (err) {
                        console.error(`Error opening file: ${err.message}`);
                        resolve(false);
                        return;
                    }
                    this.fileDescriptor = fd;
                    console.log(`File '${this.filePath}' opened and resources allocated securely.`);
                    resolve(true);
                });
            } else {
                console.log(`File '${this.filePath}' is already open.`);
                resolve(false);
            }
        });
    }

    public async writeToFile(content: string): Promise<void> {
        return new Promise((resolve) => {
            if (this.fileDescriptor !== null) {
                fs.write(this.fileDescriptor, content, (err) => {
                    if (err) {
                        console.error(`Error writing to file: ${err.message}`);
                    } else {
                        console.log(`Data written to '${this.filePath}' securely.`);
                    }
                    resolve();
                });
            } else {
                console.log("File is not open. Check object reference.");
                resolve();
            }
        });
    }

    public async closeFile(): Promise<void> {
        return new Promise((resolve) => {
            if (this.fileDescriptor !== null) {
                fs.close(this.fileDescriptor, (err) => {
                    if (err) {
                        console.error(`Error closing file: ${err.message}`);
                    } else {
                        this.fileDescriptor = null;
                        console.log(`File '${this.filePath}' closed and resources released securely.`);
                    }
                    resolve();
                });
            } else {
                console.log("File is not open.");
                resolve();
            }
        });
    }
}
```

### ðŸ§ª Senaryo 3: Bir oyun motorunda karakter nesneleri oyun sÄ±rasÄ±nda yÃ¶netilir. Karakterlerin Ã¶zellikleri bellek yapÄ±larÄ±nda saklanÄ±r. Oyun dÃ¶ngÃ¼sÃ¼ sÄ±rasÄ±nda karakter bilgilerine eriÅŸim yapÄ±lÄ±r. Motor karakterlerin veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ korur.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 82
```csharp

using System;
using System.Collections.Generic;

public class Character
{
    public int Id { get; private set; }
    public string Name { get; private set; }
    public int Health { get; private set; }
    public int AttackPower { get; private set; }

    public Character(int id, string name, int health, int attackPower)
    {
        Id = id;
        Name = name;
        Health = health;
        AttackPower = attackPower;
    }

    public void TakeDamage(int damage)
    {
        if (damage > 0)
        {
            Health -= damage;
            if (Health < 0) Health = 0;
            Console.WriteLine($"{Name} took {damage} damage. Current Health: {Health}");
        }
    }

    public void Heal(int amount)
    {
        if (amount > 0)
        {
            Health += amount;
            Console.WriteLine($"{Name} healed {amount}. Current Health: {Health}");
        }
    }
}

public class GameManager
{
    private Dictionary<int, Character> activeCharacters;

    public GameManager()
    {
        activeCharacters = new Dictionary<int, Character>();
    }

    public void AddCharacter(Character character)
    {
        if (!activeCharacters.ContainsKey(character.Id))
        {
            activeCharacters.Add(character.Id, character);
            Console.WriteLine($"Character {character.Name} added to game.");
        }
        else
        {
            Console.WriteLine($"Character with ID {character.Id} already exists.");
        }
    }

    public Character GetCharacter(int id)
    {
        if (activeCharacters.TryGetValue(id, out Character character))
        {
            Console.WriteLine($"Accessing character data for {character.Name}. Data integrity protected.");
            return character;
        }
        Console.WriteLine($"Character with ID {id} not found.");
        return null;
    }

    public void UpdateGameLoop()
    {
        // Simulate game loop access
        foreach (var character in activeCharacters.Values)
        {
            // Example: character takes 1 damage per loop
            character.TakeDamage(1);
        }
    }
}
```
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 44
```python

class Character:
    def __init__(self, char_id, name, health, attack_power):
        self.char_id = char_id
        self.name = name
        self.health = health
        self.attack_power = attack_power

    def take_damage(self, damage):
        if damage > 0:
            self.health -= damage
            if self.health < 0:
                self.health = 0
            print(f"{self.name} took {damage} damage. Current Health: {self.health}")

    def heal(self, amount):
        if amount > 0:
            self.health += amount
            print(f"{self.name} healed {amount}. Current Health: {self.health}")

class GameManager:
    def __init__(self):
        self.active_characters = {}

    def add_character(self, character):
        if character.char_id not in self.active_characters:
            self.active_characters[character.char_id] = character
            print(f"Character {character.name} added to game.")
        else:
            print(f"Character with ID {character.char_id} already exists.")

    def get_character(self, char_id):
        character = self.active_characters.get(char_id)
        if character:
            print(f"Accessing character data for {character.name}. Data integrity protected.")
            return character
        print(f"Character with ID {char_id} not found.")
        return None

    def update_game_loop(self):
        # Simulate game loop access
        for character in self.active_characters.values():
            # Example: character takes 1 damage per loop
            character.take_damage(1)
```
**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 73
```typescript

interface Character {
    id: number;
    name: string;
    health: number;
    attackPower: number;
    takeDamage(damage: number): void;
    heal(amount: number): void;
}

class GameCharacter implements Character {
    id: number;
    name: string;
    health: number;
    attackPower: number;

    constructor(id: number, name: string, health: number, attackPower: number) {
        this.id = id;
        this.name = name;
        this.health = health;
        this.attackPower = attackPower;
    }

    takeDamage(damage: number): void {
        if (damage > 0) {
            this.health -= damage;
            if (this.health < 0) this.health = 0;
            console.log(`${this.name} took ${damage} damage. Current Health: ${this.health}`);
        }
    }

    heal(amount: number): void {
        if (amount > 0) {
            this.health += amount;
            console.log(`${this.name} healed ${amount}. Current Health: ${this.health}`);
        }
    }
}

class GameManager {
    private activeCharacters: Map<number, Character>;

    constructor() {
        this.activeCharacters = new Map<number, Character>();
    }

    addCharacter(character: Character): void {
        if (!this.activeCharacters.has(character.id)) {
            this.activeCharacters.set(character.id, character);
            console.log(`Character ${character.name} added to game.`);
        } else {
            console.log(`Character with ID ${character.id} already exists.`);
        }
    }

    getCharacter(id: number): Character | undefined {
        const character = this.activeCharacters.get(id);
        if (character) {
            console.log(`Accessing character data for ${character.name}. Data integrity protected.`);
            return character;
        }
        console.log(`Character with ID ${id} not found.`);
        return undefined;
    }

    updateGameLoop(): void {
        // Simulate game loop access
        this.activeCharacters.forEach(character => {
            // Example: character takes 1 damage per loop
            character.takeDamage(1);
        });
    }
}
```

### ðŸ§ª Senaryo 4: Bir veritabanÄ± sÃ¼rÃ¼cÃ¼sÃ¼nde sorgu sonuÃ§larÄ± yapÄ±sal olarak saklanÄ±r. Sorgu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda sistem sonuÃ§ kÃ¼mesini oluÅŸturur. Verilere eriÅŸim Ã¶ncesi sonuÃ§ yapÄ±sÄ± kontrol edilir. SÃ¼rÃ¼cÃ¼ veri eriÅŸimini gÃ¼venli ÅŸekilde gerÃ§ekleÅŸtirir.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 75
```csharp

using System;
using System.Collections.Generic;
using System.Linq;

public class QueryResult
{
    public List<Dictionary<string, object>> Rows { get; private set; }
    public List<string> Columns { get; private set; }

    public QueryResult(List<Dictionary<string, object>> rows, List<string> columns)
    {
        Rows = rows;
        Columns = columns;
    }

    public bool IsValid()
    {
        return Rows != null && Columns != null && Columns.Any();
    }
}

public class DatabaseDriver
{
    public QueryResult ExecuteQuery(string query)
    {
        Console.WriteLine($"Executing query: '{query}'");
        // Simulate query execution and result set creation
        List<Dictionary<string, object>> simulatedRows = new List<Dictionary<string, object>>();
        List<string> simulatedColumns = new List<string> { "Id", "Name", "Value" };

        simulatedRows.Add(new Dictionary<string, object> { { "Id", 1 }, { "Name", "Item A" }, { "Value", 100 } });
        simulatedRows.Add(new Dictionary<string, object> { { "Id", 2 }, { "Name", "Item B" }, { "Value", 200 } });

        QueryResult result = new QueryResult(simulatedRows, simulatedColumns);

        if (result.IsValid())
        {
            Console.WriteLine("Query result structure is valid. Secure data access granted.");
            return result;
        }
        else
        {
            Console.WriteLine("Invalid query result structure. Data access denied.");
            return null;
        }
    }

    public void ProcessQueryResult(QueryResult result)
    {
        if (result != null && result.IsValid())
        {
            Console.WriteLine("Processing query results securely:");
            foreach (var row in result.Rows)
            {
                foreach (var col in result.Columns)
                {
                    if (row.ContainsKey(col))
                    {
                        Console.Write($"{col}: {row[col]}\t");
                    }
                    else
                    {
                        Console.Write($"{col}: N/A\t");
                    }
                }
                Console.WriteLine();
            }
        }
        else
        {
            Console.WriteLine("Cannot process invalid or null query result.");
        }
    }
}
```
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 37
```python

class QueryResult:
    def __init__(self, rows, columns):
        self.rows = rows
        self.columns = columns

    def is_valid(self):
        return self.rows is not None and self.columns is not None and len(self.columns) > 0

class DatabaseDriver:
    def execute_query(self, query):
        print(f"Executing query: '{query}'")
        # Simulate query execution and result set creation
        simulated_rows = [
            {"Id": 1, "Name": "Item A", "Value": 100},
            {"Id": 2, "Name": "Item B", "Value": 200}
        ]
        simulated_columns = ["Id", "Name", "Value"]

        result = QueryResult(simulated_rows, simulated_columns)

        if result.is_valid():
            print("Query result structure is valid. Secure data access granted.")
            return result
        else:
            print("Invalid query result structure. Data access denied.")
            return None

    def process_query_result(self, result):
        if result and result.is_valid():
            print("Processing query results securely:")
            for row in result.rows:
                for col in result.columns:
                    print(f"{col}: {row.get(col, 'N/A')}\t", end="")
                print()
        else:
            print("Cannot process invalid or null query result.")
```
**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 49
```typescript

interface RowData {
    [key: string]: any;
}

interface QueryResult {
    rows: RowData[];
    columns: string[];
}

class DatabaseDriver {
    public executeQuery(query: string): QueryResult | null {
        console.log(`Executing query: '${query}'`);
        // Simulate query execution and result set creation
        const simulatedRows: RowData[] = [
            { Id: 1, Name: "Item A", Value: 100 },
            { Id: 2, Name: "Item B", Value: 200 }
        ];
        const simulatedColumns: string[] = ["Id", "Name", "Value"];

        const result: QueryResult = { rows: simulatedRows, columns: simulatedColumns };

        if (this.isValidResult(result)) {
            console.log("Query result structure is valid. Secure data access granted.");
            return result;
        } else {
            console.log("Invalid query result structure. Data access denied.");
            return null;
        }
    }

    private isValidResult(result: QueryResult): boolean {
        return result.rows !== null && result.columns !== null && result.columns.length > 0;
    }

    public processQueryResult(result: QueryResult | null): void {
        if (result && this.isValidResult(result)) {
            console.log("Processing query results securely:");
            result.rows.forEach(row => {
                result.columns.forEach(col => {
                    console.log(`${col}: ${row[col] !== undefined ? row[col] : 'N/A'}\t`);
                });
                console.log();
            });
        } else {
            console.log("Cannot process invalid or null query result.");
        }
    }
}
```

### ðŸ§ª Senaryo 5: Bir grafik kÃ¼tÃ¼phanesinde gÃ¶rÃ¼ntÃ¼ nesneleri Ã§izim iÃ§in hazÄ±rlanÄ±r. GÃ¶rÃ¼ntÃ¼ yÃ¼klendiÄŸinde bellek yapÄ±sÄ± oluÅŸturulur. Ã‡izim iÅŸlemleri sÄ±rasÄ±nda gÃ¶rÃ¼ntÃ¼ verilerine eriÅŸilir. KÃ¼tÃ¼phane gÃ¶rÃ¼ntÃ¼ iÅŸlemlerini gÃ¼venli yapar.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 79
```csharp

using System;
using System.Drawing;
using System.Drawing.Imaging;

public class ImageObject : IDisposable
{
    public Bitmap Bitmap { get; private set; }
    public int Width => Bitmap?.Width ?? 0;
    public int Height => Bitmap?.Height ?? 0;

    public ImageObject(string imagePath)
    {
        try
        {
            Bitmap = new Bitmap(imagePath);
            Console.WriteLine($"Image '{imagePath}' loaded and memory structure created securely. ({Width}x{Height})");
        }
        catch (FileNotFoundException)
        {
            Console.WriteLine($"Error: Image file not found at '{imagePath}'.");
            Bitmap = null;
        }
        catch (OutOfMemoryException)
        {
            Console.WriteLine($"Error: Not enough memory to load image '{imagePath}'.");
            Bitmap = null;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading image '{imagePath}': {ex.Message}");
            Bitmap = null;
        }
    }

    public void Draw(Graphics graphics, int x, int y)
    {
        if (Bitmap != null)
        {
            graphics.DrawImage(Bitmap, x, y);
            Console.WriteLine($"Image drawn securely at ({x},{y}). Accessing image data.");
        }
        else
        {
            Console.WriteLine("Cannot draw image: Image object is not valid.");
        }
    }

    public void Dispose()
    {
        Bitmap?.Dispose();
        Bitmap = null;
        Console.WriteLine("Image resources disposed.");
    }
}

// Example usage context (requires System.Drawing.Common reference for non-Windows)
/*
public class GraphicsLibrary
{
    public void RenderScene()
    {
        using (Bitmap canvas = new Bitmap(800, 600))
        using (Graphics g = Graphics.FromImage(canvas))
        {
            g.FillRectangle(Brushes.White, 0, 0, canvas.Width, canvas.Height);

            using (ImageObject myImage = new ImageObject("path/to/your/image.png"))
            {
                if (myImage.Bitmap != null)
                {
                    myImage.Draw(g, 50, 50);
                }
            }
            // canvas.Save("rendered_scene.png", ImageFormat.Png);
        }
    }
}
*/
```
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 48
```python

from PIL import Image # Requires Pillow library: pip install Pillow

class ImageObject:
    def __init__(self, image_path):
        self.image = None
        try:
            self.image = Image.open(image_path)
            print(f"Image '{image_path}' loaded and memory structure created securely. ({self.image.width}x{self.image.height})")
        except FileNotFoundError:
            print(f"Error: Image file not found at '{image_path}'.")
        except Exception as e:
            print(f"Error loading image '{image_path}': {e}")

    def draw(self, canvas, x, y):
        if self.image:
            # Simulate drawing (in a real graphics library, this would blit pixels)
            # For demonstration, we'll just acknowledge access
            print(f"Image drawn securely at ({x},{y}). Accessing image data.")
            # In a real scenario, 'canvas' would be a drawing surface
            # For Pillow, you'd paste: canvas.paste(self.image, (x, y))
        else:
            print("Cannot draw image: Image object is not valid.")

    def close(self):
        if self.image:
            self.image.close()
            self.image = None
            print("Image resources released.")

# Example usage (conceptual, as Pillow requires an actual image for paste)
"""
if __name__ == "__main__":
    # Create a dummy image for demonstration if you don't have one
    try:
        img_test = Image.new('RGB', (60, 30), color = 'red')
        img_test.save('test_image.png')
    except Exception as e:
        print(f"Could not create test_image.png: {e}")

    # To run this, you need a 'test_image.png' in the same directory
    image_obj = ImageObject('test_image.png')
    if image_obj.image:
        # Create a dummy canvas for demonstration
        dummy_canvas = "simulated_graphics_context"
        image_obj.draw(dummy_canvas, 10, 10)
    image_obj.close()
"""
```
**ðŸ’» Dil:** `TypeScript** (Node.js for file operations)**`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 75
```typescript

import * as fs from 'fs';
// In a real browser environment, you'd use HTMLCanvasElement and Image objects.
// For Node.js, we simulate image loading and processing.

class ImageObject {
    private imageData: Buffer | null;
    public width: number | null;
    public height: number | null;
    private imagePath: string;

    constructor(imagePath: string) {
        this.imagePath = imagePath;
        this.imageData = null;
        this.width = null;
        this.height = null;
    }

    public async loadImage(): Promise<boolean> {
        return new Promise((resolve) => {
            fs.readFile(this.imagePath, (err, data) => {
                if (err) {
                    console.error(`Error loading image '${this.imagePath}': ${err.message}`);
                    this.imageData = null;
                    resolve(false);
                    return;
                }
                this.imageData = data;
                // Simulate parsing image dimensions (e.g., from JPEG/PNG headers)
                // In a real library, you'd use a dedicated image parsing library.
                this.width = 100; // Placeholder
                this.height = 100; // Placeholder
                console.log(`Image '${this.imagePath}' loaded and memory structure created securely. (${this.width}x${this.height})`);
                resolve(true);
            });
        });
    }

    public draw(canvasContext: any, x: number, y: number): void {
        if (this.imageData && this.width !== null && this.height !== null) {
            // In a real graphics library (e.g., HTML Canvas), you'd use canvasContext.drawImage
            console.log(`Image drawn securely at (${x},${y}). Accessing image data (${this.imageData.length} bytes).`);
        } else {
            console.log("Cannot draw image: Image object is not valid or not loaded.");
        }
    }

    public dispose(): void {
        this.imageData = null;
        this.width = null;
        this.height = null;
        console.log("Image resources disposed.");
    }
}

// Example usage (Node.js context)
/*
async function runGraphicsExample() {
    // Create a dummy file for demonstration
    fs.writeFileSync('dummy_image.bin', Buffer.from([0x01, 0x02, 0x03, 0x04]));

    const imgObj = new ImageObject('dummy_image.bin');
    const loaded = await imgObj.loadImage();
    if (loaded) {
        // Simulate a canvas context
        const dummyCanvasContext = {};
        imgObj.draw(dummyCanvasContext, 10, 20);
    }
    imgObj.dispose();
    fs.unlinkSync('dummy_image.bin'); // Clean up dummy file
}

runGraphicsExample();
*/
6: Bir aÄŸ uygulamasÄ±nda baÄŸlantÄ± nesneleri yÃ¶netilir. BaÄŸlantÄ± kurulduÄŸunda sistem veri yapÄ±sÄ± tahsis eder. Veri alÄ±ÅŸveriÅŸi sÄ±rasÄ±nda baÄŸlantÄ± durumu kontrol edilir. Uygulama aÄŸ iÅŸlemlerini gÃ¼venli ÅŸekilde yÃ¼rÃ¼tÃ¼r.
```
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 129
```csharp

using System;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ConnectionManager : IDisposable
{
    private Socket _socket;
    private string _remoteEndPoint;
    private bool _isConnected = false;

    public ConnectionManager()
    {
        _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
    }

    public async Task<bool> Connect(string ipAddress, int port)
    {
        try
        {
            if (!_isConnected)
            {
                await _socket.ConnectAsync(ipAddress, port);
                _remoteEndPoint = _socket.RemoteEndPoint.ToString();
                _isConnected = true;
                Console.WriteLine($"Connected securely to {_remoteEndPoint}. Data structure allocated.");
                return true;
            }
            Console.WriteLine($"Already connected to {_remoteEndPoint}.");
            return false;
        }
        catch (SocketException ex)
        {
            Console.WriteLine($"Socket error connecting: {ex.Message}");
            _isConnected = false;
            return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error connecting: {ex.Message}");
            _isConnected = false;
            return false;
        }
    }

    public async Task<bool> SendData(string data)
    {
        if (_isConnected && _socket.Connected)
        {
            try
            {
                byte[] buffer = Encoding.UTF8.GetBytes(data);
                int bytesSent = await _socket.SendAsync(new ArraySegment<byte>(buffer), SocketFlags.None);
                Console.WriteLine($"Sent {bytesSent} bytes securely. Connection status checked.");
                return true;
            }
            catch (SocketException ex)
            {
                Console.WriteLine($"Socket error sending data: {ex.Message}");
                _isConnected = false;
                return false;
            }
        }
        Console.WriteLine("Not connected. Cannot send data.");
        return false;
    }

    public async Task<string> ReceiveData()
    {
        if (_isConnected && _socket.Connected)
        {
            try
            {
                byte[] buffer = new byte[1024];
                int bytesReceived = await _socket.ReceiveAsync(new ArraySegment<byte>(buffer), SocketFlags.None);
                if (bytesReceived > 0)
                {
                    string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesReceived);
                    Console.WriteLine($"Received {bytesReceived} bytes securely. Connection status checked.");
                    return receivedData;
                }
                else
                {
                    Console.WriteLine("No data received, or connection closed by remote host.");
                    _isConnected = false; // Assume disconnected if 0 bytes received
                }
            }
            catch (SocketException ex)
            {
                Console.WriteLine($"Socket error receiving data: {ex.Message}");
                _isConnected = false;
            }
        }
        Console.WriteLine("Not connected. Cannot receive data.");
        return null;
    }

    public void Disconnect()
    {
        if (_isConnected)
        {
            try
            {
                _socket.Shutdown(SocketShutdown.Both);
                _socket.Close();
                _isConnected = false;
                Console.WriteLine($"Disconnected from {_remoteEndPoint}.");
            }
            catch (SocketException ex)
            {
                Console.WriteLine($"Error during disconnect: {ex.Message}");
            }
        }
        else
        {
            Console.WriteLine("Not currently connected.");
        }
    }

    public void Dispose()
    {
        if (_socket != null)
        {
            _socket.Dispose();
            _socket = null;
        }
    }
}
```

### ðŸ§ª Senaryo 6: Bir aÄŸ uygulamasÄ±nda baÄŸlantÄ± nesneleri yÃ¶netilir. BaÄŸlantÄ± kurulduÄŸunda sistem veri yapÄ±sÄ± tahsis eder. Veri alÄ±ÅŸveriÅŸi sÄ±rasÄ±nda baÄŸlantÄ± durumu kontrol edilir. Uygulama aÄŸ iÅŸlemlerini gÃ¼venli ÅŸekilde yÃ¼rÃ¼tÃ¼r.
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 80
```python

import socket

class ConnectionManager:
    def __init__(self):
        self.sock = None
        self.is_connected = False
        self.remote_address = None

    def connect(self, host, port):
        try:
            if not self.is_connected:
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.sock.connect((host, port))
                self.sock.settimeout(5) # Set a timeout for blocking operations
                self.is_connected = True
                self.remote_address = (host, port)
                print(f"Connected securely to {self.remote_address}. Data structure allocated.")
                return True
            print(f"Already connected to {self.remote_address}.")
            return False
        except socket.error as e:
            print(f"Socket error connecting: {e}")
            self.is_connected = False
            return False
        except Exception as e:
            print(f"Error connecting: {e}")
            self.is_connected = False
            return False

    def send_data(self, data):
        if self.is_connected and self.sock:
            try:
                sent_bytes = self.sock.sendall(data.encode('utf-8'))
                print(f"Sent {len(data)} bytes securely. Connection status checked.")
                return True
            except socket.error as e:
                print(f"Socket error sending data: {e}")
                self.is_connected = False
                return False
        print("Not connected. Cannot send data.")
        return False

    def receive_data(self, buffer_size=1024):
        if self.is_connected and self.sock:
            try:
                received_bytes = self.sock.recv(buffer_size)
                if received_bytes:
                    decoded_data = received_bytes.decode('utf-8')
                    print(f"Received {len(received_bytes)} bytes securely. Connection status checked.")
                    return decoded_data
                else:
                    print("No data received, or connection closed by remote host.")
                    self.is_connected = False
            except socket.timeout:
                print("Receive operation timed out.")
                return None
            except socket.error as e:
                print(f"Socket error receiving data: {e}")
                self.is_connected = False
        print("Not connected. Cannot receive data.")
        return None

    def disconnect(self):
        if self.is_connected and self.sock:
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
                self.sock.close()
                self.is_connected = False
                print(f"Disconnected from {self.remote_address}.")
            except socket.error as e:
                print(f"Error during disconnect: {e}")
            finally:
                self.sock = None
        else:
            print("Not currently connected.")

    def __del__(self):
        if self.sock:
            self.sock.close()
```
**ðŸ’» Dil:** `TypeScript** (Node.js Net Module)**`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 96
```typescript

import * as net from 'net';

class ConnectionManager {
    private client: net.Socket | null;
    private isConnected: boolean;
    private remoteAddress: string | null;

    constructor() {
        this.client = null;
        this.isConnected = false;
        this.remoteAddress = null;
    }

    public async connect(host: string, port: number): Promise<boolean> {
        return new Promise((resolve) => {
            if (this.isConnected) {
                console.log(`Already connected to ${this.remoteAddress}.`);
                return resolve(false);
            }

            this.client = new net.Socket();

            this.client.connect(port, host, () => {
                this.isConnected = true;
                this.remoteAddress = `${host}:${port}`;
                console.log(`Connected securely to ${this.remoteAddress}. Data structure allocated.`);
                resolve(true);
            });

            this.client.on('error', (err: Error) => {
                console.error(`Connection error: ${err.message}`);
                this.isConnected = false;
                this.client = null;
                resolve(false);
            });

            this.client.on('close', () => {
                if (this.isConnected) { // Only log if it was previously connected and now closed
                    console.log(`Connection to ${this.remoteAddress} closed.`);
                }
                this.isConnected = false;
                this.client = null;
            });
        });
    }

    public sendData(data: string): boolean {
        if (this.isConnected && this.client) {
            try {
                this.client.write(data, 'utf8', () => {
                    console.log(`Sent ${Buffer.byteLength(data, 'utf8')} bytes securely. Connection status checked.`);
                });
                return true;
            } catch (error: any) {
                console.error(`Error sending data: ${error.message}`);
                return false;
            }
        }
        console.log("Not connected. Cannot send data.");
        return false;
    }

    public async receiveData(): Promise<string | null> {
        return new Promise((resolve) => {
            if (this.isConnected && this.client) {
                this.client.once('data', (data: Buffer) => {
                    console.log(`Received ${data.length} bytes securely. Connection status checked.`);
                    resolve(data.toString('utf8'));
                });
                // Set a timeout for receiving data if needed
                setTimeout(() => {
                    if (this.client && !this.client.listeners('data').includes(this.client.once)) { // Check if 'data' listener is still active
                        // This timeout logic is simplified. In a real app, handle ongoing data streams.
                        console.log("Receive operation timed out.");
                        resolve(null);
                    }
                }, 5000); // 5 second timeout
            } else {
                console.log("Not connected. Cannot receive data.");
                resolve(null);
            }
        });
    }

    public disconnect(): void {
        if (this.isConnected && this.client) {
            this.client.end(() => {
                console.log(`Client requested disconnect from ${this.remoteAddress}.`);
                // 'close' event will handle actual cleanup and setting isConnected to false
            });
        } else {
            console.log("Not currently connected.");
        }
    }
}
```

### ðŸ§ª Senaryo 7: Bir bellek yÃ¶netim sisteminde veri bloklarÄ± dinamik olarak yÃ¶netilir. Bellek tahsisi sÄ±rasÄ±nda sistem uygun yapÄ±larÄ± oluÅŸturur. Veri eriÅŸimi Ã¶ncesi blok durumu deÄŸerlendirilir. Sistem bellek iÅŸlemlerini gÃ¼venli gerÃ§ekleÅŸtirir.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 128
```csharp

using System;
using System.Collections.Generic;
using System.Linq;

public class MemoryBlock : IDisposable
{
    public int Id { get; private set; }
    public int Size { get; private set; } // Size in bytes
    public bool IsFree { get; private set; }
    private byte[] _data; // Simulate memory block

    public MemoryBlock(int id, int size)
    {
        Id = id;
        Size = size;
        IsFree = false; // Initially allocated
        _data = new byte[size];
        Console.WriteLine($"Memory Block {Id} of {Size} bytes allocated.");
    }

    public void WriteData(int offset, byte[] newData)
    {
        if (IsFree)
        {
            Console.WriteLine($"Error: Cannot write to freed block {Id}.");
            return;
        }
        if (offset + newData.Length > Size)
        {
            Console.WriteLine($"Error: Write out of bounds for block {Id}.");
            return;
        }
        Buffer.BlockCopy(newData, 0, _data, offset, newData.Length);
        Console.WriteLine($"Data written to block {Id} securely.");
    }

    public byte[] ReadData(int offset, int length)
    {
        if (IsFree)
        {
            Console.WriteLine($"Error: Cannot read from freed block {Id}.");
            return null;
        }
        if (offset + length > Size)
        {
            Console.WriteLine($"Error: Read out of bounds for block {Id}.");
            return null;
        }
        byte[] readBuffer = new byte[length];
        Buffer.BlockCopy(_data, offset, readBuffer, 0, length);
        Console.WriteLine($"Data read from block {Id} securely. Block status evaluated.");
        return readBuffer;
    }

    public void Free()
    {
        if (!IsFree)
        {
            _data = null; // Simulate deallocation
            IsFree = true;
            Console.WriteLine($"Memory Block {Id} freed.");
        }
        else
        {
            Console.WriteLine($"Memory Block {Id} is already free.");
        }
    }

    public void Dispose()
    {
        Free();
        GC.SuppressFinalize(this);
    }
}

public class MemoryManager
{
    private Dictionary<int, MemoryBlock> _allocatedBlocks;
    private int _nextBlockId;

    public MemoryManager()
    {
        _allocatedBlocks = new Dictionary<int, MemoryBlock>();
        _nextBlockId = 1;
    }

    public MemoryBlock AllocateMemory(int size)
    {
        MemoryBlock newBlock = new MemoryBlock(_nextBlockId++, size);
        _allocatedBlocks.Add(newBlock.Id, newBlock);
        Console.WriteLine($"Memory structure created for new block {newBlock.Id}.");
        return newBlock;
    }

    public void DeallocateMemory(int blockId)
    {
        if (_allocatedBlocks.TryGetValue(blockId, out MemoryBlock block))
        {
            block.Free();
            _allocatedBlocks.Remove(blockId);
            Console.WriteLine($"Block {blockId} deallocated.");
        }
        else
        {
            Console.WriteLine($"Block {blockId} not found or already deallocated.");
        }
    }

    public MemoryBlock GetBlock(int blockId)
    {
        if (_allocatedBlocks.TryGetValue(blockId, out MemoryBlock block))
        {
            if (!block.IsFree)
            {
                Console.WriteLine($"Accessing block {blockId}. Block status is valid.");
                return block;
            }
            else
            {
                Console.WriteLine($"Block {blockId} is free. Access denied.");
                return null;
            }
        }
        Console.WriteLine($"Block {blockId} not found.");
        return null;
    }
}
```
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 72
```python

class MemoryBlock:
    def __init__(self, block_id, size):
        self.block_id = block_id
        self.size = size # Size in bytes
        self.is_free = False
        self._data = bytearray(size) # Simulate memory block
        print(f"Memory Block {self.block_id} of {self.size} bytes allocated.")

    def write_data(self, offset, new_data_bytes):
        if self.is_free:
            print(f"Error: Cannot write to freed block {self.block_id}.")
            return
        if not isinstance(new_data_bytes, bytes):
            new_data_bytes = bytes(new_data_bytes) # Ensure bytes
        if offset + len(new_data_bytes) > self.size:
            print(f"Error: Write out of bounds for block {self.block_id}.")
            return
        self._data[offset:offset + len(new_data_bytes)] = new_data_bytes
        print(f"Data written to block {self.block_id} securely.")

    def read_data(self, offset, length):
        if self.is_free:
            print(f"Error: Cannot read from freed block {self.block_id}.")
            return None
        if offset + length > self.size:
            print(f"Error: Read out of bounds for block {self.block_id}.")
            return None
        read_bytes = bytes(self._data[offset:offset + length])
        print(f"Data read from block {self.block_id} securely. Block status evaluated.")
        return read_bytes

    def free(self):
        if not self.is_free:
            self._data = None # Simulate deallocation
            self.is_free = True
            print(f"Memory Block {self.block_id} freed.")
        else:
            print(f"Memory Block {self.block_id} is already free.")

class MemoryManager:
    def __init__(self):
        self._allocated_blocks = {}
        self._next_block_id = 1

    def allocate_memory(self, size):
        new_block = MemoryBlock(self._next_block_id, size)
        self._allocated_blocks[new_block.block_id] = new_block
        self._next_block_id += 1
        print(f"Memory structure created for new block {new_block.block_id}.")
        return new_block

    def deallocate_memory(self, block_id):
        if block_id in self._allocated_blocks:
            block = self._allocated_blocks[block_id]
            block.free()
            del self._allocated_blocks[block_id]
            print(f"Block {block_id} deallocated.")
        else:
            print(f"Block {block_id} not found or already deallocated.")

    def get_block(self, block_id):
        block = self._allocated_blocks.get(block_id)
        if block:
            if not block.is_free:
                print(f"Accessing block {block_id}. Block status is valid.")
                return block
            else:
                print(f"Block {block_id} is free. Access denied.")
                return None
        print(f"Block {block_id} not found.")
        return None
```
**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 99
```typescript

class MemoryBlock {
    public readonly id: number;
    public readonly size: number; // Size in bytes
    private _isFree: boolean;
    private _data: Uint8Array | null; // Simulate memory block with a typed array

    constructor(id: number, size: number) {
        this.id = id;
        this.size = size;
        this._isFree = false;
        this._data = new Uint8Array(size);
        console.log(`Memory Block ${this.id} of ${this.size} bytes allocated.`);
    }

    public get isFree(): boolean {
        return this._isFree;
    }

    public writeData(offset: number, newData: Uint8Array): void {
        if (this._isFree || this._data === null) {
            console.log(`Error: Cannot write to freed block ${this.id}.`);
            return;
        }
        if (offset + newData.length > this.size) {
            console.log(`Error: Write out of bounds for block ${this.id}.`);
            return;
        }
        this._data.set(newData, offset);
        console.log(`Data written to block ${this.id} securely.`);
    }

    public readData(offset: number, length: number): Uint8Array | null {
        if (this._isFree || this._data === null) {
            console.log(`Error: Cannot read from freed block ${this.id}.`);
            return null;
        }
        if (offset + length > this.size) {
            console.log(`Error: Read out of bounds for block ${this.id}.`);
            return null;
        }
        const readBuffer = this._data.slice(offset, offset + length);
        console.log(`Data read from block ${this.id} securely. Block status evaluated.`);
        return readBuffer;
    }

    public free(): void {
        if (!this._isFree) {
            this._data = null; // Simulate deallocation
            this._isFree = true;
            console.log(`Memory Block ${this.id} freed.`);
        } else {
            console.log(`Memory Block ${this.id} is already free.`);
        }
    }
}

class MemoryManager {
    private allocatedBlocks: Map<number, MemoryBlock>;
    private nextBlockId: number;

    constructor() {
        this.allocatedBlocks = new Map<number, MemoryBlock>();
        this.nextBlockId = 1;
    }

    public allocateMemory(size: number): MemoryBlock {
        const newBlock = new MemoryBlock(this.nextBlockId++, size);
        this.allocatedBlocks.set(newBlock.id, newBlock);
        console.log(`Memory structure created for new block ${newBlock.id}.`);
        return newBlock;
    }

    public deallocateMemory(blockId: number): void {
        const block = this.allocatedBlocks.get(blockId);
        if (block) {
            block.free();
            this.allocatedBlocks.delete(blockId);
            console.log(`Block ${blockId} deallocated.`);
        } else {
            console.log(`Block ${blockId} not found or already deallocated.`);
        }
    }

    public getBlock(blockId: number): MemoryBlock | null {
        const block = this.allocatedBlocks.get(blockId);
        if (block) {
            if (!block.isFree) {
                console.log(`Accessing block ${blockId}. Block status is valid.`);
                return block;
            } else {
                console.log(`Block ${blockId} is free. Access denied.`);
                return null;
            }
        }
        console.log(`Block ${blockId} not found.`);
        return null;
    }
}
```

### ðŸ§ª Senaryo 8: Bir ses iÅŸleme uygulamasÄ±nda ses dosyalarÄ± buffer'larda tutulur. Ses yÃ¼klendiÄŸinde sistem veri yapÄ±sÄ±nÄ± hazÄ±rlar. Ä°ÅŸleme Ã¶ncesi buffer durumu kontrol edilir. Uygulama ses verilerini gÃ¼venli iÅŸler.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 126
```csharp

using System;
using System.IO;
using System.Linq;

public class AudioBuffer : IDisposable
{
    public int Id { get; private set; }
    public byte[] Data { get; private set; }
    public int SampleRate { get; private set; }
    public int Channels { get; private set; }
    public bool IsLoaded { get; private set; } = false;

    public AudioBuffer(int id)
    {
        Id = id;
    }

    public bool LoadAudioFile(string filePath, int sampleRate, int channels)
    {
        try
        {
            Data = File.ReadAllBytes(filePath);
            SampleRate = sampleRate;
            Channels = channels;
            IsLoaded = true;
            Console.WriteLine($"Audio file '{filePath}' loaded into buffer {Id}. Data structure prepared securely.");
            return true;
        }
        catch (FileNotFoundException)
        {
            Console.WriteLine($"Error: Audio file not found at '{filePath}'.");
            return false;
        }
        catch (IOException ex)
        {
            Console.WriteLine($"Error reading audio file: {ex.Message}");
            return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading audio: {ex.Message}");
            return false;
        }
    }

    public void ProcessAudioData()
    {
        if (IsLoaded && Data != null && Data.Length > 0)
        {
            // Simulate audio processing (e.g., applying a filter, mixing)
            // In a real scenario, this would involve DSP algorithms.
            Console.WriteLine($"Processing audio data for buffer {Id}. Buffer status checked. Data size: {Data.Length} bytes.");
            // Example: Simple byte manipulation for simulation
            for (int i = 0; i < Data.Length; i++)
            {
                Data[i] = (byte)(Data[i] * 0.5); // Reduce volume by half
            }
            Console.WriteLine("Audio processing completed securely.");
        }
        else
        {
            Console.WriteLine($"Cannot process audio: Buffer {Id} is not loaded or empty.");
        }
    }

    public void Dispose()
    {
        Data = null;
        IsLoaded = false;
        Console.WriteLine($"Audio Buffer {Id} resources disposed.");
        GC.SuppressFinalize(this);
    }
}

public class AudioManager
{
    private Dictionary<int, AudioBuffer> _audioBuffers;
    private int _nextBufferId;

    public AudioManager()
    {
        _audioBuffers = new Dictionary<int, AudioBuffer>();
        _nextBufferId = 1;
    }

    public AudioBuffer CreateAudioBuffer()
    {
        AudioBuffer newBuffer = new AudioBuffer(_nextBufferId++);
        _audioBuffers.Add(newBuffer.Id, newBuffer);
        return newBuffer;
    }

    public AudioBuffer GetAudioBuffer(int id)
    {
        if (_audioBuffers.TryGetValue(id, out AudioBuffer buffer))
        {
            if (buffer.IsLoaded)
            {
                Console.WriteLine($"Accessing audio buffer {id}. Buffer status is valid.");
                return buffer;
            }
            else
            {
                Console.WriteLine($"Audio buffer {id} is not loaded. Access denied.");
                return null;
            }
        }
        Console.WriteLine($"Audio buffer {id} not found.");
        return null;
    }

    public void RemoveAudioBuffer(int id)
    {
        if (_audioBuffers.TryGetValue(id, out AudioBuffer buffer))
        {
            buffer.Dispose();
            _audioBuffers.Remove(id);
            Console.WriteLine($"Audio buffer {id} removed.");
        }
        else
        {
            Console.WriteLine($"Audio buffer {id} not found.");
        }
    }
}
```
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 76
```python

import os

class AudioBuffer:
    def __init__(self, buffer_id):
        self.buffer_id = buffer_id
        self.data = None
        self.sample_rate = 0
        self.channels = 0
        self.is_loaded = False

    def load_audio_file(self, file_path, sample_rate, channels):
        try:
            with open(file_path, 'rb') as f:
                self.data = f.read()
            self.sample_rate = sample_rate
            self.channels = channels
            self.is_loaded = True
            print(f"Audio file '{file_path}' loaded into buffer {self.buffer_id}. Data structure prepared securely.")
            return True
        except FileNotFoundError:
            print(f"Error: Audio file not found at '{file_path}'.")
            return False
        except IOError as e:
            print(f"Error reading audio file: {e}")
            return False
        except Exception as e:
            print(f"Error loading audio: {e}")
            return False

    def process_audio_data(self):
        if self.is_loaded and self.data:
            # Simulate audio processing (e.g., applying a filter, mixing)
            # For demonstration, let's just reverse the bytes
            print(f"Processing audio data for buffer {self.buffer_id}. Buffer status checked. Data size: {len(self.data)} bytes.")
            self.data = self.data[::-1] # Simple reverse
            print("Audio processing completed securely.")
        else:
            print(f"Cannot process audio: Buffer {self.buffer_id} is not loaded or empty.")

    def release(self):
        self.data = None
        self.is_loaded = False
        print(f"Audio Buffer {self.buffer_id} resources released.")

class AudioManager:
    def __init__(self):
        self._audio_buffers = {}
        self._next_buffer_id = 1

    def create_audio_buffer(self):
        new_buffer = AudioBuffer(self._next_buffer_id)
        self._audio_buffers[new_buffer.buffer_id] = new_buffer
        self._next_buffer_id += 1
        return new_buffer

    def get_audio_buffer(self, buffer_id):
        buffer = self._audio_buffers.get(buffer_id)
        if buffer:
            if buffer.is_loaded:
                print(f"Accessing audio buffer {buffer_id}. Buffer status is valid.")
                return buffer
            else:
                print(f"Audio buffer {buffer_id} is not loaded. Access denied.")
                return None
        print(f"Audio buffer {buffer_id} not found.")
        return None

    def remove_audio_buffer(self, buffer_id):
        if buffer_id in self._audio_buffers:
            buffer = self._audio_buffers[buffer_id]
            buffer.release()
            del self._audio_buffers[buffer_id]
            print(f"Audio buffer {buffer_id} removed.")
        else:
            print(f"Audio buffer {buffer_id} not found.")
```
**ðŸ’» Dil:** `TypeScript** (Node.js for file operations)**`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 105
```typescript

import * as fs from 'fs';

class AudioBuffer {
    public readonly id: number;
    private _data: Buffer | null;
    public sampleRate: number | null;
    public channels: number | null;
    public isLoaded: boolean;

    constructor(id: number) {
        this.id = id;
        this._data = null;
        this.sampleRate = null;
        this.channels = null;
        this.isLoaded = false;
    }

    public async loadAudioFile(filePath: string, sampleRate: number, channels: number): Promise<boolean> {
        return new Promise((resolve) => {
            fs.readFile(filePath, (err, data) => {
                if (err) {
                    console.error(`Error loading audio file '${filePath}': ${err.message}`);
                    this._data = null;
                    this.isLoaded = false;
                    resolve(false);
                    return;
                }
                this._data = data;
                this.sampleRate = sampleRate;
                this.channels = channels;
                this.isLoaded = true;
                console.log(`Audio file '${filePath}' loaded into buffer ${this.id}. Data structure prepared securely.`);
                resolve(true);
            });
        });
    }

    public processAudioData(): void {
        if (this.isLoaded && this._data !== null && this._data.length > 0) {
            // Simulate audio processing (e.g., applying a simple gain)
            console.log(`Processing audio data for buffer ${this.id}. Buffer status checked. Data size: ${this._data.length} bytes.`);
            for (let i = 0; i < this._data.length; i++) {
                this._data[i] = Math.floor(this._data[i] * 0.75); // Reduce volume
            }
            console.log("Audio processing completed securely.");
        } else {
            console.log(`Cannot process audio: Buffer ${this.id} is not loaded or empty.`);
        }
    }

    public dispose(): void {
        this._data = null;
        this.sampleRate = null;
        this.channels = null;
        this.isLoaded = false;
        console.log(`Audio Buffer ${this.id} resources disposed.`);
    }

    public getData(): Buffer | null {
        return this._data;
    }
}

class AudioManager {
    private audioBuffers: Map<number, AudioBuffer>;
    private nextBufferId: number;

    constructor() {
        this.audioBuffers = new Map<number, AudioBuffer>();
        this.nextBufferId = 1;
    }

    public createAudioBuffer(): AudioBuffer {
        const newBuffer = new AudioBuffer(this.nextBufferId++);
        this.audioBuffers.set(newBuffer.id, newBuffer);
        return newBuffer;
    }

    public getAudioBuffer(id: number): AudioBuffer | null {
        const buffer = this.audioBuffers.get(id);
        if (buffer) {
            if (buffer.isLoaded) {
                console.log(`Accessing audio buffer ${id}. Buffer status is valid.`);
                return buffer;
            } else {
                console.log(`Audio buffer ${id} is not loaded. Access denied.`);
                return null;
            }
        }
        console.log(`Audio buffer ${id} not found.`);
        return null;
    }

    public removeAudioBuffer(id: number): void {
        const buffer = this.audioBuffers.get(id);
        if (buffer) {
            buffer.dispose();
            this.audioBuffers.delete(id);
            console.log(`Audio buffer ${id} removed.`);
        } else {
            console.log(`Audio buffer ${id} not found.`);
        }
    }
}
```

### ðŸ§ª Senaryo 9: Bir matematik kÃ¼tÃ¼phanesinde matris nesneleri hesaplamalar iÃ§in kullanÄ±lÄ±r. Matris oluÅŸturulduÄŸunda bellek yapÄ±sÄ± tahsis edilir. Ä°ÅŸlemler sÄ±rasÄ±nda matris verilerine eriÅŸim yapÄ±lÄ±r. KÃ¼tÃ¼phane matematik iÅŸlemlerini gÃ¼venli yÃ¼rÃ¼tÃ¼r.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 84
```csharp

using System;
using System.Linq;

public class Matrix
{
    public int Rows { get; private set; }
    public int Columns { get; private set; }
    private double[,] _data; // Internal representation of the matrix

    public Matrix(int rows, int columns)
    {
        if (rows <= 0 || columns <= 0)
        {
            throw new ArgumentException("Matrix dimensions must be positive.");
        }
        Rows = rows;
        Columns = columns;
        _data = new double[rows, columns];
        Console.WriteLine($"Matrix ({rows}x{columns}) created and memory structure allocated.");
    }

    // Indexer for safe element access
    public double this[int row, int col]
    {
        get
        {
            if (row < 0 || row >= Rows || col < 0 || col >= Columns)
            {
                throw new IndexOutOfRangeException("Matrix element index out of bounds.");
            }
            Console.WriteLine($"Accessing element at ({row},{col}) securely.");
            return _data[row, col];
        }
        set
        {
            if (row < 0 || row >= Rows || col < 0 || col >= Columns)
            {
                throw new IndexOutOfRangeException("Matrix element index out of bounds.");
            }
            _data[row, col] = value;
            Console.WriteLine($"Setting element at ({row},{col}) securely.");
        }
    }

    public static Matrix Multiply(Matrix matrixA, Matrix matrixB)
    {
        if (matrixA.Columns != matrixB.Rows)
        {
            throw new ArgumentException("Matrices cannot be multiplied: Inner dimensions must match.");
        }

        Matrix result = new Matrix(matrixA.Rows, matrixB.Columns);
        Console.WriteLine("Performing matrix multiplication securely. Accessing matrix data.");

        for (int i = 0; i < matrixA.Rows; i++)
        {
            for (int j = 0; j < matrixB.Columns; j++)
            {
                double sum = 0;
                for (int k = 0; k < matrixA.Columns; k++)
                {
                    sum += matrixA[i, k] * matrixB[k, j];
                }
                result[i, j] = sum;
            }
        }
        Console.WriteLine("Matrix multiplication completed securely.");
        return result;
    }

    public void PrintMatrix()
    {
        Console.WriteLine("Matrix Contents:");
        for (int i = 0; i < Rows; i++)
        {
            for (int j = 0; j < Columns; j++)
            {
                Console.Write($"{_data[i, j]:F2}\t");
            }
            Console.WriteLine();
        }
    }
}
```
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 43
```python

class Matrix:
    def __init__(self, rows, cols):
        if rows <= 0 or cols <= 0:
            raise ValueError("Matrix dimensions must be positive.")
        self.rows = rows
        self.cols = cols
        self._data = [[0.0 for _ in range(cols)] for _ in range(rows)]
        print(f"Matrix ({rows}x{cols}) created and memory structure allocated.")

    def get_element(self, row, col):
        if not (0 <= row < self.rows and 0 <= col < self.cols):
            raise IndexError("Matrix element index out of bounds.")
        print(f"Accessing element at ({row},{col}) securely.")
        return self._data[row][col]

    def set_element(self, row, col, value):
        if not (0 <= row < self.rows and 0 <= col < self.cols):
            raise IndexError("Matrix element index out of bounds.")
        self._data[row][col] = float(value)
        print(f"Setting element at ({row},{col}) securely.")

    @staticmethod
    def multiply(matrix_a, matrix_b):
        if matrix_a.cols != matrix_b.rows:
            raise ValueError("Matrices cannot be multiplied: Inner dimensions must match.")

        result = Matrix(matrix_a.rows, matrix_b.cols)
        print("Performing matrix multiplication securely. Accessing matrix data.")

        for i in range(matrix_a.rows):
            for j in range(matrix_b.cols):
                sum_val = 0
                for k in range(matrix_a.cols):
                    sum_val += matrix_a.get_element(i, k) * matrix_b.get_element(k, j)
                result.set_element(i, j, sum_val)
        print("Matrix multiplication completed securely.")
        return result

    def print_matrix(self):
        print("Matrix Contents:")
        for row in self._data:
            print("\t".join(f"{val:.2f}" for val in row))
```
**ðŸ’» Dil:** `TypeScript`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 64
```typescript

class Matrix {
    public readonly rows: number;
    public readonly columns: number;
    private _data: number[][]; // Internal representation of the matrix

    constructor(rows: number, columns: number) {
        if (rows <= 0 || columns <= 0) {
            throw new Error("Matrix dimensions must be positive.");
        }
        this.rows = rows;
        this.columns = columns;
        this._data = Array(rows).fill(0).map(() => Array(columns).fill(0));
        console.log(`Matrix (${rows}x${columns}) created and memory structure allocated.`);
    }

    public getElement(row: number, col: number): number {
        if (row < 0 || row >= this.rows || col < 0 || col >= this.columns) {
            throw new Error("Matrix element index out of bounds.");
        }
        console.log(`Accessing element at (${row},${col}) securely.`);
        return this._data[row][col];
    }

    public setElement(row: number, col: number, value: number): void {
        if (row < 0 || row >= this.rows || col < 0 || col >= this.columns) {
            throw new Error("Matrix element index out of bounds.");
        }
        this._data[row][col] = value;
        console.log(`Setting element at (${row},${col}) securely.`);
    }

    public static multiply(matrixA: Matrix, matrixB: Matrix): Matrix {
        if (matrixA.columns !== matrixB.rows) {
            throw new Error("Matrices cannot be multiplied: Inner dimensions must match.");
        }

        const result = new Matrix(matrixA.rows, matrixB.columns);
        console.log("Performing matrix multiplication securely. Accessing matrix data.");

        for (let i = 0; i < matrixA.rows; i++) {
            for (let j = 0; j < matrixB.columns; j++) {
                let sum = 0;
                for (let k = 0; k < matrixA.columns; k++) {
                    sum += matrixA.getElement(i, k) * matrixB.getElement(k, j);
                }
                result.setElement(i, j, sum);
            }
        }
        console.log("Matrix multiplication completed securely.");
        return result;
    }

    public printMatrix(): void {
        console.log("Matrix Contents:");
        for (let i = 0; i < this.rows; i++) {
            let rowString = "";
            for (let j = 0; j < this.columns; j++) {
                rowString += `${this._data[i][j].toFixed(2)}\t`;
            }
            console.log(rowString);
        }
    }
}
```

### ðŸ§ª Senaryo 10: Bir text editÃ¶rde dokÃ¼man nesneleri metin iÃ§in oluÅŸturulur. Dosya aÃ§Ä±ldÄ±ÄŸÄ±nda sistem bellek yapÄ±sÄ±nÄ± hazÄ±rlar. DÃ¼zenleme iÅŸlemleri sÄ±rasÄ±nda dokÃ¼man verilerine eriÅŸilir. EditÃ¶r metin iÅŸlemlerini gÃ¼venli ÅŸekilde gerÃ§ekleÅŸtirir.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 114
```csharp

using System;
using System.Text;
using System.IO;
using System.Collections.Generic;

public class Document : IDisposable
{
    public string FilePath { get; private set; }
    private StringBuilder _content; // Represents the document's text content
    public bool IsLoaded { get; private set; } = false;

    public Document(string filePath)
    {
        FilePath = filePath;
        _content = new StringBuilder();
    }

    public bool Load()
    {
        try
        {
            if (File.Exists(FilePath))
            {
                _content.Append(File.ReadAllText(FilePath));
                IsLoaded = true;
                Console.WriteLine($"Document '{FilePath}' loaded. Memory structure prepared securely.");
                return true;
            }
            else
            {
                // Create an empty document if file doesn't exist
                IsLoaded = true;
                Console.WriteLine($"New document '{FilePath}' created. Memory structure prepared securely.");
                return true;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading document '{FilePath}': {ex.Message}");
            IsLoaded = false;
            return false;
        }
    }

    public void InsertText(int position, string textToInsert)
    {
        if (!IsLoaded)
        {
            Console.WriteLine("Cannot insert text: Document not loaded.");
            return;
        }
        if (position < 0 || position > _content.Length)
        {
            Console.WriteLine("Invalid insert position.");
            return;
        }
        _content.Insert(position, textToInsert);
        Console.WriteLine($"Text inserted securely at position {position}. Accessing document data.");
    }

    public void DeleteText(int position, int length)
    {
        if (!IsLoaded)
        {
            Console.WriteLine("Cannot delete text: Document not loaded.");
            return;
        }
        if (position < 0 || position >= _content.Length || length <= 0 || position + length > _content.Length)
        {
            Console.WriteLine("Invalid delete range.");
            return;
        }
        _content.Remove(position, length);
        Console.WriteLine($"Text deleted securely from position {position}. Accessing document data.");
    }

    public string GetContent()
    {
        if (!IsLoaded)
        {
            Console.WriteLine("Cannot get content: Document not loaded.");
            return string.Empty;
        }
        Console.WriteLine("Retrieving document content securely.");
        return _content.ToString();
    }

    public void Save()
    {
        if (!IsLoaded)
        {
            Console.WriteLine("Cannot save: Document not loaded.");
            return;
        }
        try
        {
            File.WriteAllText(FilePath, _content.ToString());
            Console.WriteLine($"Document '{FilePath}' saved securely.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving document '{FilePath}': {ex.Message}");
        }
    }

    public void Dispose()
    {
        _content = null; // Release memory
        IsLoaded = false;
        Console.WriteLine($"Document '{FilePath}' resources disposed.");
        GC.SuppressFinalize(this);
    }
}
```
**ðŸ’» Dil:** `Python`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 79
```python

import os

class Document:
    def __init__(self, file_path):
        self.file_path = file_path
        self._content = [] # Store content as a list of lines for easier manipulation
        self.is_loaded = False

    def load(self):
        try:
            if os.path.exists(self.file_path):
                with open(self.file_path, 'r', encoding='utf-8') as f:
                    self._content = f.readlines()
                self.is_loaded = True
                print(f"Document '{self.file_path}' loaded. Memory structure prepared securely.")
                return True
            else:
                self.is_loaded = True
                print(f"New document '{self.file_path}' created. Memory structure prepared securely.")
                return True
        except Exception as e:
            print(f"Error loading document '{self.file_path}': {e}")
            self.is_loaded = False
            return False

    def _get_flat_content(self):
        return "".join(self._content)

    def insert_text(self, position, text_to_insert):
        if not self.is_loaded:
            print("Cannot insert text: Document not loaded.")
            return

        current_content = self._get_flat_content()
        if not (0 <= position <= len(current_content)):
            print("Invalid insert position.")
            return

        new_content = current_content[:position] + text_to_insert + current_content[position:]
        self._content = new_content.splitlines(keepends=True) # Re-split into lines
        print(f"Text inserted securely at position {position}. Accessing document data.")

    def delete_text(self, position, length):
        if not self.is_loaded:
            print("Cannot delete text: Document not loaded.")
            return

        current_content = self._get_flat_content()
        if not (0 <= position < len(current_content) and length > 0 and position + length <= len(current_content)):
            print("Invalid delete range.")
            return

        new_content = current_content[:position] + current_content[position + length:]
        self._content = new_content.splitlines(keepends=True) # Re-split into lines
        print(f"Text deleted securely from position {position}. Accessing document data.")

    def get_content(self):
        if not self.is_loaded:
            print("Cannot get content: Document not loaded.")
            return ""
        print("Retrieving document content securely.")
        return self._get_flat_content()

    def save(self):
        if not self.is_loaded:
            print("Cannot save: Document not loaded.")
            return
        try:
            with open(self.file_path, 'w', encoding='utf-8') as f:
                f.writelines(self._content)
            print(f"Document '{self.file_path}' saved securely.")
        except Exception as e:
            print(f"Error saving document '{self.file_path}': {e}")

    def __del__(self):
        self._content = None
        self.is_loaded = False
        print(f"Document '{self.file_path}' resources disposed.")
```
**ðŸ’» Dil:** `TypeScript** (Node.js for file operations)**`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 96
```typescript

import * as fs from 'fs';

class Document {
    public readonly filePath: string;
    private _content: string;
    public isLoaded: boolean;

    constructor(filePath: string) {
        this.filePath = filePath;
        this._content = "";
        this.isLoaded = false;
    }

    public async load(): Promise<boolean> {
        return new Promise((resolve) => {
            fs.readFile(this.filePath, 'utf8', (err, data) => {
                if (err) {
                    if (err.code === 'ENOENT') {
                        // File not found, create an empty document
                        this._content = "";
                        this.isLoaded = true;
                        console.log(`New document '${this.filePath}' created. Memory structure prepared securely.`);
                        resolve(true);
                        return;
                    }
                    console.error(`Error loading document '${this.filePath}': ${err.message}`);
                    this.isLoaded = false;
                    resolve(false);
                    return;
                }
                this._content = data;
                this.isLoaded = true;
                console.log(`Document '${this.filePath}' loaded. Memory structure prepared securely.`);
                resolve(true);
            });
        });
    }

    public insertText(position: number, textToInsert: string): void {
        if (!this.isLoaded) {
            console.log("Cannot insert text: Document not loaded.");
            return;
        }
        if (position < 0 || position > this._content.length) {
            console.log("Invalid insert position.");
            return;
        }
        this._content = this._content.substring(0, position) + textToInsert + this._content.substring(position);
        console.log(`Text inserted securely at position ${position}. Accessing document data.`);
    }

    public deleteText(position: number, length: number): void {
        if (!this.isLoaded) {
            console.log("Cannot delete text: Document not loaded.");
            return;
        }
        if (position < 0 || position >= this._content.length || length <= 0 || position + length > this._content.length) {
            console.log("Invalid delete range.");
            return;
        }
        this._content = this._content.substring(0, position) + this._content.substring(position + length);
        console.log(`Text deleted securely from position ${position}. Accessing document data.`);
    }

    public getContent(): string {
        if (!this.isLoaded) {
            console.log("Cannot get content: Document not loaded.");
            return "";
        }
        console.log("Retrieving document content securely.");
        return this._content;
    }

    public async save(): Promise<void> {
        if (!this.isLoaded) {
            console.log("Cannot save: Document not loaded.");
            return;
        }
        return new Promise((resolve) => {
            fs.writeFile(this.filePath, this._content, 'utf8', (err) => {
                if (err) {
                    console.error(`Error saving document '${this.filePath}': ${err.message}`);
                } else {
                    console.log(`Document '${this.filePath}' saved securely.`);
                }
                resolve();
            });
        });
    }

    public dispose(): void {
        this._content = "";
        this.isLoaded = false;
        console.log(`Document '${this.filePath}' resources disposed.`);
    }
```
}