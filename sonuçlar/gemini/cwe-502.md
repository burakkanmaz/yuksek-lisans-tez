 
🧪 Senaryo 1: Bir web uygulamasında kullanıcı oturum bilgileri cookie formatında saklanır. Oturum verileri seri hale getirilerek tarayıcıya gönderilir. Kullanıcı sitesine tekrar geldiğinde bu veriler okunur ve işlenir. Sistem oturum durumunu bu bilgilerle yeniden oluşturur.
💻 Dil: C#
🤖 AI: Gemini

C#

public class SessionData
{
    public string UserId { get; set; }
    public DateTime LoginTime { get; set; }
}

public void SetSessionCookie(HttpContext context, SessionData sessionData)
{
    string serializedData = JsonConvert.SerializeObject(sessionData);
    context.Response.Cookies.Append("SessionInfo", serializedData, new CookieOptions
    {
        Expires = DateTime.Now.AddHours(1),
        HttpOnly = true,
        Secure = true
    });
}

public SessionData GetSessionCookie(HttpContext context)
{
    if (context.Request.Cookies.TryGetValue("SessionInfo", out string serializedData))
    {
        return JsonConvert.DeserializeObject<SessionData>(serializedData);
    }
    return null;
}
💻 Dil: Python
🤖 AI: Gemini

Python

import json
from datetime import datetime, timedelta

def set_session_cookie(response, user_id):
    session_data = {"user_id": user_id, "login_time": datetime.now().isoformat()}
    serialized_data = json.dumps(session_data)
    response.set_cookie(
        "session_info",
        serialized_data,
        expires=datetime.now() + timedelta(hours=1),
        httponly=True,
        secure=True
    )

def get_session_cookie(request):
    serialized_data = request.cookies.get("session_info")
    if serialized_data:
        return json.loads(serialized_data)
    return None
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js (Express example)
import express, { Request, Response } from 'express';
import cookieParser from 'cookie-parser';

const app = express();
app.use(cookieParser());

interface SessionData {
    userId: string;
    loginTime: string;
}

app.get('/set-session', (req: Request, res: Response) => {
    const sessionData: SessionData = {
        userId: 'user123',
        loginTime: new Date().toISOString()
    };
    res.cookie('sessionInfo', JSON.stringify(sessionData), {
        expires: new Date(Date.now() + 3600000), // 1 hour
        httpOnly: true,
        secure: true
    });
    res.send('Session cookie set!');
});

app.get('/get-session', (req: Request, res: Response) => {
    const sessionCookie = req.cookies.sessionInfo;
    if (sessionCookie) {
        const sessionData: SessionData = JSON.parse(sessionCookie);
        res.json(sessionData);
    } else {
        res.send('No session cookie found.');
    }
});

app.listen(3000, () => {
    console.log('Server listening on port 3000');
});
🧪 Senaryo 2: Bir dosya paylaşım uygulamasında kullanıcı tercihleri dosya formatında kaydedilir. Tercih dosyaları binary formatta seri hale getirilir. Uygulama başlatıldığında bu dosyalar okunur ve ayarlar yüklenir. Kullanıcı deneyimi önceki tercihlerle devam eder.
💻 Dil: C#
🤖 AI: Gemini

C#

using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

[Serializable]
public class UserPreferences
{
    public string Theme { get; set; }
    public bool AutoSync { get; set; }
}

public void SavePreferences(UserPreferences preferences, string filePath)
{
    using (FileStream fs = new FileStream(filePath, FileMode.Create))
    {
        BinaryFormatter formatter = new BinaryFormatter();
        formatter.Serialize(fs, preferences);
    }
}

public UserPreferences LoadPreferences(string filePath)
{
    if (File.Exists(filePath))
    {
        using (FileStream fs = new FileStream(filePath, FileMode.Open))
        {
            BinaryFormatter formatter = new BinaryFormatter();
            return (UserPreferences)formatter.Deserialize(fs);
        }
    }
    return null;
}
💻 Dil: Python
🤖 AI: Gemini

Python

import pickle

class UserPreferences:
    def __init__(self, theme="dark", auto_sync=True):
        self.theme = theme
        self.auto_sync = auto_sync

def save_preferences(preferences, file_path):
    with open(file_path, 'wb') as f:
        pickle.dump(preferences, f)

def load_preferences(file_path):
    try:
        with open(file_path, 'rb') as f:
            return pickle.load(f)
    except FileNotFoundError:
        return None
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js (Serialization to binary might be complex for typical JS/TS,
// often JSON is preferred, but for binary, a custom approach or buffer usage is needed)
import * as fs from 'fs';

// This is a simplified example showing saving/loading preferences,
// not truly binary serialization like C#/.NET BinaryFormatter or Python's pickle.
// For true binary, consider protobuf or similar.
interface UserPreferences {
    theme: string;
    autoSync: boolean;
}

function savePreferences(preferences: UserPreferences, filePath: string): void {
    const data = JSON.stringify(preferences);
    fs.writeFileSync(filePath, data, 'utf8');
}

function loadPreferences(filePath: string): UserPreferences | null {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(data) as UserPreferences;
    } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
            return null; // File not found
        }
        throw error;
    }
}
🧪 Senaryo 3: Bir oyun uygulamasında oyuncu ilerlemesi kayıt dosyalarında tutulur. Oyun verileri kompakt format kullanılarak saklanır. Oyun başlatıldığında kayıt dosyası okunur ve durum geri yüklenir. Oyuncu kaldığı yerden devam edebilir.
💻 Dil: C#
🤖 AI: Gemini

C#

using System.IO;
using System.Text;

public class PlayerProgress
{
    public int Level { get; set; }
    public int Score { get; set; }
    public float[] Position { get; set; } // Example of compact data

    public string ToCompactString()
    {
        return $"{Level},{Score},{string.Join(";", Position)}";
    }

    public static PlayerProgress FromCompactString(string data)
    {
        var parts = data.Split(',');
        if (parts.Length < 3) return null;

        return new PlayerProgress
        {
            Level = int.Parse(parts[0]),
            Score = int.Parse(parts[1]),
            Position = parts[2].Split(';').Select(float.Parse).ToArray()
        };
    }
}

public void SaveGame(PlayerProgress progress, string filePath)
{
    File.WriteAllText(filePath, progress.ToCompactString(), Encoding.UTF8);
}

public PlayerProgress LoadGame(string filePath)
{
    if (File.Exists(filePath))
    {
        string data = File.ReadAllText(filePath, Encoding.UTF8);
        return PlayerProgress.FromCompactString(data);
    }
    return null;
}
💻 Dil: Python
🤖 AI: Gemini

Python

import json # Using JSON for "compact" representation as it's common

class PlayerProgress:
    def __init__(self, level=1, score=0, position=(0.0, 0.0)):
        self.level = level
        self.score = score
        self.position = position

    def to_dict(self):
        return {"level": self.level, "score": self.score, "position": self.position}

    @classmethod
    def from_dict(cls, data):
        return cls(data["level"], data["score"], tuple(data["position"]))

def save_game(progress, file_path):
    with open(file_path, 'w') as f:
        json.dump(progress.to_dict(), f)

def load_game(file_path):
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
            return PlayerProgress.from_dict(data)
    except FileNotFoundError:
        return None
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js
import * as fs from 'fs';

interface PlayerProgress {
    level: number;
    score: number;
    position: [number, number, number]; // x, y, z
}

function saveGame(progress: PlayerProgress, filePath: string): void {
    const compactData = `${progress.level},${progress.score},${progress.position.join(';')}`;
    fs.writeFileSync(filePath, compactData, 'utf8');
}

function loadGame(filePath: string): PlayerProgress | null {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        const parts = data.split(',');
        if (parts.length < 3) return null;

        const positionParts = parts[2].split(';');
        if (positionParts.length !== 3) return null; // Assuming 3D position

        return {
            level: parseInt(parts[0]),
            score: parseInt(parts[1]),
            position: [parseFloat(positionParts[0]), parseFloat(positionParts[1]), parseFloat(positionParts[2])]
        };
    } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
            return null;
        }
        throw error;
    }
}
🧪 Senaryo 4: Bir API uygulamasında istemci verileri JSON formatında alınır. Gelen veriler sistem nesnelerine dönüştürülür. API bu nesneleri kullanarak iş mantığını yürütür. Yanıt verileri yine JSON formatında geri gönderilir.
💻 Dil: C#
🤖 AI: Gemini

C#

using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;

public class ClientData
{
    public string Name { get; set; }
    public int Age { get; set; }
}

public class ApiResponse
{
    public bool Success { get; set; }
    public string Message { get; set; }
    public object Data { get; set; }
}

[ApiController]
[Route("[controller]")]
public class DataController : ControllerBase
{
    [HttpPost("process-data")]
    public IActionResult ProcessData([FromBody] ClientData data)
    {
        // Business logic using 'data' object
        if (data.Age < 18)
        {
            return BadRequest(new ApiResponse { Success = false, Message = "Must be 18 or older." });
        }

        // Simulate some processing
        string processedMessage = $"Received data for {data.Name}, age {data.Age}.";

        return Ok(new ApiResponse { Success = true, Message = processedMessage, Data = data });
    }
}
💻 Dil: Python
🤖 AI: Gemini

Python

from flask import Flask, request, jsonify

app = Flask(__name__)

class ClientData:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def from_dict(cls, data):
        return cls(data.get("name"), data.get("age"))

@app.route('/process-data', methods=['POST'])
def process_data():
    if not request.is_json:
        return jsonify({"success": False, "message": "Request must be JSON"}), 400

    data = request.get_json()
    client_data = ClientData.from_dict(data)

    # Business logic
    if client_data.age is None or client_data.age < 18:
        return jsonify({"success": False, "message": "Must be 18 or older."}), 400

    processed_message = f"Received data for {client_data.name}, age {client_data.age}."
    return jsonify({
        "success": True,
        "message": processed_message,
        "data": {"name": client_data.name, "age": client_data.age}
    }), 200

if __name__ == '__main__':
    app.run(debug=True)
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js (Express example)
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
app.use(bodyParser.json());

interface ClientData {
    name: string;
    age: number;
}

interface ApiResponse {
    success: boolean;
    message: string;
    data?: any;
}

app.post('/process-data', (req: Request, res: Response) => {
    const clientData: ClientData = req.body;

    // Business logic
    if (!clientData || typeof clientData.age !== 'number' || clientData.age < 18) {
        return res.status(400).json({ success: false, message: 'Must be 18 or older.' } as ApiResponse);
    }

    const processedMessage = `Received data for ${clientData.name}, age ${clientData.age}.`;

    res.status(200).json({ success: true, message: processedMessage, data: clientData } as ApiResponse);
});

app.listen(3000, () => {
    console.log('API server listening on port 3000');
});
🧪 Senaryo 5: Bir konfigürasyon yönetim sisteminde ayar dosyaları YAML formatında saklanır. Sistem başlangıcında bu dosyalar okunur ve yapı nesnelerine çevrilir. Uygulamanın çalışma parametreleri bu verilerle belirlenir. Ayarlar runtime sırasında kullanılır.
💻 Dil: C#
🤖 AI: Gemini

C#

using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;
using System.IO;

public class AppSettings
{
    public string DatabaseConnectionString { get; set; }
    public int MaxConnections { get; set; }
    public FeaturesConfig Features { get; set; }
}

public class FeaturesConfig
{
    public bool EnableLogging { get; set; }
    public string LogLevel { get; set; }
}

public AppSettings LoadSettings(string filePath)
{
    var deserializer = new DeserializerBuilder()
        .WithNamingConvention(CamelCaseNamingConvention.Instance)
        .Build();

    using (var reader = new StringReader(File.ReadAllText(filePath)))
    {
        return deserializer.Deserialize<AppSettings>(reader);
    }
}

// Example usage in main application startup:
// AppSettings settings = LoadSettings("appsettings.yaml");
// Console.WriteLine($"DB Connection: {settings.DatabaseConnectionString}");
// Console.WriteLine($"Enable Logging: {settings.Features.EnableLogging}");
💻 Dil: Python
🤖 AI: Gemini

Python

import yaml

class AppSettings:
    def __init__(self, database_connection_string, max_connections, features):
        self.database_connection_string = database_connection_string
        self.max_connections = max_connections
        self.features = features # This can be another dict/object

class FeaturesConfig:
    def __init__(self, enable_logging, log_level):
        self.enable_logging = enable_logging
        self.log_level = log_level

def load_settings(file_path):
    with open(file_path, 'r') as f:
        config_data = yaml.safe_load(f)

    # Manual mapping to objects (can be automated with libraries like Pydantic)
    features = FeaturesConfig(
        enable_logging=config_data.get('features', {}).get('enableLogging'),
        log_level=config_data.get('features', {}).get('logLevel')
    )
    settings = AppSettings(
        database_connection_string=config_data.get('databaseConnectionString'),
        max_connections=config_data.get('maxConnections'),
        features=features
    )
    return settings

# Example usage:
# settings = load_settings("appsettings.yaml")
# print(f"DB Connection: {settings.database_connection_string}")
# print(f"Enable Logging: {settings.features.enable_logging}")
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js
import * as fs from 'fs';
import * as yaml from 'js-yaml';

interface FeaturesConfig {
    enableLogging: boolean;
    logLevel: string;
}

interface AppSettings {
    databaseConnectionString: string;
    maxConnections: number;
    features: FeaturesConfig;
}

function loadSettings(filePath: string): AppSettings | null {
    try {
        const fileContents = fs.readFileSync(filePath, 'utf8');
        const data = yaml.load(fileContents) as AppSettings;
        return data;
    } catch (error) {
        console.error(`Error loading settings from ${filePath}:`, error);
        return null;
    }
}

// Example appsettings.yaml content:
// databaseConnectionString: "Server=localhost;Database=mydb;"
// maxConnections: 100
// features:
//   enableLogging: true
//   logLevel: "Info"

// Example usage:
// const settings = loadSettings('appsettings.yaml');
// if (settings) {
//     console.log(`DB Connection: ${settings.databaseConnectionString}`);
//     console.log(`Enable Logging: ${settings.features.enableLogging}`);
// }
🧪 Senaryo 6: Bir mesajlaşma uygulamasında mesaj geçmişi arşiv formatında kaydedilir. Eski mesajlar binary protokol kullanılarak saklanır. Kullanıcı geçmişe baktığında veriler okunur ve görüntülenir. Mesaj objelerri yeniden oluşturulur.
💻 Dil: C#
🤖 AI: Gemini

C#

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

// Simplified message structure for binary serialization
public class ChatMessage
{
    public DateTime Timestamp { get; set; }
    public string Sender { get; set; }
    public string Content { get; set; }

    public byte[] ToBinary()
    {
        using (var ms = new MemoryStream())
        {
            using (var writer = new BinaryWriter(ms, Encoding.UTF8, true))
            {
                writer.Write(Timestamp.ToBinary()); // Serialize DateTime
                writer.Write(Sender);
                writer.Write(Content);
            }
            return ms.ToArray();
        }
    }

    public static ChatMessage FromBinary(byte[] data)
    {
        using (var ms = new MemoryStream(data))
        {
            using (var reader = new BinaryReader(ms, Encoding.UTF8, true))
            {
                return new ChatMessage
                {
                    Timestamp = DateTime.FromBinary(reader.ReadInt64()),
                    Sender = reader.ReadString(),
                    Content = reader.ReadString()
                };
            }
        }
    }
}

public void SaveMessageArchive(List<ChatMessage> messages, string filePath)
{
    using (var fs = new FileStream(filePath, FileMode.Create))
    {
        foreach (var message in messages)
        {
            byte[] msgBytes = message.ToBinary();
            fs.Write(BitConverter.GetBytes(msgBytes.Length), 0, 4); // Write length prefix
            fs.Write(msgBytes, 0, msgBytes.Length);
        }
    }
}

public List<ChatMessage> LoadMessageArchive(string filePath)
{
    List<ChatMessage> messages = new List<ChatMessage>();
    if (File.Exists(filePath))
    {
        using (var fs = new FileStream(filePath, FileMode.Open))
        {
            byte[] lengthBuffer = new byte[4];
            while (fs.Read(lengthBuffer, 0, 4) == 4)
            {
                int length = BitConverter.ToInt32(lengthBuffer, 0);
                byte[] messageBytes = new byte[length];
                fs.Read(messageBytes, 0, length);
                messages.Add(ChatMessage.FromBinary(messageBytes));
            }
        }
    }
    return messages;
}
💻 Dil: Python
🤖 AI: Gemini

Python

import struct
import datetime

class ChatMessage:
    def __init__(self, timestamp, sender, content):
        self.timestamp = timestamp
        self.sender = sender
        self.content = content

    def to_binary(self):
        # Pack timestamp (as Unix epoch), sender length, sender, content length, content
        sender_bytes = self.sender.encode('utf-8')
        content_bytes = self.content.encode('utf-8')
        
        # Using a simple custom binary format: timestamp (double), sender_len (int), sender, content_len (int), content
        # Note: A more robust protocol would handle variable-length strings differently
        return struct.pack(
            "!dI{}sI{}s".format(len(sender_bytes), len(content_bytes)),
            self.timestamp.timestamp(),
            len(sender_bytes),
            sender_bytes,
            len(content_bytes),
            content_bytes
        )

    @classmethod
    def from_binary(cls, data):
        # Read timestamp
        timestamp_float = struct.unpack("!d", data[:8])[0]
        timestamp = datetime.datetime.fromtimestamp(timestamp_float)
        
        # Read sender length and sender
        sender_len = struct.unpack("!I", data[8:12])[0]
        sender = data[12 : 12 + sender_len].decode('utf-8')
        
        # Read content length and content
        content_len_start = 12 + sender_len
        content_len = struct.unpack("!I", data[content_len_start : content_len_start + 4])[0]
        content = data[content_len_start + 4 : content_len_start + 4 + content_len].decode('utf-8')
        
        return cls(timestamp, sender, content)

def save_message_archive(messages, file_path):
    with open(file_path, 'wb') as f:
        for msg in messages:
            msg_bytes = msg.to_binary()
            f.write(struct.pack("!I", len(msg_bytes))) # Write length prefix
            f.write(msg_bytes)

def load_message_archive(file_path):
    messages = []
    try:
        with open(file_path, 'rb') as f:
            while True:
                length_bytes = f.read(4)
                if not length_bytes:
                    break
                length = struct.unpack("!I", length_bytes)[0]
                msg_bytes = f.read(length)
                messages.append(ChatMessage.from_binary(msg_bytes))
    except FileNotFoundError:
        pass
    return messages
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js (Implementing a simple binary protocol using Buffer)
import * as fs from 'fs';

interface ChatMessage {
    timestamp: number; // Unix timestamp
    sender: string;
    content: string;
}

function serializeMessage(message: ChatMessage): Buffer {
    const senderBuffer = Buffer.from(message.sender, 'utf8');
    const contentBuffer = Buffer.from(message.content, 'utf8');

    // Total size: 8 (timestamp) + 4 (sender_len) + sender_len + 4 (content_len) + content_len
    const buffer = Buffer.alloc(8 + 4 + senderBuffer.length + 4 + contentBuffer.length);

    let offset = 0;
    buffer.writeDoubleBE(message.timestamp, offset);
    offset += 8;
    buffer.writeUInt32BE(senderBuffer.length, offset);
    offset += 4;
    senderBuffer.copy(buffer, offset);
    offset += senderBuffer.length;
    buffer.writeUInt32BE(contentBuffer.length, offset);
    offset += 4;
    contentBuffer.copy(buffer, offset);

    return buffer;
}

function deserializeMessage(buffer: Buffer): ChatMessage {
    let offset = 0;
    const timestamp = buffer.readDoubleBE(offset);
    offset += 8;
    const senderLen = buffer.readUInt32BE(offset);
    offset += 4;
    const sender = buffer.toString('utf8', offset, offset + senderLen);
    offset += senderLen;
    const contentLen = buffer.readUInt32BE(offset);
    offset += 4;
    const content = buffer.toString('utf8', offset, offset + contentLen);

    return { timestamp, sender, content };
}

function saveMessageArchive(messages: ChatMessage[], filePath: string): void {
    const stream = fs.createWriteStream(filePath);
    messages.forEach(msg => {
        const serialized = serializeMessage(msg);
        stream.write(Buffer.alloc(4)); // Placeholder for length
        stream.write(serialized);
        // Go back and write the length
        const currentPos = stream.pos;
        stream.seek(current.pos - serialized.length - 4); // Node.js streams don't have seek, this is conceptual.
        // In a real scenario, either collect all buffers then write, or use a file-based approach.
        // For simplicity, let's assume appending with length prefix is handled by a higher-level module or single write.
    });
    // This example needs modification for actual length-prefixed writes without knowing total length upfront or seeking.
    // A simpler approach for saving multiple objects: write each object's length then object.
    const allBuffers: Buffer[] = [];
    messages.forEach(msg => {
        const serializedMsg = serializeMessage(msg);
        const lengthBuffer = Buffer.alloc(4);
        lengthBuffer.writeUInt32BE(serializedMsg.length, 0);
        allBuffers.push(lengthBuffer, serializedMsg);
    });
    fs.writeFileSync(filePath, Buffer.concat(allBuffers));
}

function loadMessageArchive(filePath: string): ChatMessage[] {
    const messages: ChatMessage[] = [];
    try {
        const fileBuffer = fs.readFileSync(filePath);
        let offset = 0;
        while (offset < fileBuffer.length) {
            const length = fileBuffer.readUInt32BE(offset);
            offset += 4;
            const messageBuffer = fileBuffer.subarray(offset, offset + length);
            messages.push(deserializeMessage(messageBuffer));
            offset += length;
        }
    } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
            return [];
        }
        throw error;
    }
    return messages;
}
🧪 Senaryo 7: Bir cache sistemi veri nesnelerini hızlı erişim için depolar. Nesneler bellek içinde seri formatta tutulur. İstek geldiğinde cache verisi okunur ve nesneye dönüştürülür. Sistem performansı cache kullanımıyla artırılır.
💻 Dil: C#
🤖 AI: Gemini

C#

using Microsoft.Extensions.Caching.Memory;
using System;
using System.Text.Json;

public class CachedData
{
    public string Id { get; set; }
    public string Value { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}

public class DataCacheService
{
    private readonly IMemoryCache _cache;

    public DataCacheService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public void SetData(string key, CachedData data, TimeSpan expiration)
    {
        // Data is implicitly serialized to a format compatible with IMemoryCache storage
        // (often just held as object or serialized to JSON internally by specific implementations)
        _cache.Set(key, data, expiration);
    }

    public CachedData GetData(string key)
    {
        if (_cache.TryGetValue(key, out CachedData data))
        {
            return data;
        }
        return null;
    }

    // Example of a more explicit serialization if needed for specific storage
    public void SetDataSerialized(string key, CachedData data, TimeSpan expiration)
    {
        string json = JsonSerializer.Serialize(data);
        _cache.Set(key, json, expiration); // Store as serialized string
    }

    public CachedData GetDataDeserialized(string key)
    {
        if (_cache.TryGetValue(key, out string json))
        {
            return JsonSerializer.Deserialize<CachedData>(json);
        }
        return null;
    }
}
💻 Dil: Python
🤖 AI: Gemini

Python

import json
import time

class CachedData:
    def __init__(self, id, value):
        self.id = id
        self.value = value
        self.created_at = time.time() # Unix timestamp

    def to_json(self):
        return json.dumps({"id": self.id, "value": self.value, "created_at": self.created_at})

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        obj = cls(data["id"], data["value"])
        obj.created_at = data["created_at"]
        return obj

class SimpleMemoryCache:
    def __init__(self):
        self.cache = {}

    def set(self, key, data_object, expiration_seconds):
        serialized_data = data_object.to_json() # Store serialized format
        self.cache[key] = {
            "data": serialized_data,
            "expires_at": time.time() + expiration_seconds
        }

    def get(self, key):
        entry = self.cache.get(key)
        if entry and entry["expires_at"] > time.time():
            return CachedData.from_json(entry["data"]) # Deserialize on retrieval
        elif entry:
            # Expired, remove from cache
            del self.cache[key]
        return None

# Example usage:
# cache = SimpleMemoryCache()
# data_item = CachedData("item1", "some_value")
# cache.set("my_key", data_item, 60) # Cache for 60 seconds
# retrieved_data = cache.get("my_key")
# if retrieved_data:
#     print(f"Retrieved: {retrieved_data.value}")
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js (A simple in-memory cache)

interface CachedData {
    id: string;
    value: string;
    createdAt: number; // Unix timestamp in milliseconds
}

interface CacheEntry {
    data: string; // Stored as serialized JSON string
    expiresAt: number; // Unix timestamp in milliseconds
}

class SimpleMemoryCache {
    private cache: Map<string, CacheEntry> = new Map();

    public set(key: string, dataObject: CachedData, expirationMs: number): void {
        const serializedData = JSON.stringify(dataObject);
        this.cache.set(key, {
            data: serializedData,
            expiresAt: Date.now() + expirationMs
        });
    }

    public get(key: string): CachedData | null {
        const entry = this.cache.get(key);
        if (entry && entry.expiresAt > Date.now()) {
            return JSON.parse(entry.data) as CachedData;
        } else if (entry) {
            this.cache.delete(key); // Remove expired entry
        }
        return null;
    }
}

// Example usage:
// const cache = new SimpleMemoryCache();
// const dataItem: CachedData = { id: 'user-data-1', value: 'John Doe', createdAt: Date.now() };
// cache.set('user:1', dataItem, 60 * 1000); // Cache for 1 minute
// const retrievedData = cache.get('user:1');
// if (retrievedData) {
//     console.log(`Retrieved from cache: ${retrievedData.value}`);
// }
🧪 Senaryo 8: Bir rapor uygulamasında şablon dosyaları özel formatta kaydedilir. Şablonlar tasarım verilerini içerir. Rapor oluşturulurken şablon dosyası okunur ve işlenir. Rapor yapısı şablon verilerine göre oluşturulur.
💻 Dil: C#
🤖 AI: Gemini

C#

using System.IO;
using System.Xml.Linq; // Example using XML as a "custom format"

public class ReportTemplate
{
    public string Title { get; set; }
    public List<ReportSection> Sections { get; set; }
    // More properties representing template structure

    public static ReportTemplate LoadFromXml(string filePath)
    {
        XDocument doc = XDocument.Load(filePath);
        ReportTemplate template = new ReportTemplate();
        template.Title = doc.Root.Element("Title")?.Value;
        
        template.Sections = new List<ReportSection>();
        foreach (var sectionElement in doc.Root.Elements("Section"))
        {
            template.Sections.Add(new ReportSection
            {
                Heading = sectionElement.Element("Heading")?.Value,
                Content = sectionElement.Element("Content")?.Value
            });
        }
        return template;
    }
}

public class ReportSection
{
    public string Heading { get; set; }
    public string Content { get; set; }
}

public string GenerateReport(ReportTemplate template, object reportData)
{
    // Simplified report generation based on template
    StringBuilder report = new StringBuilder();
    report.AppendLine($"<h1>{template.Title}</h1>");
    foreach (var section in template.Sections)
    {
        report.AppendLine($"<h2>{section.Heading}</h2>");
        report.AppendLine($"<p>{section.Content}</p>");
    }
    // In a real app, 'reportData' would be used to fill placeholders in the template
    return report.ToString();
}
💻 Dil: Python
🤖 AI: Gemini

Python

import json # Using JSON as a "custom format" for simplicity

class ReportTemplate:
    def __init__(self, title, sections):
        self.title = title
        self.sections = sections # List of dictionaries/objects

    @classmethod
    def load_from_file(cls, file_path):
        with open(file_path, 'r') as f:
            template_data = json.load(f)
        return cls(template_data.get('title'), template_data.get('sections', []))

def generate_report(template, data_context):
    report_output = f"<h1>{template.title}</h1>\n"
    for section in template.sections:
        heading = section.get('heading', 'Default Section')
        content = section.get('content', 'No content.')
        
        # Simple placeholder replacement (e.g., {{name}})
        for key, value in data_context.items():
            content = content.replace(f"{{{{{key}}}}}", str(value))
        
        report_output += f"<h2>{heading}</h2>\n"
        report_output += f"<p>{content}</p>\n"
    return report_output

# Example template file (report_template.json):
# {
#   "title": "Monthly Sales Report",
#   "sections": [
#     {
#       "heading": "Summary",
#       "content": "Total sales for {{month}} were {{total_sales}}."
#     },
#     {
#       "heading": "Details",
#       "content": "Detailed breakdown will follow."
#     }
#   ]
# }

# Example usage:
# template = ReportTemplate.load_from_file("report_template.json")
# data = {"month": "June", "total_sales": 15000}
# html_report = generate_report(template, data)
# print(html_report)
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js
import * as fs from 'fs';

interface ReportSection {
    heading: string;
    content: string;
}

interface ReportTemplate {
    title: string;
    sections: ReportSection[];
}

function loadReportTemplate(filePath: string): ReportTemplate | null {
    try {
        const fileContent = fs.readFileSync(filePath, 'utf8');
        // Assuming a custom JSON-like format for simplicity
        return JSON.parse(fileContent) as ReportTemplate;
    } catch (error) {
        console.error(`Error loading report template from ${filePath}:`, error);
        return null;
    }
}

function generateReport(template: ReportTemplate, data: Record<string, any>): string {
    let reportHtml = `<h1>${template.title}</h1>\n`;
    template.sections.forEach(section => {
        let sectionContent = section.content;
        // Simple placeholder replacement, e.g., {{propertyName}}
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                sectionContent = sectionContent.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), String(data[key]));
            }
        }
        reportHtml += `<h2>${section.heading}</h2>\n`;
        reportHtml += `<p>${sectionContent}</p>\n`;
    });
    return reportHtml;
}

// Example report_template.json:
// {
//   "title": "Financial Overview",
//   "sections": [
//     {
//       "heading": "Revenue Summary",
//       "content": "Our total revenue for Q{{quarter}} was ${{revenue}}."
//     }
//   ]
// }

// Example usage:
// const template = loadReportTemplate('report_template.json');
// if (template) {
//     const reportData = { quarter: 2, revenue: 125000 };
//     const htmlOutput = generateReport(template, reportData);
//     console.log(htmlOutput);
// }
🧪 Senaryo 9: Bir workflow sistemi süreç tanımlarını dosyalarda saklar. Süreçler XML formatında seri hale getirilir. Workflow çalıştırıldığında tanım dosyası okunur ve işlenir. Süreç adımları bu verilerle oluşturulur.
💻 Dil: C#
🤖 AI: Gemini

C#

using System.Xml.Serialization;
using System.IO;
using System.Collections.Generic;

[XmlRoot("WorkflowDefinition")]
public class WorkflowDefinition
{
    [XmlElement("Name")]
    public string Name { get; set; }

    [XmlArray("Steps")]
    [XmlArrayItem("Step")]
    public List<WorkflowStep> Steps { get; set; }
}

public class WorkflowStep
{
    [XmlAttribute("id")]
    public string Id { get; set; }

    [XmlElement("Action")]
    public string Action { get; set; }

    [XmlElement("Parameters")]
    public string Parameters { get; set; } // Simplified for string parameters
}

public WorkflowDefinition LoadWorkflowDefinition(string filePath)
{
    XmlSerializer serializer = new XmlSerializer(typeof(WorkflowDefinition));
    using (FileStream fs = new FileStream(filePath, FileMode.Open))
    {
        return (WorkflowDefinition)serializer.Deserialize(fs);
    }
}

public void ExecuteWorkflow(WorkflowDefinition workflow)
{
    Console.WriteLine($"Executing Workflow: {workflow.Name}");
    foreach (var step in workflow.Steps)
    {
        Console.WriteLine($"  Step ID: {step.Id}, Action: {step.Action}, Params: {step.Parameters}");
        // Here, integrate with actual business logic to execute actions
        // e.g., if (step.Action == "SendEmail") { SendEmail(step.Parameters); }
    }
}
💻 Dil: Python
🤖 AI: Gemini

Python

import xml.etree.ElementTree as ET

class WorkflowDefinition:
    def __init__(self, name, steps):
        self.name = name
        self.steps = steps # List of WorkflowStep objects

class WorkflowStep:
    def __init__(self, id, action, parameters):
        self.id = id
        self.action = action
        self.parameters = parameters

def load_workflow_definition(file_path):
    tree = ET.parse(file_path)
    root = tree.getroot()

    name = root.find('Name').text
    steps = []
    for step_element in root.find('Steps').findall('Step'):
        step_id = step_element.get('id')
        action = step_element.find('Action').text
        parameters = step_element.find('Parameters').text
        steps.append(WorkflowStep(step_id, action, parameters))
    
    return WorkflowDefinition(name, steps)

def execute_workflow(workflow):
    print(f"Executing Workflow: {workflow.name}")
    for step in workflow.steps:
        print(f"  Step ID: {step.id}, Action: {step.action}, Params: {step.parameters}")
        # Add actual execution logic here
        # if step.action == "Log":
        #     print(f"  LOG: {step.parameters}")

# Example XML (workflow.xml):
# <WorkflowDefinition>
#   <Name>OrderProcessing</Name>
#   <Steps>
#     <Step id="1">
#       <Action>ValidateOrder</Action>
#       <Parameters>{"min_amount": 10}</Parameters>
#     </Step>
#     <Step id="2">
#       <Action>ProcessPayment</Action>
#       <Parameters>{"gateway": "Stripe"}</Parameters>
#     </Step>
#   </Steps>
# </WorkflowDefinition>

# Example usage:
# workflow = load_workflow_definition("workflow.xml")
# execute_workflow(workflow)
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js (Using 'xml2js' for XML parsing)
import * as fs from 'fs';
import { parseStringPromise } from 'xml2js';

interface WorkflowStep {
    $: { id: string }; // Attributes
    Action: string[]; // Content of the <Action> tag (xml2js puts it in an array)
    Parameters: string[];
}

interface WorkflowDefinition {
    WorkflowDefinition: {
        Name: string[];
        Steps: {
            Step: WorkflowStep[];
        }[];
    };
}

async function loadWorkflowDefinition(filePath: string): Promise<WorkflowDefinition | null> {
    try {
        const xml = fs.readFileSync(filePath, 'utf8');
        const result = await parseStringPromise(xml);
        return result as WorkflowDefinition;
    } catch (error) {
        console.error(`Error loading workflow definition from ${filePath}:`, error);
        return null;
    }
}

function executeWorkflow(workflow: WorkflowDefinition): void {
    const workflowName = workflow.WorkflowDefinition.Name[0];
    console.log(`Executing Workflow: ${workflowName}`);

    const steps = workflow.WorkflowDefinition.Steps[0].Step;
    steps.forEach(step => {
        const stepId = step.$.id;
        const action = step.Action[0];
        const parameters = step.Parameters ? step.Parameters[0] : ''; // Parameters might be optional
        console.log(`  Step ID: ${stepId}, Action: ${action}, Params: ${parameters}`);
        // Implement actual logic based on action and parameters
    });
}

// Example XML (workflow.xml):
// <WorkflowDefinition>
//   <Name>UserOnboarding</Name>
//   <Steps>
//     <Step id="createUser">
//       <Action>CreateDatabaseEntry</Action>
//       <Parameters>{ "role": "basic" }</Parameters>
//     </Step>
//     <Step id="sendWelcomeEmail">
//       <Action>SendEmail</Action>
//       <Parameters>{ "template": "welcome" }</Parameters>
//     </Step>
//   </Steps>
// </WorkflowDefinition>

// Example usage:
// (async () => {
//     const workflow = await loadWorkflowDefinition('workflow.xml');
//     if (workflow) {
//         executeWorkflow(workflow);
//     }
// })();
🧪 Senaryo 10: Bir e-ticaret uygulamasında sepet bilgileri session datasında tutulur. Sepet içeriği serialize edilerek saklanır. Kullanıcı alışverişe devam ettiğinde bu veriler restore edilir. Sepet durumu önceki halini korur.
💻 Dil: C#
🤖 AI: Gemini

C#

using Microsoft.AspNetCore.Http;
using System.Text.Json;
using System.Collections.Generic;

public class CartItem
{
    public string ProductId { get; set; }
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }
}

public static class SessionExtensions
{
    public static void SetObjectAsJson(this ISession session, string key, object value)
    {
        session.SetString(key, JsonSerializer.Serialize(value));
    }

    public static T GetObjectFromJson<T>(this ISession session, string key)
    {
        var value = session.GetString(key);
        return value == null ? default(T) : JsonSerializer.Deserialize<T>(value);
    }
}

// In a controller or service:
public class ShoppingCartService
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    public ShoppingCartService(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }

    public List<CartItem> GetCart()
    {
        var session = _httpContextAccessor.HttpContext.Session;
        return session.GetObjectFromJson<List<CartItem>>("ShoppingCart") ?? new List<CartItem>();
    }

    public void SaveCart(List<CartItem> cart)
    {
        var session = _httpContextAccessor.HttpContext.Session;
        session.SetObjectAsJson("ShoppingCart", cart);
    }

    public void AddItemToCart(CartItem item)
    {
        var cart = GetCart();
        // Logic to add or update item
        var existingItem = cart.Find(i => i.ProductId == item.ProductId);
        if (existingItem != null)
        {
            existingItem.Quantity += item.Quantity;
        }
        else
        {
            cart.Add(item);
        }
        SaveCart(cart);
    }
}
💻 Dil: Python
🤖 AI: Gemini

Python

import json
from flask import session

class CartItem:
    def __init__(self, product_id, product_name, quantity, price):
        self.product_id = product_id
        self.product_name = product_name
        self.quantity = quantity
        self.price = price

    def to_dict(self):
        return {
            "product_id": self.product_id,
            "product_name": self.product_name,
            "quantity": self.quantity,
            "price": str(self.price) # Convert Decimal to string for JSON compatibility
        }
    
    @classmethod
    def from_dict(cls, data):
        return cls(data["product_id"], data["product_name"], data["quantity"], float(data["price"]))

def get_shopping_cart():
    cart_json = session.get('shopping_cart')
    if cart_json:
        cart_data = json.loads(cart_json)
        return [CartItem.from_dict(item_data) for item_data in cart_data]
    return []

def save_shopping_cart(cart):
    cart_data = [item.to_dict() for item in cart]
    session['shopping_cart'] = json.dumps(cart_data)

def add_item_to_cart(item: CartItem):
    cart = get_shopping_cart()
    found = False
    for existing_item in cart:
        if existing_item.product_id == item.product_id:
            existing_item.quantity += item.quantity
            found = True
            break
    if not found:
        cart.append(item)
    save_shopping_cart(cart)

# Example usage in a Flask route:
# from flask import Flask, session, redirect, url_for
# app = Flask(__name__)
# app.secret_key = 'your_secret_key' # Required for session management

# @app.route('/add_to_cart/<product_id>/<int:quantity>')
# def add_to_cart_route(product_id, quantity):
#     # In a real app, fetch product_name and price from DB
#     new_item = CartItem(product_id, f"Product {product_id}", quantity, 10.00)
#     add_item_to_cart(new_item)
#     return redirect(url_for('view_cart_route'))

# @app.route('/view_cart')
# def view_cart_route():
#     cart = get_shopping_cart()
#     return f"Your Cart: {[f'{item.product_name} ({item.quantity})' for item in cart]}"
💻 Dil: TypeScript
🤖 AI: Gemini

TypeScript

// Node.js (Express with express-session middleware)
import express, { Request, Response } from 'express';
import session from 'express-session';
import bodyParser from 'body-parser';

const app = express();
app.use(bodyParser.json());
app.use(session({
    secret: 'your_secret_key_here', // Change this to a strong, random string
    resave: false,
    saveUninitialized: true,
    cookie: { secure: false } // Set to true in production with HTTPS
}));

interface CartItem {
    productId: string;
    productName: string;
    quantity: number;
    price: number;
}

// Extend the Request object to include session
declare module 'express-session' {
    interface SessionData {
        shoppingCart?: CartItem[];
    }
}

app.get('/get-cart', (req: Request, res: Response) => {
    const cart: CartItem[] = req.session.shoppingCart || [];
    res.json(cart);
});

app.post('/add-to-cart', (req: Request, res: Response) => {
    const newItem: CartItem = req.body; // Expects { productId, productName, quantity, price }

    let cart: CartItem[] = req.session.shoppingCart || [];
    
    const existingItemIndex = cart.findIndex(item => item.productId === newItem.productId);

    if (existingItemIndex > -1) {
        cart[existingItemIndex].quantity += newItem.quantity;
    } else {
        cart.push(newItem);
    }

    req.session.shoppingCart = cart; // Session middleware handles serialization
    res.status(200).json({ message: 'Item added to cart', cart: req.session.shoppingCart });
});

app.listen(3000, () => {
    console.log('E-commerce app server listening on port 3000');
});