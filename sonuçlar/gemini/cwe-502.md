 
ðŸ§ª Senaryo 1: Bir web uygulamasÄ±nda kullanÄ±cÄ± oturum bilgileri cookie formatÄ±nda saklanÄ±r. Oturum verileri seri hale getirilerek tarayÄ±cÄ±ya gÃ¶nderilir. KullanÄ±cÄ± sitesine tekrar geldiÄŸinde bu veriler okunur ve iÅŸlenir. Sistem oturum durumunu bu bilgilerle yeniden oluÅŸturur.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

public class SessionData
{
    public string UserId { get; set; }
    public DateTime LoginTime { get; set; }
}

public void SetSessionCookie(HttpContext context, SessionData sessionData)
{
    string serializedData = JsonConvert.SerializeObject(sessionData);
    context.Response.Cookies.Append("SessionInfo", serializedData, new CookieOptions
    {
        Expires = DateTime.Now.AddHours(1),
        HttpOnly = true,
        Secure = true
    });
}

public SessionData GetSessionCookie(HttpContext context)
{
    if (context.Request.Cookies.TryGetValue("SessionInfo", out string serializedData))
    {
        return JsonConvert.DeserializeObject<SessionData>(serializedData);
    }
    return null;
}
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

import json
from datetime import datetime, timedelta

def set_session_cookie(response, user_id):
    session_data = {"user_id": user_id, "login_time": datetime.now().isoformat()}
    serialized_data = json.dumps(session_data)
    response.set_cookie(
        "session_info",
        serialized_data,
        expires=datetime.now() + timedelta(hours=1),
        httponly=True,
        secure=True
    )

def get_session_cookie(request):
    serialized_data = request.cookies.get("session_info")
    if serialized_data:
        return json.loads(serialized_data)
    return None
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js (Express example)
import express, { Request, Response } from 'express';
import cookieParser from 'cookie-parser';

const app = express();
app.use(cookieParser());

interface SessionData {
    userId: string;
    loginTime: string;
}

app.get('/set-session', (req: Request, res: Response) => {
    const sessionData: SessionData = {
        userId: 'user123',
        loginTime: new Date().toISOString()
    };
    res.cookie('sessionInfo', JSON.stringify(sessionData), {
        expires: new Date(Date.now() + 3600000), // 1 hour
        httpOnly: true,
        secure: true
    });
    res.send('Session cookie set!');
});

app.get('/get-session', (req: Request, res: Response) => {
    const sessionCookie = req.cookies.sessionInfo;
    if (sessionCookie) {
        const sessionData: SessionData = JSON.parse(sessionCookie);
        res.json(sessionData);
    } else {
        res.send('No session cookie found.');
    }
});

app.listen(3000, () => {
    console.log('Server listening on port 3000');
});
ðŸ§ª Senaryo 2: Bir dosya paylaÅŸÄ±m uygulamasÄ±nda kullanÄ±cÄ± tercihleri dosya formatÄ±nda kaydedilir. Tercih dosyalarÄ± binary formatta seri hale getirilir. Uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda bu dosyalar okunur ve ayarlar yÃ¼klenir. KullanÄ±cÄ± deneyimi Ã¶nceki tercihlerle devam eder.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

[Serializable]
public class UserPreferences
{
    public string Theme { get; set; }
    public bool AutoSync { get; set; }
}

public void SavePreferences(UserPreferences preferences, string filePath)
{
    using (FileStream fs = new FileStream(filePath, FileMode.Create))
    {
        BinaryFormatter formatter = new BinaryFormatter();
        formatter.Serialize(fs, preferences);
    }
}

public UserPreferences LoadPreferences(string filePath)
{
    if (File.Exists(filePath))
    {
        using (FileStream fs = new FileStream(filePath, FileMode.Open))
        {
            BinaryFormatter formatter = new BinaryFormatter();
            return (UserPreferences)formatter.Deserialize(fs);
        }
    }
    return null;
}
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

import pickle

class UserPreferences:
    def __init__(self, theme="dark", auto_sync=True):
        self.theme = theme
        self.auto_sync = auto_sync

def save_preferences(preferences, file_path):
    with open(file_path, 'wb') as f:
        pickle.dump(preferences, f)

def load_preferences(file_path):
    try:
        with open(file_path, 'rb') as f:
            return pickle.load(f)
    except FileNotFoundError:
        return None
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js (Serialization to binary might be complex for typical JS/TS,
// often JSON is preferred, but for binary, a custom approach or buffer usage is needed)
import * as fs from 'fs';

// This is a simplified example showing saving/loading preferences,
// not truly binary serialization like C#/.NET BinaryFormatter or Python's pickle.
// For true binary, consider protobuf or similar.
interface UserPreferences {
    theme: string;
    autoSync: boolean;
}

function savePreferences(preferences: UserPreferences, filePath: string): void {
    const data = JSON.stringify(preferences);
    fs.writeFileSync(filePath, data, 'utf8');
}

function loadPreferences(filePath: string): UserPreferences | null {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(data) as UserPreferences;
    } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
            return null; // File not found
        }
        throw error;
    }
}
ðŸ§ª Senaryo 3: Bir oyun uygulamasÄ±nda oyuncu ilerlemesi kayÄ±t dosyalarÄ±nda tutulur. Oyun verileri kompakt format kullanÄ±larak saklanÄ±r. Oyun baÅŸlatÄ±ldÄ±ÄŸÄ±nda kayÄ±t dosyasÄ± okunur ve durum geri yÃ¼klenir. Oyuncu kaldÄ±ÄŸÄ± yerden devam edebilir.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

using System.IO;
using System.Text;

public class PlayerProgress
{
    public int Level { get; set; }
    public int Score { get; set; }
    public float[] Position { get; set; } // Example of compact data

    public string ToCompactString()
    {
        return $"{Level},{Score},{string.Join(";", Position)}";
    }

    public static PlayerProgress FromCompactString(string data)
    {
        var parts = data.Split(',');
        if (parts.Length < 3) return null;

        return new PlayerProgress
        {
            Level = int.Parse(parts[0]),
            Score = int.Parse(parts[1]),
            Position = parts[2].Split(';').Select(float.Parse).ToArray()
        };
    }
}

public void SaveGame(PlayerProgress progress, string filePath)
{
    File.WriteAllText(filePath, progress.ToCompactString(), Encoding.UTF8);
}

public PlayerProgress LoadGame(string filePath)
{
    if (File.Exists(filePath))
    {
        string data = File.ReadAllText(filePath, Encoding.UTF8);
        return PlayerProgress.FromCompactString(data);
    }
    return null;
}
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

import json # Using JSON for "compact" representation as it's common

class PlayerProgress:
    def __init__(self, level=1, score=0, position=(0.0, 0.0)):
        self.level = level
        self.score = score
        self.position = position

    def to_dict(self):
        return {"level": self.level, "score": self.score, "position": self.position}

    @classmethod
    def from_dict(cls, data):
        return cls(data["level"], data["score"], tuple(data["position"]))

def save_game(progress, file_path):
    with open(file_path, 'w') as f:
        json.dump(progress.to_dict(), f)

def load_game(file_path):
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
            return PlayerProgress.from_dict(data)
    except FileNotFoundError:
        return None
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js
import * as fs from 'fs';

interface PlayerProgress {
    level: number;
    score: number;
    position: [number, number, number]; // x, y, z
}

function saveGame(progress: PlayerProgress, filePath: string): void {
    const compactData = `${progress.level},${progress.score},${progress.position.join(';')}`;
    fs.writeFileSync(filePath, compactData, 'utf8');
}

function loadGame(filePath: string): PlayerProgress | null {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        const parts = data.split(',');
        if (parts.length < 3) return null;

        const positionParts = parts[2].split(';');
        if (positionParts.length !== 3) return null; // Assuming 3D position

        return {
            level: parseInt(parts[0]),
            score: parseInt(parts[1]),
            position: [parseFloat(positionParts[0]), parseFloat(positionParts[1]), parseFloat(positionParts[2])]
        };
    } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
            return null;
        }
        throw error;
    }
}
ðŸ§ª Senaryo 4: Bir API uygulamasÄ±nda istemci verileri JSON formatÄ±nda alÄ±nÄ±r. Gelen veriler sistem nesnelerine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r. API bu nesneleri kullanarak iÅŸ mantÄ±ÄŸÄ±nÄ± yÃ¼rÃ¼tÃ¼r. YanÄ±t verileri yine JSON formatÄ±nda geri gÃ¶nderilir.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;

public class ClientData
{
    public string Name { get; set; }
    public int Age { get; set; }
}

public class ApiResponse
{
    public bool Success { get; set; }
    public string Message { get; set; }
    public object Data { get; set; }
}

[ApiController]
[Route("[controller]")]
public class DataController : ControllerBase
{
    [HttpPost("process-data")]
    public IActionResult ProcessData([FromBody] ClientData data)
    {
        // Business logic using 'data' object
        if (data.Age < 18)
        {
            return BadRequest(new ApiResponse { Success = false, Message = "Must be 18 or older." });
        }

        // Simulate some processing
        string processedMessage = $"Received data for {data.Name}, age {data.Age}.";

        return Ok(new ApiResponse { Success = true, Message = processedMessage, Data = data });
    }
}
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

from flask import Flask, request, jsonify

app = Flask(__name__)

class ClientData:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def from_dict(cls, data):
        return cls(data.get("name"), data.get("age"))

@app.route('/process-data', methods=['POST'])
def process_data():
    if not request.is_json:
        return jsonify({"success": False, "message": "Request must be JSON"}), 400

    data = request.get_json()
    client_data = ClientData.from_dict(data)

    # Business logic
    if client_data.age is None or client_data.age < 18:
        return jsonify({"success": False, "message": "Must be 18 or older."}), 400

    processed_message = f"Received data for {client_data.name}, age {client_data.age}."
    return jsonify({
        "success": True,
        "message": processed_message,
        "data": {"name": client_data.name, "age": client_data.age}
    }), 200

if __name__ == '__main__':
    app.run(debug=True)
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js (Express example)
import express, { Request, Response } from 'express';
import bodyParser from 'body-parser';

const app = express();
app.use(bodyParser.json());

interface ClientData {
    name: string;
    age: number;
}

interface ApiResponse {
    success: boolean;
    message: string;
    data?: any;
}

app.post('/process-data', (req: Request, res: Response) => {
    const clientData: ClientData = req.body;

    // Business logic
    if (!clientData || typeof clientData.age !== 'number' || clientData.age < 18) {
        return res.status(400).json({ success: false, message: 'Must be 18 or older.' } as ApiResponse);
    }

    const processedMessage = `Received data for ${clientData.name}, age ${clientData.age}.`;

    res.status(200).json({ success: true, message: processedMessage, data: clientData } as ApiResponse);
});

app.listen(3000, () => {
    console.log('API server listening on port 3000');
});
ðŸ§ª Senaryo 5: Bir konfigÃ¼rasyon yÃ¶netim sisteminde ayar dosyalarÄ± YAML formatÄ±nda saklanÄ±r. Sistem baÅŸlangÄ±cÄ±nda bu dosyalar okunur ve yapÄ± nesnelerine Ã§evrilir. UygulamanÄ±n Ã§alÄ±ÅŸma parametreleri bu verilerle belirlenir. Ayarlar runtime sÄ±rasÄ±nda kullanÄ±lÄ±r.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;
using System.IO;

public class AppSettings
{
    public string DatabaseConnectionString { get; set; }
    public int MaxConnections { get; set; }
    public FeaturesConfig Features { get; set; }
}

public class FeaturesConfig
{
    public bool EnableLogging { get; set; }
    public string LogLevel { get; set; }
}

public AppSettings LoadSettings(string filePath)
{
    var deserializer = new DeserializerBuilder()
        .WithNamingConvention(CamelCaseNamingConvention.Instance)
        .Build();

    using (var reader = new StringReader(File.ReadAllText(filePath)))
    {
        return deserializer.Deserialize<AppSettings>(reader);
    }
}

// Example usage in main application startup:
// AppSettings settings = LoadSettings("appsettings.yaml");
// Console.WriteLine($"DB Connection: {settings.DatabaseConnectionString}");
// Console.WriteLine($"Enable Logging: {settings.Features.EnableLogging}");
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

import yaml

class AppSettings:
    def __init__(self, database_connection_string, max_connections, features):
        self.database_connection_string = database_connection_string
        self.max_connections = max_connections
        self.features = features # This can be another dict/object

class FeaturesConfig:
    def __init__(self, enable_logging, log_level):
        self.enable_logging = enable_logging
        self.log_level = log_level

def load_settings(file_path):
    with open(file_path, 'r') as f:
        config_data = yaml.safe_load(f)

    # Manual mapping to objects (can be automated with libraries like Pydantic)
    features = FeaturesConfig(
        enable_logging=config_data.get('features', {}).get('enableLogging'),
        log_level=config_data.get('features', {}).get('logLevel')
    )
    settings = AppSettings(
        database_connection_string=config_data.get('databaseConnectionString'),
        max_connections=config_data.get('maxConnections'),
        features=features
    )
    return settings

# Example usage:
# settings = load_settings("appsettings.yaml")
# print(f"DB Connection: {settings.database_connection_string}")
# print(f"Enable Logging: {settings.features.enable_logging}")
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js
import * as fs from 'fs';
import * as yaml from 'js-yaml';

interface FeaturesConfig {
    enableLogging: boolean;
    logLevel: string;
}

interface AppSettings {
    databaseConnectionString: string;
    maxConnections: number;
    features: FeaturesConfig;
}

function loadSettings(filePath: string): AppSettings | null {
    try {
        const fileContents = fs.readFileSync(filePath, 'utf8');
        const data = yaml.load(fileContents) as AppSettings;
        return data;
    } catch (error) {
        console.error(`Error loading settings from ${filePath}:`, error);
        return null;
    }
}

// Example appsettings.yaml content:
// databaseConnectionString: "Server=localhost;Database=mydb;"
// maxConnections: 100
// features:
//   enableLogging: true
//   logLevel: "Info"

// Example usage:
// const settings = loadSettings('appsettings.yaml');
// if (settings) {
//     console.log(`DB Connection: ${settings.databaseConnectionString}`);
//     console.log(`Enable Logging: ${settings.features.enableLogging}`);
// }
ðŸ§ª Senaryo 6: Bir mesajlaÅŸma uygulamasÄ±nda mesaj geÃ§miÅŸi arÅŸiv formatÄ±nda kaydedilir. Eski mesajlar binary protokol kullanÄ±larak saklanÄ±r. KullanÄ±cÄ± geÃ§miÅŸe baktÄ±ÄŸÄ±nda veriler okunur ve gÃ¶rÃ¼ntÃ¼lenir. Mesaj objelerri yeniden oluÅŸturulur.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

// Simplified message structure for binary serialization
public class ChatMessage
{
    public DateTime Timestamp { get; set; }
    public string Sender { get; set; }
    public string Content { get; set; }

    public byte[] ToBinary()
    {
        using (var ms = new MemoryStream())
        {
            using (var writer = new BinaryWriter(ms, Encoding.UTF8, true))
            {
                writer.Write(Timestamp.ToBinary()); // Serialize DateTime
                writer.Write(Sender);
                writer.Write(Content);
            }
            return ms.ToArray();
        }
    }

    public static ChatMessage FromBinary(byte[] data)
    {
        using (var ms = new MemoryStream(data))
        {
            using (var reader = new BinaryReader(ms, Encoding.UTF8, true))
            {
                return new ChatMessage
                {
                    Timestamp = DateTime.FromBinary(reader.ReadInt64()),
                    Sender = reader.ReadString(),
                    Content = reader.ReadString()
                };
            }
        }
    }
}

public void SaveMessageArchive(List<ChatMessage> messages, string filePath)
{
    using (var fs = new FileStream(filePath, FileMode.Create))
    {
        foreach (var message in messages)
        {
            byte[] msgBytes = message.ToBinary();
            fs.Write(BitConverter.GetBytes(msgBytes.Length), 0, 4); // Write length prefix
            fs.Write(msgBytes, 0, msgBytes.Length);
        }
    }
}

public List<ChatMessage> LoadMessageArchive(string filePath)
{
    List<ChatMessage> messages = new List<ChatMessage>();
    if (File.Exists(filePath))
    {
        using (var fs = new FileStream(filePath, FileMode.Open))
        {
            byte[] lengthBuffer = new byte[4];
            while (fs.Read(lengthBuffer, 0, 4) == 4)
            {
                int length = BitConverter.ToInt32(lengthBuffer, 0);
                byte[] messageBytes = new byte[length];
                fs.Read(messageBytes, 0, length);
                messages.Add(ChatMessage.FromBinary(messageBytes));
            }
        }
    }
    return messages;
}
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

import struct
import datetime

class ChatMessage:
    def __init__(self, timestamp, sender, content):
        self.timestamp = timestamp
        self.sender = sender
        self.content = content

    def to_binary(self):
        # Pack timestamp (as Unix epoch), sender length, sender, content length, content
        sender_bytes = self.sender.encode('utf-8')
        content_bytes = self.content.encode('utf-8')
        
        # Using a simple custom binary format: timestamp (double), sender_len (int), sender, content_len (int), content
        # Note: A more robust protocol would handle variable-length strings differently
        return struct.pack(
            "!dI{}sI{}s".format(len(sender_bytes), len(content_bytes)),
            self.timestamp.timestamp(),
            len(sender_bytes),
            sender_bytes,
            len(content_bytes),
            content_bytes
        )

    @classmethod
    def from_binary(cls, data):
        # Read timestamp
        timestamp_float = struct.unpack("!d", data[:8])[0]
        timestamp = datetime.datetime.fromtimestamp(timestamp_float)
        
        # Read sender length and sender
        sender_len = struct.unpack("!I", data[8:12])[0]
        sender = data[12 : 12 + sender_len].decode('utf-8')
        
        # Read content length and content
        content_len_start = 12 + sender_len
        content_len = struct.unpack("!I", data[content_len_start : content_len_start + 4])[0]
        content = data[content_len_start + 4 : content_len_start + 4 + content_len].decode('utf-8')
        
        return cls(timestamp, sender, content)

def save_message_archive(messages, file_path):
    with open(file_path, 'wb') as f:
        for msg in messages:
            msg_bytes = msg.to_binary()
            f.write(struct.pack("!I", len(msg_bytes))) # Write length prefix
            f.write(msg_bytes)

def load_message_archive(file_path):
    messages = []
    try:
        with open(file_path, 'rb') as f:
            while True:
                length_bytes = f.read(4)
                if not length_bytes:
                    break
                length = struct.unpack("!I", length_bytes)[0]
                msg_bytes = f.read(length)
                messages.append(ChatMessage.from_binary(msg_bytes))
    except FileNotFoundError:
        pass
    return messages
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js (Implementing a simple binary protocol using Buffer)
import * as fs from 'fs';

interface ChatMessage {
    timestamp: number; // Unix timestamp
    sender: string;
    content: string;
}

function serializeMessage(message: ChatMessage): Buffer {
    const senderBuffer = Buffer.from(message.sender, 'utf8');
    const contentBuffer = Buffer.from(message.content, 'utf8');

    // Total size: 8 (timestamp) + 4 (sender_len) + sender_len + 4 (content_len) + content_len
    const buffer = Buffer.alloc(8 + 4 + senderBuffer.length + 4 + contentBuffer.length);

    let offset = 0;
    buffer.writeDoubleBE(message.timestamp, offset);
    offset += 8;
    buffer.writeUInt32BE(senderBuffer.length, offset);
    offset += 4;
    senderBuffer.copy(buffer, offset);
    offset += senderBuffer.length;
    buffer.writeUInt32BE(contentBuffer.length, offset);
    offset += 4;
    contentBuffer.copy(buffer, offset);

    return buffer;
}

function deserializeMessage(buffer: Buffer): ChatMessage {
    let offset = 0;
    const timestamp = buffer.readDoubleBE(offset);
    offset += 8;
    const senderLen = buffer.readUInt32BE(offset);
    offset += 4;
    const sender = buffer.toString('utf8', offset, offset + senderLen);
    offset += senderLen;
    const contentLen = buffer.readUInt32BE(offset);
    offset += 4;
    const content = buffer.toString('utf8', offset, offset + contentLen);

    return { timestamp, sender, content };
}

function saveMessageArchive(messages: ChatMessage[], filePath: string): void {
    const stream = fs.createWriteStream(filePath);
    messages.forEach(msg => {
        const serialized = serializeMessage(msg);
        stream.write(Buffer.alloc(4)); // Placeholder for length
        stream.write(serialized);
        // Go back and write the length
        const currentPos = stream.pos;
        stream.seek(current.pos - serialized.length - 4); // Node.js streams don't have seek, this is conceptual.
        // In a real scenario, either collect all buffers then write, or use a file-based approach.
        // For simplicity, let's assume appending with length prefix is handled by a higher-level module or single write.
    });
    // This example needs modification for actual length-prefixed writes without knowing total length upfront or seeking.
    // A simpler approach for saving multiple objects: write each object's length then object.
    const allBuffers: Buffer[] = [];
    messages.forEach(msg => {
        const serializedMsg = serializeMessage(msg);
        const lengthBuffer = Buffer.alloc(4);
        lengthBuffer.writeUInt32BE(serializedMsg.length, 0);
        allBuffers.push(lengthBuffer, serializedMsg);
    });
    fs.writeFileSync(filePath, Buffer.concat(allBuffers));
}

function loadMessageArchive(filePath: string): ChatMessage[] {
    const messages: ChatMessage[] = [];
    try {
        const fileBuffer = fs.readFileSync(filePath);
        let offset = 0;
        while (offset < fileBuffer.length) {
            const length = fileBuffer.readUInt32BE(offset);
            offset += 4;
            const messageBuffer = fileBuffer.subarray(offset, offset + length);
            messages.push(deserializeMessage(messageBuffer));
            offset += length;
        }
    } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
            return [];
        }
        throw error;
    }
    return messages;
}
ðŸ§ª Senaryo 7: Bir cache sistemi veri nesnelerini hÄ±zlÄ± eriÅŸim iÃ§in depolar. Nesneler bellek iÃ§inde seri formatta tutulur. Ä°stek geldiÄŸinde cache verisi okunur ve nesneye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r. Sistem performansÄ± cache kullanÄ±mÄ±yla artÄ±rÄ±lÄ±r.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

using Microsoft.Extensions.Caching.Memory;
using System;
using System.Text.Json;

public class CachedData
{
    public string Id { get; set; }
    public string Value { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}

public class DataCacheService
{
    private readonly IMemoryCache _cache;

    public DataCacheService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public void SetData(string key, CachedData data, TimeSpan expiration)
    {
        // Data is implicitly serialized to a format compatible with IMemoryCache storage
        // (often just held as object or serialized to JSON internally by specific implementations)
        _cache.Set(key, data, expiration);
    }

    public CachedData GetData(string key)
    {
        if (_cache.TryGetValue(key, out CachedData data))
        {
            return data;
        }
        return null;
    }

    // Example of a more explicit serialization if needed for specific storage
    public void SetDataSerialized(string key, CachedData data, TimeSpan expiration)
    {
        string json = JsonSerializer.Serialize(data);
        _cache.Set(key, json, expiration); // Store as serialized string
    }

    public CachedData GetDataDeserialized(string key)
    {
        if (_cache.TryGetValue(key, out string json))
        {
            return JsonSerializer.Deserialize<CachedData>(json);
        }
        return null;
    }
}
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

import json
import time

class CachedData:
    def __init__(self, id, value):
        self.id = id
        self.value = value
        self.created_at = time.time() # Unix timestamp

    def to_json(self):
        return json.dumps({"id": self.id, "value": self.value, "created_at": self.created_at})

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        obj = cls(data["id"], data["value"])
        obj.created_at = data["created_at"]
        return obj

class SimpleMemoryCache:
    def __init__(self):
        self.cache = {}

    def set(self, key, data_object, expiration_seconds):
        serialized_data = data_object.to_json() # Store serialized format
        self.cache[key] = {
            "data": serialized_data,
            "expires_at": time.time() + expiration_seconds
        }

    def get(self, key):
        entry = self.cache.get(key)
        if entry and entry["expires_at"] > time.time():
            return CachedData.from_json(entry["data"]) # Deserialize on retrieval
        elif entry:
            # Expired, remove from cache
            del self.cache[key]
        return None

# Example usage:
# cache = SimpleMemoryCache()
# data_item = CachedData("item1", "some_value")
# cache.set("my_key", data_item, 60) # Cache for 60 seconds
# retrieved_data = cache.get("my_key")
# if retrieved_data:
#     print(f"Retrieved: {retrieved_data.value}")
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js (A simple in-memory cache)

interface CachedData {
    id: string;
    value: string;
    createdAt: number; // Unix timestamp in milliseconds
}

interface CacheEntry {
    data: string; // Stored as serialized JSON string
    expiresAt: number; // Unix timestamp in milliseconds
}

class SimpleMemoryCache {
    private cache: Map<string, CacheEntry> = new Map();

    public set(key: string, dataObject: CachedData, expirationMs: number): void {
        const serializedData = JSON.stringify(dataObject);
        this.cache.set(key, {
            data: serializedData,
            expiresAt: Date.now() + expirationMs
        });
    }

    public get(key: string): CachedData | null {
        const entry = this.cache.get(key);
        if (entry && entry.expiresAt > Date.now()) {
            return JSON.parse(entry.data) as CachedData;
        } else if (entry) {
            this.cache.delete(key); // Remove expired entry
        }
        return null;
    }
}

// Example usage:
// const cache = new SimpleMemoryCache();
// const dataItem: CachedData = { id: 'user-data-1', value: 'John Doe', createdAt: Date.now() };
// cache.set('user:1', dataItem, 60 * 1000); // Cache for 1 minute
// const retrievedData = cache.get('user:1');
// if (retrievedData) {
//     console.log(`Retrieved from cache: ${retrievedData.value}`);
// }
ðŸ§ª Senaryo 8: Bir rapor uygulamasÄ±nda ÅŸablon dosyalarÄ± Ã¶zel formatta kaydedilir. Åžablonlar tasarÄ±m verilerini iÃ§erir. Rapor oluÅŸturulurken ÅŸablon dosyasÄ± okunur ve iÅŸlenir. Rapor yapÄ±sÄ± ÅŸablon verilerine gÃ¶re oluÅŸturulur.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

using System.IO;
using System.Xml.Linq; // Example using XML as a "custom format"

public class ReportTemplate
{
    public string Title { get; set; }
    public List<ReportSection> Sections { get; set; }
    // More properties representing template structure

    public static ReportTemplate LoadFromXml(string filePath)
    {
        XDocument doc = XDocument.Load(filePath);
        ReportTemplate template = new ReportTemplate();
        template.Title = doc.Root.Element("Title")?.Value;
        
        template.Sections = new List<ReportSection>();
        foreach (var sectionElement in doc.Root.Elements("Section"))
        {
            template.Sections.Add(new ReportSection
            {
                Heading = sectionElement.Element("Heading")?.Value,
                Content = sectionElement.Element("Content")?.Value
            });
        }
        return template;
    }
}

public class ReportSection
{
    public string Heading { get; set; }
    public string Content { get; set; }
}

public string GenerateReport(ReportTemplate template, object reportData)
{
    // Simplified report generation based on template
    StringBuilder report = new StringBuilder();
    report.AppendLine($"<h1>{template.Title}</h1>");
    foreach (var section in template.Sections)
    {
        report.AppendLine($"<h2>{section.Heading}</h2>");
        report.AppendLine($"<p>{section.Content}</p>");
    }
    // In a real app, 'reportData' would be used to fill placeholders in the template
    return report.ToString();
}
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

import json # Using JSON as a "custom format" for simplicity

class ReportTemplate:
    def __init__(self, title, sections):
        self.title = title
        self.sections = sections # List of dictionaries/objects

    @classmethod
    def load_from_file(cls, file_path):
        with open(file_path, 'r') as f:
            template_data = json.load(f)
        return cls(template_data.get('title'), template_data.get('sections', []))

def generate_report(template, data_context):
    report_output = f"<h1>{template.title}</h1>\n"
    for section in template.sections:
        heading = section.get('heading', 'Default Section')
        content = section.get('content', 'No content.')
        
        # Simple placeholder replacement (e.g., {{name}})
        for key, value in data_context.items():
            content = content.replace(f"{{{{{key}}}}}", str(value))
        
        report_output += f"<h2>{heading}</h2>\n"
        report_output += f"<p>{content}</p>\n"
    return report_output

# Example template file (report_template.json):
# {
#   "title": "Monthly Sales Report",
#   "sections": [
#     {
#       "heading": "Summary",
#       "content": "Total sales for {{month}} were {{total_sales}}."
#     },
#     {
#       "heading": "Details",
#       "content": "Detailed breakdown will follow."
#     }
#   ]
# }

# Example usage:
# template = ReportTemplate.load_from_file("report_template.json")
# data = {"month": "June", "total_sales": 15000}
# html_report = generate_report(template, data)
# print(html_report)
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js
import * as fs from 'fs';

interface ReportSection {
    heading: string;
    content: string;
}

interface ReportTemplate {
    title: string;
    sections: ReportSection[];
}

function loadReportTemplate(filePath: string): ReportTemplate | null {
    try {
        const fileContent = fs.readFileSync(filePath, 'utf8');
        // Assuming a custom JSON-like format for simplicity
        return JSON.parse(fileContent) as ReportTemplate;
    } catch (error) {
        console.error(`Error loading report template from ${filePath}:`, error);
        return null;
    }
}

function generateReport(template: ReportTemplate, data: Record<string, any>): string {
    let reportHtml = `<h1>${template.title}</h1>\n`;
    template.sections.forEach(section => {
        let sectionContent = section.content;
        // Simple placeholder replacement, e.g., {{propertyName}}
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                sectionContent = sectionContent.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), String(data[key]));
            }
        }
        reportHtml += `<h2>${section.heading}</h2>\n`;
        reportHtml += `<p>${sectionContent}</p>\n`;
    });
    return reportHtml;
}

// Example report_template.json:
// {
//   "title": "Financial Overview",
//   "sections": [
//     {
//       "heading": "Revenue Summary",
//       "content": "Our total revenue for Q{{quarter}} was ${{revenue}}."
//     }
//   ]
// }

// Example usage:
// const template = loadReportTemplate('report_template.json');
// if (template) {
//     const reportData = { quarter: 2, revenue: 125000 };
//     const htmlOutput = generateReport(template, reportData);
//     console.log(htmlOutput);
// }
ðŸ§ª Senaryo 9: Bir workflow sistemi sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± dosyalarda saklar. SÃ¼reÃ§ler XML formatÄ±nda seri hale getirilir. Workflow Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda tanÄ±m dosyasÄ± okunur ve iÅŸlenir. SÃ¼reÃ§ adÄ±mlarÄ± bu verilerle oluÅŸturulur.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

using System.Xml.Serialization;
using System.IO;
using System.Collections.Generic;

[XmlRoot("WorkflowDefinition")]
public class WorkflowDefinition
{
    [XmlElement("Name")]
    public string Name { get; set; }

    [XmlArray("Steps")]
    [XmlArrayItem("Step")]
    public List<WorkflowStep> Steps { get; set; }
}

public class WorkflowStep
{
    [XmlAttribute("id")]
    public string Id { get; set; }

    [XmlElement("Action")]
    public string Action { get; set; }

    [XmlElement("Parameters")]
    public string Parameters { get; set; } // Simplified for string parameters
}

public WorkflowDefinition LoadWorkflowDefinition(string filePath)
{
    XmlSerializer serializer = new XmlSerializer(typeof(WorkflowDefinition));
    using (FileStream fs = new FileStream(filePath, FileMode.Open))
    {
        return (WorkflowDefinition)serializer.Deserialize(fs);
    }
}

public void ExecuteWorkflow(WorkflowDefinition workflow)
{
    Console.WriteLine($"Executing Workflow: {workflow.Name}");
    foreach (var step in workflow.Steps)
    {
        Console.WriteLine($"  Step ID: {step.Id}, Action: {step.Action}, Params: {step.Parameters}");
        // Here, integrate with actual business logic to execute actions
        // e.g., if (step.Action == "SendEmail") { SendEmail(step.Parameters); }
    }
}
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

import xml.etree.ElementTree as ET

class WorkflowDefinition:
    def __init__(self, name, steps):
        self.name = name
        self.steps = steps # List of WorkflowStep objects

class WorkflowStep:
    def __init__(self, id, action, parameters):
        self.id = id
        self.action = action
        self.parameters = parameters

def load_workflow_definition(file_path):
    tree = ET.parse(file_path)
    root = tree.getroot()

    name = root.find('Name').text
    steps = []
    for step_element in root.find('Steps').findall('Step'):
        step_id = step_element.get('id')
        action = step_element.find('Action').text
        parameters = step_element.find('Parameters').text
        steps.append(WorkflowStep(step_id, action, parameters))
    
    return WorkflowDefinition(name, steps)

def execute_workflow(workflow):
    print(f"Executing Workflow: {workflow.name}")
    for step in workflow.steps:
        print(f"  Step ID: {step.id}, Action: {step.action}, Params: {step.parameters}")
        # Add actual execution logic here
        # if step.action == "Log":
        #     print(f"  LOG: {step.parameters}")

# Example XML (workflow.xml):
# <WorkflowDefinition>
#   <Name>OrderProcessing</Name>
#   <Steps>
#     <Step id="1">
#       <Action>ValidateOrder</Action>
#       <Parameters>{"min_amount": 10}</Parameters>
#     </Step>
#     <Step id="2">
#       <Action>ProcessPayment</Action>
#       <Parameters>{"gateway": "Stripe"}</Parameters>
#     </Step>
#   </Steps>
# </WorkflowDefinition>

# Example usage:
# workflow = load_workflow_definition("workflow.xml")
# execute_workflow(workflow)
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js (Using 'xml2js' for XML parsing)
import * as fs from 'fs';
import { parseStringPromise } from 'xml2js';

interface WorkflowStep {
    $: { id: string }; // Attributes
    Action: string[]; // Content of the <Action> tag (xml2js puts it in an array)
    Parameters: string[];
}

interface WorkflowDefinition {
    WorkflowDefinition: {
        Name: string[];
        Steps: {
            Step: WorkflowStep[];
        }[];
    };
}

async function loadWorkflowDefinition(filePath: string): Promise<WorkflowDefinition | null> {
    try {
        const xml = fs.readFileSync(filePath, 'utf8');
        const result = await parseStringPromise(xml);
        return result as WorkflowDefinition;
    } catch (error) {
        console.error(`Error loading workflow definition from ${filePath}:`, error);
        return null;
    }
}

function executeWorkflow(workflow: WorkflowDefinition): void {
    const workflowName = workflow.WorkflowDefinition.Name[0];
    console.log(`Executing Workflow: ${workflowName}`);

    const steps = workflow.WorkflowDefinition.Steps[0].Step;
    steps.forEach(step => {
        const stepId = step.$.id;
        const action = step.Action[0];
        const parameters = step.Parameters ? step.Parameters[0] : ''; // Parameters might be optional
        console.log(`  Step ID: ${stepId}, Action: ${action}, Params: ${parameters}`);
        // Implement actual logic based on action and parameters
    });
}

// Example XML (workflow.xml):
// <WorkflowDefinition>
//   <Name>UserOnboarding</Name>
//   <Steps>
//     <Step id="createUser">
//       <Action>CreateDatabaseEntry</Action>
//       <Parameters>{ "role": "basic" }</Parameters>
//     </Step>
//     <Step id="sendWelcomeEmail">
//       <Action>SendEmail</Action>
//       <Parameters>{ "template": "welcome" }</Parameters>
//     </Step>
//   </Steps>
// </WorkflowDefinition>

// Example usage:
// (async () => {
//     const workflow = await loadWorkflowDefinition('workflow.xml');
//     if (workflow) {
//         executeWorkflow(workflow);
//     }
// })();
ðŸ§ª Senaryo 10: Bir e-ticaret uygulamasÄ±nda sepet bilgileri session datasÄ±nda tutulur. Sepet iÃ§eriÄŸi serialize edilerek saklanÄ±r. KullanÄ±cÄ± alÄ±ÅŸveriÅŸe devam ettiÄŸinde bu veriler restore edilir. Sepet durumu Ã¶nceki halini korur.
ðŸ’» Dil: C#
ðŸ¤– AI: Gemini

C#

using Microsoft.AspNetCore.Http;
using System.Text.Json;
using System.Collections.Generic;

public class CartItem
{
    public string ProductId { get; set; }
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }
}

public static class SessionExtensions
{
    public static void SetObjectAsJson(this ISession session, string key, object value)
    {
        session.SetString(key, JsonSerializer.Serialize(value));
    }

    public static T GetObjectFromJson<T>(this ISession session, string key)
    {
        var value = session.GetString(key);
        return value == null ? default(T) : JsonSerializer.Deserialize<T>(value);
    }
}

// In a controller or service:
public class ShoppingCartService
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    public ShoppingCartService(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }

    public List<CartItem> GetCart()
    {
        var session = _httpContextAccessor.HttpContext.Session;
        return session.GetObjectFromJson<List<CartItem>>("ShoppingCart") ?? new List<CartItem>();
    }

    public void SaveCart(List<CartItem> cart)
    {
        var session = _httpContextAccessor.HttpContext.Session;
        session.SetObjectAsJson("ShoppingCart", cart);
    }

    public void AddItemToCart(CartItem item)
    {
        var cart = GetCart();
        // Logic to add or update item
        var existingItem = cart.Find(i => i.ProductId == item.ProductId);
        if (existingItem != null)
        {
            existingItem.Quantity += item.Quantity;
        }
        else
        {
            cart.Add(item);
        }
        SaveCart(cart);
    }
}
ðŸ’» Dil: Python
ðŸ¤– AI: Gemini

Python

import json
from flask import session

class CartItem:
    def __init__(self, product_id, product_name, quantity, price):
        self.product_id = product_id
        self.product_name = product_name
        self.quantity = quantity
        self.price = price

    def to_dict(self):
        return {
            "product_id": self.product_id,
            "product_name": self.product_name,
            "quantity": self.quantity,
            "price": str(self.price) # Convert Decimal to string for JSON compatibility
        }
    
    @classmethod
    def from_dict(cls, data):
        return cls(data["product_id"], data["product_name"], data["quantity"], float(data["price"]))

def get_shopping_cart():
    cart_json = session.get('shopping_cart')
    if cart_json:
        cart_data = json.loads(cart_json)
        return [CartItem.from_dict(item_data) for item_data in cart_data]
    return []

def save_shopping_cart(cart):
    cart_data = [item.to_dict() for item in cart]
    session['shopping_cart'] = json.dumps(cart_data)

def add_item_to_cart(item: CartItem):
    cart = get_shopping_cart()
    found = False
    for existing_item in cart:
        if existing_item.product_id == item.product_id:
            existing_item.quantity += item.quantity
            found = True
            break
    if not found:
        cart.append(item)
    save_shopping_cart(cart)

# Example usage in a Flask route:
# from flask import Flask, session, redirect, url_for
# app = Flask(__name__)
# app.secret_key = 'your_secret_key' # Required for session management

# @app.route('/add_to_cart/<product_id>/<int:quantity>')
# def add_to_cart_route(product_id, quantity):
#     # In a real app, fetch product_name and price from DB
#     new_item = CartItem(product_id, f"Product {product_id}", quantity, 10.00)
#     add_item_to_cart(new_item)
#     return redirect(url_for('view_cart_route'))

# @app.route('/view_cart')
# def view_cart_route():
#     cart = get_shopping_cart()
#     return f"Your Cart: {[f'{item.product_name} ({item.quantity})' for item in cart]}"
ðŸ’» Dil: TypeScript
ðŸ¤– AI: Gemini

TypeScript

// Node.js (Express with express-session middleware)
import express, { Request, Response } from 'express';
import session from 'express-session';
import bodyParser from 'body-parser';

const app = express();
app.use(bodyParser.json());
app.use(session({
    secret: 'your_secret_key_here', // Change this to a strong, random string
    resave: false,
    saveUninitialized: true,
    cookie: { secure: false } // Set to true in production with HTTPS
}));

interface CartItem {
    productId: string;
    productName: string;
    quantity: number;
    price: number;
}

// Extend the Request object to include session
declare module 'express-session' {
    interface SessionData {
        shoppingCart?: CartItem[];
    }
}

app.get('/get-cart', (req: Request, res: Response) => {
    const cart: CartItem[] = req.session.shoppingCart || [];
    res.json(cart);
});

app.post('/add-to-cart', (req: Request, res: Response) => {
    const newItem: CartItem = req.body; // Expects { productId, productName, quantity, price }

    let cart: CartItem[] = req.session.shoppingCart || [];
    
    const existingItemIndex = cart.findIndex(item => item.productId === newItem.productId);

    if (existingItemIndex > -1) {
        cart[existingItemIndex].quantity += newItem.quantity;
    } else {
        cart.push(newItem);
    }

    req.session.shoppingCart = cart; // Session middleware handles serialization
    res.status(200).json({ message: 'Item added to cart', cart: req.session.shoppingCart });
});

app.listen(3000, () => {
    console.log('E-commerce app server listening on port 3000');
});