 
Markdown

----

### ğŸ§ª Senaryo 1: Bir fatura hesaplama uygulamasÄ±nda kullanÄ±cÄ± adet ve birim fiyat girerek toplam tutarÄ± gÃ¶rebiliyor. Hesaplama iÅŸlemi iki tam sayÄ± deÄŸerin Ã§arpÄ±mÄ±yla yapÄ±lÄ±yor. Uygulama girilen deÄŸerlerin sÄ±nÄ±rlarÄ±nÄ± deÄŸerlendiriyor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde sonuÃ§ hesaplanÄ±yor.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Gemini

```csharp
public class InvoiceCalculator
{
    public long CalculateTotal(int quantity, int unitPrice)
    {
        // Check for potential overflow before multiplication
        if ((long)quantity * unitPrice > long.MaxValue || (long)quantity * unitPrice < long.MinValue)
        {
            throw new OverflowException("The product of quantity and unit price is too large or too small.");
        }
        return (long)quantity * unitPrice;
    }
}
ğŸ§ª Senaryo 1: Bir fatura hesaplama uygulamasÄ±nda kullanÄ±cÄ± adet ve birim fiyat girerek toplam tutarÄ± gÃ¶rebiliyor. Hesaplama iÅŸlemi iki tam sayÄ± deÄŸerin Ã§arpÄ±mÄ±yla yapÄ±lÄ±yor. Uygulama girilen deÄŸerlerin sÄ±nÄ±rlarÄ±nÄ± deÄŸerlendiriyor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde sonuÃ§ hesaplanÄ±yor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class InvoiceCalculator:
    def calculate_total(self, quantity: int, unit_price: int) -> int:
        # Python handles large integers automatically, so explicit overflow checks are not strictly necessary
        # for preventing overflow, but can be added for boundary awareness or specific application logic.
        return quantity * unit_price
ğŸ§ª Senaryo 1: Bir fatura hesaplama uygulamasÄ±nda kullanÄ±cÄ± adet ve birim fiyat girerek toplam tutarÄ± gÃ¶rebiliyor. Hesaplama iÅŸlemi iki tam sayÄ± deÄŸerin Ã§arpÄ±mÄ±yla yapÄ±lÄ±yor. Uygulama girilen deÄŸerlerin sÄ±nÄ±rlarÄ±nÄ± deÄŸerlendiriyor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde sonuÃ§ hesaplanÄ±yor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class InvoiceCalculator {
    calculateTotal(quantity: number, unitPrice: number): number {
        // JavaScript numbers are 64-bit floating point, so large integer multiplication
        // can lose precision. For exact large integer arithmetic, BigInt can be used.
        if (Number.isSafeInteger(quantity) && Number.isSafeInteger(unitPrice)) {
            const result = quantity * unitPrice;
            if (Number.isSafeInteger(result)) {
                return result;
            } else {
                console.warn("Result exceeds Number.MAX_SAFE_INTEGER. Consider using BigInt for precise calculations.");
                return result; // Or throw an error, or use BigInt
            }
        } else {
            console.warn("Input values are not safe integers. Consider using BigInt for precise calculations.");
            return quantity * unitPrice; // Or throw an error, or use BigInt
        }
    }
}

// Example with BigInt for precise calculations
class InvoiceCalculatorBigInt {
    calculateTotal(quantity: bigint, unitPrice: bigint): bigint {
        return quantity * unitPrice;
    }
}
ğŸ§ª Senaryo 2: Bir oyun uygulamasÄ±nda oyuncular topladÄ±klarÄ± puanlara gÃ¶re seviye atlÄ±yor. Puanlar her baÅŸarÄ±yla birlikte belirli miktarda artÄ±rÄ±lÄ±yor. Uygulama puan deÄŸiÅŸkeninin sÄ±nÄ±rlarÄ±nÄ± takip ediyor. Belirli eÅŸik aÅŸÄ±ldÄ±ÄŸÄ±nda puan sistemi yeniden baÅŸlatÄ±lÄ±yor.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

public class GameScoreManager
{
    private const int MaxScore = 10000;
    private int _currentScore;

    public GameScoreManager(int initialScore = 0)
    {
        _currentScore = initialScore;
    }

    public int AddScore(int points)
    {
        if (_currentScore + points > MaxScore)
        {
            _currentScore = 0; // Reset score
            Console.WriteLine("Score reset due to exceeding max score.");
        }
        else
        {
            _currentScore += points;
        }
        return _currentScore;
    }

    public int GetCurrentScore()
    {
        return _currentScore;
    }
}
ğŸ§ª Senaryo 2: Bir oyun uygulamasÄ±nda oyuncular topladÄ±klarÄ± puanlara gÃ¶re seviye atlÄ±yor. Puanlar her baÅŸarÄ±yla birlikte belirli miktarda artÄ±rÄ±lÄ±yor. Uygulama puan deÄŸiÅŸkeninin sÄ±nÄ±rlarÄ±nÄ± takip ediyor. Belirli eÅŸik aÅŸÄ±ldÄ±ÄŸÄ±nda puan sistemi yeniden baÅŸlatÄ±lÄ±yor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class GameScoreManager:
    MAX_SCORE = 10000

    def __init__(self, initial_score: int = 0):
        self._current_score = initial_score

    def add_score(self, points: int) -> int:
        if self._current_score + points > self.MAX_SCORE:
            self._current_score = 0  # Reset score
            print("Score reset due to exceeding max score.")
        else:
            self._current_score += points
        return self._current_score

    def get_current_score(self) -> int:
        return self._current_score
ğŸ§ª Senaryo 2: Bir oyun uygulamasÄ±nda oyuncular topladÄ±klarÄ± puanlara gÃ¶re seviye atlÄ±yor. Puanlar her baÅŸarÄ±yla birlikte belirli miktarda artÄ±rÄ±lÄ±yor. Uygulama puan deÄŸiÅŸkeninin sÄ±nÄ±rlarÄ±nÄ± takip ediyor. Belirli eÅŸik aÅŸÄ±ldÄ±ÄŸÄ±nda puan sistemi yeniden baÅŸlatÄ±lÄ±yor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class GameScoreManager {
    private readonly MAX_SCORE: number = 10000;
    private _currentScore: number;

    constructor(initialScore: number = 0) {
        this._currentScore = initialScore;
    }

    addScore(points: number): number {
        if (this._currentScore + points > this.MAX_SCORE) {
            this._currentScore = 0; // Reset score
            console.log("Score reset due to exceeding max score.");
        } else {
            this._currentScore += points;
        }
        return this._currentScore;
    }

    getCurrentScore(): number {
        return this._currentScore;
    }
}
ğŸ§ª Senaryo 3: Bir bÃ¼tÃ§e planlama aracÄ±nda kullanÄ±cÄ±lar gelir ve giderleri belirterek hesaplama yapabiliyor. Verilen rakamlar toplanarak kalan bÃ¼tÃ§e hesaplanÄ±yor. Sistem toplam deÄŸerlerin veri tipine uygunluÄŸunu deÄŸerlendiriyor. BÃ¼yÃ¼k sayÄ±lar girildiÄŸinde hesaplama dÃ¶ngÃ¼sel olarak gerÃ§ekleÅŸiyor.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

public class BudgetPlanner
{
    public decimal CalculateRemainingBudget(decimal income, decimal expenses)
    {
        // Using decimal for financial calculations to avoid floating point inaccuracies
        // and to handle larger numbers than int/long for currency.
        // C# decimal type has a much larger range and higher precision suitable for financial data.
        return income - expenses;
    }
}
ğŸ§ª Senaryo 3: Bir bÃ¼tÃ§e planlama aracÄ±nda kullanÄ±cÄ±lar gelir ve giderleri belirterek hesaplama yapabiliyor. Verilen rakamlar toplanarak kalan bÃ¼tÃ§e hesaplanÄ±yor. Sistem toplam deÄŸerlerin veri tipine uygunluÄŸunu deÄŸerlendiriyor. BÃ¼yÃ¼k sayÄ±lar girildiÄŸinde hesaplama dÃ¶ngÃ¼sel olarak gerÃ§ekleÅŸiyor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

from decimal import Decimal, getcontext

class BudgetPlanner:
    def calculate_remaining_budget(self, income: Decimal, expenses: Decimal) -> Decimal:
        # Using Decimal for precise financial calculations
        getcontext().prec = 28 # Set precision if needed, default is usually sufficient
        return income - expenses
ğŸ§ª Senaryo 3: Bir bÃ¼tÃ§e planlama aracÄ±nda kullanÄ±cÄ±lar gelir ve giderleri belirterek hesaplama yapabiliyor. Verilen rakamlar toplanarak kalan bÃ¼tÃ§e hesaplanÄ±yor. Sistem toplam deÄŸerlerin veri tipine uygunluÄŸunu deÄŸerlendiriyor. BÃ¼yÃ¼k sayÄ±lar girildiÄŸinde hesaplama dÃ¶ngÃ¼sel olarak gerÃ§ekleÅŸiyor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class BudgetPlanner {
    calculateRemainingBudget(income: number | bigint, expenses: number | bigint): number | bigint {
        // For financial calculations, especially with large numbers, using BigInt is recommended
        // to avoid floating point inaccuracies.
        if (typeof income === 'bigint' && typeof expenses === 'bigint') {
            return income - expenses;
        } else if (typeof income === 'number' && typeof expenses === 'number') {
            // Check for potential precision loss if numbers are large
            if (!Number.isSafeInteger(income) || !Number.isSafeInteger(expenses)) {
                console.warn("Input values are not safe integers. Consider using BigInt for precise financial calculations.");
            }
            return income - expenses;
        } else {
            throw new Error("Income and expenses must be of the same type (number or bigint).");
        }
    }
}
ğŸ§ª Senaryo 4: Bir tarih hesaplama uygulamasÄ±nda kullanÄ±cÄ±lar gÃ¼n sayÄ±sÄ± girerek gelecekteki tarihi Ã¶ÄŸrenebiliyor. Sistem mevcut tarihe bu gÃ¼n sayÄ±sÄ±nÄ± ekleyerek sonucu gÃ¶steriyor. BÃ¼yÃ¼k sayÄ± girildiÄŸinde yÄ±l deÄŸeri deÄŸiÅŸim gÃ¶steriyor. Uygulama bu durumda uygun sonuÃ§ Ã¼retiyor.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

public class DateCalculator
{
    public DateTime CalculateFutureDate(DateTime startDate, int daysToAdd)
    {
        // DateTime.AddDays handles large numbers of days and correctly adjusts years, months, etc.
        return startDate.AddDays(daysToAdd);
    }
}
ğŸ§ª Senaryo 4: Bir tarih hesaplama uygulamasÄ±nda kullanÄ±cÄ±lar gÃ¼n sayÄ±sÄ± girerek gelecekteki tarihi Ã¶ÄŸrenebiliyor. Sistem mevcut tarihe bu gÃ¼n sayÄ±sÄ±nÄ± ekleyerek sonucu gÃ¶steriyor. BÃ¼yÃ¼k sayÄ± girildiÄŸinde yÄ±l deÄŸeri deÄŸiÅŸim gÃ¶steriyor. Uygulama bu durumda uygun sonuÃ§ Ã¼retiyor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

from datetime import datetime, timedelta

class DateCalculator:
    def calculate_future_date(self, start_date: datetime, days_to_add: int) -> datetime:
        # timedelta handles large numbers of days and correctly adjusts the date.
        return start_date + timedelta(days=days_to_add)
ğŸ§ª Senaryo 4: Bir tarih hesaplama uygulamasÄ±nda kullanÄ±cÄ±lar gÃ¼n sayÄ±sÄ± girerek gelecekteki tarihi Ã¶ÄŸrenebiliyor. Sistem mevcut tarihe bu gÃ¼n sayÄ±sÄ±nÄ± ekleyerek sonucu gÃ¶steriyor. BÃ¼yÃ¼k sayÄ± girildiÄŸinde yÄ±l deÄŸeri deÄŸiÅŸim gÃ¶steriyor. Uygulama bu durumda uygun sonuÃ§ Ã¼retiyor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class DateCalculator {
    calculateFutureDate(startDate: Date, daysToAdd: number): Date {
        const futureDate = new Date(startDate);
        // JavaScript Date object handles adding large numbers of days,
        // correctly adjusting months and years.
        futureDate.setDate(startDate.getDate() + daysToAdd);
        return futureDate;
    }
}
ğŸ§ª Senaryo 5: Bir video dÃ¼zenleyici yazÄ±lÄ±mÄ± kare numarasÄ±na gÃ¶re zaman hesaplamasÄ± yapÄ±yor. KullanÄ±cÄ± kare deÄŸeri girdiÄŸinde sistem bunu sÃ¼reye Ã§eviriyor. Kare deÄŸeri bÃ¼yÃ¼kse hesaplanan sÃ¼re deÄŸiÅŸken deÄŸerlere dÃ¶nÃ¼ÅŸebiliyor. Uygulama bu durumu yÃ¶netiyor.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

public class VideoTimeCalculator
{
    private const int FramesPerSecond = 30; // Example FPS

    public TimeSpan CalculateTimeFromFrames(long frameNumber)
    {
        // Using long for frameNumber to handle very large numbers of frames.
        // TimeSpan can handle large durations.
        double totalSeconds = (double)frameNumber / FramesPerSecond;
        return TimeSpan.FromSeconds(totalSeconds);
    }
}
ğŸ§ª Senaryo 5: Bir video dÃ¼zenleyici yazÄ±lÄ±mÄ± kare numarasÄ±na gÃ¶re zaman hesaplamasÄ± yapÄ±yor. KullanÄ±cÄ± kare deÄŸeri girdiÄŸinde sistem bunu sÃ¼reye Ã§eviriyor. Kare deÄŸeri bÃ¼yÃ¼kse hesaplanan sÃ¼re deÄŸiÅŸken deÄŸerlere dÃ¶nÃ¼ÅŸebiliyor. Uygulama bu durumu yÃ¶netiyor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

from datetime import timedelta

class VideoTimeCalculator:
    FRAMES_PER_SECOND = 30  # Example FPS

    def calculate_time_from_frames(self, frame_number: int) -> timedelta:
        # Python's integers handle arbitrary size, and timedelta can represent very long durations.
        total_seconds = frame_number / self.FRAMES_PER_SECOND
        return timedelta(seconds=total_seconds)
ğŸ§ª Senaryo 5: Bir video dÃ¼zenleyici yazÄ±lÄ±mÄ± kare numarasÄ±na gÃ¶re zaman hesaplamasÄ± yapÄ±yor. KullanÄ±cÄ± kare deÄŸeri girdiÄŸinde sistem bunu sÃ¼reye Ã§eviriyor. Kare deÄŸeri bÃ¼yÃ¼kse hesaplanan sÃ¼re deÄŸiÅŸken deÄŸerlere dÃ¶nÃ¼ÅŸebiliyor. Uygulama bu durumu yÃ¶netiyor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class VideoTimeCalculator {
    private readonly FRAMES_PER_SECOND: number = 30; // Example FPS

    calculateTimeFromFrames(frameNumber: number | bigint): number {
        // If frameNumber can be very large, use BigInt for precise division.
        // However, the result of seconds will eventually be a number (float).
        if (typeof frameNumber === 'bigint') {
            // Using BigInt for division and then converting to number for seconds.
            // Precision might be lost in the conversion for extremely large results.
            return Number(frameNumber) / this.FRAMES_PER_SECOND;
        } else {
            return frameNumber / this.FRAMES_PER_SECOND;
        }
    }

    // A more robust approach might be to return an object with hours, minutes, seconds etc.
    // or to use a library for large number arithmetic if extremely high precision is needed for seconds.
}
ğŸ§ª Senaryo 6: Bir sayaÃ§ uygulamasÄ±nda kullanÄ±cÄ±lar belirli iÅŸlemlerle sayacÄ± artÄ±rabiliyor. SayacÄ±n varsayÄ±lan veri tipi kÃ¼Ã§Ã¼k boyutlu tamsayÄ± olarak belirlenmiÅŸ. Uygulama artÄ±ÅŸ sÄ±rasÄ±nda sÄ±nÄ±r durumlarÄ±nÄ± denetliyor. SayacÄ±n deÄŸeri gerektiÄŸinde sÄ±fÄ±rlanÄ±yor.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

public class Counter
{
    private const byte MaxValue = 255; // Example: small integer (byte)
    private byte _currentValue;

    public Counter(byte initialValue = 0)
    {
        _currentValue = initialValue;
    }

    public byte Increment()
    {
        if (_currentValue == MaxValue)
        {
            _currentValue = 0; // Reset counter
            Console.WriteLine("Counter reset due to reaching max value.");
        }
        else
        {
            _currentValue++;
        }
        return _currentValue;
    }

    public byte GetCurrentValue()
    {
        return _currentValue;
    }
}
ğŸ§ª Senaryo 6: Bir sayaÃ§ uygulamasÄ±nda kullanÄ±cÄ±lar belirli iÅŸlemlerla sayacÄ± artÄ±rabiliyor. SayacÄ±n varsayÄ±lan veri tipi kÃ¼Ã§Ã¼k boyutlu tamsayÄ± olarak belirlenmiÅŸ. Uygulama artÄ±ÅŸ sÄ±rasÄ±nda sÄ±nÄ±r durumlarÄ±nÄ± denetliyor. SayacÄ±n deÄŸeri gerektiÄŸinde sÄ±fÄ±rlanÄ±yor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class Counter:
    MAX_VALUE = 255  # Example: small integer

    def __init__(self, initial_value: int = 0):
        self._current_value = initial_value

    def increment(self) -> int:
        if self._current_value >= self.MAX_VALUE:
            self._current_value = 0  # Reset counter
            print("Counter reset due to reaching max value.")
        else:
            self._current_value += 1
        return self._current_value

    def get_current_value(self) -> int:
        return self._current_value
ğŸ§ª Senaryo 6: Bir sayaÃ§ uygulamasÄ±nda kullanÄ±cÄ±lar belirli iÅŸlemlerle sayacÄ± artÄ±rabiliyor. SayacÄ±n varsayÄ±lan veri tipi kÃ¼Ã§Ã¼k boyutlu tamsayÄ± olarak belirlenmiÅŸ. Uygulama artÄ±ÅŸ sÄ±rasÄ±nda sÄ±nÄ±r durumlarÄ±nÄ± denetliyor. SayacÄ±n deÄŸeri gerektiÄŸinde sÄ±fÄ±rlanÄ±yor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class Counter {
    private readonly MAX_VALUE: number = 255; // Example: small integer
    private _currentValue: number;

    constructor(initialValue: number = 0) {
        this._currentValue = initialValue;
    }

    increment(): number {
        if (this._currentValue >= this.MAX_VALUE) {
            this._currentValue = 0; // Reset counter
            console.log("Counter reset due to reaching max value.");
        } else {
            this._currentValue++;
        }
        return this._currentValue;
    }

    getCurrentValue(): number {
        return this._currentValue;
    }
}
ğŸ§ª Senaryo 7: Bir taÅŸÄ±ma yÃ¶netim sisteminde kullanÄ±cÄ±lar taÅŸÄ±nan malzeme miktarÄ±nÄ± ve birim hacmini girerek toplam hacmi hesaplatÄ±yor. Bu hesaplama iki deÄŸerin Ã§arpÄ±lmasÄ±yla yapÄ±lÄ±yor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde toplam hacim deÄŸiÅŸken sayÄ±lara dÃ¶nÃ¼ÅŸebiliyor. Sistem bu deÄŸeri yÃ¶netiyor.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

public class TransportVolumeCalculator
{
    public long CalculateTotalVolume(int quantity, int unitVolume)
    {
        // Check for potential overflow before multiplication
        if ((long)quantity * unitVolume > long.MaxValue || (long)quantity * unitVolume < long.MinValue)
        {
            throw new OverflowException("The product of quantity and unit volume is too large or too small.");
        }
        return (long)quantity * unitVolume;
    }
}
ğŸ§ª Senaryo 7: Bir taÅŸÄ±ma yÃ¶netim sisteminde kullanÄ±cÄ±lar taÅŸÄ±nan malzeme miktarÄ±nÄ± ve birim hacmini girerek toplam hacmi hesaplatÄ±yor. Bu hesaplama iki deÄŸerin Ã§arpÄ±lmasÄ±yla yapÄ±lÄ±yor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde toplam hacim deÄŸiÅŸken sayÄ±lara dÃ¶nÃ¼ÅŸebiliyor. Sistem bu deÄŸeri yÃ¶netiyor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class TransportVolumeCalculator:
    def calculate_total_volume(self, quantity: int, unit_volume: int) -> int:
        # Python handles large integers automatically.
        return quantity * unit_volume
ğŸ§ª Senaryo 7: Bir taÅŸÄ±ma yÃ¶netim sisteminde kullanÄ±cÄ±lar taÅŸÄ±nan malzeme miktarÄ±nÄ± ve birim hacmini girerek toplam hacmi hesaplatÄ±yor. Bu hesaplama iki deÄŸerin Ã§arpÄ±lmasÄ±yla yapÄ±lÄ±yor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde toplam hacim deÄŸiÅŸken sayÄ±lara dÃ¶nÃ¼ÅŸebiliyor. Sistem bu deÄŸeri yÃ¶netiyor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class TransportVolumeCalculator {
    calculateTotalVolume(quantity: number, unitVolume: number): number {
        // For very large volumes, consider using BigInt for precision.
        if (Number.isSafeInteger(quantity) && Number.isSafeInteger(unitVolume)) {
            const result = quantity * unitVolume;
            if (Number.isSafeInteger(result)) {
                return result;
            } else {
                console.warn("Calculated volume exceeds Number.MAX_SAFE_INTEGER. Consider using BigInt for precise calculations.");
                return result; // Or throw an error, or use BigInt
            }
        } else {
            console.warn("Input values are not safe integers. Consider using BigInt for precise calculations.");
            return quantity * unitVolume; // Or throw an error, or use BigInt
        }
    }
}

// Example with BigInt for precise calculations
class TransportVolumeCalculatorBigInt {
    calculateTotalVolume(quantity: bigint, unitVolume: bigint): bigint {
        return quantity * unitVolume;
    }
}
ğŸ§ª Senaryo 8: Bir envanter sistemi Ã¼rÃ¼nlerin stok sayÄ±sÄ±nÄ± sipariÅŸ adediyle toplayarak gÃ¼ncelliyor. SipariÅŸ deÄŸeri yÃ¼ksekse toplam stok sayÄ±sÄ± Ã¼st limiti geÃ§ebiliyor. SayÄ± tipi sabit olduÄŸundan taÅŸma meydana geliyor. Sistem bu durumu ele alÄ±yor.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

public class InventorySystem
{
    private const int MaxStock = int.MaxValue; // Assuming stock is int, using its max value
    private int _currentStock;

    public InventorySystem(int initialStock = 0)
    {
        _currentStock = initialStock;
    }

    public int AddToStock(int orderQuantity)
    {
        try
        {
            // Using checked context to explicitly catch overflow
            checked
            {
                _currentStock += orderQuantity;
            }
        }
        catch (OverflowException)
        {
            Console.WriteLine($"Overflow detected! Attempted to add {orderQuantity} to stock, but current stock {_currentStock} would exceed maximum. Stock will be capped at MaxInt.");
            _currentStock = MaxStock; // Cap at max value or handle as per business logic
        }
        return _currentStock;
    }

    public int GetCurrentStock()
    {
        return _currentStock;
    }
}
ğŸ§ª Senaryo 8: Bir envanter sistemi Ã¼rÃ¼nlerin stok sayÄ±sÄ±nÄ± sipariÅŸ adediyle toplayarak gÃ¼ncelliyor. SipariÅŸ deÄŸeri yÃ¼ksekse toplam stok sayÄ±sÄ± Ã¼st limiti geÃ§ebiliyor. SayÄ± tipi sabit olduÄŸundan taÅŸma meydana geliyor. Sistem bu durumu ele alÄ±yor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class InventorySystem:
    # Python integers handle arbitrary size, so overflow as in fixed-size types doesn't occur.
    # However, we can still define a logical "max stock" for business rules.
    MAX_STOCK = 2_147_483_647 # Equivalent to int.MaxValue for conceptual comparison

    def __init__(self, initial_stock: int = 0):
        self._current_stock = initial_stock

    def add_to_stock(self, order_quantity: int) -> int:
        if self._current_stock + order_quantity > self.MAX_STOCK:
            print(f"Warning: Attempted to add {order_quantity} to stock, but current stock {self._current_stock} would exceed logical maximum. Stock will be capped.")
            self._current_stock = self.MAX_STOCK # Cap at max value
        else:
            self._current_stock += order_quantity
        return self._current_stock

    def get_current_stock(self) -> int:
        return self._current_stock
ğŸ§ª Senaryo 8: Bir envanter sistemi Ã¼rÃ¼nlerin stok sayÄ±sÄ±nÄ± sipariÅŸ adediyle toplayarak gÃ¼ncelliyor. SipariÅŸ deÄŸeri yÃ¼ksekse toplam stok sayÄ±sÄ± Ã¼st limiti geÃ§ebiliyor. SayÄ± tipi sabit olduÄŸundan taÅŸma meydana geliyor. Sistem bu durumu ele alÄ±yor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class InventorySystem {
    // JavaScript numbers have a max safe integer. For larger stock counts, BigInt should be used.
    private readonly MAX_SAFE_INTEGER: number = Number.MAX_SAFE_INTEGER;
    private _currentStock: number | bigint;

    constructor(initialStock: number | bigint = 0) {
        this._currentStock = initialStock;
    }

    addToStock(orderQuantity: number | bigint): number | bigint {
        if (typeof this._currentStock === 'number' && typeof orderQuantity === 'number') {
            if (this._currentStock + orderQuantity > this.MAX_SAFE_INTEGER) {
                console.warn("Calculated stock exceeds Number.MAX_SAFE_INTEGER. Consider switching to BigInt for stock management.");
                // Option 1: Cap at MAX_SAFE_INTEGER
                this._currentStock = this.MAX_SAFE_INTEGER;
                // Option 2: Convert to BigInt if overflow occurs
                // this._currentStock = BigInt(this._currentStock) + BigInt(orderQuantity);
            } else {
                this._currentStock += orderQuantity;
            }
        } else if (typeof this._currentStock === 'bigint' && typeof orderQuantity === 'bigint') {
            this._currentStock += orderQuantity;
        } else {
            throw new Error("Stock and order quantity must be of the same type (number or bigint).");
        }
        return this._currentStock;
    }

    getCurrentStock(): number | bigint {
        return this._currentStock;
    }
}
ğŸ§ª Senaryo 9: Bir sÄ±nav uygulamasÄ±nda Ã¶ÄŸretmenler her soru iÃ§in puan deÄŸerini ve soru sayÄ±sÄ±nÄ± girerek toplam puanÄ± belirliyor. Hesaplama iÅŸlemi bu iki deÄŸerin Ã§arpÄ±mÄ±yla gerÃ§ekleÅŸiyor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde toplam puan deÄŸiÅŸken deÄŸerlere dÃ¶nÃ¼ÅŸebiliyor. Uygulama bu iÅŸlemi yÃ¶netiyor.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

public class ExamScoring
{
    public long CalculateTotalScore(int pointsPerQuestion, int numberOfQuestions)
    {
        // Check for potential overflow before multiplication
        if ((long)pointsPerQuestion * numberOfQuestions > long.MaxValue || (long)pointsPerQuestion * numberOfQuestions < long.MinValue)
        {
            throw new OverflowException("The total score exceeds the maximum representable value.");
        }
        return (long)pointsPerQuestion * numberOfQuestions;
    }
}
ğŸ§ª Senaryo 9: Bir sÄ±nav uygulamasÄ±nda Ã¶ÄŸretmenler her soru iÃ§in puan deÄŸerini ve soru sayÄ±sÄ±nÄ± girerek toplam puanÄ± belirliyor. Hesaplama iÅŸlemi bu iki deÄŸerin Ã§arpÄ±mÄ±yla gerÃ§ekleÅŸiyor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde toplam puan deÄŸiÅŸken deÄŸerlere dÃ¶nÃ¼ÅŸebiliyor. Uygulama bu iÅŸlemi yÃ¶netiyor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class ExamScoring:
    def calculate_total_score(self, points_per_question: int, number_of_questions: int) -> int:
        # Python handles large integers automatically.
        return points_per_question * number_of_questions
ğŸ§ª Senaryo 9: Bir sÄ±nav uygulamasÄ±nda Ã¶ÄŸretmenler her soru iÃ§in puan deÄŸerini ve soru sayÄ±sÄ±nÄ± girerek toplam puanÄ± belirliyor. Hesaplama iÅŸlemi bu iki deÄŸerin Ã§arpÄ±mÄ±yla gerÃ§ekleÅŸiyor. BÃ¼yÃ¼k deÄŸerler girildiÄŸinde toplam puan deÄŸiÅŸken deÄŸerlere dÃ¶nÃ¼ÅŸebiliyor. Uygulama bu iÅŸlemi yÃ¶netiyor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class ExamScoring {
    calculateTotalScore(pointsPerQuestion: number, numberOfQuestions: number): number {
        // For potentially very large total scores, BigInt should be considered.
        if (Number.isSafeInteger(pointsPerQuestion) && Number.isSafeInteger(numberOfQuestions)) {
            const result = pointsPerQuestion * numberOfQuestions;
            if (Number.isSafeInteger(result)) {
                return result;
            } else {
                console.warn("Calculated total score exceeds Number.MAX_SAFE_INTEGER. Consider using BigInt for precise calculations.");
                return result; // Or throw an error, or use BigInt
            }
        } else {
            console.warn("Input values are not safe integers. Consider using BigInt for precise calculations.");
            return pointsPerQuestion * numberOfQuestions; // Or throw an error, or use BigInt
        }
    }
}

// Example with BigInt for precise calculations
class ExamScoringBigInt {
    calculateTotalScore(pointsPerQuestion: bigint, numberOfQuestions: bigint): bigint {
        return pointsPerQuestion * numberOfQuestions;
    }
}
ğŸ§ª Senaryo 10: Bir dosya aktarÄ±m uygulamasÄ±nda kullanÄ±cÄ±lar dosya boyutu ve parÃ§a sayÄ±sÄ± girerek aktarÄ±m birimlerini hesaplayabiliyor. ParÃ§a boyutu bu iki deÄŸerin bÃ¶lÃ¼nmesiyle elde ediliyor. Dosya boyutu bÃ¼yÃ¼k olduÄŸunda Ã§arpÄ±m sonucu taÅŸma yapabiliyor. Uygulama bu durumu iÅŸliyor.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

public class FileTransferCalculator
{
    public long CalculateChunkSize(long fileSize, int numberOfChunks)
    {
        if (numberOfChunks <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(numberOfChunks), "Number of chunks must be greater than zero.");
        }

        // Using long for fileSize to handle large file sizes.
        // Division is generally safe from overflow unless number_of_chunks is 0.
        return fileSize / numberOfChunks;
    }
}
ğŸ§ª Senaryo 10: Bir dosya aktarÄ±m uygulamasÄ±nda kullanÄ±cÄ±lar dosya boyutu ve parÃ§a sayÄ±sÄ± girerek aktarÄ±m birimlerini hesaplayabiliyor. ParÃ§a boyutu bu iki deÄŸerin bÃ¶lÃ¼nmesiyle elde ediliyor. Dosya boyutu bÃ¼yÃ¼k olduÄŸunda Ã§arpÄ±m sonucu taÅŸma yapabiliyor. Uygulama bu durumu iÅŸliyor.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class FileTransferCalculator:
    def calculate_chunk_size(self, file_size: int, number_of_chunks: int) -> int:
        if number_of_chunks <= 0:
            raise ValueError("Number of chunks must be greater than zero.")
        # Python handles large integers automatically. Integer division (//) for whole chunks.
        return file_size // number_of_chunks
ğŸ§ª Senaryo 10: Bir dosya aktarÄ±m uygulamasÄ±nda kullanÄ±cÄ±lar dosya boyutu ve parÃ§a sayÄ±sÄ± girerek aktarÄ±m birimlerini hesaplayabiliyor. ParÃ§a boyutu bu iki deÄŸerin bÃ¶lÃ¼nmesiyle elde ediliyor. Dosya boyutu bÃ¼yÃ¼k olduÄŸunda Ã§arpÄ±m sonucu taÅŸma yapabiliyor. Uygulama bu durumu iÅŸliyor.
ğŸ’» Dil: TypeScript

ğŸ¤– AI: Gemini

TypeScript

class FileTransferCalculator {
    calculateChunkSize(fileSize: number | bigint, numberOfChunks: number | bigint): number | bigint {
        if (typeof numberOfChunks === 'number' && numberOfChunks <= 0) {
            throw new Error("Number of chunks must be greater than zero.");
        }
        if (typeof numberOfChunks === 'bigint' && numberOfChunks <= 0n) {
            throw new Error("Number of chunks must be greater than zero.");
        }

        if (typeof fileSize === 'bigint' && typeof numberOfChunks === 'bigint') {
            return fileSize / numberOfChunks; // BigInt division truncates
        } else if (typeof fileSize === 'number' && typeof numberOfChunks === 'number') {
            // If file size is large and precision is critical, BigInt should be used.
            if (!Number.isSafeInteger(fileSize) || !Number.isSafeInteger(numberOfChunks)) {
                console.warn("Input values are not safe integers. Consider using BigInt for precise calculations, especially for large file sizes.");
            }
            return fileSize / numberOfChunks;
        } else {
            throw new Error("File size and number of chunks must be of the same type (number or bigint).");
        }
    }
}