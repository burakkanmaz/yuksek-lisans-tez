 
----

### ğŸ§ª Senaryo 1: Bir dÃ¶kÃ¼man yÃ¶netim sisteminde kullanÄ±cÄ±lar XML dosyalarÄ±nÄ± yÃ¼kleyebiliyor. Sistem bu dosyalarÄ± okuyarak iÃ§erik verilerini Ã§Ä±karÄ±yor. XML dosyalarÄ± Ã§eÅŸitli yapÄ±larda olabilir ve sistem bunlarÄ± iÅŸleyebilir. YÃ¼klenen dÃ¶kÃ¼manlar sisteme entegre edilir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Gemini

```csharp
using System.Xml.Linq;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class DocumentController : ControllerBase
{
    [HttpPost("upload")]
    public async Task<IActionResult> UploadDocument(IFormFile file)
    {
        if (file == null || file.Length == 0)
            return BadRequest("Upload a valid XML file.");

        try
        {
            using (var stream = file.OpenReadStream())
            {
                XDocument doc = XDocument.Load(stream);
                // Extract and process content data from doc
                // For demonstration, let's just log the root element name
                Console.WriteLine($"Processing XML document with root element: {doc.Root.Name}");

                // Integrate document into the system (e.g., save to database, file system)
                // Example: Save to a dummy database context
                // _dbContext.Documents.Add(new Document { Content = doc.ToString(), FileName = file.FileName });
                // await _dbContext.SaveChangesAsync();

                return Ok("Document uploaded and processed successfully.");
            }
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}
ğŸ§ª Senaryo 1: Bir dÃ¶kÃ¼man yÃ¶netim sisteminde kullanÄ±cÄ±lar XML dosyalarÄ±nÄ± yÃ¼kleyebiliyor. Sistem bu dosyalarÄ± okuyarak iÃ§erik verilerini Ã§Ä±karÄ±yor. XML dosyalarÄ± Ã§eÅŸitli yapÄ±larda olabilir ve sistem bunlarÄ± iÅŸleyebilir. YÃ¼klenen dÃ¶kÃ¼manlar sisteme entegre edilir.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
import xml.etree.ElementTree as ET
import os

app = Flask(__name__)

@app.route('/api/documents/upload', methods=['POST'])
def upload_document():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    if file and file.filename.endswith('.xml'):
        try:
            # Read XML content
            xml_content = file.read()
            root = ET.fromstring(xml_content)

            # Extract and process content data
            # For demonstration, print the root tag and some attributes
            print(f"Processing XML document with root tag: {root.tag}")
            for attr, value in root.attrib.items():
                print(f"  Attribute: {attr}, Value: {value}")

            # Integrate document into the system (e.g., save to database, file system)
            # Example: Save to a dummy file
            # with open(f"uploaded_docs/{file.filename}", "wb") as f:
            #     f.write(xml_content)

            return jsonify({"message": "Document uploaded and processed successfully."}), 200
        except ET.ParseError as e:
            return jsonify({"error": f"Invalid XML file: {e}"}), 400
        except Exception as e:
            return jsonify({"error": f"Internal server error: {e}"}), 500
    return jsonify({"error": "Invalid file type. Only XML allowed."}), 400

if __name__ == '__main__':
    # os.makedirs("uploaded_docs", exist_ok=True) # Uncomment if saving to file system
    app.run(debug=True)
```
ğŸ§ª Senaryo 1: Bir dÃ¶kÃ¼man yÃ¶netim sisteminde kullanÄ±cÄ±lar XML dosyalarÄ±nÄ± yÃ¼kleyebiliyor. Sistem bu dosyalarÄ± okuyarak iÃ§erik verilerini Ã§Ä±karÄ±yor. XML dosyalarÄ± Ã§eÅŸitli yapÄ±larda olabilir ve sistem bunlarÄ± iÅŸleyebilir. YÃ¼klenen dÃ¶kÃ¼manlar sisteme entegre edilir.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import { XMLParser } from 'fast-xml-parser';
import fs from 'fs';
import path from 'path';

const app = express();
const upload = multer({ dest: 'uploads/' }); // Temporary storage for uploaded files

app.post('/api/documents/upload', upload.single('document'), async (req, res) => {
    if (!req.file) {
        return res.status(400).send('Please upload an XML file.');
    }

    try {
        const filePath = req.file.path;
        const xmlContent = fs.readFileSync(filePath, 'utf8');

        const options = {
            ignoreAttributes: false,
            attributeNamePrefix : "@_"
        };
        const parser = new XMLParser(options);
        let jsonObj = parser.parse(xmlContent);

        // Extract and process content data from jsonObj
        // For demonstration, log the parsed JSON object
        console.log("Processing XML document:", JSON.stringify(jsonObj, null, 2));

        // Integrate document into the system (e.g., save to database)
        // Example: Save to a dummy database object
        // const documentRepository.save({
        //     fileName: req.file.originalname,
        //     content: JSON.stringify(jsonObj)
        // });

        // Clean up the uploaded file
        fs.unlinkSync(filePath);

        res.status(200).send('Document uploaded and processed successfully.');
    } catch (error: any) {
        // Ensure the temporary file is deleted even if an error occurs
        if (req.file) {
            fs.unlinkSync(req.file.path);
        }
        if (error.message.includes("Non-whitespace characters are not allowed")) {
            return res.status(400).send('Invalid XML file content.');
        }
        res.status(500).send(`Internal server error: ${error.message}`);
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```
ğŸ§ª Senaryo 2: Bir yapÄ±landÄ±rma uygulamasÄ±nda ayar dosyalarÄ± XML formatÄ±nda tutulur. KullanÄ±cÄ±lar bu dosyalarÄ± dÃ¼zenleyip sisteme yÃ¼kleyebilir. Uygulama XML iÃ§eriÄŸini okuyarak ayarlarÄ± gÃ¼nceller. YapÄ±landÄ±rma verileri uygulamada aktif hale gelir.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

```csharp

using System.Xml.Linq;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using System.Collections.Generic;

public static class AppSettings
{
    public static string Theme { get; set; } = "Default";
    public static int PageSize { get; set; } = 10;

    public static void LoadFromXml(XDocument doc)
    {
        // Example of parsing specific settings
        var themeElement = doc.Root?.Element("Theme");
        if (themeElement != null)
        {
            Theme = themeElement.Value;
        }

        var pageSizeElement = doc.Root?.Element("PageSize");
        if (pageSizeElement != null && int.TryParse(pageSizeElement.Value, out int pageSize))
        {
            PageSize = pageSize;
        }
        Console.WriteLine($"Application settings updated: Theme='{Theme}', PageSize={PageSize}");
    }
}

[ApiController]
[Route("api/[controller]")]
public class ConfigurationController : ControllerBase
{
    [HttpPost("upload-settings")]
    public async Task<IActionResult> UploadSettings(IFormFile file)
    {
        if (file == null || file.Length == 0)
            return BadRequest("Upload a valid XML settings file.");

        try
        {
            using (var stream = file.OpenReadStream())
            {
                XDocument doc = XDocument.Load(stream);
                AppSettings.LoadFromXml(doc); // Update application settings
                // In a real application, you might persist these settings or notify other services
                return Ok("Application settings updated successfully.");
            }
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}
```
ğŸ§ª Senaryo 2: Bir yapÄ±landÄ±rma uygulamasÄ±nda ayar dosyalarÄ± XML formatÄ±nda tutulur. KullanÄ±cÄ±lar bu dosyalarÄ± dÃ¼zenleyip sisteme yÃ¼kleyebilir. Uygulama XML iÃ§eriÄŸini okuyarak ayarlarÄ± gÃ¼nceller. YapÄ±landÄ±rma verileri uygulamada aktif hale gelir.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
import xml.etree.ElementTree as ET

app = Flask(__name__)

# Global dictionary to hold application settings
app_settings = {
    "theme": "default",
    "pageSize": 10
}

def update_app_settings(xml_content):
    root = ET.fromstring(xml_content)
    for child in root:
        if child.tag in app_settings:
            # Basic type conversion for demonstration
            if isinstance(app_settings[child.tag], int):
                try:
                    app_settings[child.tag] = int(child.text)
                except ValueError:
                    print(f"Warning: Could not convert {child.text} to int for {child.tag}")
            else:
                app_settings[child.tag] = child.text
            print(f"Setting '{child.tag}' updated to '{app_settings[child.tag]}'")

@app.route('/api/config/upload', methods=['POST'])
def upload_config():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    if file and file.filename.endswith('.xml'):
        try:
            xml_content = file.read()
            update_app_settings(xml_content)
            return jsonify({"message": "Configuration updated successfully.", "current_settings": app_settings}), 200
        except ET.ParseError as e:
            return jsonify({"error": f"Invalid XML file: {e}"}), 400
        except Exception as e:
            return jsonify({"error": f"Internal server error: {e}"}), 500
    return jsonify({"error": "Invalid file type. Only XML allowed."}), 400

@app.route('/api/config/current', methods=['GET'])
def get_current_config():
    return jsonify(app_settings), 200

if __name__ == '__main__':
    app.run(debug=True)
```
ğŸ§ª Senaryo 2: Bir yapÄ±landÄ±rma uygulamasÄ±nda ayar dosyalarÄ± XML formatÄ±nda tutulur. KullanÄ±cÄ±lar bu dosyalarÄ± dÃ¼zenleyip sisteme yÃ¼kleyebilir. Uygulama XML iÃ§eriÄŸini okuyarak ayarlarÄ± gÃ¼nceller. YapÄ±landÄ±rma verileri uygulamada aktif hale gelir.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import { XMLParser } from 'fast-xml-parser';
import fs from 'fs';
import path from 'path';

const app = express();
const upload = multer({ dest: 'uploads/' });

// Global object to hold application settings
interface AppSettings {
    theme: string;
    pageSize: number;
    [key: string]: any; // Allow for dynamic properties
}

let appSettings: AppSettings = {
    theme: 'default',
    pageSize: 10,
};

function updateAppSettings(xmlContent: string) {
    const options = {
        ignoreAttributes: false,
        attributeNamePrefix : "@_",
        parseNodeValue: true,
        arrayNodeName: "items", // Example for array nodes, not directly used here
        textNodeName: "#text"
    };
    const parser = new XMLParser(options);
    const parsedXml = parser.parse(xmlContent);

    if (parsedXml && typeof parsedXml === 'object' && 'Settings' in parsedXml) {
        const settings = parsedXml.Settings; // Assuming root element is <Settings>
        for (const key in settings) {
            if (Object.prototype.hasOwnProperty.call(appSettings, key)) {
                // Basic type conversion, more robust error handling needed for production
                if (key === 'pageSize') {
                    appSettings[key] = parseInt(settings[key]);
                } else {
                    appSettings[key] = settings[key];
                }
                console.log(`Setting '${key}' updated to '${appSettings[key]}'`);
            } else {
                console.warn(`Unknown setting '${key}' found in XML, skipping.`);
            }
        }
    } else {
        console.warn("XML did not contain expected 'Settings' root element or format.");
    }
}

app.post('/api/config/upload', upload.single('settingsFile'), async (req, res) => {
    if (!req.file) {
        return res.status(400).send('Please upload an XML settings file.');
    }

    try {
        const filePath = req.file.path;
        const xmlContent = fs.readFileSync(filePath, 'utf8');
        updateAppSettings(xmlContent);

        fs.unlinkSync(filePath); // Clean up the temporary file

        res.status(200).json({ message: 'Configuration updated successfully.', currentSettings: appSettings });
    } catch (error: any) {
        if (req.file) {
            fs.unlinkSync(req.file.path);
        }
        res.status(500).send(`Internal server error: ${error.message}`);
    }
});

app.get('/api/config/current', (req, res) => {
    res.status(200).json(appSettings);
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```
ğŸ§ª Senaryo 3: Bir veri dÃ¶nÃ¼ÅŸtÃ¼rme servisi farklÄ± formatlarÄ± XML'e Ã§evirir. KullanÄ±cÄ±lar kaynak dosyalarÄ±nÄ± yÃ¼kleyerek dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi baÅŸlatÄ±r. Sistem XML Ã§Ä±ktÄ±sÄ±nÄ± oluÅŸturur ve iÅŸler. DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ veriler kullanÄ±cÄ±ya sunulur.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

```csharp

using System.Xml.Linq;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using System.IO;
using System.Text;

[ApiController]
[Route("api/[controller]")]
public class DataConverterController : ControllerBase
{
    // Dummy converter function - in real world, this would handle various formats
    private XDocument ConvertToXml(Stream sourceStream, string fileExtension)
    {
        // This is a highly simplified example.
        // Real-world conversion would involve parsing the source format (e.g., CSV, JSON)
        // and constructing an XDocument.
        switch (fileExtension.ToLower())
        {
            case ".txt":
            case ".csv":
                using (StreamReader reader = new StreamReader(sourceStream))
                {
                    var content = reader.ReadToEnd();
                    return new XDocument(
                        new XElement("Root",
                            new XElement("OriginalFileName", "uploaded_file" + fileExtension),
                            new XElement("ConvertedContent", content)
                        )
                    );
                }
            case ".json":
                using (StreamReader reader = new StreamReader(sourceStream))
                {
                    var jsonContent = reader.ReadToEnd();
                    // Example: Simple conversion of JSON to XML. A proper converter would be complex.
                    return new XDocument(
                        new XElement("Root",
                            new XElement("OriginalFileName", "uploaded_file" + fileExtension),
                            new XElement("JsonData", new XCData(jsonContent)) // Wrap JSON in CDATA
                        )
                    );
                }
            default:
                throw new NotSupportedException(<span class="math-inline">"File type \{fileExtension\} is not supported for conversion\."\);
\}
\}
\[HttpPost\("convert"\)\]
public async Task<IActionResult\> ConvertData\(IFormFile file\)
\{
if \(file \=\= null \|\| file\.Length \=\= 0\)
return BadRequest\("Please upload a file for conversion\."\);
try
\{
var fileExtension \= Path\.GetExtension\(file\.FileName\);
XDocument xmlOutput \= ConvertToXml\(file\.OpenReadStream\(\), fileExtension\);
// Process the XML output \(e\.g\., save to a database, apply XSLT\)
Console\.WriteLine\(</span>"Generated XML output for {file.FileName}. Root element: {xmlOutput.Root?.Name}");

            // Return the converted XML to the user
            return File(Encoding.UTF8.GetBytes(xmlOutput.ToString()), "application/xml", "converted_data.xml");
        }
        catch (NotSupportedException ex)
        {
            return BadRequest(ex.Message);
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error during conversion: {ex.Message}");
        }
    }
}
```
ğŸ§ª Senaryo 3: Bir veri dÃ¶nÃ¼ÅŸtÃ¼rme servisi farklÄ± formatlarÄ± XML'e Ã§evirir. KullanÄ±cÄ±lar kaynak dosyalarÄ±nÄ± yÃ¼kleyerek dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi baÅŸlatÄ±r. Sistem XML Ã§Ä±ktÄ±sÄ±nÄ± oluÅŸturur ve iÅŸler. DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ veriler kullanÄ±cÄ±ya sunulur.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify, send_file
import xml.etree.ElementTree as ET
import io
import json

app = Flask(__name__)

def convert_to_xml(source_stream, file_extension):
    # Simplified converter function
    if file_extension.lower() in ['.txt', '.csv']:
        content = source_stream.read().decode('utf-8')
        root = ET.Element("Root")
        ET.SubElement(root, "OriginalFileName").text = "uploaded_file" + file_extension
        ET.SubElement(root, "ConvertedContent").text = content
        return ET.ElementTree(root)
    elif file_extension.lower() == '.json':
        json_content = source_stream.read().decode('utf-8')
        try:
            data = json.loads(json_content)
            root = ET.Element("Root")
            ET.SubElement(root, "OriginalFileName").text = "uploaded_file" + file_extension
            # Simple conversion of JSON dict to XML elements
            for key, value in data.items():
                if isinstance(value, (str, int, float, bool)):
                    ET.SubElement(root, key).text = str(value)
                elif isinstance(value, list):
                    list_elem = ET.SubElement(root, key)
                    for item in value:
                        ET.SubElement(list_elem, "Item").text = str(item)
                elif isinstance(value, dict):
                    dict_elem = ET.SubElement(root, key)
                    for sub_key, sub_value in value.items():
                         ET.SubElement(dict_elem, sub_key).text = str(sub_value)
            return ET.ElementTree(root)
        except json.JSONDecodeError:
            raise ValueError("Invalid JSON content.")
    else:
        raise ValueError(f"File type {file_extension} is not supported for conversion.")

@app.route('/api/convert', methods=['POST'])
def convert_data():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    try:
        file_extension = os.path.splitext(file.filename)[1]
        xml_tree = convert_to_xml(file.stream, file_extension)

        # Process the XML output (e.g., save, further transform)
        print(f"Generated XML output for {file.filename}.")

        xml_output_bytes = ET.tostring(xml_tree.getroot(), encoding='utf-8', xml_declaration=True)
        return send_file(
            io.BytesIO(xml_output_bytes),
            mimetype='application/xml',
            as_attachment=True,
            download_name='converted_data.xml'
        )
    except ValueError as e:
        return jsonify({"error": str(e)}), 400
    except Exception as e:
        return jsonify({"error": f"Internal server error during conversion: {e}"}), 500

if __name__ == '__main__':
    app.run(debug=True)
```
ğŸ§ª Senaryo 3: Bir veri dÃ¶nÃ¼ÅŸtÃ¼rme servisi farklÄ± formatlarÄ± XML'e Ã§evirir. KullanÄ±cÄ±lar kaynak dosyalarÄ±nÄ± yÃ¼kleyerek dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi baÅŸlatÄ±r. Sistem XML Ã§Ä±ktÄ±sÄ±nÄ± oluÅŸturur ve iÅŸler. DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ veriler kullanÄ±cÄ±ya sunulur.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import { Builder } from 'xmlbuilder2';
import fs from 'fs';
import path from 'path';

const app = express();
const upload = multer({ dest: 'uploads/' });

function convertToXml(filePath: string, fileExtension: string): string {
    let xmlContent: any; // Use 'any' for now to hold the intermediate structure

    switch (fileExtension.toLowerCase()) {
        case '.txt':
        case '.csv':
            const textContent = fs.readFileSync(filePath, 'utf8');
            xmlContent = Builder.create({ encoding: 'UTF-8' })
                .ele('Root')
                    .ele('OriginalFileName').txt(path.basename(filePath)).up()
                    .ele('ConvertedContent').txt(textContent).up()
                .end();
            break;
        case '.json':
            const jsonString = fs.readFileSync(filePath, 'utf8');
            try {
                const jsonData = JSON.parse(jsonString);
                // Simple conversion from JSON to XML. More complex structures need recursive handling.
                xmlContent = Builder.create({ encoding: 'UTF-8' })
                    .ele('Root')
                        .ele('OriginalFileName').txt(path.basename(filePath)).up()
                        .ele('JsonData');
                // Iterate over JSON properties and add them as XML elements
                for (const key in jsonData) {
                    if (Object.prototype.hasOwnProperty.call(jsonData, key)) {
                        const value = jsonData[key];
                        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                            // For nested objects, create sub-elements
                            const subEl = xmlContent.ele(key);
                            for (const subKey in value) {
                                if (Object.prototype.hasOwnProperty.call(value, subKey)) {
                                    subEl.ele(subKey).txt(String(value[subKey])).up();
                                }
                            }
                            subEl.up();
                        } else if (Array.isArray(value)) {
                            const arrEl = xmlContent.ele(key);
                            value.forEach(item => {
                                arrEl.ele('Item').txt(String(item)).up();
                            });
                            arrEl.up();
                        }
                        else {
                            xmlContent.ele(key).txt(String(value)).up();
                        }
                    }
                }
                xmlContent = xmlContent.end();
            } catch (error) {
                throw new Error("Invalid JSON content.");
            }
            break;
        default:
            throw new Error(`File type ${fileExtension} is not supported for conversion.`);
    }
    return xmlContent;
}

app.post('/api/convert', upload.single('sourceFile'), async (req, res) => {
    if (!req.file) {
        return res.status(400).send('Please upload a file to convert.');
    }

    try {
        const fileExtension = path.extname(req.file.originalname);
        const xmlOutput = convertToXml(req.file.path, fileExtension);

        console.log(`Generated XML output for ${req.file.originalname}.`);

        // Clean up the uploaded file
        fs.unlinkSync(req.file.path);

        res.header('Content-Type', 'application/xml');
        res.attachment('converted_data.xml');
        res.send(xmlOutput);
    } catch (error: any) {
        if (req.file) {
            fs.unlinkSync(req.file.path);
        }
        res.status(500).send(`Internal server error: ${error.message}`);
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```
ğŸ§ª Senaryo 4: Bir raporlama aracÄ±nda ÅŸablon dosyalarÄ± XML formatÄ±nda saklanÄ±r. KullanÄ±cÄ±lar Ã¶zel ÅŸablonlar oluÅŸturarak sisteme yÃ¼kleyebilir. Rapor Ã¼retimi sÄ±rasÄ±nda XML ÅŸablonlarÄ± iÅŸlenir. OluÅŸturulan raporlar ÅŸablon yapÄ±sÄ±na gÃ¶re formatlanÄ±r.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

```csharp

using System.Xml.Linq;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using System.Collections.Generic;

// Dummy ReportTemplate class
public class ReportTemplate
{
    public string TemplateName { get; set; }
    public XDocument TemplateContent { get; set; }
    // In a real app, this would be stored in a database
    private static readonly Dictionary<string, ReportTemplate> _templates = new Dictionary<string, ReportTemplate>();

    public static void SaveTemplate(ReportTemplate template)
    {
        _templates[template.TemplateName] = template;
        Console.WriteLine(<span class="math-inline">"Template '\{template\.TemplateName\}' saved\."\);
\}
public static ReportTemplate GetTemplate\(string name\)
\{
\_templates\.TryGetValue\(name, out var template\);
return template;
\}
\}
\[ApiController\]
\[Route\("api/\[controller\]"\)\]
public class ReportController \: ControllerBase
\{
\[HttpPost\("upload\-template"\)\]
public async Task<IActionResult\> UploadTemplate\(IFormFile file, \[FromQuery\] string templateName\)
\{
if \(file \=\= null \|\| file\.Length \=\= 0\)
return BadRequest\("Upload a valid XML template file\."\);
if \(string\.IsNullOrEmpty\(templateName\)\)
return BadRequest\("Template name is required\."\);
try
\{
using \(var stream \= file\.OpenReadStream\(\)\)
\{
XDocument doc \= XDocument\.Load\(stream\);
ReportTemplate\.SaveTemplate\(new ReportTemplate \{ TemplateName \= templateName, TemplateContent \= doc \}\);
return Ok\(</span>"Report template '{templateName}' uploaded successfully.");
            }
        }
        catch (Exception ex)
        {
            return StatusCode(500, <span class="math-inline">"Internal server error\: \{ex\.Message\}"\);
\}
\}
\[HttpGet\("generate\-report"\)\]
public IActionResult GenerateReport\(\[FromQuery\] string templateName\)
\{
ReportTemplate template \= ReportTemplate\.GetTemplate\(templateName\);
if \(template \=\= null\)
return NotFound\(</span>"Template '{templateName}' not found.");

        // In a real scenario, you would combine the template with actual data
        // For demonstration, we'll just return a simplified XML report structure
        XDocument report = new XDocument(
            new XElement("Report",
                new XElement("Title", <span class="math-inline">"Report generated using \{template\.TemplateName\}"\),
new XElement\("GeneratedDate", DateTime\.Now\.ToString\("yyyy\-MM\-dd HH\:mm\:ss"\)\),
new XComment\("This would contain actual data formatted by the template"\),
template\.TemplateContent\.Root \!\= null ? new XElement\("TemplateStructureExample", template\.TemplateContent\.Root\.Elements\(\)\) \: null
\)
\);
Console\.WriteLine\(</span>"Report generated using template '{templateName}'.");
        return File(System.Text.Encoding.UTF8.GetBytes(report.ToString()), "application/xml", $"report_{templateName}.xml");
    }
}
```
ğŸ§ª Senaryo 4: Bir raporlama aracÄ±nda ÅŸablon dosyalarÄ± XML formatÄ±nda saklanÄ±r. KullanÄ±cÄ±lar Ã¶zel ÅŸablonlar oluÅŸturarak sisteme yÃ¼kleyebilir. Rapor Ã¼retimi sÄ±rasÄ±nda XML ÅŸablonlarÄ± iÅŸlenir. OluÅŸturulan raporlar ÅŸablon yapÄ±sÄ±na gÃ¶re formatlanÄ±r.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify, send_file
import xml.etree.ElementTree as ET
import io
from datetime import datetime

app = Flask(__name__)

# In-memory store for report templates
report_templates = {}

@app.route('/api/report/upload-template', methods=['POST'])
def upload_template():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    template_name = request.args.get('templateName')

    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    if not template_name:
        return jsonify({"error": "Template name is required."}), 400

    if file and file.filename.endswith('.xml'):
        try:
            xml_content = file.read()
            ET.fromstring(xml_content) # Validate XML
            report_templates[template_name] = xml_content.decode('utf-8')
            print(f"Report template '{template_name}' uploaded successfully.")
            return jsonify({"message": f"Template '{template_name}' uploaded successfully."}), 200
        except ET.ParseError as e:
            return jsonify({"error": f"Invalid XML file: {e}"}), 400
        except Exception as e:
            return jsonify({"error": f"Internal server error: {e}"}), 500
    return jsonify({"error": "Invalid file type. Only XML allowed."}), 400

@app.route('/api/report/generate', methods=['GET'])
def generate_report():
    template_name = request.args.get('templateName')
    if not template_name:
        return jsonify({"error": "Template name is required."}), 400

    template_content = report_templates.get(template_name)
    if not template_content:
        return jsonify({"error": f"Template '{template_name}' not found."}), 404

    try:
        template_root = ET.fromstring(template_content)

        # Create a new XML for the report, incorporating template structure
        report_root = ET.Element("Report")
        ET.SubElement(report_root, "Title").text = f"Report generated using {template_name}"
        ET.SubElement(report_root, "GeneratedDate").text = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Include template structure as an example (in a real app, data would be merged)
        template_structure_example = ET.SubElement(report_root, "TemplateStructureExample")
        # Copy elements from the template root to the report
        for child in template_root:
            template_structure_example.append(child)

        xml_output_bytes = ET.tostring(report_root, encoding='utf-8', xml_declaration=True)

        print(f"Report generated using template '{template_name}'.")
        return send_file(
            io.BytesIO(xml_output_bytes),
            mimetype='application/xml',
            as_attachment=True,
            download_name=f'report_{template_name}.xml'
        )
    except Exception as e:
        return jsonify({"error": f"Error generating report: {e}"}), 500

if __name__ == '__main__':
    app.run(debug=True)
```
ğŸ§ª Senaryo 4: Bir raporlama aracÄ±nda ÅŸablon dosyalarÄ± XML formatÄ±nda saklanÄ±r. KullanÄ±cÄ±lar Ã¶zel ÅŸablonlar oluÅŸturarak sisteme yÃ¼kleyebilir. Rapor Ã¼retimi sÄ±rasÄ±nda XML ÅŸablonlarÄ± iÅŸlenir. OluÅŸturulan raporlar ÅŸablon yapÄ±sÄ±na gÃ¶re formatlanÄ±r.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import { XMLParser, XMLBuilder } from 'fast-xml-parser';
import fs from 'fs';
import path from 'path';

const app = express();
const upload = multer({ dest: 'uploads/' });

// In-memory store for report templates
interface ReportTemplate {
    name: string;
    content: string; // Storing as raw XML string
}
const reportTemplates: Map<string, ReportTemplate> = new Map();

app.post('/api/report/upload-template', upload.single('templateFile'), async (req, res) => {
    if (!req.file) {
        return res.status(400).send('Please upload an XML template file.');
    }
    const templateName = req.query.templateName as string;
    if (!templateName) {
        return res.status(400).send('Template name is required.');
    }

    try {
        const filePath = req.file.path;
        const xmlContent = fs.readFileSync(filePath, 'utf8');

        // Basic XML validation
        const parser = new XMLParser();
        parser.parse(xmlContent);

        reportTemplates.set(templateName, { name: templateName, content: xmlContent });
        fs.unlinkSync(filePath); // Clean up temp file

        res.status(200).send(`Report template '${templateName}' uploaded successfully.`);
    } catch (error: any) {
        if (req.file) {
            fs.unlinkSync(req.file.path);
        }
        if (error.message.includes("Non-whitespace characters are not allowed")) {
            return res.status(400).send('Invalid XML file content.');
        }
        res.status(500).send(`Internal server error: ${error.message}`);
    }
});

app.get('/api/report/generate', (req, res) => {
    const templateName = req.query.templateName as string;
    if (!templateName) {
        return res.status(400).send('Template name is required.');
    }

    const template = reportTemplates.get(templateName);
    if (!template) {
        return res.status(404).send(`Template '${templateName}' not found.`);
    }

    try {
        const options = {
            ignoreAttributes: false,
            attributeNamePrefix : "@_",
            format: true
        };
        const builder = new XMLBuilder(options);
        const parser = new XMLParser(options);
        const parsedTemplate = parser.parse(template.content);

        // Construct the report XML
        const reportRoot = {
            Report: {
                Title: `Report generated using ${template.name}`,
                GeneratedDate: new Date().toISOString(),
                // In a real application, you would merge actual data here
                TemplateStructureExample: parsedTemplate // Include the parsed template structure
            }
        };

        const reportXml = builder.build(reportRoot);

        console.log(`Report generated using template '${templateName}'.`);
        res.header('Content-Type', 'application/xml');
        res.attachment(`report_${templateName}.xml`);
        res.send(reportXml);
    } catch (error: any) {
        res.status(500).send(`Error generating report: ${error.message}`);
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```
ğŸ§ª Senaryo 5: Bir API entegrasyon platformu XML tabanlÄ± mesajlar alÄ±r. Ä°stemci uygulamalar XML formatÄ±nda veri gÃ¶nderir. Platform bu verileri iÅŸleyerek iÅŸ mantÄ±ÄŸÄ±nÄ± yÃ¼rÃ¼tÃ¼r. YanÄ±t mesajlarÄ± yine XML formatÄ±nda dÃ¶nÃ¼lÃ¼r.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

```csharp

using System.Xml.Linq;
using Microsoft.AspNetCore.Mvc;
using System.IO;
using System.Text;
using System.Threading.Tasks;

[ApiController]
[Route("api/[controller]")]
public class IntegrationController : ControllerBase
{
    [HttpPost("process-message")]
    [Consumes("application/xml")] // Expect XML content type
    public async Task<IActionResult> ProcessXmlMessage()
    {
        try
        {
            // Read the incoming XML from the request body
            using (StreamReader reader = new StreamReader(Request.Body, Encoding.UTF8))
            {
                string xmlString = await reader.ReadToEndAsync();
                XDocument receivedXml = XDocument.Parse(xmlString);

                // Log received message for demonstration
                Console.WriteLine(<span class="math-inline">"Received XML message with root\: \{receivedXml\.Root?\.Name\}"\);
Console\.WriteLine\(</span>"Message content: {receivedXml.ToString(SaveOptions.DisableFormatting)}");

                // --- Business Logic Simulation ---
                // Example: Check for a specific element and modify response
                XElement requestTypeElement = receivedXml.Root?.Element("RequestType");
                string requestType = requestTypeElement?.Value ?? "Unknown";

                XDocument responseXml = new XDocument(
                    new XElement("Response",
                        new XElement("Status", "Success"),
                        new XElement("ProcessedRequestType", requestType),
                        new XElement("Timestamp", DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss"))
                    )
                );

                if (requestType == "Order")
                {
                    responseXml.Root.Add(new XElement("Message", "Order successfully processed."));
                    // Further processing for orders...
                }
                else
                {
                    responseXml.Root.Add(new XElement("Message", "Request processed."));
                }
                // --- End Business Logic Simulation ---

                // Return the XML response
                return Content(responseXml.ToString(), "application/xml");
            }
        }
        catch (System.Xml.XmlException ex)
        {
            return BadRequest($"Invalid XML format: {ex.Message}");
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}
```
ğŸ§ª Senaryo 5: Bir API entegrasyon platformu XML tabanlÄ± mesajlar alÄ±r. Ä°stemci uygulamalar XML formatÄ±nda veri gÃ¶nderir. Platform bu verileri iÅŸleyerek iÅŸ mantÄ±ÄŸÄ±nÄ± yÃ¼rÃ¼tÃ¼r. YanÄ±t mesajlarÄ± yine XML formatÄ±nda dÃ¶nÃ¼lÃ¼r.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, Response, jsonify
import xml.etree.ElementTree as ET
from datetime import datetime
import io

app = Flask(__name__)

@app.route('/api/integration/process-message', methods=['POST'])
def process_xml_message():
    if request.content_type != 'application/xml':
        return jsonify({"error": "Content-Type must be application/xml"}), 415

    try:
        xml_data = request.data
        received_xml_root = ET.fromstring(xml_data)

        # Log received message
        print(f"Received XML message with root tag: {received_xml_root.tag}")
        print(f"Message content: {xml_data.decode('utf-8')}")

        # --- Business Logic Simulation ---
        request_type_element = received_xml_root.find('RequestType')
        request_type = request_type_element.text if request_type_element is not None else "Unknown"

        response_root = ET.Element("Response")
        ET.SubElement(response_root, "Status").text = "Success"
        ET.SubElement(response_root, "ProcessedRequestType").text = request_type
        ET.SubElement(response_root, "Timestamp").text = datetime.now().isoformat()

        if request_type == "Order":
            ET.SubElement(response_root, "Message").text = "Order successfully processed."
            # Further processing for orders...
        else:
            ET.SubElement(response_root, "Message").text = "Request processed."
        # --- End Business Logic Simulation ---

        xml_output_bytes = ET.tostring(response_root, encoding='utf-8', xml_declaration=True)
        return Response(xml_output_bytes, mimetype='application/xml')

    except ET.ParseError as e:
        return jsonify({"error": f"Invalid XML format: {e}"}), 400
    except Exception as e:
        return jsonify({"error": f"Internal server error: {e}"}), 500

if __name__ == '__main__':
    app.run(debug=True)
```
ğŸ§ª Senaryo 5: Bir API entegrasyon platformu XML tabanlÄ± mesajlar alÄ±r. Ä°stemci uygulamalar XML formatÄ±nda veri gÃ¶nderir. Platform bu verileri iÅŸleyerek iÅŸ mantÄ±ÄŸÄ±nÄ± yÃ¼rÃ¼tÃ¼r. YanÄ±t mesajlarÄ± yine XML formatÄ±nda dÃ¶nÃ¼lÃ¼r.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import { XMLParser, XMLBuilder } from 'fast-xml-parser';

const app = express();
app.use(express.text({ type: 'application/xml' })); // Middleware to parse XML as text

const options = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_",
    format: true // For pretty printing output XML
};
const parser = new XMLParser(options);
const builder = new XMLBuilder(options);

app.post('/api/integration/process-message', (req, res) => {
    if (req.headers['content-type'] !== 'application/xml') {
        return res.status(415).send('Content-Type must be application/xml');
    }

    try {
        const xmlString = req.body;
        const receivedJson = parser.parse(xmlString);

        console.log("Received XML message (parsed to JSON):", JSON.stringify(receivedJson, null, 2));

        // --- Business Logic Simulation ---
        const requestType = receivedJson?.Request?.RequestType || "Unknown"; // Assuming <Request><RequestType>

        let responseJson: any = {
            Response: {
                Status: "Success",
                ProcessedRequestType: requestType,
                Timestamp: new Date().toISOString()
            }
        };

        if (requestType === "Order") {
            responseJson.Response.Message = "Order successfully processed.";
            // Further processing for orders...
        } else {
            responseJson.Response.Message = "Request processed.";
        }
        // --- End Business Logic Simulation ---

        const responseXml = builder.build(responseJson);

        res.header('Content-Type', 'application/xml');
        res.status(200).send(responseXml);

    } catch (error: any) {
        if (error.message.includes("Non-whitespace characters are not allowed") || error.message.includes("Unclosed tag")) {
            return res.status(400).send(`Invalid XML format: ${error.message}`);
        }
        res.status(500).send(`Internal server error: ${error.message}`);
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```
ğŸ§ª Senaryo 6: Bir iÃ§erik editÃ¶rÃ¼ XML tabanlÄ± belgeleri dÃ¼zenler. KullanÄ±cÄ±lar yapÄ±landÄ±rÄ±lmÄ±ÅŸ belgeler oluÅŸturabilir. EditÃ¶r XML iÃ§eriÄŸini analiz ederek gÃ¶rsel arayÃ¼z sunar. Belge yapÄ±sÄ± XML ÅŸemasÄ±na gÃ¶re korunur.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

```csharp

using System.Xml.Linq;
using System.Xml.Schema;
using System.IO;
using Microsoft.AspNetCore.Mvc;

// Simulate a document repository (in-memory for this example)
public static class DocumentStore
{
    private static readonly Dictionary<string, XDocument> _documents = new Dictionary<string, XDocument>();
    private static XmlSchemaSet _schemas = new XmlSchemaSet();

    public static void LoadSchema(string schemaPath)
    {
        using (var stream = File.OpenRead(schemaPath))
        {
            _schemas.Add(null, XmlReader.Create(stream));
        }
        Console.WriteLine(<span class="math-inline">"XML Schema loaded from \{schemaPath\}"\);
\}
public static bool ValidateDocument\(XDocument doc\)
\{
bool isValid \= true;
doc\.Validate\(\_schemas, \(sender, args\) \=\>
\{
Console\.WriteLine\(</span>"XML Validation Error: {args.Message}");
            isValid = false;
        });
        return isValid;
    }

    public static void SaveDocument(string docId, XDocument doc)
    {
        if (ValidateDocument(doc))
        {
            _documents[docId] = doc;
            Console.WriteLine(<span class="math-inline">"Document '\{docId\}' saved successfully and is valid\."\);
\}
else
\{
throw new InvalidOperationException\(</span>"Document '{docId}' failed schema validation and was not saved.");
        }
    }

    public static XDocument GetDocument(string docId)
    {
        _documents.TryGetValue(docId, out var doc);
        return doc;
    }
}

[ApiController]
[Route("api/[controller]")]
public class ContentEditorController : ControllerBase
{
    public ContentEditorController()
    {
        // Load a dummy schema on startup (adjust path as needed)
        // For a real application, schema management would be more robust.
        // Ensure you have a dummy_schema.xsd file in a reachable location.
        // For local testing, you might put it in the project root or similar.
        // Example: DocumentStore.LoadSchema("dummy_schema.xsd");
        // For this example, let's assume a schema for <Article><Title/><Content/></Article>
        string dummySchema = @"<?xml version=""1.0"" encoding=""utf-8""?>
            <xs:schema xmlns:xs=""[http://www.w3.org/2001/XMLSchema](http://www.w3.org/2001/XMLSchema)"">
                <xs:element name=""Article"">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name=""Title"" type=""xs:string""/>
                            <xs:element name=""Content"" type=""xs:string""/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:schema>";
        using (var reader = new StringReader(dummySchema))
        {
            DocumentStore._schemas.Add(null, XmlReader.Create(reader));
        }
        Console.WriteLine("Dummy XML Schema loaded in-memory.");
    }

    [HttpPost("save-document")]
    [Consumes("application/xml")]
    public async Task<IActionResult> SaveDocument([FromQuery] string documentId)
    {
        if (string.IsNullOrEmpty(documentId))
            return BadRequest("Document ID is required.");

        try
        {
            using (StreamReader reader = new StreamReader(Request.Body, Encoding.UTF8))
            {
                string xmlString = await reader.ReadToEndAsync();
                XDocument doc = XDocument.Parse(xmlString);

                // This is where the editor would analyze and present the UI
                Console.WriteLine(<span class="math-inline">"Analyzing XML for document '\{documentId\}'\. Root element\: \{doc\.Root?\.Name\}"\);
DocumentStore\.SaveDocument\(documentId, doc\); // This includes validation
return Ok\(</span>"Document '{documentId}' saved and validated successfully.");
            }
        }
        catch (System.Xml.XmlException ex)
        {
            return BadRequest($"Invalid XML format: {ex.Message}");
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(ex.Message); // Validation error
        }
        catch (Exception ex)
        {
            return StatusCode(500, <span class="math-inline">"Internal server error\: \{ex\.Message\}"\);
\}
\}
\[HttpGet\("get\-document"\)\]
public IActionResult GetDocument\(\[FromQuery\] string documentId\)
\{
XDocument doc \= DocumentStore\.GetDocument\(documentId\);
if \(doc \=\= null\)
return NotFound\(</span>"Document '{documentId}' not found.");

        return Content(doc.ToString(), "application/xml");
    }
}
```
ğŸ§ª Senaryo 6: Bir iÃ§erik editÃ¶rÃ¼ XML tabanlÄ± belgeleri dÃ¼zenler. KullanÄ±cÄ±lar yapÄ±landÄ±rÄ±lmÄ±ÅŸ belgeler oluÅŸturabilir. EditÃ¶r XML iÃ§eriÄŸini analiz ederek gÃ¶rsel arayÃ¼z sunar. Belge yapÄ±sÄ± XML ÅŸemasÄ±na gÃ¶re korunur.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, Response, jsonify
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import XMLSchema, parse, XMLParser
from io import StringIO
import os

app = Flask(__name__)

# In-memory store for documents and schema
document_store = {}
xml_schema = None # Will hold the XMLSchema object

# Dummy schema for demonstration
DUMMY_SCHEMA_CONTENT = """<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="[http://www.w3.org/2001/XMLSchema](http://www.w3.org/2001/XMLSchema)">
    <xs:element name="Article">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Title" type="xs:string"/>
                <xs:element name="Content" type="xs:string"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>
"""

# Load schema on startup
try:
    schema_root = ET.fromstring(DUMMY_SCHEMA_CONTENT)
    xml_schema = XMLSchema(schema_root)
    print("Dummy XML Schema loaded in-memory.")
except Exception as e:
    print(f"Error loading dummy XML schema: {e}")

def validate_xml_with_schema(xml_content):
    if xml_schema is None:
        raise RuntimeError("XML schema not loaded.")
    try:
        # Use a custom parser to validate during parsing
        parser = XMLParser(schema=xml_schema)
        ET.fromstring(xml_content, parser=parser)
        return True, "Validation successful."
    except Exception as e:
        return False, f"XML validation error: {e}"

@app.route('/api/content/save-document', methods=['POST'])
def save_document():
    document_id = request.args.get('documentId')
    if not document_id:
        return jsonify({"error": "Document ID is required."}), 400

    if request.content_type != 'application/xml':
        return jsonify({"error": "Content-Type must be application/xml"}), 415

    try:
        xml_data = request.data.decode('utf-8')
        
        # Analyze XML content (simulated for UI)
        root = ET.fromstring(xml_data)
        print(f"Analyzing XML for document '{document_id}'. Root element: {root.tag}")

        # Validate against schema
        is_valid, validation_msg = validate_xml_with_schema(xml_data)
        if not is_valid:
            return jsonify({"error": f"Document failed schema validation: {validation_msg}"}), 400

        document_store[document_id] = xml_data
        print(f"Document '{document_id}' saved and validated successfully.")
        return jsonify({"message": f"Document '{document_id}' saved and validated successfully."}), 200

    except ET.ParseError as e:
        return jsonify({"error": f"Invalid XML format: {e}"}), 400
    except RuntimeError as e:
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": f"Internal server error: {e}"}), 500

@app.route('/api/content/get-document', methods=['GET'])
def get_document():
    document_id = request.args.get('documentId')
    if not document_id:
        return jsonify({"error": "Document ID is required."}), 400

    document_content = document_store.get(document_id)
    if document_content is None:
        return jsonify({"error": f"Document '{document_id}' not found."}), 404

    return Response(document_content, mimetype='application/xml')

if __name__ == '__main__':
    app.run(debug=True)
```
ğŸ§ª Senaryo 6: Bir iÃ§erik editÃ¶rÃ¼ XML tabanlÄ± belgeleri dÃ¼zenler. KullanÄ±cÄ±lar yapÄ±landÄ±rÄ±lmÄ±ÅŸ belgeler oluÅŸturabilir. EditÃ¶r XML iÃ§eriÄŸini analiz ederek gÃ¶rsel arayÃ¼z sunar. Belge yapÄ±sÄ± XML ÅŸemasÄ±na gÃ¶re korunur.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import { XMLParser, XMLBuilder } from 'fast-xml-parser';
// For XML schema validation in Node.js, a dedicated library like 'libxmljs' or 'xml-schema-validator' is needed.
// For simplicity in this example, we'll simulate basic schema-like checks or use a very basic validator if available.
// NOTE: Native Node.js does not have a built-in XML Schema validator.
// You would typically use a WASM compiled libxml2 or a separate service for robust validation.
import { DOMParser } from '@xmldom/xmldom'; // For DOM manipulation if needed, not direct schema validation
// import { XmlSchemaValidator } from 'xml-schema-validator'; // Example of a potential library

const app = express();
app.use(express.text({ type: 'application/xml' }));

const parserOptions = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_",
};
const parser = new XMLParser(parserOptions);
const builder = new XMLBuilder(parserOptions);

// In-memory store for documents
const documentStore: Map<string, string> = new Map();

// Dummy XML Schema content (for conceptual validation, not actual enforcement here)
const DUMMY_SCHEMA_CONTENT = `<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="[http://www.w3.org/2001/XMLSchema](http://www.w3.org/2001/XMLSchema)">
    <xs:element name="Article">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Title" type="xs:string"/>
                <xs:element name="Content" type="xs:string"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>`;

// A very basic simulated validation function
function simulateSchemaValidation(xmlString: string): { isValid: boolean, message?: string } {
    try {
        const parsed = parser.parse(xmlString);
        // This is a superficial check. A real validator would parse against the DUMMY_SCHEMA_CONTENT.
        if (!parsed.Article || !parsed.Article.Title || !parsed.Article.Content) {
            return { isValid: false, message: "Document does not conform to expected Article schema (missing Title or Content)." };
        }
        return { isValid: true };
    } catch (error: any) {
        return { isValid: false, message: `XML parsing error during simulated validation: ${error.message}` };
    }
}

app.post('/api/content/save-document', (req, res) => {
    const documentId = req.query.documentId as string;
    if (!documentId) {
        return res.status(400).send('Document ID is required.');
    }
    if (req.headers['content-type'] !== 'application/xml') {
        return res.status(415).send('Content-Type must be application/xml');
    }

    try {
        const xmlString = req.body;

        // Simulate editor analyzing XML for UI presentation
        const parsedXml = parser.parse(xmlString);
        console.log(`Analyzing XML for document '${documentId}'. Root element: ${Object.keys(parsedXml)[0]}`);

        // Validate document structure against schema (simulated)
        const validationResult = simulateSchemaValidation(xmlString);
        if (!validationResult.isValid) {
            return res.status(400).send(`Document failed schema validation: ${validationResult.message}`);
        }

        documentStore.set(documentId, xmlString);
        res.status(200).send(`Document '${documentId}' saved and validated successfully.`);

    } catch (error: any) {
        res.status(500).send(`Internal server error: ${error.message}`);
    }
});

app.get('/api/content/get-document', (req, res) => {
    const documentId = req.query.documentId as string;
    if (!documentId) {
        return res.status(400).send('Document ID is required.');
    }

    const documentContent = documentStore.get(documentId);
    if (!documentContent) {
        return res.status(404).send(`Document '${documentId}' not found.`);
    }

    res.header('Content-Type', 'application/xml');
    res.status(200).send(documentContent);
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```
ğŸ§ª Senaryo 7: Bir veri aktarÄ±m sistemi XML formatÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. FarklÄ± sistemler arasÄ± veri transferi XML ile gerÃ§ekleÅŸir. AktarÄ±m sÄ±rasÄ±nda veriler iÅŸlenip hedefe yÃ¶nlendirilir. XML yapÄ±sÄ± veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ korur.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

```csharp

using System.Xml.Linq;
using Microsoft.AspNetCore.Mvc;
using System.IO;
using System.Text;
using System.Threading.Tasks;

// Simulate a destination system
public static class DestinationSystem
{
    public static void ReceiveAndProcessData(XDocument data)
    {
        Console.WriteLine(<span class="math-inline">"Destination System received data\. Root\: \{data\.Root?\.Name\}"\);
// In a real scenario, this would involve saving to DB, triggering events, etc\.
var recordCount \= data\.Descendants\("Record"\)\.Count\(\);
Console\.WriteLine\(</span>"Processing {recordCount} records.");
        // Example: If data has a specific structure like <Batch><Record>...</Record></Batch>
        foreach (var record in data.Descendants("Record"))
        {
            Console.WriteLine(<span class="math-inline">"  Processing record ID\: \{record\.Element\("Id"\)?\.Value\}"\);
// Simulate saving or processing each record
\}
Console\.WriteLine\("Data processed by Destination System\."\);
\}
\}
\[ApiController\]
\[Route\("api/\[controller\]"\)\]
public class DataTransferController \: ControllerBase
\{
\[HttpPost\("transfer\-data"\)\]
\[Consumes\("application/xml"\)\]
public async Task<IActionResult\> TransferData\(\)
\{
try
\{
using \(StreamReader reader \= new StreamReader\(Request\.Body, Encoding\.UTF8\)\)
\{
string xmlString \= await reader\.ReadToEndAsync\(\);
XDocument dataToTransfer \= XDocument\.Parse\(xmlString\);
Console\.WriteLine\(</span>"Data Transfer System received XML for transfer. Root: {dataToTransfer.Root?.Name}");

                // --- Data Processing and Routing Simulation ---
                // Example: Modify data before sending, or route based on content
                XElement header = dataToTransfer.Root?.Element("Header");
                if (header != null)
                {
                    header.Add(new XElement("ProcessedByTransferSystem", DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss")));
                }
                else if (dataToTransfer.Root != null)
                {
                     dataToTransfer.Root.AddFirst(new XElement("Header", new XElement("ProcessedByTransferSystem", DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss"))));
                }

                // Route data to the destination system
                DestinationSystem.ReceiveAndProcessData(dataToTransfer);
                // --- End Data Processing and Routing Simulation ---

                return Ok("Data transferred and processed by destination system successfully.");
            }
        }
        catch (System.Xml.XmlException ex)
        {
            return BadRequest($"Invalid XML data received: {ex.Message}");
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error during data transfer: {ex.Message}");
        }
    }
}
```
ğŸ§ª Senaryo 7: Bir veri aktarÄ±m sistemi XML formatÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. FarklÄ± sistemler arasÄ± veri transferi XML ile gerÃ§ekleÅŸir. AktarÄ±m sÄ±rasÄ±nda veriler iÅŸlenip hedefe yÃ¶nlendirilir. XML yapÄ±sÄ± veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ korur.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify, Response
import xml.etree.ElementTree as ET
from datetime import datetime
import requests # For simulating sending data to another system

app = Flask(__name__)

# Simulate a destination system endpoint
DESTINATION_SYSTEM_URL = "http://localhost:5001/api/destination/receive-data"

@app.route('/api/transfer/data', methods=['POST'])
def transfer_data():
    if request.content_type != 'application/xml':
        return jsonify({"error": "Content-Type must be application/xml"}), 415

    try:
        xml_data = request.data.decode('utf-8')
        received_xml_root = ET.fromstring(xml_data)

        print(f"Data Transfer System received XML for transfer. Root: {received_xml_root.tag}")

        # --- Data Processing and Routing Simulation ---
        # Example: Add a processing timestamp or route based on a 'Type' element
        header_element = received_xml_root.find('Header')
        if header_element is None:
            header_element = ET.SubElement(received_xml_root, 'Header')
        
        processed_by_transfer_system = header_element.find('ProcessedByTransferSystem')
        if processed_by_transfer_system is None:
            ET.SubElement(header_element, "ProcessedByTransferSystem").text = datetime.now().isoformat()
        else:
            processed_by_transfer_system.text = datetime.now().isoformat()
        
        # Determine target based on content (e.g., if there's a <TargetSystem> tag)
        target_system_element = received_xml_root.find('TargetSystem')
        target_url = DESTINATION_SYSTEM_URL
        if target_system_element is not None and target_system_element.text:
            # In a real system, you'd look up actual URLs based on a system ID
            print(f"Routing data to specified target: {target_system_element.text}")
            # For simplicity, we'll stick to our dummy URL
            # target_url = get_url_for_system(target_system_element.text)

        processed_xml_data = ET.tostring(received_xml_root, encoding='utf-8', xml_declaration=True)

        # Simulate sending data to the destination system
        print(f"Sending processed data to {target_url}")
        # response_from_destination = requests.post(target_url, data=processed_xml_data, headers={'Content-Type': 'application/xml'})
        # response_from_destination.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)

        print("Data transferred and processed by destination system (simulated) successfully.")
        return jsonify({"message": "Data transferred successfully."}), 200

    except ET.ParseError as e:
        return jsonify({"error": f"Invalid XML data received: {e}"}), 400
    # except requests.exceptions.RequestException as e:
    #     return jsonify({"error": f"Error communicating with destination system: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Internal server error during data transfer: {e}"}), 500

# Dummy destination system endpoint for testing the transfer
@app.route('/api/destination/receive-data', methods=['POST'])
def receive_data():
    if request.content_type != 'application/xml':
        return jsonify({"error": "Content-Type must be application/xml"}), 415
    try:
        data = request.data.decode('utf-8')
        root = ET.fromstring(data)
        print(f"Destination System received data. Root: {root.tag}")
        record_count = len(root.findall('.//Record')) # Example for counting records
        print(f"Destination System processing {record_count} records.")
        # Simulate saving to DB, etc.
        return jsonify({"message": "Data received and processed by destination system."}), 200
    except ET.ParseError as e:
        return jsonify({"error": f"Invalid XML received by destination system: {e}"}), 400
    except Exception as e:
        return jsonify({"error": f"Destination system internal error: {e}"}), 500

if __name__ == '__main__':
    # You would typically run the transfer and destination systems as separate processes or services
    # For a single run, comment out the `app.run` if you are using another server for destination
    app.run(debug=True, port=5000)
```
ğŸ§ª Senaryo 7: Bir veri aktarÄ±m sistemi XML formatÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. FarklÄ± sistemler arasÄ± veri transferi XML ile gerÃ§ekleÅŸir. AktarÄ±m sÄ±rasÄ±nda veriler iÅŸlenip hedefe yÃ¶nlendirilir. XML yapÄ±sÄ± veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ korur.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import { XMLParser, XMLBuilder } from 'fast-xml-parser';
import axios from 'axios'; // For making HTTP requests to other systems

const app = express();
app.use(express.text({ type: 'application/xml' }));

const parserOptions = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_",
};
const parser = new XMLParser(parserOptions);
const builder = new XMLBuilder(parserOptions);

// Simulate a destination system URL
const DESTINATION_SYSTEM_URL = 'http://localhost:3001/api/destination/receive-data';

app.post('/api/transfer/data', async (req, res) => {
    if (req.headers['content-type'] !== 'application/xml') {
        return res.status(415).send('Content-Type must be application/xml');
    }

    try {
        const xmlString = req.body;
        let receivedJson = parser.parse(xmlString);

        console.log("Data Transfer System received XML for transfer. Root:", Object.keys(receivedJson)[0]);

        // --- Data Processing and Routing Simulation ---
        // Example: Add a timestamp or modify data
        if (receivedJson.Data && typeof receivedJson.Data === 'object') {
            if (receivedJson.Data.Header) {
                receivedJson.Data.Header.ProcessedByTransferSystem = new Date().toISOString();
            } else {
                receivedJson.Data.Header = { ProcessedByTransferSystem: new Date().toISOString() };
            }
        } else {
            // If no data root, wrap in a new structure or handle differently
            receivedJson = {
                TransferData: {
                    Header: { ProcessedByTransferSystem: new Date().toISOString() },
                    OriginalContent: receivedJson // Embed original content
                }
            };
        }

        // Determine target based on content (e.g., a specific XML element)
        const targetSystem = receivedJson.Data?.TargetSystem || 'DefaultSystem'; // Assuming <Data><TargetSystem>
        let targetUrl = DESTINATION_SYSTEM_URL;
        // In a real system, you'd have a lookup for target URLs based on 'targetSystem'

        const processedXml = builder.build(receivedJson);

        // Simulate sending data to the destination system
        console.log(`Sending processed data to ${targetUrl} (for system: ${targetSystem})`);
        const destinationResponse = await axios.post(targetUrl, processedXml, {
            headers: { 'Content-Type': 'application/xml' }
        });

        console.log(`Response from destination system: ${destinationResponse.status}`);
        res.status(200).send('Data transferred and processed by destination system successfully.');

    } catch (error: any) {
        if (axios.isAxiosError(error) && error.response) {
            console.error(`Error from destination system: ${error.response.status} - ${error.response.data}`);
            return res.status(502).send(`Error from destination system: ${error.response.data}`);
        }
        res.status(500).send(`Internal server error during data transfer: ${error.message}`);
    }
});

// Dummy destination system endpoint (run this in a separate Node.js process if needed)
// For this example, it's part of the same application.
app.post('/api/destination/receive-data', (req, res) => {
    if (req.headers['content-type'] !== 'application/xml') {
        return res.status(411).send('Content-Type must be application/xml');
    }
    try {
        const receivedXmlString = req.body;
        const parsed = parser.parse(receivedXmlString);
        console.log("Destination System received and parsed data:", JSON.stringify(parsed, null, 2));
        // Perform actual processing here (e.g., save to database)
        res.status(200).send('Data received and processed by destination system.');
    } catch (error: any) {
        res.status(500).send(`Error processing data at destination: ${error.message}`);
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Data Transfer Server running on port ${PORT}`);
    // console.log(`Dummy Destination Server also running on port 3001 if started separately`);
});

// To run the destination system as a separate server for testing:
/*
const destApp = express();
destApp.use(express.text({ type: 'application/xml' }));
destApp.post('/api/destination/receive-data', (req, res) => {
    try {
        const receivedXmlString = req.body;
        const parsed = parser.parse(receivedXmlString);
        console.log("Destination System received and parsed data:", JSON.stringify(parsed, null, 2));
        res.status(200).send('Data received and processed by destination system.');
    } catch (error: any) {
        res.status(500).send(`Error processing data at destination: ${error.message}`);
    }
});
const DEST_PORT = 3001;
destApp.listen(DEST_PORT, () => {
    console.log(`Dummy Destination System running on port ${DEST_PORT}`);
});
*/
```
ğŸ§ª Senaryo 8: Bir web servisi XML tabanlÄ± istekleri karÅŸÄ±lar. Ä°stemciler SOAP protokolÃ¼ ile XML mesajlarÄ± gÃ¶nderir. Servis bu mesajlarÄ± yorumlayarak uygun iÅŸlemleri yapar. YanÄ±tlar XML formatÄ±nda structurelanÄ±r.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

```csharp

using System.Xml.Linq;
using Microsoft.AspNetCore.Mvc;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Xml; // For XmlReader, XmlWriter if needed for SOAP

[ApiController]
[Route("api/[controller]")]
public class WebServiceController : ControllerBase
{
    // A simplified SOAP-like endpoint. Full SOAP implementation often uses WCF or ASP.NET Core gRPC with SOAP integration.
    // This example focuses on receiving and responding with XML, mimicking a SOAP message structure.
    [HttpPost("soap-endpoint")]
    [Consumes("text/xml", "application/soap+xml")] // Common SOAP content types
    public async Task<IActionResult> ProcessSoapRequest()
    {
        try
        {
            using (StreamReader reader = new StreamReader(Request.Body, Encoding.UTF8))
            {
                string xmlString = await reader.ReadToEndAsync();
                XDocument soapRequest = XDocument.Parse(xmlString);

                Console.WriteLine(<span class="math-inline">"Received SOAP request\. Root\: \{soapRequest\.Root?\.Name\}"\);
Console\.WriteLine\(</span>"SOAP Body content (example): {soapRequest.Descendants(XName.Get("Body", "[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)")).FirstOrDefault()?.ToString()}");

                // --- Business Logic Simulation based on SOAP request ---
                // Find the method call within the SOAP Body (example: <GetUserInfo>)
                XElement requestMethod = soapRequest.Descendants().FirstOrDefault(e => e.Name.LocalName == "GetUserInfo");
                
                XDocument soapResponse;

                if (requestMethod != null)
                {
                    string userId = requestMethod.Element("UserId")?.Value;
                    string userName = "UnknownUser";
                    string userEmail = "unknown@example.com";

                    // Simulate fetching user data
                    if (userId == "123")
                    {
                        userName = "Alice Smith";
                        userEmail = "alice.s@example.com";
                    } else if (userId == "456") {
                        userName = "Bob Johnson";
                        userEmail = "bob.j@example.com";
                    }

                    // Construct SOAP response
                    soapResponse = new XDocument(
                        new XDeclaration("1.0", "utf-8", "yes"),
                        new XElement(XName.Get("Envelope", "[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)"),
                            new XAttribute(XNamespace.Xmlns + "soap", "[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)"),
                            new XElement(XName.Get("Body", "[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)"),
                                new XElement(XName.Get("GetUserInfoResponse", "[http://tempuri.org/](http://tempuri.org/)"), // Example namespace
                                    new XElement("UserId", userId),
                                    new XElement("UserName", userName),
                                    new XElement("UserEmail", userEmail),
                                    new XElement("Status", "Success")
                                )
                            )
                        )
                    );
                }
                else
                {
                    // Handle unsupported method or invalid request
                    soapResponse = new XDocument(
                        new XDeclaration("1.0", "utf-8", "yes"),
                        new XElement(XName.Get("Envelope", "[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)"),
                            new XAttribute(XNamespace.Xmlns + "soap", "[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)"),
                            new XElement(XName.Get("Body", "[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)"),
                                new XElement(XName.Get("Fault", "[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)"),
                                    new XElement("faultcode", "soap:Client"),
                                    new XElement("faultstring", "Unsupported request method or invalid message structure.")
                                )
                            )
                        )
                    );
                }
                // --- End Business Logic Simulation ---

                return Content(soapResponse.ToString(), "text/xml"); // Return XML with appropriate content type
            }
        }
        catch (System.Xml.XmlException ex)
        {
            return BadRequest($"Invalid XML/SOAP message received: {ex.Message}");
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error: {ex.Message}");
        }
    }
}
```
ğŸ§ª Senaryo 8: Bir web servisi XML tabanlÄ± istekleri karÅŸÄ±lar. Ä°stemciler SOAP protokolÃ¼ ile XML mesajlarÄ± gÃ¶nderir. Servis bu mesajlarÄ± yorumlayarak uygun iÅŸlemleri yapar. YanÄ±tlar XML formatÄ±nda structurelanÄ±r.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, Response, jsonify
import xml.etree.ElementTree as ET

app = Flask(__name__)

# Define SOAP namespaces
SOAP_ENVELOPE = "{[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)}"
TEMP_URI = "{[http://tempuri.org/](http://tempuri.org/)}" # Example namespace for your methods

@app.route('/api/webservice/soap-endpoint', methods=['POST'])
def process_soap_request():
    if request.content_type not in ['text/xml', 'application/soap+xml']:
        return jsonify({"error": "Content-Type must be text/xml or application/soap+xml"}), 415

    try:
        xml_data = request.data.decode('utf-8')
        soap_request_root = ET.fromstring(xml_data)

        print(f"Received SOAP request. Root tag: {soap_request_root.tag}")

        # Find the SOAP Body
        soap_body = soap_request_root.find(f'{SOAP_ENVELOPE}Body')
        if soap_body is None:
            raise ValueError("SOAP Body not found in the request.")

        # --- Business Logic Simulation based on SOAP request ---
        response_body_content = None
        
        # Example: Check for a specific method like <GetUserInfo>
        get_user_info_request = soap_body.find(f'{TEMP_URI}GetUserInfo')
        if get_user_info_request is not None:
            user_id_element = get_user_info_request.find(f'{TEMP_URI}UserId')
            user_id = user_id_element.text if user_id_element is not None else "N/A"

            # Simulate fetching user data
            user_name = "UnknownUser"
            user_email = "unknown@example.com"
            if user_id == "123":
                user_name = "Alice Smith"
                user_email = "alice.s@example.com"
            elif user_id == "456":
                user_name = "Bob Johnson"
                user_email = "bob.j@example.com"

            get_user_info_response = ET.Element(f'{TEMP_URI}GetUserInfoResponse')
            ET.SubElement(get_user_info_response, f'{TEMP_URI}UserId').text = user_id
            ET.SubElement(get_user_info_response, f'{TEMP_URI}UserName').text = user_name
            ET.SubElement(get_user_info_response, f'{TEMP_URI}UserEmail').text = user_email
            ET.SubElement(get_user_info_response, f'{TEMP_URI}Status').text = "Success"
            response_body_content = get_user_info_response
        else:
            # Construct SOAP Fault for unsupported method
            fault = ET.Element(f'{SOAP_ENVELOPE}Fault')
            ET.SubElement(fault, 'faultcode').text = 'soap:Client'
            ET.SubElement(fault, 'faultstring').text = 'Unsupported request method or invalid message structure.'
            response_body_content = fault

        # Construct full SOAP response
        soap_envelope = ET.Element(f'{SOAP_ENVELOPE}Envelope',
                                    attrib={f'xmlns:soap': '[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)',
                                             f'xmlns:tem': '[http://tempuri.org/](http://tempuri.org/)'}) # Add your service namespace here
        soap_body_response = ET.SubElement(soap_envelope, f'{SOAP_ENVELOPE}Body')
        if response_body_content is not None:
            soap_body_response.append(response_body_content)

        xml_output_bytes = ET.tostring(soap_envelope, encoding='utf-8', xml_declaration=True)
        return Response(xml_output_bytes, mimetype='text/xml')

    except ET.ParseError as e:
        return jsonify({"error": f"Invalid XML/SOAP message received: {e}"}), 400
    except ValueError as e:
        return jsonify({"error": str(e)}), 400
    except Exception as e:
        return jsonify({"error": f"Internal server error: {e}"}), 500

if __name__ == '__main__':
    app.run(debug=True)
```
ğŸ§ª Senaryo 8: Bir web servisi XML tabanlÄ± istekleri karÅŸÄ±lar. Ä°stemciler SOAP protokolÃ¼ ile XML mesajlarÄ± gÃ¶nderir. Servis bu mesajlarÄ± yorumlayarak uygun iÅŸlemleri yapar. YanÄ±tlar XML formatÄ±nda structurelanÄ±r.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import { XMLParser, XMLBuilder } from 'fast-xml-parser';

const app = express();
app.use(express.text({ type: ['text/xml', 'application/soap+xml'] }));

const parserOptions = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_",
    // Set stopNodes to define points where parsing should stop for raw XML access if needed
    // stopNodes: ["*.soap:Body"]
};
const parser = new XMLParser(parserOptions);
const builderOptions = {
    format: true // For pretty printing output XML
};
const builder = new XMLBuilder(builderOptions);

// Define SOAP namespaces
const SOAP_ENV_NAMESPACE = "[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)";
const TEMP_URI_NAMESPACE = "[http://tempuri.org/](http://tempuri.org/)"; // Example namespace for your service methods

app.post('/api/webservice/soap-endpoint', (req, res) => {
    if (!req.headers['content-type'] || !req.headers['content-type'].includes('xml')) {
        return res.status(415).send('Content-Type must be text/xml or application/soap+xml');
    }

    try {
        const xmlString = req.body;
        const parsedSoapRequest = parser.parse(xmlString);

        console.log("Received SOAP request (parsed to JSON):", JSON.stringify(parsedSoapRequest, null, 2));

        // Navigate to SOAP Body to find the method call
        const soapBody = parsedSoapRequest['soap:Envelope']?.['soap:Body'];
        if (!soapBody) {
            throw new Error("SOAP Body not found in the request.");
        }

        let responseBodyContent: any;

        // --- Business Logic Simulation based on SOAP request ---
        // Check for specific method, e.g., <tem:GetUserInfo>
        const getUserInfoRequest = soapBody['tem:GetUserInfo'];

        if (getUserInfoRequest) {
            const userId = getUserInfoRequest['tem:UserId'];
            let userName = "UnknownUser";
            let userEmail = "unknown@example.com";

            // Simulate fetching user data
            if (userId === "123") {
                userName = "Alice Smith";
                userEmail = "alice.s@example.com";
            } else if (userId === "456") {
                userName = "Bob Johnson";
                userEmail = "bob.j@example.com";
            }

            responseBodyContent = {
                'tem:GetUserInfoResponse': {
                    'tem:UserId': userId,
                    'tem:UserName': userName,
                    'tem:UserEmail': userEmail,
                    'tem:Status': "Success"
                }
            };
        } else {
            // Construct SOAP Fault for unsupported method
            responseBodyContent = {
                'soap:Fault': {
                    'faultcode': 'soap:Client',
                    'faultstring': 'Unsupported request method or invalid message structure.'
                }
            };
        }
        // --- End Business Logic Simulation ---

        // Construct full SOAP response
        const soapResponseJson = {
            'soap:Envelope': {
                '@_xmlns:soap': SOAP_ENV_NAMESPACE,
                '@_xmlns:tem': TEMP_URI_NAMESPACE, // Add your service namespace prefix
                'soap:Body': responseBodyContent
            }
        };

        const responseXml = builder.build(soapResponseJson);

        res.header('Content-Type', 'text/xml'); // Standard SOAP response content type
        res.status(200).send(responseXml);

    } catch (error: any) {
        // More robust error handling with SOAP Fault messages can be implemented here
        const faultResponseJson = {
            'soap:Envelope': {
                '@_xmlns:soap': SOAP_ENV_NAMESPACE,
                'soap:Body': {
                    'soap:Fault': {
                        'faultcode': 'soap:Server',
                        'faultstring': `Internal Server Error: ${error.message}`
                    }
                }
            }
        };
        const faultXml = builder.build(faultResponseJson);
        res.header('Content-Type', 'text/xml');
        res.status(500).send(faultXml);
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Web Service Server running on port ${PORT}`);
});
```
ğŸ§ª Senaryo 9: Bir katalog yÃ¶netim sistemi Ã¼rÃ¼n bilgilerini XML dosyalarÄ±ndan okur. TedarikÃ§iler Ã¼rÃ¼n veritabanlarÄ±nÄ± XML formatÄ±nda saÄŸlar. Sistem bu dosyalarÄ± iÅŸleyerek katalog gÃ¼nceller. ÃœrÃ¼n bilgileri XML yapÄ±sÄ±ndan Ã§Ä±karÄ±lÄ±r.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

```csharp

using System.Xml.Linq;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using System.Collections.Generic;
using System.Linq;

// Represents a simplified Product model
public class Product
{
    public string ProductId { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public decimal Price { get; set; }
    public int Stock { get; set; }
}

// In-memory catalog database simulation
public static class ProductCatalog
{
    private static readonly Dictionary<string, Product> _products = new Dictionary<string, Product>();

    public static void UpdateCatalogFromXml(XDocument supplierData)
    {
        Console.WriteLine(<span class="math-inline">"Updating catalog from XML\. Root element\: \{supplierData\.Root?\.Name\}"\);
// Assuming a structure like <Products\><Product\><Id\>\.\.\.</Id\><Name\>\.\.\.</Name\>\.\.\.</Product\></Products\>
var productElements \= supplierData\.Descendants\("Product"\);
foreach \(var productElement in productElements\)
\{
try
\{
Product product \= new Product
\{
ProductId \= productElement\.Element\("Id"\)?\.Value,
Name \= productElement\.Element\("Name"\)?\.Value,
Description \= productElement\.Element\("Description"\)?\.Value,
Price \= decimal\.Parse\(productElement\.Element\("Price"\)?\.Value ?? "0"\),
Stock \= int\.Parse\(productElement\.Element\("Stock"\)?\.Value ?? "0"\)
\};
if \(\!string\.IsNullOrEmpty\(product\.ProductId\)\)
\{
\_products\[product\.ProductId\] \= product;
Console\.WriteLine\(</span>"  Product '{product.Name}' (ID: {product.ProductId}) updated/added.");
                }
                else
                {
                    Console.WriteLine("  Skipping product with missing ID.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(<span class="math-inline">"Error processing product element\: \{ex\.Message\}"\);
\}
\}
Console\.WriteLine\(</span>"Catalog updated. Total products: {_products.Count}");
    }

    public static IEnumerable<Product> GetAllProducts()
    {
        return _products.Values;
    }
}

[ApiController]
[Route("api/[controller]")]
public class CatalogController : ControllerBase
{
    [HttpPost("upload-supplier-data")]
    public async Task<IActionResult> UploadSupplierData(IFormFile file)
    {
        if (file == null || file.Length == 0)
            return BadRequest("Upload a valid XML supplier data file.");

        try
        {
            using (var stream = file.OpenReadStream())
            {
                XDocument supplierData = XDocument.Load(stream);
                ProductCatalog.UpdateCatalogFromXml(supplierData); // Process and update catalog
                return Ok("Product catalog updated successfully from supplier data.");
            }
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Internal server error processing supplier data: {ex.Message}");
        }
    }

    [HttpGet("products")]
    public IActionResult GetProducts()
    {
        return Ok(ProductCatalog.GetAllProducts());
    }
}
```
ğŸ§ª Senaryo 9: Bir katalog yÃ¶netim sistemi Ã¼rÃ¼n bilgilerini XML dosyalarÄ±ndan okur. TedarikÃ§iler Ã¼rÃ¼n veritabanlarÄ±nÄ± XML formatÄ±nda saÄŸlar. Sistem bu dosyalarÄ± iÅŸleyerek katalog gÃ¼nceller. ÃœrÃ¼n bilgileri XML yapÄ±sÄ±ndan Ã§Ä±karÄ±lÄ±r.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
import xml.etree.ElementTree as ET

app = Flask(__name__)

# In-memory dictionary to simulate a product catalog database
product_catalog = {} # {product_id: {name: "", description: "", ...}}

def update_catalog_from_xml(xml_content):
    root = ET.fromstring(xml_content)
    print(f"Updating catalog from XML. Root tag: {root.tag}")

    # Assuming products are under a 'Products' root, and each product is a 'Product' element
    for product_elem in root.findall('.//Product'):
        product_id = product_elem.find('Id').text if product_elem.find('Id') is not None else None
        
        if product_id:
            try:
                product_data = {
                    "name": product_elem.find('Name').text if product_elem.find('Name') is not None else "",
                    "description": product_elem.find('Description').text if product_elem.find('Description') is not None else "",
                    "price": float(product_elem.find('Price').text) if product_elem.find('Price') is not None else 0.0,
                    "stock": int(product_elem.find('Stock').text) if product_elem.find('Stock') is not None else 0
                }
                product_catalog[product_id] = product_data
                print(f"  Product '{product_data['name']}' (ID: {product_id}) updated/added.")
            except (ValueError, TypeError) as e:
                print(f"Error parsing product data for ID {product_id}: {e}")
        else:
            print("Skipping product with missing ID.")
    
    print(f"Catalog updated. Total products: {len(product_catalog)}")

@app.route('/api/catalog/upload-supplier-data', methods=['POST'])
def upload_supplier_data():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    if file and file.filename.endswith('.xml'):
        try:
            xml_content = file.read()
            update_catalog_from_xml(xml_content)
            return jsonify({"message": "Product catalog updated successfully from supplier data."}), 200
        except ET.ParseError as e:
            return jsonify({"error": f"Invalid XML file: {e}"}), 400
        except Exception as e:
            return jsonify({"error": f"Internal server error processing supplier data: {e}"}), 500
    return jsonify({"error": "Invalid file type. Only XML allowed."}), 400

@app.route('/api/catalog/products', methods=['GET'])
def get_products():
    return jsonify(product_catalog), 200

if __name__ == '__main__':
    app.run(debug=True)
```
ğŸ§ª Senaryo 9: Bir katalog yÃ¶netim sistemi Ã¼rÃ¼n bilgilerini XML dosyalarÄ±ndan okur. TedarikÃ§iler Ã¼rÃ¼n veritabanlarÄ±nÄ± XML formatÄ±nda saÄŸlar. Sistem bu dosyalarÄ± iÅŸleyerek katalog gÃ¼nceller. ÃœrÃ¼n bilgileri XML yapÄ±sÄ±ndan Ã§Ä±karÄ±lÄ±r.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import { XMLParser } from 'fast-xml-parser';
import fs from 'fs';
import path from 'path';

const app = express();
const upload = multer({ dest: 'uploads/' });

// In-memory object to simulate a product catalog database
interface Product {
    id: string;
    name: string;
    description: string;
    price: number;
    stock: number;
}
const productCatalog: Map<string, Product> = new Map();

// Options for XML parsing, especially to handle arrays if multiple products are present
const parserOptions = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_",
    // For handling multiple 'Product' elements directly under a root
    isArray: (name: string, jPath: string, is:{ [key:string]: string|number }) => {
        if (jPath === "Products.Product") return true; // Treat "Product" as an array if under "Products"
        return false;
    }
};
const parser = new XMLParser(parserOptions);

function updateCatalogFromXml(xmlContent: string) {
    const parsedXml = parser.parse(xmlContent);
    console.log("Updating catalog from XML. Parsed root element:", Object.keys(parsedXml)[0]);

    // Assuming the XML has a root like <Products> and then <Product> elements
    const productsData = parsedXml.Products?.Product;

    if (productsData && Array.isArray(productsData)) {
        productsData.forEach((product: any) => {
            try {
                const id = product.Id;
                if (id) {
                    const newProduct: Product = {
                        id: String(id),
                        name: String(product.Name || ''),
                        description: String(product.Description || ''),
                        price: parseFloat(product.Price || '0'),
                        stock: parseInt(product.Stock || '0')
                    };
                    productCatalog.set(newProduct.id, newProduct);
                    console.log(`  Product '${newProduct.name}' (ID: ${newProduct.id}) updated/added.`);
                } else {
                    console.warn("  Skipping product with missing ID.");
                }
            } catch (error: any) {
                console.error(`Error processing product element: ${error.message}. Product data: ${JSON.stringify(product)}`);
            }
        });
    } else if (productsData && typeof productsData === 'object') {
        // Handle case where there's only one <Product> directly under <Products>
        try {
            const id = productsData.Id;
            if (id) {
                const newProduct: Product = {
                    id: String(id),
                    name: String(productsData.Name || ''),
                    description: String(productsData.Description || ''),
                    price: parseFloat(productsData.Price || '0'),
                    stock: parseInt(productsData.Stock || '0')
                };
                productCatalog.set(newProduct.id, newProduct);
                console.log(`  Single product '${newProduct.name}' (ID: ${newProduct.id}) updated/added.`);
            } else {
                console.warn("  Skipping single product with missing ID.");
            }
        } catch (error: any) {
            console.error(`Error processing single product element: ${error.message}. Product data: ${JSON.stringify(productsData)}`);
        }
    } else {
        console.warn("No 'Product' elements found under 'Products' or XML structure not as expected.");
    }
    console.log(`Catalog updated. Total products: ${productCatalog.size}`);
}

app.post('/api/catalog/upload-supplier-data', upload.single('supplierFile'), async (req, res) => {
    if (!req.file) {
        return res.status(400).send('Please upload an XML supplier data file.');
    }

    try {
        const filePath = req.file.path;
        const xmlContent = fs.readFileSync(filePath, 'utf8');
        updateCatalogFromXml(xmlContent);

        fs.unlinkSync(filePath); // Clean up the temporary file

        res.status(200).send('Product catalog updated successfully from supplier data.');
    } catch (error: any) {
        if (req.file) {
            fs.unlinkSync(req.file.path);
        }
        if (error.message.includes("Non-whitespace characters are not allowed") || error.message.includes("Unclosed tag")) {
            return res.status(400).send('Invalid XML file content.');
        }
        res.status(500).send(`Internal server error processing supplier data: ${error.message}`);
    }
});

app.get('/api/catalog/products', (req, res) => {
    const productsArray = Array.from(productCatalog.values());
    res.status(200).json(productsArray);
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```
ğŸ§ª Senaryo 10: Bir iÅŸ akÄ±ÅŸÄ± motoru sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± XML dosyalarÄ±nda tutar. KullanÄ±cÄ±lar iÅŸ akÄ±ÅŸÄ± ÅŸemalarÄ±nÄ± XML olarak sisteme yÃ¼kler. Motor bu tanÄ±mlarÄ± iÅŸleyerek sÃ¼reÃ§leri baÅŸlatÄ±r. Ä°ÅŸ akÄ±ÅŸÄ± adÄ±mlarÄ± XML yapÄ±sÄ±ndan oluÅŸturulur.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

```csharp

using System.Xml.Linq;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using System.Collections.Generic;
using System.Linq;

// Simple representation of a Workflow Process
public class WorkflowProcess
{
    public string Id { get; set; }
    public string Name { get; set; }
    public List<WorkflowStep> Steps { get; set; } = new List<WorkflowStep>();

    public void Execute()
    {
        Console.WriteLine(<span class="math-inline">"Executing Workflow\: \{Name\} \(ID\: \{Id\}\)"\);
foreach \(var step in Steps\.OrderBy\(s \=\> s\.Order\)\)
\{
Console\.WriteLine\(</span>"  Executing Step {step.Order}: {step.Name} (Type: {step.Type})");
            // In a real engine, this would trigger specific actions based on step type
            // e.g., calling an external service, updating a database, sending an email
            if (step.Type == "Approval")
            {
                Console.WriteLine("    Waiting for approval...");
                // Simulate approval process
            }
            else if (step.Type == "Task")
            {
                Console.WriteLine(<span class="math-inline">"    Performing task\: \{step\.Details\}"\);
\}
Thread\.Sleep\(50\); // Simulate some work
\}
Console\.WriteLine\(</span>"Workflow '{Name}' completed.");
    }
}

public class WorkflowStep
{
    public string Name { get; set; }
    public string Type { get; set; }
    public int Order { get; set; }
    public string Details { get; set; } // Additional step-specific data
}

// In-memory store for workflow definitions
public static class WorkflowEngine
{
    private static readonly Dictionary<string, WorkflowProcess> _processes = new Dictionary<string, WorkflowProcess>();

    public static void LoadWorkflowDefinition(XDocument workflowXml)
    {
        Console.WriteLine(<span class="math-inline">"Loading workflow definition from XML\. Root\: \{workflowXml\.Root?\.Name\}"\);
// Assuming a structure like <Workflow\><Id/\><Name/\><Steps\><Step\>\.\.\.</Step\></Steps\></Workflow\>
XElement workflowElement \= workflowXml\.Root;
if \(workflowElement \=\= null \|\| workflowElement\.Name \!\= "Workflow"\)
\{
throw new InvalidOperationException\("Invalid workflow XML structure\. Root must be 'Workflow'\."\);
\}
WorkflowProcess process \= new WorkflowProcess
\{
Id \= workflowElement\.Element\("Id"\)?\.Value,
Name \= workflowElement\.Element\("Name"\)?\.Value
\};
if \(string\.IsNullOrEmpty\(process\.Id\)\)
\{
throw new InvalidOperationException\("Workflow ID is missing in the XML definition\."\);
\}
var stepsElement \= workflowElement\.Element\("Steps"\);
if \(stepsElement \!\= null\)
\{
int stepOrder \= 1;
foreach \(var stepElement in stepsElement\.Elements\("Step"\)\)
\{
process\.Steps\.Add\(new WorkflowStep
\{
Name \= stepElement\.Element\("Name"\)?\.Value,
Type \= stepElement\.Element\("Type"\)?\.Value,
Order \= int\.Parse\(stepElement\.Element\("Order"\)?\.Value ?? \(stepOrder\+\+\)\.ToString\(\)\), // Use explicit order or infer
Details \= stepElement\.Element\("Details"\)?\.Value
\}\);
\}
\}
\_processes\[process\.Id\] \= process;
Console\.WriteLine\(</span>"Workflow '{process.Name}' (ID: {process.Id}) loaded successfully with {process.Steps.Count} steps.");
    }

    public static WorkflowProcess GetWorkflowProcess(string processId)
    {
        _processes.TryGetValue(processId, out var process);
        return process;
    }
}

[ApiController]
[Route("api/[controller]")]
public class WorkflowController : ControllerBase
{
    [HttpPost("upload-definition")]
    public async Task<IActionResult> UploadWorkflowDefinition(IFormFile file)
    {
        if (file == null || file.Length == 0)
            return BadRequest("Upload a valid XML workflow definition file.");

        try
        {
            using (var stream = file.OpenReadStream())
            {
                XDocument workflowXml = XDocument.Load(stream);
                WorkflowEngine.LoadWorkflowDefinition(workflowXml);
                return Ok("Workflow definition uploaded and parsed successfully.");
            }
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(ex.Message);
        }
        catch (Exception ex)
        {
            return StatusCode(500, <span class="math-inline">"Internal server error processing workflow definition\: \{ex\.Message\}"\);
\}
\}
\[HttpPost\("start\-process"\)\]
public IActionResult StartWorkflowProcess\(\[FromQuery\] string processId\)
\{
WorkflowProcess process \= WorkflowEngine\.GetWorkflowProcess\(processId\);
if \(process \=\= null\)
return NotFound\(</span>"Workflow process with ID '{processId}' not found.");

        // In a real system, this would typically be asynchronous and might return a process instance ID
        Task.Run(() => process.Execute()); // Execute in a background thread for simulation

        return Ok($"Workflow process '{process.Name}' (ID: {processId}) started.");
    }
}
```
ğŸ§ª Senaryo 10: Bir iÅŸ akÄ±ÅŸÄ± motoru sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± XML dosyalarÄ±nda tutar. KullanÄ±cÄ±lar iÅŸ akÄ±ÅŸÄ± ÅŸemalarÄ±nÄ± XML olarak sisteme yÃ¼kler. Motor bu tanÄ±mlarÄ± iÅŸleyerek sÃ¼reÃ§leri baÅŸlatÄ±r. Ä°ÅŸ akÄ±ÅŸÄ± adÄ±mlarÄ± XML yapÄ±sÄ±ndan oluÅŸturulur.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

```python

from flask import Flask, request, jsonify
import xml.etree.ElementTree as ET
import threading
import time

app = Flask(__name__)

# Simple representation of a Workflow Process
class WorkflowProcess:
    def __init__(self, id, name, steps):
        self.id = id
        self.name = name
        self.steps = sorted(steps, key=lambda s: s['order'])

    def execute(self):
        print(f"Executing Workflow: {self.name} (ID: {self.id})")
        for step in self.steps:
            print(f"  Executing Step {step['order']}: {step['name']} (Type: {step['type']})")
            # Simulate step execution based on type
            if step['type'] == 'Approval':
                print("    Waiting for approval (simulated)...")
                time.sleep(0.1) # Simulate delay
            elif step['type'] == 'Task':
                print(f"    Performing task: {step.get('details', 'No details')}")
                time.sleep(0.05) # Simulate delay
        print(f"Workflow '{self.name}' completed.")

# In-memory store for workflow definitions
workflow_definitions = {} # {process_id: WorkflowProcess object}

def load_workflow_definition(xml_content):
    root = ET.fromstring(xml_content)
    print(f"Loading workflow definition from XML. Root tag: {root.tag}")

    if root.tag != 'Workflow':
        raise ValueError("Invalid workflow XML structure. Root must be 'Workflow'.")

    process_id_elem = root.find('Id')
    process_name_elem = root.find('Name')

    if process_id_elem is None or not process_id_elem.text:
        raise ValueError("Workflow ID is missing in the XML definition.")
    if process_name_elem is None or not process_name_elem.text:
        raise ValueError("Workflow Name is missing in the XML definition.")

    process_id = process_id_elem.text
    process_name = process_name_elem.text
    
    steps = []
    steps_element = root.find('Steps')
    if steps_element is not None:
        step_order_counter = 1
        for step_elem in steps_element.findall('Step'):
            step_name = step_elem.find('Name').text if step_elem.find('Name') is not None else "Unnamed Step"
            step_type = step_elem.find('Type').text if step_elem.find('Type') is not None else "Generic"
            step_order = int(step_elem.find('Order').text) if step_elem.find('Order') is not None and step_elem.find('Order').text.isdigit() else step_order_counter
            step_details = step_elem.find('Details').text if step_elem.find('Details') is not None else None
            
            steps.append({
                "name": step_name,
                "type": step_type,
                "order": step_order,
                "details": step_details
            })
            step_order_counter += 1
    
    workflow_process = WorkflowProcess(process_id, process_name, steps)
    workflow_definitions[process_id] = workflow_process
    print(f"Workflow '{workflow_process.name}' (ID: {workflow_process.id}) loaded successfully with {len(workflow_process.steps)} steps.")

@app.route('/api/workflow/upload-definition', methods=['POST'])
def upload_workflow_definition():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    if file and file.filename.endswith('.xml'):
        try:
            xml_content = file.read()
            load_workflow_definition(xml_content)
            return jsonify({"message": "Workflow definition uploaded and parsed successfully."}), 200
        except ET.ParseError as e:
            return jsonify({"error": f"Invalid XML file: {e}"}), 400
        except ValueError as e:
            return jsonify({"error": str(e)}), 400
        except Exception as e:
            return jsonify({"error": f"Internal server error processing workflow definition: {e}"}), 500
    return jsonify({"error": "Invalid file type. Only XML allowed."}), 400

@app.route('/api/workflow/start-process', methods=['POST'])
def start_workflow_process():
    process_id = request.args.get('processId')
    if not process_id:
        return jsonify({"error": "Process ID is required."}), 400

    workflow = workflow_definitions.get(process_id)
    if not workflow:
        return jsonify({"error": f"Workflow process with ID '{process_id}' not found."}), 404
    
    # Start the workflow in a new thread to simulate background execution
    threading.Thread(target=workflow.execute).start()

    return jsonify({"message": f"Workflow process '{workflow.name}' (ID: {process_id}) started."}), 200

if __name__ == '__main__':
    app.run(debug=True)
```
ğŸ§ª Senaryo 10: Bir iÅŸ akÄ±ÅŸÄ± motoru sÃ¼reÃ§ tanÄ±mlarÄ±nÄ± XML dosyalarÄ±nda tutar. KullanÄ±cÄ±lar iÅŸ akÄ±ÅŸÄ± ÅŸemalarÄ±nÄ± XML olarak sisteme yÃ¼kler. Motor bu tanÄ±mlarÄ± iÅŸleyerek sÃ¼reÃ§leri baÅŸlatÄ±r. Ä°ÅŸ akÄ±ÅŸÄ± adÄ±mlarÄ± XML yapÄ±sÄ±ndan oluÅŸturulur.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

```typescript

import express from 'express';
import multer from 'multer';
import { XMLParser } from 'fast-xml-parser';
import fs from 'fs';
import path from 'path';

const app = express();
const upload = multer({ dest: 'uploads/' });

// Represents a simplified Workflow Step
interface WorkflowStep {
    name: string;
    type: string;
    order: number;
    details?: string;
}

// Represents a simplified Workflow Process
class WorkflowProcess {
    id: string;
    name: string;
    steps: WorkflowStep[] = [];

    constructor(id: string, name: string, steps: WorkflowStep[]) {
        this.id = id;
        this.name = name;
        // Sort steps by order
        this.steps = steps.sort((a, b) => a.order - b.order);
    }

    async execute(): Promise<void> {
        console.log(`Executing Workflow: ${this.name} (ID: ${this.id})`);
        for (const step of this.steps) {
            console.log(`  Executing Step ${step.order}: ${step.name} (Type: ${step.type})`);
            // Simulate asynchronous operations or delays
            await new Promise(resolve => setTimeout(resolve, 50)); // Simulate some work

            if (step.type === 'Approval') {
                console.log("    Waiting for approval (simulated)...");
            } else if (step.type === 'Task') {
                console.log(`    Performing task: ${step.details || 'No details'}`);
            }
        }
        console.log(`Workflow '${this.name}' completed.`);
    }
}

// In-memory store for workflow definitions
const workflowDefinitions: Map<string, WorkflowProcess> = new Map();

const parserOptions = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_",
    // To ensure 'Step' elements are always parsed as an array if multiple exist
    isArray: (name: string, jPath: string, is:{ [key:string]: string|number }) => {
        if (jPath === "Workflow.Steps.Step") return true;
        return false;
    }
};
const parser = new XMLParser(parserOptions);

function loadWorkflowDefinition(xmlContent: string) {
    const parsedXml = parser.parse(xmlContent);
    console.log("Loading workflow definition from XML. Parsed root element:", Object.keys(parsedXml)[0]);

    const workflowData = parsedXml.Workflow;
    if (!workflowData) {
        throw new Error("Invalid workflow XML structure. Root must be 'Workflow'.");
    }

    const id = String(workflowData.Id || '');
    const name = String(workflowData.Name || '');

    if (!id) {
        throw new Error("Workflow ID is missing in the XML definition.");
    }
    if (!name) {
        throw new Error("Workflow Name is missing in the XML definition.");
    }

    const steps: WorkflowStep[] = [];
    const stepsData = workflowData.Steps?.Step;

    if (stepsData && Array.isArray(stepsData)) {
        let orderCounter = 1;
        stepsData.forEach((step: any) => {
            steps.push({
                name: String(step.Name || 'Unnamed Step'),
                type: String(step.Type || 'Generic'),
                order: parseInt(step.Order || String(orderCounter++)), // Use explicit order or infer
                details: String(step.Details || '')
            });
        });
    } else if (stepsData && typeof stepsData === 'object') {
        // Handle single step case
        steps.push({
            name: String(stepsData.Name || 'Unnamed Step'),
            type: String(stepsData.Type || 'Generic'),
            order: parseInt(stepsData.Order || '1'),
            details: String(stepsData.Details || '')
        });
    }

    const workflowProcess = new WorkflowProcess(id, name, steps);
    workflowDefinitions.set(id, workflowProcess);
    console.log(`Workflow '${workflowProcess.name}' (ID: ${workflowProcess.id}) loaded successfully with ${workflowProcess.steps.length} steps.`);
}

app.post('/api/workflow/upload-definition', upload.single('workflowFile'), async (req, res) => {
    if (!req.file) {
        return res.status(400).send('Please upload an XML workflow definition file.');
    }

    try {
        const filePath = req.file.path;
        const xmlContent = fs.readFileSync(filePath, 'utf8');
        loadWorkflowDefinition(xmlContent);

        fs.unlinkSync(filePath); // Clean up the temporary file

        res.status(200).send('Workflow definition uploaded and parsed successfully.');
    } catch (error: any) {
        if (req.file) {
            fs.unlinkSync(req.file.path);
        }
        if (error.message.includes("Non-whitespace characters are not allowed") || error.message.includes("Unclosed tag")) {
            return res.status(400).send('Invalid XML file content.');
        }
        res.status(500).send(`Internal server error processing workflow definition: ${error.message}`);
    }
});

app.post('/api/workflow/start-process', (req, res) => {
    const processId = req.query.processId as string;
    if (!processId) {
        return res.status(400).send('Process ID is required.');
    }

    const workflow = workflowDefinitions.get(processId);
    if (!workflow) {
        return res.status(404).send(`Workflow process with ID '${processId}' not found.`);
    }

    // Execute the workflow asynchronously (don't await in the express handler)
    workflow.execute().catch(error => {
        console.error(`Error during workflow execution for ID ${processId}:`, error);
        // You might want to log this to a persistent store or send a notification
    });

    res.status(200).send(`Workflow process '${workflow.name}' (ID: ${processId}) started.`);
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
```
});