### ğŸ§ª Senaryo 1: Bir metin dÃ¼zenleyici uygulamasÄ±nda kullanÄ±cÄ±lar Ã§ok satÄ±rlÄ± metinleri dÃ¼zenleyebiliyor. Her satÄ±r uygulama iÃ§inde bellekte tutuluyor ve dizin bilgisiyle eriÅŸiliyor. KullanÄ±cÄ± metne ekleme yaptÄ±ÄŸÄ±nda sistem belirli bir tampon belleÄŸe veri yazÄ±yor. Bu belleÄŸin boyutu kullanÄ±cÄ± girdisine gÃ¶re ayarlanÄ±yor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 42
```csharp

public class TextEditor
{
    private List<string> lines;
    private char[] buffer;
    private int bufferSize;

    public TextEditor()
    {
        lines = new List<string>();
        bufferSize = 0;
    }

    public void AddLine(string line)
    {
        lines.Add(line);
    }

    public void InsertText(int lineNumber, int columnIndex, string textToInsert)
    {
        if (lineNumber >= 0 && lineNumber < lines.Count)
        {
            string currentLine = lines[lineNumber];
            // Adjust buffer size based on the length of the text to insert
            bufferSize = textToInsert.Length;
            buffer = new char[bufferSize];
            textToInsert.CopyTo(0, buffer, 0, textToInsert.Length);

            string newLine = currentLine.Insert(columnIndex, new string(buffer));
            lines[lineNumber] = newLine;
        }
    }

    public string GetLine(int lineNumber)
    {
        if (lineNumber >= 0 && lineNumber < lines.Count)
        {
            return lines[lineNumber];
        }
        return null;
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 24
```python

class TextEditor:
    def __init__(self):
        self.lines = []
        self.buffer = bytearray()
        self.buffer_size = 0

    def add_line(self, line):
        self.lines.append(line)

    def insert_text(self, line_number, column_index, text_to_insert):
        if 0 <= line_number < len(self.lines):
            current_line = self.lines[line_number]
            # Adjust buffer size based on the length of the text to insert
            self.buffer_size = len(text_to_insert.encode('utf-8'))
            self.buffer = bytearray(text_to_insert.encode('utf-8'))

            new_line = current_line[:column_index] + self.buffer.decode('utf-8') + current_line[column_index:]
            self.lines[line_number] = new_line

    def get_line(self, line_number):
        if 0 <= line_number < len(self.lines):
            return self.lines[line_number]
        return None
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 37
```typescript

class TextEditor {
    private lines: string[];
    private buffer: Uint8Array; // Using Uint8Array for byte buffer
    private bufferSize: number;

    constructor() {
        this.lines = [];
        this.bufferSize = 0;
    }

    public addLine(line: string): void {
        this.lines.push(line);
    }

    public insertText(lineNumber: number, columnIndex: number, textToInsert: string): void {
        if (lineNumber >= 0 && lineNumber < this.lines.length) {
            let currentLine = this.lines[lineNumber];
            // Adjust buffer size based on the byte length of the text to insert
            const encoder = new TextEncoder();
            const encodedText = encoder.encode(textToInsert);
            this.bufferSize = encodedText.length;
            this.buffer = encodedText;

            const newCharArr = currentLine.split('');
            newCharArr.splice(columnIndex, 0, textToInsert);
            this.lines[lineNumber] = newCharArr.join('');
        }
    }

    public getLine(lineNumber: number): string | null {
        if (lineNumber >= 0 && lineNumber < this.lines.length) {
            return this.lines[lineNumber];
        }
        return null;
    }
}
```

### ğŸ§ª Senaryo 2: Bir ses iÅŸleme yazÄ±lÄ±mÄ± gelen mikrofon verilerini belirli aralÄ±klarda buffer'a alÄ±yor. KullanÄ±cÄ± farklÄ± Ã¶rnekleme oranlarÄ± seÃ§erek kaydÄ± baÅŸlatabiliyor. Bu veri buffer'a sabit aralÄ±kla ekleniyor. Uzun kayÄ±tlar iÃ§in sistem bellek boyutlarÄ±nÄ± yÃ¶netiyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 45
```csharp

public class AudioProcessor
{
    private List<byte> audioBuffer;
    private int samplingRate; // Samples per second
    private int bufferChunkSize; // How many bytes to add at a time

    public AudioProcessor(int initialSamplingRate, int chunkSizeBytes)
    {
        audioBuffer = new List<byte>();
        samplingRate = initialSamplingRate;
        bufferChunkSize = chunkSizeBytes;
    }

    public void SetSamplingRate(int newSamplingRate)
    {
        samplingRate = newSamplingRate;
        // In a real scenario, this might trigger a recalculation of bufferChunkSize
        // or other audio processing parameters based on the new sampling rate.
    }

    // Simulate receiving microphone data and adding to buffer
    public void AddMicrophoneData(byte[] data)
    {
        // For simplicity, we assume data length is bufferChunkSize.
        // In a real application, data could be of varying lengths,
        // and we'd append based on availability and chunk size logic.
        if (data.Length <= bufferChunkSize)
        {
            audioBuffer.AddRange(data);
        }
        else
        {
            // Handle larger data chunks, e.g., by processing in smaller parts
            audioBuffer.AddRange(data.Take(bufferChunkSize));
        }
        // For long recordings, system manages memory by dynamically growing the List<byte>.
        // For very large scale, consider memory-mapped files or streaming to disk.
    }

    public byte[] GetBufferedAudioData()
    {
        return audioBuffer.ToArray();
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 27
```python

class AudioProcessor:
    def __init__(self, initial_sampling_rate, chunk_size_bytes):
        self.audio_buffer = bytearray()
        self.sampling_rate = initial_sampling_rate  # Samples per second
        self.buffer_chunk_size = chunk_size_bytes  # How many bytes to add at a time

    def set_sampling_rate(self, new_sampling_rate):
        self.sampling_rate = new_sampling_rate
        # In a real scenario, this might trigger a recalculation of buffer_chunk_size
        # or other audio processing parameters based on the new sampling rate.

    # Simulate receiving microphone data and adding to buffer
    def add_microphone_data(self, data: bytes):
        # For simplicity, we assume data length is buffer_chunk_size.
        # In a real application, data could be of varying lengths,
        # and we'd append based on availability and chunk size logic.
        if len(data) <= self.buffer_chunk_size:
            self.audio_buffer.extend(data)
        else:
            # Handle larger data chunks, e.g., by processing in smaller parts
            self.audio_buffer.extend(data[:self.buffer_chunk_size])
        # For long recordings, system manages memory by dynamically growing the bytearray.
        # For very large scale, consider streaming to disk or using external libraries for efficient handling.

    def get_buffered_audio_data(self):
        return self.audio_buffer
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 37
```typescript

class AudioProcessor {
    private audioBuffer: Uint8Array;
    private samplingRate: number; // Samples per second
    private bufferChunkSize: number; // How many bytes to add at a time
    private currentBufferLength: number;

    constructor(initialSamplingRate: number, chunkSizeBytes: number) {
        this.audioBuffer = new Uint8Array(0); // Initialize with an empty Uint8Array
        this.samplingRate = initialSamplingRate;
        this.bufferChunkSize = chunkSizeBytes;
        this.currentBufferLength = 0;
    }

    public setSamplingRate(newSamplingRate: number): void {
        this.samplingRate = newSamplingRate;
        // In a real scenario, this might trigger a recalculation of bufferChunkSize
        // or other audio processing parameters based on the new sampling rate.
    }

    // Simulate receiving microphone data and adding to buffer
    public addMicrophoneData(data: Uint8Array): void {
        // Create a new buffer that is large enough to hold existing data plus new data
        const newBuffer = new Uint8Array(this.currentBufferLength + Math.min(data.length, this.bufferChunkSize));
        newBuffer.set(this.audioBuffer, 0); // Copy existing data
        newBuffer.set(data.subarray(0, Math.min(data.length, this.bufferChunkSize)), this.currentBufferLength); // Add new data
        this.audioBuffer = newBuffer;
        this.currentBufferLength = this.audioBuffer.length;

        // For long recordings, the system manages memory by creating new, larger Uint8Arrays and copying data.
        // For very large scale, consider Node.js streams or Web Audio API's advanced buffering.
    }

    public getBufferedAudioData(): Uint8Array {
        return this.audioBuffer;
    }
}
```

### ğŸ§ª Senaryo 3: Bir gÃ¶rÃ¼ntÃ¼ dÃ¼zenleme programÄ±nda kullanÄ±cÄ± bir resmi kÄ±rptÄ±ÄŸÄ±nda sistem seÃ§ilen koordinatlara gÃ¶re iÅŸlem yapÄ±yor. KÄ±rpÄ±lacak alan bellekteki pikseller Ã¼zerinden hesaplanarak yeni buffer'a aktarÄ±lÄ±yor. Bu alanlarÄ±n sÄ±nÄ±rlarÄ± iÅŸlem sÄ±rasÄ±nda belirleniyor. Sistem seÃ§ilen alanÄ± iÅŸleyerek sonuÃ§ Ã¼retiyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 37
```csharp

using System;
using System.Drawing; // For Rectangle and Bitmap operations

public class ImageEditor
{
    private Bitmap originalImage;

    public ImageEditor(Bitmap image)
    {
        originalImage = image;
    }

    public Bitmap CropImage(Rectangle cropArea)
    {
        if (cropArea.X < 0 || cropArea.Y < 0 ||
            cropArea.X + cropArea.Width > originalImage.Width ||
            cropArea.Y + cropArea.Height > originalImage.Height)
        {
            throw new ArgumentOutOfRangeException("Crop area is out of image bounds.");
        }

        // Create a new bitmap (buffer) for the cropped image
        Bitmap croppedImage = new Bitmap(cropArea.Width, cropArea.Height);

        // Calculate pixel data and transfer to the new buffer
        for (int y = 0; y < cropArea.Height; y++)
        {
            for (int x = 0; x < cropArea.Width; x++)
            {
                Color pixel = originalImage.GetPixel(cropArea.X + x, cropArea.Y + y);
                croppedImage.SetPixel(x, y, pixel);
            }
        }
        return croppedImage;
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 22
```python

from PIL import Image # Pillow library for image processing

class ImageEditor:
    def __init__(self, image_path):
        self.original_image = Image.open(image_path)

    def crop_image(self, left, top, right, bottom):
        # Define the cropping area using a tuple (left, upper, right, lower)
        crop_area = (left, top, right, bottom)

        # Perform the crop operation
        cropped_image = self.original_image.crop(crop_area)

        # In a real scenario, the pixel data from the original image
        # is copied to a new memory buffer representing the cropped image.
        return cropped_image

# Example Usage (assuming you have an image file named 'example.png'):
# editor = ImageEditor('example.png')
# cropped = editor.crop_image(100, 100, 300, 300)
# cropped.save('cropped_example.png')
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 70
```typescript

// This example assumes a Node.js environment with a library like 'sharp' or 'jimp' for image manipulation.
// For browser environments, you would typically use Canvas API.

// If using Node.js with 'jimp':
// import Jimp from 'jimp';

interface CropArea {
    x: number;
    y: number;
    width: number;
    height: number;
}

class ImageEditor {
    private imageData: ImageData; // Or a library-specific image object

    constructor(imageData: ImageData) { // For browser: ImageData object from Canvas
        this.imageData = imageData;
    }

    public async cropImage(cropArea: CropArea): Promise<ImageData> {
        // In a browser environment using Canvas:
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            throw new Error('Could not get 2D context');
        }

        canvas.width = this.imageData.width;
        canvas.height = this.imageData.height;

        ctx.putImageData(this.imageData, 0, 0);

        // Get the image data for the cropped area. This simulates copying pixels to a new buffer.
        const croppedImageData = ctx.getImageData(cropArea.x, cropArea.y, cropArea.width, cropArea.height);

        return croppedImageData;

        // If using a Node.js library like Jimp:
        /*
        const image = await Jimp.read(this.imagePath); // Assuming imagePath is stored
        const croppedImage = await image.crop(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
        // The croppedImage object internally manages its own pixel buffer.
        return croppedImage;
        */
    }
}

// Example for browser environment:
// Assume 'originalCanvas' is an HTMLCanvasElement with an image drawn on it.
/*
const originalCanvas = document.getElementById('myCanvas') as HTMLCanvasElement;
const ctx = originalCanvas.getContext('2d');
if (ctx) {
    const originalImageData = ctx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
    const editor = new ImageEditor(originalImageData);
    const cropArea = { x: 50, y: 50, width: 100, height: 100 };
    editor.cropImage(cropArea).then(croppedData => {
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = croppedData.width;
        croppedCanvas.height = croppedData.height;
        const croppedCtx = croppedCanvas.getContext('2d');
        if (croppedCtx) {
            croppedCtx.putImageData(croppedData, 0, 0);
            document.body.appendChild(croppedCanvas);
        }
    });
}
*/
```

### ğŸ§ª Senaryo 4: Bir aÄŸ protokolÃ¼ uygulamasÄ±nda gelen veri paketleri byte dizisine aktarÄ±lÄ±yor. Paket uzunluÄŸu dÄ±ÅŸarÄ±dan geldiÄŸi iÃ§in sistem bu deÄŸeri referans alarak yazma iÅŸlemi gerÃ§ekleÅŸtiriyor. Paket boyutlarÄ± deÄŸiÅŸken olabildiÄŸinden tampon bellek bu duruma gÃ¶re ayarlanÄ±yor. Bellek sÄ±nÄ±rlarÄ± uygulamayla yÃ¶netiliyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 34
```csharp

public class NetworkPacketProcessor
{
    private byte[] receiveBuffer;
    private int currentBufferOffset;

    public NetworkPacketProcessor()
    {
        // Initial buffer size, will be resized based on incoming packet length
        receiveBuffer = new byte[0];
        currentBufferOffset = 0;
    }

    public void ProcessIncomingPacket(byte[] packetData, int packetLength)
    {
        // Adjust buffer size if the incoming packet is larger than current buffer capacity
        if (packetLength > receiveBuffer.Length)
        {
            // Allocate a new buffer of the required size.
            // In a real application, you might pre-allocate a larger buffer or use a pooling mechanism.
            receiveBuffer = new byte[packetLength];
        }

        // Copy the incoming packet data to the receive buffer
        Buffer.BlockCopy(packetData, 0, receiveBuffer, 0, packetLength);
        currentBufferOffset = packetLength; // Mark the end of the current packet in the buffer

        // Further processing of the packet data would occur here, e.g.,
        // parsing headers, extracting payload, etc.
        Console.WriteLine($"Received packet of length: {packetLength} bytes.");
        // Example: Print first few bytes of the packet
        // Console.WriteLine("Packet data (first 5 bytes): " + BitConverter.ToString(receiveBuffer, 0, Math.Min(5, packetLength)));
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 25
```python

class NetworkPacketProcessor:
    def __init__(self):
        self.receive_buffer = bytearray()

    def process_incoming_packet(self, packet_data: bytes, packet_length: int):
        # Ensure the buffer can hold the incoming packet data
        # In Python, bytearray can be resized dynamically, but for explicit
        # buffer management, we might reassign or extend.
        if len(self.receive_buffer) < packet_length:
            # Reallocate or extend the buffer to accommodate the new packet
            # For simplicity, let's just create a new bytearray for the packet
            # In a more complex system, you might manage a pre-allocated buffer pool
            self.receive_buffer = bytearray(packet_length)
        else:
            # If the current buffer is large enough, clear it or overwrite
            # For this scenario, we'll just take the exact length.
            self.receive_buffer = bytearray(packet_length)

        # Copy the incoming packet data to the receive buffer
        self.receive_buffer[:packet_length] = packet_data[:packet_length]

        # Further processing of the packet data would occur here
        print(f"Received packet of length: {packet_length} bytes.")
        # print(f"Packet data (first 5 bytes): {self.receive_buffer[:5].hex()}")
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 33
```typescript

// This example is suitable for Node.js using Buffer for byte operations.
// For browser environments, Uint8Array would be used, potentially with DataView.

class NetworkPacketProcessor {
    private receiveBuffer: Buffer; // Using Node.js Buffer
    private currentBufferLength: number;

    constructor() {
        // Initialize with an empty buffer or a small initial size
        this.receiveBuffer = Buffer.alloc(0);
        this.currentBufferLength = 0;
    }

    public processIncomingPacket(packetData: Buffer, packetLength: number): void {
        // Adjust buffer size if the incoming packet is larger than current buffer capacity
        if (packetLength > this.receiveBuffer.length) {
            // Allocate a new buffer of the required size.
            // In a real application, you might pre-allocate a larger buffer or use a pooling mechanism.
            this.receiveBuffer = Buffer.alloc(packetLength);
        }

        // Copy the incoming packet data to the receive buffer
        // packetData.copy(destination, destinationStart, sourceStart, sourceEnd)
        packetData.copy(this.receiveBuffer, 0, 0, packetLength);
        this.currentBufferLength = packetLength;

        // Further processing of the packet data would occur here, e.g.,
        // parsing headers, extracting payload, etc.
        console.log(`Received packet of length: ${packetLength} bytes.`);
        // console.log(`Packet data (first 5 bytes): ${this.receiveBuffer.toString('hex', 0, Math.min(5, packetLength))}`);
    }
}
```

### ğŸ§ª Senaryo 5: Bir oyun motoru karakter animasyonlarÄ±nÄ± bellekteki belirli diziler Ã¼zerinden kontrol ediyor. Animasyonlar kare dizisi olarak tutuluyor ve karakterin hareketine gÃ¶re gÃ¼ncelleniyor. KullanÄ±cÄ± eylemleri bu dizinin aralÄ±ÄŸÄ±nÄ± deÄŸiÅŸtirebiliyor. Sistem hareket aralÄ±ÄŸÄ±nÄ± animasyon sÄ±rasÄ±nda ayarlÄ±yor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 84
```csharp

using System.Collections.Generic;

public class AnimationFrame
{
    // Represents a single frame of an animation
    public int FrameId { get; set; }
    public string SpritePath { get; set; }
    // Other frame-specific data like offset, rotation, etc.
}

public class CharacterAnimator
{
    private List<AnimationFrame> allAnimationFrames;
    private int currentFrameIndex;
    private int animationStartFrame;
    private int animationEndFrame;

    public CharacterAnimator()
    {
        allAnimationFrames = new List<AnimationFrame>();
        currentFrameIndex = 0;
        animationStartFrame = 0;
        animationEndFrame = 0;
    }

    public void LoadAnimation(List<AnimationFrame> frames)
    {
        allAnimationFrames = frames;
        animationEndFrame = frames.Count > 0 ? frames.Count - 1 : 0;
    }

    public void SetAnimationRange(int startFrame, int endFrame)
    {
        if (startFrame >= 0 && endFrame < allAnimationFrames.Count && startFrame <= endFrame)
        {
            animationStartFrame = startFrame;
            animationEndFrame = endFrame;
            currentFrameIndex = startFrame; // Reset to the start of the new range
        }
        else
        {
            Console.WriteLine("Invalid animation range.");
        }
    }

    public AnimationFrame GetCurrentFrame()
    {
        if (allAnimationFrames.Count == 0) return null;

        AnimationFrame frame = allAnimationFrames[currentFrameIndex];
        return frame;
    }

    public void UpdateAnimation()
    {
        if (allAnimationFrames.Count == 0) return;

        currentFrameIndex++;
        if (currentFrameIndex > animationEndFrame)
        {
            currentFrameIndex = animationStartFrame; // Loop the animation
        }
    }

    // Simulate user action changing animation range (e.g., 'jump' action)
    public void HandleUserAction(string action)
    {
        switch (action)
        {
            case "idle":
                SetAnimationRange(0, 10); // Example idle animation frames
                break;
            case "walk":
                SetAnimationRange(11, 20); // Example walk animation frames
                break;
            case "jump":
                SetAnimationRange(21, 25); // Example jump animation frames
                break;
            default:
                break;
        }
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 48
```python

class AnimationFrame:
    def __init__(self, frame_id, sprite_path):
        self.frame_id = frame_id
        self.sprite_path = sprite_path
        # Other frame-specific data

class CharacterAnimator:
    def __init__(self):
        self.all_animation_frames = []
        self.current_frame_index = 0
        self.animation_start_frame = 0
        self.animation_end_frame = 0

    def load_animation(self, frames: list[AnimationFrame]):
        self.all_animation_frames = frames
        self.animation_end_frame = len(frames) - 1 if frames else 0

    def set_animation_range(self, start_frame: int, end_frame: int):
        if 0 <= start_frame <= end_frame < len(self.all_animation_frames):
            self.animation_start_frame = start_frame
            self.animation_end_frame = end_frame
            self.current_frame_index = start_frame  # Reset to the start of the new range
        else:
            print("Invalid animation range.")

    def get_current_frame(self) -> AnimationFrame | None:
        if not self.all_animation_frames:
            return None
        return self.all_animation_frames[self.current_frame_index]

    def update_animation(self):
        if not self.all_animation_frames:
            return

        self.current_frame_index += 1
        if self.current_frame_index > self.animation_end_frame:
            self.current_frame_index = self.animation_start_frame  # Loop the animation

    # Simulate user action changing animation range (e.g., 'jump' action)
    def handle_user_action(self, action: str):
        if action == "idle":
            self.set_animation_range(0, 10)  # Example idle animation frames
        elif action == "walk":
            self.set_animation_range(11, 20)  # Example walk animation frames
        elif action == "jump":
            self.set_animation_range(21, 25)  # Example jump animation frames
        # else: handle other actions or default
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 66
```typescript

interface AnimationFrame {
    frameId: number;
    spritePath: string;
    // Other frame-specific data like offset, rotation, etc.
}

class CharacterAnimator {
    private allAnimationFrames: AnimationFrame[];
    private currentFrameIndex: number;
    private animationStartFrame: number;
    private animationEndFrame: number;

    constructor() {
        this.allAnimationFrames = [];
        this.currentFrameIndex = 0;
        this.animationStartFrame = 0;
        this.animationEndFrame = 0;
    }

    public loadAnimation(frames: AnimationFrame[]): void {
        this.allAnimationFrames = frames;
        this.animationEndFrame = frames.length > 0 ? frames.length - 1 : 0;
    }

    public setAnimationRange(startFrame: number, endFrame: number): void {
        if (startFrame >= 0 && endFrame < this.allAnimationFrames.length && startFrame <= endFrame) {
            this.animationStartFrame = startFrame;
            this.animationEndFrame = endFrame;
            this.currentFrameIndex = startFrame; // Reset to the start of the new range
        } else {
            console.log("Invalid animation range.");
        }
    }

    public getCurrentFrame(): AnimationFrame | null {
        if (this.allAnimationFrames.length === 0) return null;
        return this.allAnimationFrames[this.currentFrameIndex];
    }

    public updateAnimation(): void {
        if (this.allAnimationFrames.length === 0) return;

        this.currentFrameIndex++;
        if (this.currentFrameIndex > this.animationEndFrame) {
            this.currentFrameIndex = this.animationStartFrame; // Loop the animation
        }
    }

    // Simulate user action changing animation range (e.g., 'jump' action)
    public handleUserAction(action: string): void {
        switch (action) {
            case "idle":
                this.setAnimationRange(0, 10); // Example idle animation frames
                break;
            case "walk":
                this.setAnimationRange(11, 20); // Example walk animation frames
                break;
            case "jump":
                this.setAnimationRange(21, 25); // Example jump animation frames
                break;
            default:
                break;
        }
    }
}
```

### ğŸ§ª Senaryo 6: Bir veritabanÄ± motorunda dizinleme iÅŸlemleri sÄ±rasÄ±nda kayÄ±tlar bellekte bloklar halinde tutuluyor. Arama sÄ±rasÄ±nda kullanÄ±cÄ± girdisiyle bu bloklara eriÅŸim yapÄ±lÄ±yor. Sistem gelen deÄŸerin blok aralÄ±ÄŸÄ±nda olup olmadÄ±ÄŸÄ±nÄ± deÄŸerlendiriyor. Okuma ve yazma sÄ±rasÄ±nda blok sÄ±nÄ±rlarÄ± kontrol ediliyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 80
```csharp

using System;
using System.Collections.Generic;

public class DataBlock
{
    public int BlockId { get; set; }
    public int StartKey { get; set; } // Example: serves as a key for range checking
    public int EndKey { get; set; }
    public byte[] Data { get; set; } // The actual data stored in the block

    public DataBlock(int id, int start, int end, byte[] data)
    {
        BlockId = id;
        StartKey = start;
        EndKey = end;
        Data = data;
    }

    public bool ContainsKey(int key)
    {
        return key >= StartKey && key <= EndKey;
    }
}

public class DatabaseIndexer
{
    private Dictionary<int, DataBlock> blockCache; // In-memory cache of data blocks

    public DatabaseIndexer()
    {
        blockCache = new Dictionary<int, DataBlock>();
        // Simulate loading some blocks into memory
        LoadInitialBlocks();
    }

    private void LoadInitialBlocks()
    {
        // In a real database, blocks would be loaded from disk based on access patterns
        blockCache.Add(1, new DataBlock(1, 100, 199, new byte[1024]));
        blockCache.Add(2, new DataBlock(2, 200, 299, new byte[1024]));
        blockCache.Add(3, new DataBlock(3, 300, 399, new byte[1024]));
    }

    public DataBlock GetBlockContainingKey(int userKey)
    {
        foreach (var block in blockCache.Values)
        {
            if (block.ContainsKey(userKey))
            {
                Console.WriteLine($"Accessing block {block.BlockId} for key {userKey}.");
                return block;
            }
        }
        Console.WriteLine($"No block found for key {userKey}.");
        return null;
    }

    public void WriteDataToBlock(int blockId, int key, byte[] dataToWrite)
    {
        if (blockCache.TryGetValue(blockId, out DataBlock block))
        {
            if (block.ContainsKey(key))
            {
                // Simulate writing data within the block's boundaries
                // In a real DB, this would involve managing offsets within the Data byte array
                Console.WriteLine($"Writing data to block {blockId} for key {key}. (Simulated)");
                // block.Data = dataToWrite; // This is a simplification; typically partial writes
            }
            else
            {
                Console.WriteLine($"Key {key} is outside the range of block {blockId}.");
            }
        }
        else
        {
            Console.WriteLine($"Block {blockId} not found in cache.");
        }
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 48
```python

class DataBlock:
    def __init__(self, block_id, start_key, end_key, data: bytes):
        self.block_id = block_id
        self.start_key = start_key
        self.end_key = end_key
        self.data = data # The actual data stored in the block

    def contains_key(self, key: int) -> bool:
        return self.start_key <= key <= self.end_key

class DatabaseIndexer:
    def __init__(self):
        self.block_cache = {} # In-memory cache of data blocks (block_id -> DataBlock)
        self._load_initial_blocks()

    def _load_initial_blocks(self):
        # Simulate loading some blocks into memory
        self.block_cache[1] = DataBlock(1, 100, 199, b'\x00' * 1024)
        self.block_cache[2] = DataBlock(2, 200, 299, b'\x00' * 1024)
        self.block_cache[3] = DataBlock(3, 300, 399, b'\x00' * 1024)

    def get_block_containing_key(self, user_key: int) -> DataBlock | None:
        for block in self.block_cache.values():
            if block.contains_key(user_key):
                print(f"Accessing block {block.block_id} for key {user_key}.")
                return block
        print(f"No block found for key {user_key}.")
        return None

    def write_data_to_block(self, block_id: int, key: int, data_to_write: bytes):
        block = self.block_cache.get(block_id)
        if block:
            if block.contains_key(key):
                # Simulate writing data within the block's boundaries
                # In a real DB, this would involve managing offsets within the data byte array
                print(f"Writing data to block {block_id} for key {key}. (Simulated)")
                # For actual data modification: block.data = new_data_from_write_operation
            else:
                print(f"Key {key} is outside the range of block {block_id}.")
        else:
            print(f"Block {block_id} not found in cache.")

# Example usage:
# indexer = DatabaseIndexer()
# block = indexer.get_block_containing_key(150)
# indexer.write_data_to_block(1, 150, b'some_new_data')
# indexer.write_data_to_block(1, 50, b'out_of_range_data')
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 54
```typescript

interface DataBlock {
    blockId: number;
    startKey: number; // Example: serves as a key for range checking
    endKey: number;
    data: Uint8Array; // The actual data stored in the block (using Uint8Array for bytes)
}

class DatabaseIndexer {
    private blockCache: Map<number, DataBlock>; // In-memory cache of data blocks (blockId -> DataBlock)

    constructor() {
        this.blockCache = new Map<number, DataBlock>();
        this.loadInitialBlocks();
    }

    private loadInitialBlocks(): void {
        // Simulate loading some blocks into memory
        this.blockCache.set(1, { blockId: 1, startKey: 100, endKey: 199, data: new Uint8Array(1024) });
        this.blockCache.set(2, { blockId: 2, startKey: 200, endKey: 299, data: new Uint8Array(1024) });
        this.blockCache.set(3, { blockId: 3, startKey: 300, endKey: 399, data: new Uint8Array(1024) });
    }

    private containsKey(block: DataBlock, key: number): boolean {
        return key >= block.startKey && key <= block.endKey;
    }

    public getBlockContainingKey(userKey: number): DataBlock | null {
        for (const block of this.blockCache.values()) {
            if (this.containsKey(block, userKey)) {
                console.log(`Accessing block ${block.blockId} for key ${userKey}.`);
                return block;
            }
        }
        console.log(`No block found for key ${userKey}.`);
        return null;
    }

    public writeDataToBlock(blockId: number, key: number, dataToWrite: Uint8Array): void {
        const block = this.blockCache.get(blockId);
        if (block) {
            if (this.containsKey(block, key)) {
                // Simulate writing data within the block's boundaries
                // In a real DB, this would involve managing offsets and lengths within the block.data Uint8Array.
                console.log(`Writing data to block ${blockId} for key ${key}. (Simulated)`);
                // For actual data modification: block.data.set(dataToWrite, offset);
            } else {
                console.log(`Key ${key} is outside the range of block ${blockId}.`);
            }
        } else {
            console.log(`Block ${blockId} not found in cache.`);
        }
    }
}
```

### ğŸ§ª Senaryo 7: Bir terminal uygulamasÄ±nda komut geÃ§miÅŸi sÄ±nÄ±rlÄ± sayÄ±da kayÄ±tla tutuluyor. KullanÄ±cÄ± daha fazla komut girdiÄŸinde eski kayÄ±tlar bellekte kaydÄ±rÄ±larak yenileri ekleniyor. Komutlar farklÄ± uzunlukta olabildiÄŸi iÃ§in buffer boyutu dinamik ayarlanÄ±yor. Sistem gelen komutun uzunluÄŸuna gÃ¶re alan oluÅŸturuyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 49
```csharp

using System;
using System.Collections.Generic;
using System.Linq;

public class TerminalCommandHistory
{
    private List<string> commandHistory;
    private int maxHistorySize;

    public TerminalCommandHistory(int maxHistorySize)
    {
        this.maxHistorySize = maxHistorySize;
        this.commandHistory = new List<string>(maxHistorySize);
    }

    public void AddCommand(string command)
    {
        if (commandHistory.Count >= maxHistorySize)
        {
            // Remove the oldest command to make space for the new one
            // This simulates shifting, effectively discarding the oldest entry.
            commandHistory.RemoveAt(0);
        }
        commandHistory.Add(command);

        // In this C# List<string> implementation, the buffer size (underlying array)
        // is managed by the List itself. When adding elements, if capacity is exceeded,
        // the List automatically allocates a larger array and copies elements.
        // The "dynamic buffer adjustment" for varying command lengths is implicitly handled
        // as strings in C# are objects whose memory is managed independently of the List's underlying array.
        Console.WriteLine($"Command added: '{command}'. History size: {commandHistory.Count}");
    }

    public List<string> GetHistory()
    {
        return new List<string>(commandHistory); // Return a copy to prevent external modification
    }

    public void PrintHistory()
    {
        Console.WriteLine("\n--- Command History ---");
        for (int i = 0; i < commandHistory.Count; i++)
        {
            Console.WriteLine($"{i + 1}: {commandHistory[i]}");
        }
        Console.WriteLine("-----------------------\n");
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 35
```python

from collections import deque

class TerminalCommandHistory:
    def __init__(self, max_history_size: int):
        self.max_history_size = max_history_size
        # deque (double-ended queue) is efficient for appending and popping from ends
        self.command_history = deque(maxlen=max_history_size)

    def add_command(self, command: str):
        # When using deque with maxlen, adding an element automatically
        # removes the oldest element if the maxlen is reached.
        # This elegantly handles the "shifting" and "dynamic buffer adjustment" for strings.
        self.command_history.append(command)
        print(f"Command added: '{command}'. History size: {len(self.command_history)}")

    def get_history(self) -> list[str]:
        return list(self.command_history) # Return a list copy

    def print_history(self):
        print("\n--- Command History ---")
        for i, command in enumerate(self.command_history):
            print(f"{i + 1}: {command}")
        print("-----------------------\n")

# Example Usage:
# history = TerminalCommandHistory(5)
# history.add_command("ls -l")
# history.add_command("cd /home/user")
# history.add_command("python script.py")
# history.add_command("git status")
# history.add_command("npm install")
# history.print_history()
# history.add_command("vim my_file.txt") # This will push out "ls -l"
# history.print_history()
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 36
```typescript

class TerminalCommandHistory {
    private commandHistory: string[];
    private maxHistorySize: number;

    constructor(maxHistorySize: number) {
        this.maxHistorySize = maxHistorySize;
        this.commandHistory = [];
    }

    public addCommand(command: string): void {
        if (this.commandHistory.length >= this.maxHistorySize) {
            // Remove the oldest command (at index 0)
            this.commandHistory.shift(); // This mutates the array by removing the first element
        }
        this.commandHistory.push(command);

        // In TypeScript/JavaScript arrays, when elements are added or removed,
        // the underlying memory management for variable-length strings is handled automatically.
        // The "dynamic buffer adjustment" for varying command lengths is implicitly handled
        // as strings are reference types and their memory is managed by the JS engine, not by the array's contiguous block.
        console.log(`Command added: '${command}'. History size: ${this.commandHistory.length}`);
    }

    public getHistory(): string[] {
        return [...this.commandHistory]; // Return a shallow copy to prevent external modification
    }

    public printHistory(): void {
        console.log("\n--- Command History ---");
        this.commandHistory.forEach((cmd, index) => {
            console.log(`${index + 1}: ${cmd}`);
        });
        console.log("-----------------------\n");
    }
}
```

### ğŸ§ª Senaryo 8: Bir gÃ¶rÃ¼ntÃ¼ iÅŸleme kÃ¼tÃ¼phanesi gelen kamera verilerini kare kare analiz ediyor. Her kare belleÄŸe tampon aracÄ±lÄ±ÄŸÄ±yla alÄ±nÄ±yor. Kamera Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ deÄŸiÅŸtiÄŸinde buffer boyutu bu duruma gÃ¶re ayarlanÄ±yor. Bu sayede bellek sÄ±nÄ±rlarÄ± iÃ§inde iÅŸlem yapÄ±lÄ±yor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 63
```csharp

using System;
using System.Linq;

public class CameraFeedProcessor
{
    private byte[] frameBuffer;
    private int currentWidth;
    private int currentHeight;
    private int bytesPerPixel; // e.g., 3 for RGB, 4 for RGBA

    public CameraFeedProcessor(int initialWidth, int initialHeight, int bytesPerPixel)
    {
        this.currentWidth = initialWidth;
        this.currentHeight = initialHeight;
        this.bytesPerPixel = bytesPerPixel;
        AllocateBuffer();
    }

    private void AllocateBuffer()
    {
        int requiredSize = currentWidth * currentHeight * bytesPerPixel;
        frameBuffer = new byte[requiredSize];
        Console.WriteLine($"Buffer allocated for resolution {currentWidth}x{currentHeight}, size: {requiredSize} bytes.");
    }

    public void SetCameraResolution(int newWidth, int newHeight)
    {
        if (newWidth <= 0 || newHeight <= 0)
        {
            throw new ArgumentException("Resolution dimensions must be positive.");
        }

        if (newWidth != currentWidth || newHeight != currentHeight)
        {
            currentWidth = newWidth;
            currentHeight = newHeight;
            AllocateBuffer(); // Reallocate buffer for the new resolution
            Console.WriteLine($"Camera resolution changed to {newWidth}x{newHeight}. Buffer reallocated.");
        }
        else
        {
            Console.WriteLine("Resolution is already set to the requested values. No buffer change.");
        }
    }

    public void ProcessFrame(byte[] cameraData)
    {
        int expectedSize = currentWidth * currentHeight * bytesPerPixel;
        if (cameraData.Length != expectedSize)
        {
            Console.WriteLine($"Warning: Incoming frame data size mismatch. Expected {expectedSize}, got {cameraData.Length}.");
            // In a real system, you might handle this by reallocating or logging an error
            return;
        }

        // Copy camera data to the internal buffer
        Buffer.BlockCopy(cameraData, 0, frameBuffer, 0, expectedSize);

        // Simulate frame analysis
        Console.WriteLine($"Processing frame ({currentWidth}x{currentHeight}). First few bytes: {BitConverter.ToString(frameBuffer, 0, Math.Min(10, frameBuffer.Length))}");
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 45
```python

class CameraFeedProcessor:
    def __init__(self, initial_width: int, initial_height: int, bytes_per_pixel: int):
        self.current_width = initial_width
        self.current_height = initial_height
        self.bytes_per_pixel = bytes_per_pixel
        self.frame_buffer = bytearray()
        self._allocate_buffer()

    def _allocate_buffer(self):
        required_size = self.current_width * self.current_height * self.bytes_per_pixel
        self.frame_buffer = bytearray(required_size)
        print(f"Buffer allocated for resolution {self.current_width}x{self.current_height}, size: {required_size} bytes.")

    def set_camera_resolution(self, new_width: int, new_height: int):
        if new_width <= 0 or new_height <= 0:
            raise ValueError("Resolution dimensions must be positive.")

        if new_width != self.current_width or new_height != self.current_height:
            self.current_width = new_width
            self.current_height = new_height
            self._allocate_buffer() # Reallocate buffer for the new resolution
            print(f"Camera resolution changed to {new_width}x{new_height}. Buffer reallocated.")
        else:
            print("Resolution is already set to the requested values. No buffer change.")

    def process_frame(self, camera_data: bytes):
        expected_size = self.current_width * self.current_height * self.bytes_per_pixel
        if len(camera_data) != expected_size:
            print(f"Warning: Incoming frame data size mismatch. Expected {expected_size}, got {len(camera_data)}.")
            return

        # Copy camera data to the internal buffer
        self.frame_buffer[:] = camera_data[:] # Efficiently copies data

        # Simulate frame analysis
        print(f"Processing frame ({self.current_width}x{self.current_height}). First few bytes: {self.frame_buffer[:10].hex()}")

# Example Usage:
# processor = CameraFeedProcessor(640, 480, 3) # RGB
# dummy_frame_data = b'\x01' * (640 * 480 * 3)
# processor.process_frame(dummy_frame_data)
# processor.set_camera_resolution(1280, 720)
# new_dummy_frame_data = b'\x02' * (1280 * 720 * 3)
# processor.process_frame(new_dummy_frame_data)
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 52
```typescript

class CameraFeedProcessor {
    private frameBuffer: Uint8Array;
    private currentWidth: number;
    private currentHeight: number;
    private bytesPerPixel: number; // e.g., 3 for RGB, 4 for RGBA

    constructor(initialWidth: number, initialHeight: number, bytesPerPixel: number) {
        this.currentWidth = initialWidth;
        this.currentHeight = initialHeight;
        this.bytesPerPixel = bytesPerPixel;
        this.frameBuffer = new Uint8Array(0); // Initialize as empty
        this.allocateBuffer();
    }

    private allocateBuffer(): void {
        const requiredSize = this.currentWidth * this.currentHeight * this.bytesPerPixel;
        this.frameBuffer = new Uint8Array(requiredSize);
        console.log(`Buffer allocated for resolution ${this.currentWidth}x${this.currentHeight}, size: ${requiredSize} bytes.`);
    }

    public setCameraResolution(newWidth: number, newHeight: number): void {
        if (newWidth <= 0 || newHeight <= 0) {
            throw new Error("Resolution dimensions must be positive.");
        }

        if (newWidth !== this.currentWidth || newHeight !== this.currentHeight) {
            this.currentWidth = newWidth;
            this.currentHeight = newHeight;
            this.allocateBuffer(); // Reallocate buffer for the new resolution
            console.log(`Camera resolution changed to ${newWidth}x${newHeight}. Buffer reallocated.`);
        } else {
            console.log("Resolution is already set to the requested values. No buffer change.");
        }
    }

    public processFrame(cameraData: Uint8Array): void {
        const expectedSize = this.currentWidth * this.currentHeight * this.bytesPerPixel;
        if (cameraData.length !== expectedSize) {
            console.log(`Warning: Incoming frame data size mismatch. Expected ${expectedSize}, got ${cameraData.length}.`);
            // In a real system, you might handle this by reallocating or logging an error
            return;
        }

        // Copy camera data to the internal buffer
        this.frameBuffer.set(cameraData);

        // Simulate frame analysis
        const firstFewBytes = Array.from(this.frameBuffer.slice(0, Math.min(10, this.frameBuffer.length))).map(b => b.toString(16).padStart(2, '0')).join('');
        console.log(`Processing frame (${this.currentWidth}x${this.currentHeight}). First few bytes: ${firstFewBytes}`);
    }
}
```

### ğŸ§ª Senaryo 9: Bir hesaplama aracÄ± kullanÄ±cÄ±dan alÄ±nan sayÄ± dizisini bir diziye aktarÄ±yor ve iÅŸlem yapÄ±yor. KullanÄ±cÄ±nÄ±n girdiÄŸi eleman sayÄ±sÄ± sistemdeki diziden farklÄ± olabiliyor. Sistem bu sayÄ±yÄ± deÄŸerlendirerek dizi boyutunu ayarlÄ±yor. Bu ÅŸekilde bellekte uygun bÃ¶lgelere eriÅŸim saÄŸlanÄ±yor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 47
```csharp

using System;
using System.Linq;

public class NumericProcessor
{
    private double[] dataArray;

    public NumericProcessor()
    {
        dataArray = new double[0]; // Initialize with an empty array
    }

    public void LoadNumbers(double[] userNumbers)
    {
        // Adjust array size based on user input
        // C# arrays are fixed-size once created, so we create a new one if size changes.
        // For more dynamic resizing without re-creation, List<T> is often preferred.
        // However, this scenario specifically mentions "array" and "adjusting size".
        if (dataArray.Length != userNumbers.Length)
        {
            dataArray = new double[userNumbers.Length];
            Console.WriteLine($"Array resized to {userNumbers.Length} elements.");
        }

        // Copy user input to the internal array
        Array.Copy(userNumbers, dataArray, userNumbers.Length);
        Console.WriteLine($"Loaded {userNumbers.Length} numbers into the array.");
    }

    public double CalculateSum()
    {
        return dataArray.Sum();
    }

    public double GetValueAtIndex(int index)
    {
        if (index >= 0 && index < dataArray.Length)
        {
            return dataArray[index];
        }
        else
        {
            throw new IndexOutOfRangeException("Index is out of bounds for the current data array.");
        }
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 30
```python

class NumericProcessor:
    def __init__(self):
        self.data_array = [] # Python lists are dynamic arrays

    def load_numbers(self, user_numbers: list[float]):
        # In Python, lists automatically adjust their size.
        # Assigning a new list effectively "adjusts the array size" and copies the data.
        self.data_array = list(user_numbers) # Create a new list from the input
        print(f"Loaded {len(user_numbers)} numbers into the array.")
        # If we were strictly managing a fixed-size buffer, we'd use bytearray/array.array
        # and slice/copy, but for a "sequence of numbers", a list is the natural fit.

    def calculate_sum(self) -> float:
        return sum(self.data_array)

    def get_value_at_index(self, index: int) -> float:
        if 0 <= index < len(self.data_array):
            return self.data_array[index]
        else:
            raise IndexError("Index is out of bounds for the current data array.")

# Example Usage:
# processor = NumericProcessor()
# processor.load_numbers([1.0, 2.5, 3.7])
# print(f"Sum: {processor.calculate_sum()}")
# print(f"Value at index 1: {processor.get_value_at_index(1)}")
#
# processor.load_numbers([10.0, 20.0, 30.0, 40.0, 50.0]) # Array size adjusts
# print(f"New sum: {processor.calculate_sum()}")
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 29
```typescript

class NumericProcessor {
    private dataArray: number[]; // TypeScript arrays (JavaScript arrays) are dynamic

    constructor() {
        this.dataArray = []; // Initialize as an empty array
    }

    public loadNumbers(userNumbers: number[]): void {
        // In TypeScript/JavaScript, arrays are dynamic.
        // Assigning a new array to `dataArray` effectively "adjusts the array size" and copies the data.
        this.dataArray = [...userNumbers]; // Create a new array from the input (spread operator for copying)
        console.log(`Loaded ${userNumbers.length} numbers into the array.`);
        // If we needed a fixed-size typed array for performance/memory reasons (e.g., Float64Array),
        // the logic would involve creating a new typed array of the correct size.
    }

    public calculateSum(): number {
        return this.dataArray.reduce((sum, current) => sum + current, 0);
    }

    public getValueAtIndex(index: number): number {
        if (index >= 0 && index < this.dataArray.length) {
            return this.dataArray[index];
        } else {
            throw new Error("Index is out of bounds for the current data array.");
        }
    }
}
```

### ğŸ§ª Senaryo 10: Bir video oynatÄ±cÄ± yazÄ±lÄ±mÄ± oynatma sÄ±rasÄ±nda ses ve video karelerini farklÄ± tamponlara alÄ±yor. Video Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ bÃ¼yÃ¼dÃ¼kÃ§e tampon alan gereksinimleri artÄ±yor. Sistem Ã§Ã¶zÃ¼nÃ¼rlÃ¼k deÄŸiÅŸimini belleÄŸe yansÄ±tÄ±yor. Bu durum tampon boyutu sorunlarÄ±nÄ± Ã¶nleyecek ÅŸekilde yÃ¶netiliyor.
**ğŸ’» Dil:** `C#`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 89
```csharp

using System;

public class VideoPlayer
{
    private byte[] videoFrameBuffer;
    private byte[] audioSampleBuffer;
    private int currentVideoWidth;
    private int currentVideoHeight;
    private int bytesPerPixel; // For video frames
    private int audioSampleSizeBytes; // For audio samples

    public VideoPlayer(int initialVideoWidth, int initialVideoHeight, int initialAudioSampleSizeBytes)
    {
        currentVideoWidth = initialVideoWidth;
        currentVideoHeight = initialVideoHeight;
        bytesPerPixel = 4; // Assuming RGBA for video
        audioSampleSizeBytes = initialAudioSampleSizeBytes;

        AllocateBuffers();
    }

    private void AllocateBuffers()
    {
        // Video buffer allocation
        int videoBufferSize = currentVideoWidth * currentVideoHeight * bytesPerPixel;
        videoFrameBuffer = new byte[videoBufferSize];
        Console.WriteLine($"Video buffer allocated: {videoBufferSize} bytes for {currentVideoWidth}x{currentVideoHeight}.");

        // Audio buffer allocation (example fixed size for simplicity, but could be dynamic)
        int audioBufferSize = 48000 * 2 * 2; // e.g., 1 second of 48kHz, 16-bit stereo audio
        audioSampleBuffer = new byte[audioBufferSize];
        Console.WriteLine($"Audio buffer allocated: {audioBufferSize} bytes.");
    }

    public void SetVideoResolution(int newWidth, int newHeight)
    {
        if (newWidth <= 0 || newHeight <= 0)
        {
            throw new ArgumentException("Video resolution dimensions must be positive.");
        }

        if (newWidth != currentVideoWidth || newHeight != currentVideoHeight)
        {
            currentVideoWidth = newWidth;
            currentVideoHeight = newHeight;
            AllocateBuffers(); // Reallocate video buffer due to resolution change
            Console.WriteLine($"Video resolution changed to {newWidth}x{newHeight}. Video buffer reallocated.");
        }
        else
        {
            Console.WriteLine("Video resolution is already set to the requested values. No video buffer change.");
        }
    }

    // Simulate receiving and processing a video frame
    public void ReceiveVideoFrame(byte[] frameData)
    {
        int expectedSize = currentVideoWidth * currentVideoHeight * bytesPerPixel;
        if (frameData.Length != expectedSize)
        {
            Console.WriteLine($"Error: Video frame data size mismatch. Expected {expectedSize}, got {frameData.Length}.");
            return;
        }

        Buffer.BlockCopy(frameData, 0, videoFrameBuffer, 0, expectedSize);
        // Process video frame from videoFrameBuffer
        Console.WriteLine("Video frame received and buffered.");
    }

    // Simulate receiving and processing audio samples
    public void ReceiveAudioSamples(byte[] sampleData)
    {
        // For simplicity, assuming sampleData fits into audioSampleBuffer
        // In a real player, this would likely be a ring buffer or a queue
        // and audio data would be consumed by the audio output device.
        if (sampleData.Length > audioSampleBuffer.Length)
        {
            Console.WriteLine($"Warning: Audio sample data too large for buffer. Truncating. Expected max {audioSampleBuffer.Length}, got {sampleData.Length}.");
            Buffer.BlockCopy(sampleData, 0, audioSampleBuffer, 0, audioSampleBuffer.Length);
        }
        else
        {
            Buffer.BlockCopy(sampleData, 0, audioSampleBuffer, 0, sampleData.Length);
        }
        // Process audio samples from audioSampleBuffer
        Console.WriteLine("Audio samples received and buffered.");
    }
}
```
**ğŸ’» Dil:** `Python`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 67
```python

class VideoPlayer:
    def __init__(self, initial_video_width: int, initial_video_height: int, initial_audio_sample_bytes: int):
        self.current_video_width = initial_video_width
        self.current_video_height = initial_video_height
        self.bytes_per_pixel = 4 # Assuming RGBA for video
        self.audio_sample_bytes = initial_audio_sample_bytes

        self.video_frame_buffer = bytearray()
        self.audio_sample_buffer = bytearray()
        self._allocate_buffers()

    def _allocate_buffers(self):
        # Video buffer allocation
        video_buffer_size = self.current_video_width * self.current_video_height * self.bytes_per_pixel
        self.video_frame_buffer = bytearray(video_buffer_size)
        print(f"Video buffer allocated: {video_buffer_size} bytes for {self.current_video_width}x{self.current_video_height}.")

        # Audio buffer allocation (example fixed size for simplicity)
        audio_buffer_size = 48000 * 2 * 2 # e.g., 1 second of 48kHz, 16-bit stereo audio
        self.audio_sample_buffer = bytearray(audio_buffer_size)
        print(f"Audio buffer allocated: {audio_buffer_size} bytes.")

    def set_video_resolution(self, new_width: int, new_height: int):
        if new_width <= 0 or new_height <= 0:
            raise ValueError("Video resolution dimensions must be positive.")

        if new_width != self.current_video_width or new_height != self.current_video_height:
            self.current_video_width = new_width
            self.current_video_height = new_height
            self._allocate_buffers() # Reallocate video buffer due to resolution change
            print(f"Video resolution changed to {new_width}x{new_height}. Video buffer reallocated.")
        else:
            print("Video resolution is already set to the requested values. No video buffer change.")

    # Simulate receiving and processing a video frame
    def receive_video_frame(self, frame_data: bytes):
        expected_size = self.current_video_width * self.current_video_height * self.bytes_per_pixel
        if len(frame_data) != expected_size:
            print(f"Error: Video frame data size mismatch. Expected {expected_size}, got {len(frame_data)}.")
            return

        self.video_frame_buffer[:] = frame_data[:] # Efficiently copies data
        # Process video frame from video_frame_buffer
        print("Video frame received and buffered.")

    # Simulate receiving and processing audio samples
    def receive_audio_samples(self, sample_data: bytes):
        # For simplicity, assuming sample_data fits into audio_sample_buffer
        # In a real player, this would likely be a ring buffer or a queue
        # and audio data would be consumed by the audio output device.
        if len(sample_data) > len(self.audio_sample_buffer):
            print(f"Warning: Audio sample data too large for buffer. Truncating. Expected max {len(self.audio_sample_buffer)}, got {len(sample_data)}.")
            self.audio_sample_buffer[:] = sample_data[:len(self.audio_sample_buffer)]
        else:
            self.audio_sample_buffer[:] = sample_data[:]
        # Process audio samples from audio_sample_buffer
        print("Audio samples received and buffered.")

# Example Usage:
# player = VideoPlayer(1920, 1080, 4) # Full HD, 4 bytes per sample (e.g., 32-bit float)
# dummy_video_frame = b'\xFF' * (1920 * 1080 * 4)
# player.receive_video_frame(dummy_video_frame)
# dummy_audio_samples = b'\xAA' * (48000 * 2 * 2)
# player.receive_audio_samples(dummy_audio_samples)
#
# player.set_video_resolution(1280, 720) # Change resolution, buffer should reallocate
```
**ğŸ’» Dil:** `TypeScript`

**ğŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 74
```typescript

class VideoPlayer {
    private videoFrameBuffer: Uint8Array;
    private audioSampleBuffer: Uint8Array;
    private currentVideoWidth: number;
    private currentVideoHeight: number;
    private bytesPerPixel: number; // For video frames
    private audioSampleSizeBytes: number; // For audio samples (e.g., 2 bytes for 16-bit)

    constructor(initialVideoWidth: number, initialVideoHeight: number, initialAudioSampleSizeBytes: number) {
        this.currentVideoWidth = initialVideoWidth;
        this.currentVideoHeight = initialVideoHeight;
        this.bytesPerPixel = 4; // Assuming RGBA for video
        this.audioSampleSizeBytes = initialAudioSampleSizeBytes;

        this.videoFrameBuffer = new Uint8Array(0); // Initialize as empty
        this.audioSampleBuffer = new Uint8Array(0); // Initialize as empty
        this.allocateBuffers();
    }

    private allocateBuffers(): void {
        // Video buffer allocation
        const videoBufferSize = this.currentVideoWidth * this.currentVideoHeight * this.bytesPerPixel;
        this.videoFrameBuffer = new Uint8Array(videoBufferSize);
        console.log(`Video buffer allocated: ${videoBufferSize} bytes for ${this.currentVideoWidth}x${this.currentVideoHeight}.`);

        // Audio buffer allocation (example fixed size for simplicity, but could be dynamic)
        const audioBufferSize = 48000 * 2 * this.audioSampleSizeBytes; // e.g., 1 second of 48kHz, stereo audio
        this.audioSampleBuffer = new Uint8Array(audioBufferSize);
        console.log(`Audio buffer allocated: ${audioBufferSize} bytes.`);
    }

    public setVideoResolution(newWidth: number, newHeight: number): void {
        if (newWidth <= 0 || newHeight <= 0) {
            throw new Error("Video resolution dimensions must be positive.");
        }

        if (newWidth !== this.currentVideoWidth || newHeight !== this.currentVideoHeight) {
            this.currentVideoWidth = newWidth;
            this.currentVideoHeight = newHeight;
            this.allocateBuffers(); // Reallocate video buffer due to resolution change
            console.log(`Video resolution changed to ${newWidth}x${newHeight}. Video buffer reallocated.`);
        } else {
            console.log("Video resolution is already set to the requested values. No video buffer change.");
        }
    }

    // Simulate receiving and processing a video frame
    public receiveVideoFrame(frameData: Uint8Array): void {
        const expectedSize = this.currentVideoWidth * this.currentVideoHeight * this.bytesPerPixel;
        if (frameData.length !== expectedSize) {
            console.log(`Error: Video frame data size mismatch. Expected ${expectedSize}, got ${frameData.length}.`);
            return;
        }

        this.videoFrameBuffer.set(frameData);
        // Process video frame from videoFrameBuffer
        console.log("Video frame received and buffered.");
    }

    // Simulate receiving and processing audio samples
    public receiveAudioSamples(sampleData: Uint8Array): void {
        // For simplicity, assuming sampleData fits into audioSampleBuffer
        // In a real player, this would likely be a ring buffer or a queue
        // and audio data would be consumed by the audio output device.
        if (sampleData.length > this.audioSampleBuffer.length) {
            console.log(`Warning: Audio sample data too large for buffer. Truncating. Expected max ${this.audioSampleBuffer.length}, got ${sampleData.length}.`);
            this.audioSampleBuffer.set(sampleData.slice(0, this.audioSampleBuffer.length));
        } else {
            this.audioSampleBuffer.set(sampleData);
        }
        // Process audio samples from audioSampleBuffer
        console.log("Audio samples received and buffered.");
    }
```
}