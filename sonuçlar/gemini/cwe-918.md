### ðŸ§ª Senaryo 1: Bir web uygulamasÄ± kullanÄ±cÄ±larÄ±n belirttiÄŸi URL'lerden veri Ã§eker. KullanÄ±cÄ±lar RSS feed adresleri veya API endpoint'leri girebilir. Sistem bu adreslere istek gÃ¶ndererek iÃ§eriÄŸi alÄ±r. Ä°Ã§erik iÅŸlendikten sonra kullanÄ±cÄ±ya sunulur.
**ðŸ’» Dil:** `C#`
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 86
```csharp
using System;
using System.Net.Http;
using System.Threading.Tasks;
using System.Xml.Linq;
using Newtonsoft.Json;

public class DataFetcher
{
    private readonly HttpClient _httpClient;

    public DataFetcher()
    {
        _httpClient = new HttpClient();
    }

    public async Task<string> FetchAndProcessContent(string url)
    {
        try
        {
            HttpResponseMessage response = await _httpClient.GetAsync(url);
            response.EnsureSuccessStatusCode(); // Throws an exception if the HTTP response status is an error code.
            string content = await response.Content.ReadAsStringAsync();

            // Simple content processing based on presumed type
            if (url.EndsWith(".xml") || url.Contains("rss"))
            {
                // Assume it's an RSS feed
                XDocument doc = XDocument.Parse(content);
                return $"XML/RSS Content Processed: {doc.Root.Name}";
            }
            else if (response.Content.Headers.ContentType?.MediaType == "application/json")
            {
                // Assume it's JSON from an API endpoint
                dynamic json = JsonConvert.DeserializeObject(content);
                return $"JSON Content Processed: {json.ToString()}";
            }
            else
            {
                // Generic HTML or text content
                return $"Generic Content Fetched: {content.Substring(0, Math.Min(content.Length, 100))}...";
            }
        }
        catch (HttpRequestException e)
        {
            return $"Request error: {e.Message}";
        }
        catch (Exception e)
        {
            return $"An error occurred: {e.Message}";
        }
    }
}
```

**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 28

```python

import requests
import xml.etree.ElementTree as ET
import json

class DataFetcher:
    def fetch_and_process_content(self, url: str) -> str:
        try:
            response = requests.get(url)
            response.raise_for_status()  # Raise an exception for HTTP errors

            content_type = response.headers.get('Content-Type', '')

            if 'xml' in content_type or 'rss' in url:
                # Assume it's an RSS feed
                root = ET.fromstring(response.content)
                return f"XML/RSS Content Processed: {root.tag}"
            elif 'json' in content_type:
                # Assume it's JSON from an API endpoint
                data = response.json()
                return f"JSON Content Processed: {json.dumps(data, indent=2)}"
            else:
                # Generic HTML or text content
                return f"Generic Content Fetched: {response.text[:100]}..."
        except requests.exceptions.RequestException as e:
            return f"Request error: {e}"
        except Exception as e:
            return f"An error occurred: {e}"
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 33
```typescript

import axios from 'axios';
import { XMLParser } from 'fast-xml-parser'; // You might need to install this package

export class DataFetcher {
    async fetchAndProcessContent(url: string): Promise<string> {
        try {
            const response = await axios.get(url, { responseType: 'text' });
            const contentType = response.headers['content-type'];
            const content = response.data;

            if (contentType?.includes('xml') || url.includes('rss')) {
                // Assume it's an RSS feed
                const parser = new XMLParser();
                const xmlContent = parser.parse(content);
                return `XML/RSS Content Processed: ${JSON.stringify(xmlContent, null, 2)}`;
            } else if (contentType?.includes('json')) {
                // Assume it's JSON from an API endpoint
                const jsonContent = JSON.parse(content);
                return `JSON Content Processed: ${JSON.stringify(jsonContent, null, 2)}`;
            } else {
                // Generic HTML or text content
                return `Generic Content Fetched: ${content.substring(0, 100)}...`;
            }
        } catch (error: any) {
            if (axios.isAxiosError(error)) {
                return `Request error: ${error.message}`;
            } else {
                return `An error occurred: ${error.message}`;
            }
        }
    }
}
```

### ðŸ§ª Senaryo 2: Bir iÃ§erik toplama servisi farklÄ± kaynaklardan bilgi alÄ±r. KullanÄ±cÄ±lar veri kaynaÄŸÄ± URL'lerini sisteme kaydedebilir. Servis bu URL'lere dÃ¼zenli olarak eriÅŸim saÄŸlar. Toplanan veriler analiz edilerek raporlanÄ±r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 51
```csharp

using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;

public class ContentAggregatorService
{
    private readonly HttpClient _httpClient;
    private readonly List<string> _dataSourceUrls;

    public ContentAggregatorService()
    {
        _httpClient = new HttpClient();
        _dataSourceUrls = new List<string>();
    }

    public void AddDataSourceUrl(string url)
    {
        if (!_dataSourceUrls.Contains(url))
        {
            _dataSourceUrls.Add(url);
            Console.WriteLine(<span class="math-inline">"Added data source URL\: \{url\}"\);
\}
\}
public async Task<List<string\>\> CollectAndAnalyzeData\(\)
\{
List<string\> collectedData \= new List<string\>\(\);
foreach \(var url in \_dataSourceUrls\)
\{
try
\{
HttpResponseMessage response \= await \_httpClient\.GetAsync\(url\);
response\.EnsureSuccessStatusCode\(\);
string content \= await response\.Content\.ReadAsStringAsync\(\);
collectedData\.Add\(</span>"Data from {url}: {content.Substring(0, Math.Min(content.Length, 100))}...");
                // In a real scenario, deeper analysis would occur here
                Console.WriteLine(<span class="math-inline">"Successfully collected data from \{url\}"\);
\}
catch \(HttpRequestException e\)
\{
collectedData\.Add\(</span>"Error collecting from {url}: {e.Message}");
                Console.WriteLine($"Error collecting data from {url}: {e.Message}");
            }
        }
        // Simulate reporting
        Console.WriteLine("\n--- Data Collection Report ---");
        collectedData.ForEach(Console.WriteLine);
        return collectedData;
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 32
```python

import requests
import time

class ContentAggregatorService:
    def __init__(self):
        self.data_source_urls = []

    def add_data_source_url(self, url: str):
        if url not in self.data_source_urls:
            self.data_source_urls.append(url)
            print(f"Added data source URL: {url}")

    def collect_and_analyze_data(self) -> list[str]:
        collected_data = []
        for url in self.data_source_urls:
            try:
                response = requests.get(url)
                response.raise_for_status()
                content = response.text
                collected_data.append(f"Data from {url}: {content[:100]}...")
                # In a real scenario, deeper analysis would occur here
                print(f"Successfully collected data from {url}")
            except requests.exceptions.RequestException as e:
                collected_data.append(f"Error collecting from {url}: {e}")
                print(f"Error collecting data from {url}: {e}")
            time.sleep(1) # Simulate regular access

        print("\n--- Data Collection Report ---")
        for data in collected_data:
            print(data)
        return collected_data
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 39
```typescript

import axios from 'axios';

export class ContentAggregatorService {
    private dataSourceUrls: string[] = [];

    public addDataSourceUrl(url: string): void {
        if (!this.dataSourceUrls.includes(url)) {
            this.dataSourceUrls.push(url);
            console.log(`Added data source URL: ${url}`);
        }
    }

    public async collectAndAnalyzeData(): Promise<string[]> {
        const collectedData: string[] = [];
        for (const url of this.dataSourceUrls) {
            try {
                const response = await axios.get(url);
                const content = response.data;
                collectedData.push(`Data from ${url}: ${String(content).substring(0, 100)}...`);
                // In a real scenario, deeper analysis would occur here
                console.log(`Successfully collected data from ${url}`);
            } catch (error: any) {
                if (axios.isAxiosError(error)) {
                    collectedData.push(`Error collecting from ${url}: ${error.message}`);
                    console.error(`Error collecting data from ${url}: ${error.message}`);
                } else {
                    collectedData.push(`An unexpected error occurred for ${url}: ${error.message}`);
                    console.error(`An unexpected error occurred for ${url}: ${error.message}`);
                }
            }
            await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate regular access
        }

        console.log("\n--- Data Collection Report ---");
        collectedData.forEach(data => console.log(data));
        return collectedData;
    }
}
```

### ðŸ§ª Senaryo 3: Bir web sayfasÄ± Ã¶nizleme aracÄ± URL'leri ziyaret ederek ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alÄ±r. KullanÄ±cÄ±lar Ã¶nizlemek istedikleri web sayfasÄ± adresini girebilir. Sistem belirtilen sayfaya eriÅŸerek gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ oluÅŸturur. OluÅŸturulan Ã¶nizleme kullanÄ±cÄ±ya gÃ¶sterilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 36
```csharp

// This scenario typically requires a headless browser automation library like Selenium or Playwright.
// The following is a conceptual outline, as a full implementation would be extensive.

using System;
using System.IO;
using System.Threading.Tasks;
// using OpenQA.Selenium;
// using OpenQA.Selenium.Chrome; // Example for Chrome

public class WebpagePreviewTool
{
    public async Task<string> GenerateWebpagePreview(string url, string outputPath)
    {
        // For a real application, you'd use a headless browser like Chrome or Firefox
        // For demonstration, we'll simulate the process.

        // Example using Playwright (requires Playwright package)
        /*
        using var playwright = await Playwright.CreateAsync();
        await using var browser = await playwright.Chromium.LaunchAsync();
        var page = await browser.NewPageAsync();
        await page.GotoAsync(url);
        await page.ScreenshotAsync(new PageScreenshotOptions { Path = outputPath });
        return $"Screenshot saved to: {outputPath}";
        */

        // Placeholder for actual screenshot generation
        string simulatedScreenshotPath = Path.Combine(outputPath, <span class="math-inline">"preview\_\{Guid\.NewGuid\(\)\.ToString\(\)\}\.png"\);
Console\.WriteLine\(</span>"Simulating screenshot generation for {url}...");
        File.WriteAllText(simulatedScreenshotPath, <span class="math-inline">"Simulated content for \{url\}"\); // Create a dummy file
await Task\.Delay\(100\); // Simulate some work
Console\.WriteLine\(</span>"Simulated preview generated at: {simulatedScreenshotPath}");
        return simulatedScreenshotPath;
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 30
```python

# This scenario typically requires a headless browser automation library like Selenium or Playwright.
# You would need to install 'playwright' and 'playwright install' for the browsers.

import asyncio
from playwright.async_api import Playwright, async_playwright, expect
import os

class WebpagePreviewTool:
    async def generate_webpage_preview(self, url: str, output_dir: str = "previews") -> str:
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        try:
            async with async_playwright() as playwright:
                browser = await playwright.chromium.launch()
                page = await browser.new_page()
                await page.goto(url)

                # Generate a unique filename for the screenshot
                filename = f"preview_{hash(url)}.png"
                output_path = os.path.join(output_dir, filename)

                await page.screenshot(path=output_path)
                await browser.close()
                print(f"Screenshot saved to: {output_path}")
                return output_path
        except Exception as e:
            print(f"Error generating preview for {url}: {e}")
            return f"Error: {e}"
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 36
```typescript

// This scenario typically requires a headless browser automation library like Playwright.
// You would need to install 'playwright'.

import { chromium, Page } from 'playwright';
import * as path from 'path';
import * as fs from 'fs';

export class WebpagePreviewTool {
    public async generateWebpagePreview(url: string, outputDir: string = 'previews'): Promise<string> {
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        let browser;
        try {
            browser = await chromium.launch();
            const page: Page = await browser.newPage();
            await page.goto(url);

            const filename = `preview_${new Date().getTime()}.png`;
            const outputPath = path.join(outputDir, filename);

            await page.screenshot({ path: outputPath });
            console.log(`Screenshot saved to: ${outputPath}`);
            return outputPath;
        } catch (error: any) {
            console.error(`Error generating preview for ${url}:`, error);
            return `Error: ${error.message}`;
        } finally {
            if (browser) {
                await browser.close();
            }
        }
    }
}
```

### ðŸ§ª Senaryo 4: Bir API proxy servisi istemci isteklerini hedef sunuculara yÃ¶nlendirir. Ä°stemciler hangi API'ye eriÅŸmek istediklerini belirtir. Proxy servisi bu istekleri hedef sunucuya iletir. YanÄ±t alÄ±ndÄ±ÄŸÄ±nda istemciye geri dÃ¶ndÃ¼rÃ¼lÃ¼r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 73
```csharp

using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System.Net.Http;
using System.Threading.Tasks;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddHttpClient(); // Registers HttpClient for dependency injection
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        app.Run(async context =>
        {
            var targetApiUrl = context.Request.Query["targetApi"].ToString(); // Get target API from query parameter
            if (string.IsNullOrEmpty(targetApiUrl))
            {
                context.Response.StatusCode = StatusCodes.Status400BadRequest;
                await context.Response.WriteAsync("Please provide a 'targetApi' query parameter.");
                return;
            }

            var httpClientFactory = context.RequestServices.GetRequiredService<IHttpClientFactory>();
            var httpClient = httpClientFactory.CreateClient();

            // Create a new HttpRequestMessage to forward the original request
            var request = new HttpRequestMessage(new HttpMethod(context.Request.Method), targetApiUrl + context.Request.QueryString);

            // Copy headers from original request to the new request
            foreach (var header in context.Request.Headers)
            {
                request.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
            }

            // Copy body if present
            if (context.Request.ContentLength > 0)
            {
                request.Content = new StreamContent(context.Request.Body);
                request.Content.Headers.Add("Content-Type", context.Request.ContentType);
            }

            try
            {
                var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);

                // Copy status code and headers from target API response to proxy response
                context.Response.StatusCode = (int)response.StatusCode;
                foreach (var header in response.Headers)
                {
                    context.Response.Headers[header.Key] = header.Value.ToArray();
                }
                foreach (var header in response.Content.Headers)
                {
                    context.Response.Headers[header.Key] = header.Value.ToArray();
                }

                // Copy content from target API response to proxy response
                await response.Content.CopyToAsync(context.Response.Body);
            }
            catch (HttpRequestException ex)
            {
                context.Response.StatusCode = StatusCodes.Status500InternalServerError;
                await context.Response.WriteAsync($"Error proxying request: {ex.Message}");
            }
        });
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 38
```python

from flask import Flask, request, Response, abort
import requests

app = Flask(__name__)

@app.route('/proxy', defaults={'path': ''}, methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH'])
@app.route('/proxy/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH'])
def proxy(path):
    target_api_url = request.args.get('targetApi')
    if not target_api_url:
        abort(400, "Please provide a 'targetApi' query parameter.")

    full_target_url = f"{target_api_url}/{path}" if path else target_api_url

    headers = {key: value for key, value in request.headers if key.lower() != 'host'}

    try:
        resp = requests.request(
            method=request.method,
            url=full_target_url,
            headers=headers,
            data=request.get_data(),
            params=request.args,
            allow_redirects=False,
            stream=True # Stream the response for efficiency
        )

        excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection']
        response_headers = [(name, value) for name, value in resp.raw.headers.items()
                            if name.lower() not in excluded_headers]

        return Response(resp.content, resp.status_code, response_headers)
    except requests.exceptions.RequestException as e:
        abort(500, f"Error proxying request: {e}")

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 56
```typescript

import express from 'express';
import axios from 'axios';
import { Request, Response } from 'express';

const app = express();
const port = 3000;

app.use(express.json()); // For parsing application/json
app.use(express.urlencoded({ extended: true })); // For parsing application/x-www-form-urlencoded

app.all('/proxy', async (req: Request, res: Response) => {
    const targetApiUrl = req.query.targetApi as string;

    if (!targetApiUrl) {
        return res.status(400).send("Please provide a 'targetApi' query parameter.");
    }

    try {
        const axiosConfig = {
            method: req.method,
            url: targetApiUrl,
            headers: { ...req.headers, host: undefined }, // Remove host header to avoid issues
            data: req.body,
            params: req.query,
            responseType: 'stream' // Stream the response
        };

        const response = await axios(axiosConfig as any); // Type assertion for axios config

        // Set status code and headers from the target API response
        res.status(response.status);
        for (const key in response.headers) {
            // Exclude headers that cause issues with Node.js http module or are managed automatically
            if (key !== 'content-encoding' && key !== 'content-length' && key !== 'transfer-encoding') {
                res.setHeader(key, response.headers[key] as string);
            }
        }

        // Pipe the response stream directly to the client
        response.data.pipe(res);

    } catch (error: any) {
        if (axios.isAxiosError(error)) {
            const status = error.response?.status || 500;
            const message = error.response?.data ? JSON.stringify(error.response.data) : error.message;
            res.status(status).send(`Error proxying request: ${message}`);
        } else {
            res.status(500).send(`An unexpected error occurred: ${error.message}`);
        }
    }
});

app.listen(port, () => {
    console.log(`API Proxy Service listening at http://localhost:${port}`);
});
```

### ðŸ§ª Senaryo 5: Bir dosya indirme uygulamasÄ± uzak sunuculardan dosyalarÄ± Ã§eker. KullanÄ±cÄ±lar indirmek istedikleri dosyanÄ±n URL'sini girebilir. Sistem belirtilen adresten dosyayÄ± indirir. Ä°ndirilen dosya kullanÄ±cÄ± depolamasÄ±na kaydedilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 51
```csharp

using System;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;

public class FileDownloader
{
    private readonly HttpClient _httpClient;

    public FileDownloader()
    {
        _httpClient = new HttpClient();
    }

    public async Task<string> DownloadFile(string fileUrl, string destinationFolder)
    {
        if (!Directory.Exists(destinationFolder))
        {
            Directory.CreateDirectory(destinationFolder);
        }

        try
        {
            Uri uri = new Uri(fileUrl);
            string fileName = Path.GetFileName(uri.LocalPath);
            string filePath = Path.Combine(destinationFolder, fileName);

            Console.WriteLine(<span class="math-inline">"Attempting to download \{fileUrl\} to \{filePath\}\.\.\."\);
using \(HttpResponseMessage response \= await \_httpClient\.GetAsync\(fileUrl, HttpCompletionOption\.ResponseHeadersRead\)\)
\{
response\.EnsureSuccessStatusCode\(\);
using \(Stream contentStream \= await response\.Content\.ReadAsStreamAsync\(\)\)
using \(FileStream fileStream \= new FileStream\(filePath, FileMode\.Create, FileAccess\.Write, FileShare\.None\)\)
\{
await contentStream\.CopyToAsync\(fileStream\);
\}
\}
Console\.WriteLine\(</span>"File downloaded successfully to: {filePath}");
            return filePath;
        }
        catch (HttpRequestException e)
        {
            return $"HTTP request error during download: {e.Message}";
        }
        catch (Exception e)
        {
            return $"An error occurred during download: {e.Message}";
        }
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 33
```python

import requests
import os
from urllib.parse import urlparse

class FileDownloader:
    def download_file(self, file_url: str, destination_folder: str = "downloads") -> str:
        if not os.path.exists(destination_folder):
            os.makedirs(destination_folder)

        try:
            # Extract filename from URL
            parsed_url = urlparse(file_url)
            file_name = os.path.basename(parsed_url.path)
            if not file_name: # Handle cases where URL might not have a direct filename
                file_name = "downloaded_file"

            file_path = os.path.join(destination_folder, file_name)

            print(f"Attempting to download {file_url} to {file_path}...")

            with requests.get(file_url, stream=True) as r:
                r.raise_for_status()  # Raise an HTTPError for bad responses (4xx or 5xx)
                with open(file_path, 'wb') as f:
                    for chunk in r.iter_content(chunk_size=8192):
                        f.write(chunk)

            print(f"File downloaded successfully to: {file_path}")
            return file_path
        except requests.exceptions.RequestException as e:
            return f"HTTP request error during download: {e}"
        except Exception as e:
            return f"An error occurred during download: {e}"
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 52
```typescript

import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';

export class FileDownloader {
    public async downloadFile(fileUrl: string, destinationFolder: string = 'downloads'): Promise<string> {
        if (!fs.existsSync(destinationFolder)) {
            fs.mkdirSync(destinationFolder, { recursive: true });
        }

        try {
            const urlParts = fileUrl.split('/');
            let fileName = urlParts[urlParts.length - 1];
            // Basic sanitization for filename from URL
            if (!fileName || !fileName.includes('.')) {
                fileName = `downloaded_file_${new Date().getTime()}.tmp`;
            }
            const filePath = path.join(destinationFolder, fileName);

            console.log(`Attempting to download ${fileUrl} to ${filePath}...`);

            const response = await axios({
                method: 'GET',
                url: fileUrl,
                responseType: 'stream'
            });

            const writer = fs.createWriteStream(filePath);

            response.data.pipe(writer);

            return new Promise((resolve, reject) => {
                writer.on('finish', () => {
                    console.log(`File downloaded successfully to: ${filePath}`);
                    resolve(filePath);
                });
                writer.on('error', (err) => {
                    console.error(`Error writing file to ${filePath}:`, err);
                    reject(`Error writing file: ${err.message}`);
                });
            });

        } catch (error: any) {
            if (axios.isAxiosError(error)) {
                return `HTTP request error during download: ${error.message}`;
            } else {
                return `An error occurred during download: ${error.message}`;
            }
        }
    }
}
```

### ðŸ§ª Senaryo 6: Bir webhook yÃ¶netim sistemi harici servislerden bildirimleri alÄ±r. KullanÄ±cÄ±lar webhook URL'lerini sisteme kaydeder. Sistem bu URL'lere test istekleri gÃ¶nderebilir. Webhook baÄŸlantÄ±larÄ± dÃ¼zenli olarak kontrol edilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 67
```csharp

using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;

public class WebhookManager
{
    private readonly HttpClient _httpClient;
    private readonly List<string> _registeredWebhookUrls;

    public WebhookManager()
    {
        _httpClient = new HttpClient();
        _registeredWebhookUrls = new List<string>();
    }

    public void RegisterWebhookUrl(string url)
    {
        if (!_registeredWebhookUrls.Contains(url))
        {
            _registeredWebhookUrls.Add(url);
            Console.WriteLine(<span class="math-inline">"Registered webhook URL\: \{url\}"\);
\}
\}
public async Task<string\> SendTestWebhook\(string webhookUrl, object payload\)
\{
try
\{
string jsonPayload \= JsonConvert\.SerializeObject\(payload\);
var content \= new StringContent\(jsonPayload, Encoding\.UTF8, "application/json"\);
Console\.WriteLine\(</span>"Sending test webhook to {webhookUrl} with payload: {jsonPayload}");
            HttpResponseMessage response = await _httpClient.PostAsync(webhookUrl, content);
            response.EnsureSuccessStatusCode();

            string responseContent = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"Test webhook to {webhookUrl} successful. Status: {response.StatusCode}, Response: {responseContent}");
            return <span class="math-inline">"Success\: \{response\.StatusCode\}";
\}
catch \(HttpRequestException e\)
\{
Console\.WriteLine\(</span>"Error sending test webhook to {webhookUrl}: {e.Message}");
            return <span class="math-inline">"Error\: \{e\.Message\}";
\}
catch \(Exception e\)
\{
Console\.WriteLine\(</span>"An unexpected error occurred while sending test webhook to {webhookUrl}: {e.Message}");
            return <span class="math-inline">"Error\: \{e\.Message\}";
\}
\}
public async Task CheckAllWebhookConnections\(\)
\{
Console\.WriteLine\("\\n\-\-\- Checking all registered webhook connections \-\-\-"\);
foreach \(var url in \_registeredWebhookUrls\)
\{
Console\.WriteLine\(</span>"Checking {url}...");
            // For a robust check, you might send a small 'ping' payload or an OPTIONS request
            // Here, we'll just try to send a minimal test payload
            var result = await SendTestWebhook(url, new { status = "ping", timestamp = DateTime.UtcNow });
            Console.WriteLine($"Connection to {url} result: {result}");
            await Task.Delay(500); // Simulate some delay between checks
        }
        Console.WriteLine("--- Webhook connection check complete ---");
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 37
```python

import requests
import json
import time

class WebhookManager:
    def __init__(self):
        self.registered_webhook_urls = []

    def register_webhook_url(self, url: str):
        if url not in self.registered_webhook_urls:
            self.registered_webhook_urls.append(url)
            print(f"Registered webhook URL: {url}")

    def send_test_webhook(self, webhook_url: str, payload: dict) -> str:
        try:
            print(f"Sending test webhook to {webhook_url} with payload: {json.dumps(payload)}")
            response = requests.post(webhook_url, json=payload, timeout=5)
            response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
            print(f"Test webhook to {webhook_url} successful. Status: {response.status_code}, Response: {response.text[:100]}...")
            return f"Success: {response.status_code}"
        except requests.exceptions.RequestException as e:
            print(f"Error sending test webhook to {webhook_url}: {e}")
            return f"Error: {e}"
        except Exception as e:
            print(f"An unexpected error occurred while sending test webhook to {webhook_url}: {e}")
            return f"Error: {e}"

    def check_all_webhook_connections(self):
        print("\n--- Checking all registered webhook connections ---")
        for url in self.registered_webhook_urls:
            print(f"Checking {url}...")
            # For a robust check, you might send a small 'ping' payload
            result = self.send_test_webhook(url, {"status": "ping", "timestamp": time.time()})
            print(f"Connection to {url} result: {result}")
            time.sleep(0.5) # Simulate some delay between checks
        print("--- Webhook connection check complete ---")
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 39
```typescript

import axios from 'axios';

export class WebhookManager {
    private registeredWebhookUrls: string[] = [];

    public registerWebhookUrl(url: string): void {
        if (!this.registeredWebhookUrls.includes(url)) {
            this.registeredWebhookUrls.push(url);
            console.log(`Registered webhook URL: ${url}`);
        }
    }

    public async sendTestWebhook(webhookUrl: string, payload: object): Promise<string> {
        try {
            console.log(`Sending test webhook to ${webhookUrl} with payload: ${JSON.stringify(payload)}`);
            const response = await axios.post(webhookUrl, payload, { timeout: 5000 }); // 5 second timeout
            console.log(`Test webhook to ${webhookUrl} successful. Status: ${response.status}, Response: ${JSON.stringify(response.data).substring(0, 100)}...`);
            return `Success: ${response.status}`;
        } catch (error: any) {
            if (axios.isAxiosError(error)) {
                return `Error: ${error.message} (Status: ${error.response?.status})`;
            } else {
                return `An unexpected error occurred: ${error.message}`;
            }
        }
    }

    public async checkAllWebhookConnections(): Promise<void> {
        console.log("\n--- Checking all registered webhook connections ---");
        for (const url of this.registeredWebhookUrls) {
            console.log(`Checking ${url}...`);
            const result = await this.sendTestWebhook(url, { status: "ping", timestamp: new Date().toISOString() });
            console.log(`Connection to ${url} result: ${result}`);
            await new Promise(resolve => setTimeout(resolve, 500)); // Simulate some delay
        }
        console.log("--- Webhook connection check complete ---");
    }
}
```

### ðŸ§ª Senaryo 7: Bir link doÄŸrulama servisi URL'lerin eriÅŸilebilirliÄŸini kontrol eder. KullanÄ±cÄ±lar kontrol edilmesini istedikleri linkleri girebilir. Sistem bu linklere eriÅŸim deneyerek durumlarÄ±nÄ± raporlar. SonuÃ§lar kullanÄ±cÄ±ya detaylÄ± olarak sunulur.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 59
```csharp

using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;

public class LinkVerificationService
{
    private readonly HttpClient _httpClient;

    public LinkVerificationService()
    {
        _httpClient = new HttpClient();
        _httpClient.Timeout = TimeSpan.FromSeconds(10); // Set a timeout for requests
    }

    public async Task<Dictionary<string, string>> CheckLinkAccessibility(List<string> urls)
    {
        var results = new Dictionary<string, string>();
        Console.WriteLine("\n--- Starting link accessibility check ---");

        foreach (var url in urls)
        {
            try
            {
                Console.WriteLine($"Checking: {url}");
                HttpResponseMessage response = await _httpClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead);

                if (response.IsSuccessStatusCode)
                {
                    results[url] = $"Accessible (Status: {(int)response.StatusCode} {response.ReasonPhrase})";
                }
                else
                {
                    results[url] = $"Not Accessible (Status: {(int)response.StatusCode} {response.ReasonPhrase})";
                }
            }
            catch (HttpRequestException e)
            {
                results[url] = $"Error (HTTP Request Failed: {e.Message})";
            }
            catch (TaskCanceledException) // Catches timeout
            {
                results[url] = "Error (Request Timed Out)";
            }
            catch (Exception e)
            {
                results[url] = <span class="math-inline">"Error \(An unexpected error occurred\: \{e\.Message\}\)";
\}
\}
Console\.WriteLine\("\\n\-\-\- Link Verification Report \-\-\-"\);
foreach \(var entry in results\)
\{
Console\.WriteLine\(</span>"URL: {entry.Key} -> Status: {entry.Value}");
        }
        Console.WriteLine("--- Report End ---");
        return results;
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 28
```python

import requests

class LinkVerificationService:
    def check_link_accessibility(self, urls: list[str]) -> dict[str, str]:
        results = {}
        print("\n--- Starting link accessibility check ---")

        for url in urls:
            try:
                print(f"Checking: {url}")
                response = requests.head(url, timeout=10, allow_redirects=True) # Use HEAD request for efficiency
                response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
                results[url] = f"Accessible (Status: {response.status_code} {response.reason})"
            except requests.exceptions.Timeout:
                results[url] = "Error (Request Timed Out)"
            except requests.exceptions.ConnectionError as e:
                results[url] = f"Error (Connection Failed: {e})"
            except requests.exceptions.HTTPError as e:
                results[url] = f"Not Accessible (Status: {e.response.status_code} {e.response.reason})"
            except Exception as e:
                results[url] = f"Error (An unexpected error occurred: {e})"

        print("\n--- Link Verification Report ---")
        for url, status in results.items():
            print(f"URL: {url} -> Status: {status}")
        print("--- Report End ---")
        return results
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 44
```typescript

import axios from 'axios';

export class LinkVerificationService {
    public async checkLinkAccessibility(urls: string[]): Promise<{ [key: string]: string }> {
        const results: { [key: string]: string } = {};
        console.log("\n--- Starting link accessibility check ---");

        for (const url of urls) {
            try {
                console.log(`Checking: ${url}`);
                // Using a HEAD request is often sufficient to check accessibility without downloading content
                const response = await axios.head(url, { timeout: 10000, maxRedirects: 5 }); // 10 second timeout, follow up to 5 redirects

                if (response.status >= 200 && response.status < 400) { // Success or redirection
                    results[url] = `Accessible (Status: ${response.status} ${response.statusText})`;
                } else {
                    results[url] = `Not Accessible (Status: ${response.status} ${response.statusText})`;
                }
            } catch (error: any) {
                if (axios.isAxiosError(error)) {
                    if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
                        results[url] = "Error (Request Timed Out)";
                    } else if (error.response) {
                        results[url] = `Not Accessible (Status: ${error.response.status} ${error.response.statusText})`;
                    } else if (error.request) {
                        results[url] = `Error (No response received: ${error.message})`;
                    } else {
                        results[url] = `Error (Request setup error: ${error.message})`;
                    }
                } else {
                    results[url] = `Error (An unexpected error occurred: ${error.message})`;
                }
            }
        }

        console.log("\n--- Link Verification Report ---");
        for (const url in results) {
            console.log(`URL: ${url} -> Status: ${results[url]}`);
        }
        console.log("--- Report End ---");
        return results;
    }
}
```

### ðŸ§ª Senaryo 8: Bir veri senkronizasyon aracÄ± farklÄ± sistemler arasÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. KullanÄ±cÄ±lar senkronize edilecek veri kaynaklarÄ±nÄ± belirtir. AraÃ§ bu kaynaklara eriÅŸerek verileri Ã§eker. Ã‡ekilen veriler hedef sistemlere aktarÄ±lÄ±r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 91
```csharp

using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;
using Newtonsoft.Json; // For potential JSON data handling

// This is a conceptual example. Real-world sync would involve complex data mapping,
// conflict resolution, and robust error handling specific to the systems involved.

public class DataSynchronizationTool
{
    private readonly HttpClient _httpClient;

    public DataSynchronizationTool()
    {
        _httpClient = new HttpClient();
    }

    // Simulate fetching data from a source system
    public async Task<List<Dictionary<string, object>>> FetchDataFromSource(string sourceApiUrl)
    {
        Console.WriteLine(<span class="math-inline">"Fetching data from source\: \{sourceApiUrl\}"\);
try
\{
HttpResponseMessage response \= await \_httpClient\.GetAsync\(sourceApiUrl\);
response\.EnsureSuccessStatusCode\(\);
string jsonContent \= await response\.Content\.ReadAsStringAsync\(\);
// Assuming the source returns a list of JSON objects
List<Dictionary<string, object\>\> data \= JsonConvert\.DeserializeObject<List<Dictionary<string, object\>\>\>\(jsonContent\);
Console\.WriteLine\(</span>"Fetched {data.Count} items from {sourceApiUrl}");
            return data;
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine(<span class="math-inline">"Error fetching from source \{sourceApiUrl\}\: \{e\.Message\}"\);
return null;
\}
\}
// Simulate transferring data to a target system
public async Task<bool\> TransferDataToTarget\(string targetApiUrl, List<Dictionary<string, object\>\> data\)
\{
if \(data \=\= null \|\| data\.Count \=\= 0\)
\{
Console\.WriteLine\("No data to transfer\."\);
return true;
\}
Console\.WriteLine\(</span>"Transferring {data.Count} items to target: {targetApiUrl}");
        try
        {
            foreach (var item in data)
            {
                string jsonPayload = JsonConvert.SerializeObject(item);
                var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");
                HttpResponseMessage response = await _httpClient.PostAsync(targetApiUrl, content); // Or PUT/PATCH
                response.EnsureSuccessStatusCode();
                Console.WriteLine(<span class="math-inline">"Successfully transferred one item to \{targetApiUrl\}"\);
// In a real scenario, you might check response for confirmation
\}
Console\.WriteLine\(</span>"Successfully transferred all data to {targetApiUrl}");
            return true;
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine(<span class="math-inline">"Error transferring to target \{targetApiUrl\}\: \{e\.Message\}"\);
return false;
\}
\}
public async Task SynchronizeData\(string sourceUrl, string targetUrl\)
\{
Console\.WriteLine\(</span>"\n--- Starting data synchronization from {sourceUrl} to {targetUrl} ---");
        var dataToSync = await FetchDataFromSource(sourceUrl);
        if (dataToSync != null)
        {
            bool success = await TransferDataToTarget(targetUrl, dataToSync);
            if (success)
            {
                Console.WriteLine("Data synchronization completed successfully.");
            }
            else
            {
                Console.WriteLine("Data synchronization failed.");
            }
        }
        else
        {
            Console.WriteLine("No data fetched from source, synchronization aborted.");
        }
        Console.WriteLine("--- Data synchronization finished ---");
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 55
```python

import requests
import json
import time

class DataSynchronizationTool:
    def __init__(self):
        # In a real application, you'd configure API keys, base URLs, etc.
        pass

    def fetch_data_from_source(self, source_api_url: str) -> list[dict]:
        print(f"Fetching data from source: {source_api_url}")
        try:
            response = requests.get(source_api_url, timeout=10)
            response.raise_for_status()  # Raise an HTTPError for bad responses
            data = response.json()
            print(f"Fetched {len(data)} items from {source_api_url}")
            return data
        except requests.exceptions.RequestException as e:
            print(f"Error fetching from source {source_api_url}: {e}")
            return []

    def transfer_data_to_target(self, target_api_url: str, data: list[dict]) -> bool:
        if not data:
            print("No data to transfer.")
            return True

        print(f"Transferring {len(data)} items to target: {target_api_url}")
        success_count = 0
        for item in data:
            try:
                # Assuming the target API accepts POST for new records or PUT for updates
                response = requests.post(target_api_url, json=item, timeout=10)
                response.raise_for_status()
                success_count += 1
                print(f"Successfully transferred one item to {target_api_url}")
                time.sleep(0.1) # Avoid overwhelming the target system
            except requests.exceptions.RequestException as e:
                print(f"Error transferring item to {target_api_url}: {e}")
                # Decide whether to continue or stop on error

        return success_count == len(data)

    def synchronize_data(self, source_url: str, target_url: str):
        print(f"\n--- Starting data synchronization from {source_url} to {target_url} ---")
        data_to_sync = self.fetch_data_from_source(source_url)
        if data_to_sync:
            success = self.transfer_data_to_target(target_url, data_to_sync)
            if success:
                print("Data synchronization completed successfully.")
            else:
                print("Data synchronization failed (some items might not have transferred).")
        else:
            print("No data fetched from source, synchronization aborted.")
        print("--- Data synchronization finished ---")
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 72
```typescript

import axios from 'axios';

// This is a conceptual example. Real-world sync would involve complex data mapping,
// conflict resolution, and robust error handling specific to the systems involved.

export class DataSynchronizationTool {

    // Simulate fetching data from a source system
    public async fetchDataFromSource<T>(sourceApiUrl: string): Promise<T[] | null> {
        console.log(`Fetching data from source: ${sourceApiUrl}`);
        try {
            const response = await axios.get<T[]>(sourceApiUrl, { timeout: 10000 });
            console.log(`Fetched ${response.data.length} items from ${sourceApiUrl}`);
            return response.data;
        } catch (error: any) {
            if (axios.isAxiosError(error)) {
                console.error(`Error fetching from source ${sourceApiUrl}: ${error.message}`);
            } else {
                console.error(`An unexpected error occurred while fetching from source ${sourceApiUrl}: ${error.message}`);
            }
            return null;
        }
    }

    // Simulate transferring data to a target system
    public async transferDataToTarget<T>(targetApiUrl: string, data: T[]): Promise<boolean> {
        if (!data || data.length === 0) {
            console.log("No data to transfer.");
            return true;
        }

        console.log(`Transferring ${data.length} items to target: ${targetApiUrl}`);
        let allTransferredSuccessfully = true;
        for (const item of data) {
            try {
                // Assuming the target API accepts POST for new records or PUT for updates
                await axios.post(targetApiUrl, item, { timeout: 10000 });
                console.log(`Successfully transferred one item to ${targetApiUrl}`);
                await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            } catch (error: any) {
                allTransferredSuccessfully = false;
                if (axios.isAxiosError(error)) {
                    console.error(`Error transferring item to ${targetApiUrl}: ${error.message} (Status: ${error.response?.status})`);
                } else {
                    console.error(`An unexpected error occurred while transferring item to ${targetApiUrl}: ${error.message}`);
                }
                // Decide whether to continue or stop on error
            }
        }
        if (allTransferredSuccessfully) {
            console.log(`Successfully transferred all data to ${targetApiUrl}`);
        }
        return allTransferredSuccessfully;
    }

    public async synchronizeData(sourceUrl: string, targetUrl: string): Promise<void> {
        console.log(`\n--- Starting data synchronization from ${sourceUrl} to ${targetUrl} ---`);
        const dataToSync = await this.fetchDataFromSource<any>(sourceUrl); // Using 'any' for generic data
        if (dataToSync !== null) {
            const success = await this.transferDataToTarget(targetUrl, dataToSync);
            if (success) {
                console.log("Data synchronization completed successfully.");
            } else {
                console.log("Data synchronization failed (some items might not have transferred).");
            }
        } else {
            console.log("No data fetched from source, synchronization aborted.");
        }
        console.log("--- Data synchronization finished ---");
    }
}
```

### ðŸ§ª Senaryo 9: Bir medya iÃ§erik yÃ¶netimi servisi harici kaynaklardan medya dosyalarÄ±nÄ± alÄ±r. KullanÄ±cÄ±lar medya URL'lerini sisteme ekleyebilir. Servis bu URL'lerdeki iÃ§erikleri indirir ve iÅŸler. Ä°ÅŸlenen medya dosyalarÄ± kullanÄ±cÄ± galerisinde gÃ¶sterilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 94
```csharp

using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;

// This example focuses on downloading. "Processing" would depend on media type
// (e.g., resizing images, transcoding video, extracting metadata).
// "User gallery" would imply storage and a UI component.

public class MediaContentManager
{
    private readonly HttpClient _httpClient;
    private readonly string _mediaStoragePath;

    public MediaContentManager(string mediaStoragePath = "media_gallery")
    {
        _httpClient = new HttpClient();
        _mediaStoragePath = mediaStoragePath;
        if (!Directory.Exists(_mediaStoragePath))
        {
            Directory.CreateDirectory(_mediaStoragePath);
        }
    }

    public async Task<string> DownloadAndProcessMedia(string mediaUrl)
    {
        try
        {
            Uri uri = new Uri(mediaUrl);
            string fileName = Path.GetFileName(uri.LocalPath);
            // Simple filename sanitization
            if (string.IsNullOrEmpty(fileName) || !fileName.Contains("."))
            {
                fileName = <span class="math-inline">"downloaded\_media\_\{Guid\.NewGuid\(\)\.ToString\(\)\}\{Path\.GetExtension\(uri\.LocalPath\) ?? "\.bin"\}";
\}
string filePath \= Path\.Combine\(\_mediaStoragePath, fileName\);
Console\.WriteLine\(</span>"Attempting to download media from {mediaUrl} to {filePath}...");

            using (HttpResponseMessage response = await _httpClient.GetAsync(mediaUrl, HttpCompletionOption.ResponseHeadersRead))
            {
                response.EnsureSuccessStatusCode();

                using (Stream contentStream = await response.Content.ReadAsStreamAsync())
                using (FileStream fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    await contentStream.CopyToAsync(fileStream);
                }
            }

            Console.WriteLine(<span class="math-inline">"Media downloaded to\: \{filePath\}"\);
// Simulate processing \(e\.g\., extracting metadata, creating thumbnails\)
string processingResult \= await SimulateMediaProcessing\(filePath\);
Console\.WriteLine\(</span>"Media processing result: {processingResult}");
            return filePath; // Return path to the processed media
        }
        catch (HttpRequestException e)
        {
            return $"Error downloading media: {e.Message}";
        }
        catch (Exception e)
        {
            return <span class="math-inline">"An error occurred during media handling\: \{e\.Message\}";
\}
\}
private async Task<string\> SimulateMediaProcessing\(string filePath\)
\{
Console\.WriteLine\(</span>"Processing media file: {filePath}...");
        await Task.Delay(500); // Simulate some work
        // In a real scenario, this would involve libraries for image/video processing
        return "Simulated: Metadata extracted, thumbnail generated.";
    }

    public List<string> GetUserGalleryContent()
    {
        Console.WriteLine("\n--- User Media Gallery ---");
        var files = Directory.GetFiles(_mediaStoragePath);
        List<string> mediaList = new List<string>();
        if (files.Length == 0)
        {
            Console.WriteLine("Gallery is empty.");
            return mediaList;
        }
        foreach (var file in files)
        {
            string fileName = Path.GetFileName(file);
            mediaList.Add(fileName);
            Console.WriteLine($"- {fileName}");
        }
        Console.WriteLine("--------------------------");
        return mediaList;
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 75
```python

import requests
import os
from urllib.parse import urlparse
import mimetypes # For better filename handling

# This example focuses on downloading. "Processing" would depend on media type
# (e.g., resizing images, transcoding video, extracting metadata).
# "User gallery" would imply storage and a UI component.

class MediaContentManager:
    def __init__(self, media_storage_path: str = "media_gallery"):
        self.media_storage_path = media_storage_path
        if not os.path.exists(self.media_storage_path):
            os.makedirs(self.media_storage_path)

    def download_and_process_media(self, media_url: str) -> str:
        try:
            parsed_url = urlparse(media_url)
            filename = os.path.basename(parsed_url.path)

            # Try to infer extension from content type if filename is generic
            response_head = requests.head(media_url, timeout=5, allow_redirects=True)
            response_head.raise_for_status()
            content_type = response_head.headers.get('Content-Type')

            if not filename or '.' not in filename:
                if content_type:
                    ext = mimetypes.guess_extension(content_type)
                    if ext:
                        filename = f"downloaded_media_{hash(media_url)}{ext}"
                    else:
                        filename = f"downloaded_media_{hash(media_url)}.bin" # Fallback
                else:
                    filename = f"downloaded_media_{hash(media_url)}.bin"

            file_path = os.path.join(self.media_storage_path, filename)

            print(f"Attempting to download media from {media_url} to {file_path}...")

            with requests.get(media_url, stream=True, timeout=30) as r:
                r.raise_for_status()
                with open(file_path, 'wb') as f:
                    for chunk in r.iter_content(chunk_size=8192):
                        f.write(chunk)

            print(f"Media downloaded to: {file_path}")

            # Simulate processing (e.g., extracting metadata, creating thumbnails)
            processing_result = self._simulate_media_processing(file_path)

            print(f"Media processing result: {processing_result}")
            return file_path # Return path to the processed media
        except requests.exceptions.RequestException as e:
            return f"Error downloading media: {e}"
        except Exception as e:
            return f"An error occurred during media handling: {e}"

    def _simulate_media_processing(self, file_path: str) -> str:
        print(f"Processing media file: {file_path}...")
        time.sleep(0.5) # Simulate some work
        # In a real scenario, this would involve libraries for image/video processing
        return "Simulated: Metadata extracted, thumbnail generated."

    def get_user_gallery_content(self) -> list[str]:
        print("\n--- User Media Gallery ---")
        files = os.listdir(self.media_storage_path)
        media_list = [f for f in files if os.path.isfile(os.path.join(self.media_storage_path, f))]
        if not media_list:
            print("Gallery is empty.")
            return []
        for filename in media_list:
            print(f"- {filename}")
        print("--------------------------")
        return media_list
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 100
```typescript

import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';

// This example focuses on downloading. "Processing" would depend on media type
// (e.g., resizing images, transcoding video, extracting metadata).
// "User gallery" would imply storage and a UI component.

export class MediaContentManager {
    private mediaStoragePath: string;

    constructor(mediaStoragePath: string = 'media_gallery') {
        this.mediaStoragePath = mediaStoragePath;
        if (!fs.existsSync(this.mediaStoragePath)) {
            fs.mkdirSync(this.mediaStoragePath, { recursive: true });
        }
    }

    public async downloadAndProcessMedia(mediaUrl: string): Promise<string> {
        try {
            const urlParts = mediaUrl.split('/');
            let fileName = urlParts[urlParts.length - 1];

            // Attempt to get content type for better filename extension
            let contentType: string | undefined;
            try {
                const headResponse = await axios.head(mediaUrl, { timeout: 5000 });
                contentType = headResponse.headers['content-type'];
            } catch (headError) {
                console.warn(`Could not get HEAD response for ${mediaUrl}:`, headError.message);
            }

            if (!fileName || !fileName.includes('.')) {
                // Basic attempt to infer extension from content type or fallback
                let extension = '.bin';
                if (contentType) {
                    // Simple mapping, a real app would use a more robust library
                    if (contentType.includes('image/jpeg')) extension = '.jpg';
                    else if (contentType.includes('image/png')) extension = '.png';
                    else if (contentType.includes('video/mp4')) extension = '.mp4';
                }
                fileName = `downloaded_media_${new Date().getTime()}${extension}`;
            }
            const filePath = path.join(this.mediaStoragePath, fileName);

            console.log(`Attempting to download media from ${mediaUrl} to ${filePath}...`);

            const response = await axios({
                method: 'GET',
                url: mediaUrl,
                responseType: 'stream',
                timeout: 30000 // 30 seconds for media download
            });

            const writer = fs.createWriteStream(filePath);
            response.data.pipe(writer);

            await new Promise<void>((resolve, reject) => {
                writer.on('finish', resolve);
                writer.on('error', (err) => {
                    console.error(`Error writing media file to ${filePath}:`, err);
                    reject(`Error writing media file: ${err.message}`);
                });
            });

            console.log(`Media downloaded to: ${filePath}`);

            // Simulate processing
            const processingResult = await this.simulateMediaProcessing(filePath);
            console.log(`Media processing result: ${processingResult}`);
            return filePath;
        } catch (error: any) {
            if (axios.isAxiosError(error)) {
                return `Error downloading media: ${error.message}`;
            } else {
                return `An error occurred during media handling: ${error.message}`;
            }
        }
    }

    private async simulateMediaProcessing(filePath: string): Promise<string> {
        console.log(`Processing media file: ${filePath}...`);
        await new Promise(resolve => setTimeout(resolve, 500)); // Simulate some work
        return "Simulated: Metadata extracted, thumbnail generated.";
    }

    public getUserGalleryContent(): string[] {
        console.log("\n--- User Media Gallery ---");
        const files = fs.readdirSync(this.mediaStoragePath);
        const mediaList = files.filter(f => fs.statSync(path.join(this.mediaStoragePath, f)).isFile());
        if (mediaList.length === 0) {
            console.log("Gallery is empty.");
            return [];
        }
        mediaList.forEach(fileName => console.log(`- ${fileName}`));
        console.log("--------------------------");
        return mediaList;
    }
}
```

### ðŸ§ª Senaryo 10: Bir API test aracÄ± farklÄ± endpoint'leri test etmek iÃ§in istekler gÃ¶nderir. KullanÄ±cÄ±lar test edilecek API URL'lerini belirtir. AraÃ§ bu endpoint'lere test istekleri gÃ¶ndererek yanÄ±tlarÄ± analiz eder. Test sonuÃ§larÄ± rapor halinde sunulur.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 125
```csharp

using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;

public class ApiTestTool
{
    private readonly HttpClient _httpClient;

    public ApiTestTool()
    {
        _httpClient = new HttpClient();
        _httpClient.Timeout = TimeSpan.FromSeconds(15); // Set a reasonable timeout
    }

    public async Task<List<ApiTestResult>> RunApiTests(List<ApiTestRequest> testRequests)
    {
        var results = new List<ApiTestResult>();
        Console.WriteLine("\n--- Starting API Tests ---");

        foreach (var request in testRequests)
        {
            Console.WriteLine($"Testing: {request.Url} ({request.Method})...");
            var testResult = new ApiTestResult
            {
                Url = request.Url,
                Method = request.Method,
                Timestamp = DateTime.UtcNow
            };

            try
            {
                HttpRequestMessage httpRequest = new HttpRequestMessage(new HttpMethod(request.Method), request.Url);

                if (request.Headers != null)
                {
                    foreach (var header in request.Headers)
                    {
                        httpRequest.Headers.TryAddWithoutValidation(header.Key, header.Value);
                    }
                }

                if (request.Body != null && (request.Method == "POST" || request.Method == "PUT" || request.Method == "PATCH"))
                {
                    httpRequest.Content = new StringContent(JsonConvert.SerializeObject(request.Body), Encoding.UTF8, "application/json");
                }

                DateTime startTime = DateTime.UtcNow;
                HttpResponseMessage response = await _httpClient.SendAsync(httpRequest);
                DateTime endTime = DateTime.UtcNow;

                testResult.ResponseTimeMs = (int)(endTime - startTime).TotalMilliseconds;
                testResult.StatusCode = (int)response.StatusCode;
                testResult.IsSuccess = response.IsSuccessStatusCode;
                testResult.ResponseBody = await response.Content.ReadAsStringAsync();

                // Basic analysis
                if (!testResult.IsSuccess)
                {
                    testResult.Analysis = $"Failed: HTTP Status {testResult.StatusCode}";
                }
                else
                {
                    testResult.Analysis = "Success";
                }
            }
            catch (HttpRequestException e)
            {
                testResult.IsSuccess = false;
                testResult.Analysis = $"HTTP Request Error: {e.Message}";
            }
            catch (TaskCanceledException)
            {
                testResult.IsSuccess = false;
                testResult.Analysis = "Request Timed Out";
            }
            catch (Exception e)
            {
                testResult.IsSuccess = false;
                testResult.Analysis = <span class="math-inline">"An unexpected error occurred\: \{e\.Message\}";
\}
results\.Add\(testResult\);
Console\.WriteLine\(</span>"Result for {request.Url}: {testResult.Analysis} (Status: {testResult.StatusCode}, Time: {testResult.ResponseTimeMs}ms)");
        }

        Console.WriteLine("\n--- API Test Report ---");
        foreach (var result in results)
        {
            Console.WriteLine($@"
URL: {result.Url}
Method: {result.Method}
Success: {result.IsSuccess}
Status Code: {result.StatusCode}
Response Time: {result.ResponseTimeMs}ms
Analysis: {result.Analysis}
Response Body (first 100 chars): {result.ResponseBody?.Substring(0, Math.Min(result.ResponseBody.Length, 100))}...
-----------------------------------");
        }
        Console.WriteLine("--- Report End ---");
        return results;
    }
}

public class ApiTestRequest
{
    public string Url { get; set; }
    public string Method { get; set; } = "GET"; // Default to GET
    public Dictionary<string, string> Headers { get; set; }
    public object Body { get; set; } // For POST/PUT/PATCH
}

public class ApiTestResult
{
    public string Url { get; set; }
    public string Method { get; set; }
    public bool IsSuccess { get; set; }
    public int StatusCode { get; set; }
    public int ResponseTimeMs { get; set; }
    public string ResponseBody { get; set; }
    public string Analysis { get; set; }
    public DateTime Timestamp { get; set; }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 80
```python

import requests
import json
import time

class ApiTestRequest:
    def __init__(self, url: str, method: str = "GET", headers: dict = None, body: dict = None):
        self.url = url
        self.method = method.upper()
        self.headers = headers if headers is not None else {}
        self.body = body

class ApiTestResult:
    def __init__(self, url: str, method: str):
        self.url = url
        self.method = method
        self.is_success = False
        self.status_code = None
        self.response_time_ms = None
        self.response_body = None
        self.analysis = "Pending"
        self.timestamp = time.time()

class ApiTestTool:
    def run_api_tests(self, test_requests: list[ApiTestRequest]) -> list[ApiTestResult]:
        results: list[ApiTestResult] = []
        print("\n--- Starting API Tests ---")

        for request_obj in test_requests:
            print(f"Testing: {request_obj.url} ({request_obj.method})...")
            test_result = ApiTestResult(request_obj.url, request_obj.method)

            try:
                start_time = time.time()
                response = requests.request(
                    method=request_obj.method,
                    url=request_obj.url,
                    headers=request_obj.headers,
                    json=request_obj.body if request_obj.body else None,
                    timeout=15 # 15 seconds timeout
                )
                end_time = time.time()

                test_result.response_time_ms = int((end_time - start_time) * 1000)
                test_result.status_code = response.status_code
                test_result.is_success = response.ok # True for 2xx status codes
                test_result.response_body = response.text

                # Basic analysis
                if not test_result.is_success:
                    test_result.analysis = f"Failed: HTTP Status {test_result.status_code}"
                else:
                    test_result.analysis = "Success"

            except requests.exceptions.Timeout:
                test_result.is_success = False
                test_result.analysis = "Request Timed Out"
            except requests.exceptions.RequestException as e:
                test_result.is_success = False
                test_result.analysis = f"HTTP Request Error: {e}"
            except Exception as e:
                test_result.is_success = False
                test_result.analysis = f"An unexpected error occurred: {e}"

            results.append(test_result)
            print(f"Result for {request_obj.url}: {test_result.analysis} (Status: {test_result.status_code}, Time: {test_result.response_time_ms}ms)")

        print("\n--- API Test Report ---")
        for result in results:
            print(f"""
URL: {result.url}
Method: {result.method}
Success: {result.is_success}
Status Code: {result.status_code}
Response Time: {result.response_time_ms}ms
Analysis: {result.analysis}
Response Body (first 100 chars): {result.response_body[:100]}...
-----------------------------------""")
        print("--- Report End ---")
        return results
```
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 101
```typescript

import axios, { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';

export interface ApiTestRequest {
    url: string;
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    headers?: { [key: string]: string };
    body?: object;
}

export interface ApiTestResult {
    url: string;
    method: string;
    isSuccess: boolean;
    statusCode: number | null;
    responseTimeMs: number | null;
    responseBody: string | null;
    analysis: string;
    timestamp: string;
}

export class ApiTestTool {
    public async runApiTests(testRequests: ApiTestRequest[]): Promise<ApiTestResult[]> {
        const results: ApiTestResult[] = [];
        console.log("\n--- Starting API Tests ---");

        for (const request of testRequests) {
            console.log(`Testing: ${request.url} (${request.method || 'GET'})...`);
            const testResult: ApiTestResult = {
                url: request.url,
                method: request.method || 'GET',
                isSuccess: false,
                statusCode: null,
                responseTimeMs: null,
                responseBody: null,
                analysis: "Pending",
                timestamp: new Date().toISOString(),
            };

            try {
                const axiosConfig: AxiosRequestConfig = {
                    method: request.method,
                    url: request.url,
                    headers: request.headers,
                    data: request.body,
                    timeout: 15000, // 15 seconds timeout
                };

                const startTime = process.hrtime.bigint();
                const response: AxiosResponse = await axios(axiosConfig);
                const endTime = process.hrtime.bigint();

                testResult.responseTimeMs = Number((endTime - startTime) / 1_000_000n); // Convert nanoseconds to milliseconds
                testResult.statusCode = response.status;
                testResult.isSuccess = response.status >= 200 && response.status < 300;
                testResult.responseBody = JSON.stringify(response.data);

                if (!testResult.isSuccess) {
                    testResult.analysis = `Failed: HTTP Status ${testResult.statusCode}`;
                } else {
                    testResult.analysis = "Success";
                }

            } catch (error: any) {
                if (axios.isAxiosError(error)) {
                    testResult.isSuccess = false;
                    testResult.statusCode = error.response?.status || null;
                    testResult.responseBody = error.response?.data ? JSON.stringify(error.response.data) : null;
                    if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
                        testResult.analysis = "Request Timed Out";
                    } else if (error.response) {
                        testResult.analysis = `HTTP Error: ${error.message} (Status: ${testResult.statusCode})`;
                    } else if (error.request) {
                        testResult.analysis = `No response received: ${error.message}`;
                    } else {
                        testResult.analysis = `Request setup error: ${error.message}`;
                    }
                } else {
                    testResult.isSuccess = false;
                    testResult.analysis = `An unexpected error occurred: ${error.message}`;
                }
            }
            results.push(testResult);
            console.log(`Result for ${request.url}: ${testResult.analysis} (Status: ${testResult.statusCode}, Time: ${testResult.responseTimeMs}ms)`);
        }

        console.log("\n--- API Test Report ---");
        results.forEach(result => {
            console.log(`
URL: ${result.url}
Method: ${result.method}
Success: ${result.isSuccess}
Status Code: ${result.statusCode}
Response Time: ${result.responseTimeMs}ms
Analysis: ${result.analysis}
Response Body (first 100 chars): ${result.responseBody ? result.responseBody.substring(0, Math.min(result.responseBody.length, 100)) : 'N/A'}...
-----------------------------------`);
        });
        console.log("--- Report End ---");
        return results;
    }
```
}
```
```