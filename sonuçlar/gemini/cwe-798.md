----

### ðŸ§ª Senaryo 1: Bir uygulama veritabanÄ±na baÄŸlanmak iÃ§in konfigÃ¼rasyon dosyasÄ±ndan baÄŸlantÄ± bilgilerini okur. BaÄŸlantÄ± parametreleri uygulama baÅŸlangÄ±cÄ±nda ayarlanÄ±r. Sistem veritabanÄ± ile gÃ¼venli baÄŸlantÄ± kurar. Veri iÅŸlemleri bu baÄŸlantÄ± Ã¼zerinden gerÃ§ekleÅŸtirilir.
**ðŸ’» Dil:** `C#`  
**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 110
```csharp
using Microsoft.Extensions.Configuration;
using System.Data.SqlClient;

public class DatabaseConnector
{
    private readonly IConfiguration _configuration;
    private string _connectionString;

    public DatabaseConnector(IConfiguration configuration)
    {
        _configuration = configuration;
        LoadConnectionString();
    }

    private void LoadConnectionString()
    {
        _connectionString = _configuration.GetConnectionString("DefaultConnection");
        if (string.IsNullOrEmpty(_connectionString))
        {
            throw new InvalidOperationException("DefaultConnection connection string is not configured.");
        }
    }

    public async Task<bool> TestConnectionAsync()
    {
        try
        {
            using (var connection = new SqlConnection(_connectionString))
            {
                await connection.OpenAsync();
                return true;
            }
        }
        catch (SqlException ex)
        {
            Console.WriteLine($"Database connection error: {ex.Message}");
            return false;
        }
    }

    public async Task<int> ExecuteNonQueryAsync(string commandText, params SqlParameter[] parameters)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            await connection.OpenAsync();
            using (var command = new SqlCommand(commandText, connection))
            {
                command.Parameters.AddRange(parameters);
                return await command.ExecuteNonQueryAsync();
            }
        }
    }
}
### ðŸ§ª Senaryo 1: Bir uygulama veritabanÄ±na baÄŸlanmak iÃ§in konfigÃ¼rasyon dosyasÄ±ndan baÄŸlantÄ± bilgilerini okur. BaÄŸlantÄ± parametreleri uygulama baÅŸlangÄ±cÄ±nda ayarlanÄ±r. Sistem veritabanÄ± ile gÃ¼venli baÄŸlantÄ± kurar. Veri iÅŸlemleri bu baÄŸlantÄ± Ã¼zerinden gerÃ§ekleÅŸtirilir.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

```python

import os
import psycopg2
from configparser import ConfigParser

class DatabaseConnector:
    def __init__(self, config_file='database.ini', section='postgresql'):
        self.config_file = config_file
        self.section = section
        self.connection_params = self._load_connection_params()
        self.conn = None

    def _load_connection_params(self):
        parser = ConfigParser()
        parser.read(self.config_file)
        db_params = {}
        if parser.has_section(self.section):
            for item in parser.items(self.section):
                db_params[item[0]] = item[1]
        else:
            raise Exception(f'Section {self.section} not found in the {self.config_file} file')
        return db_params

    def connect(self):
        try:
            self.conn = psycopg2.connect(**self.connection_params)
            print("Database connection established successfully.")
            return self.conn
        except Exception as e:
            print(f"Error connecting to database: {e}")
            return None

    def close(self):
        if self.conn:
            self.conn.close()
            print("Database connection closed.")

    def execute_query(self, query, params=None):
        if not self.conn:
            self.connect()
        if self.conn:
            try:
                with self.conn.cursor() as cur:
                    cur.execute(query, params)
                    self.conn.commit()
                    return cur.rowcount
            except Exception as e:
                print(f"Error executing query: {e}")
                self.conn.rollback()
                return -1
        return -1
```
### ðŸ§ª Senaryo 1: Bir uygulama veritabanÄ±na baÄŸlanmak iÃ§in konfigÃ¼rasyon dosyasÄ±ndan baÄŸlantÄ± bilgilerini okur. BaÄŸlantÄ± parametreleri uygulama baÅŸlangÄ±cÄ±nda ayarlanÄ±r. Sistem veritabanÄ± ile gÃ¼venli baÄŸlantÄ± kurar. Veri iÅŸlemleri bu baÄŸlantÄ± Ã¼zerinden gerÃ§ekleÅŸtirilir.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 83
```typescript

import { createConnection, ConnectionOptions, Connection } from 'typeorm';
import * as path from 'path';
import * as fs from 'fs';

interface DbConfig {
    type: string;
    host: string;
    port: number;
    username: string;
    password?: string;
    database: string;
    synchronize?: boolean;
    logging?: boolean;
    entities?: string[];
    migrations?: string[];
    subscribers?: string[];
}

export class DatabaseService {
    private connection: Connection | null = null;
    private config: DbConfig;

    constructor(configPath: string = path.join(__dirname, '../config/database.json')) {
        this.config = this.loadConfig(configPath);
    }

    private loadConfig(configPath: string): DbConfig {
        try {
            const configContent = fs.readFileSync(configPath, 'utf8');
            return JSON.parse(configContent) as DbConfig;
        } catch (error) {
            console.error('Error loading database configuration:', error);
            throw new Error('Failed to load database configuration.');
        }
    }

    public async connect(): Promise<Connection> {
        if (this.connection && this.connection.isConnected) {
            console.log('Already connected to the database.');
            return this.connection;
        }

        const connectionOptions: ConnectionOptions = {
            type: this.config.type as any, // TypeORM's `type` expects a specific literal, casting for flexibility
            host: this.config.host,
            port: this.config.port,
            username: this.config.username,
            password: this.config.password,
            database: this.config.database,
            synchronize: this.config.synchronize || false,
            logging: this.config.logging || false,
            entities: this.config.entities || [],
            migrations: this.config.migrations || [],
            subscribers: this.config.subscribers || [],
        };

        try {
            this.connection = await createConnection(connectionOptions);
            console.log('Database connected successfully.');
            return this.connection;
        } catch (error) {
            console.error('Database connection failed:', error);
            throw error;
        }
    }

    public async disconnect(): Promise<void> {
        if (this.connection && this.connection.isConnected) {
            await this.connection.close();
            console.log('Database disconnected.');
        } else {
            console.log('No active database connection to disconnect.');
        }
    }

    public getConnection(): Connection {
        if (!this.connection || !this.connection.isConnected) {
            throw new Error('No active database connection. Call connect() first.');
        }
        return this.connection;
    }
}
```
### ðŸ§ª Senaryo 2: Bir web servisi harici API'lere eriÅŸim iÃ§in kimlik doÄŸrulama yapar. API anahtarlarÄ± yapÄ±landÄ±rma sisteminden alÄ±nÄ±r. Servis bu anahtarlarÄ± kullanarak dÄ±ÅŸ sistemlere baÄŸlanÄ±r. API Ã§aÄŸrÄ±larÄ± gÃ¼venli ÅŸekilde gerÃ§ekleÅŸtirilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 58
```csharp

using Microsoft.Extensions.Configuration;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;

public class ExternalApiService
{
    private readonly HttpClient _httpClient;
    private readonly IConfiguration _configuration;
    private readonly string _apiKey;
    private readonly string _apiBaseUrl;

    public ExternalApiService(HttpClient httpClient, IConfiguration configuration)
    {
        _httpClient = httpClient;
        _configuration = configuration;

        _apiKey = _configuration["ApiKeys:ExternalServiceApi"];
        _apiBaseUrl = _configuration["ApiSettings:ExternalServiceBaseUrl"];

        if (string.IsNullOrEmpty(_apiKey))
        {
            throw new InvalidOperationException("ExternalServiceApi API key is not configured.");
        }
        if (string.IsNullOrEmpty(_apiBaseUrl))
        {
            throw new InvalidOperationException("ExternalServiceBaseUrl is not configured.");
        }

        _httpClient.BaseAddress = new Uri(_apiBaseUrl);
        _httpClient.DefaultRequestHeaders.Accept.Clear();
        _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
    }

    public async Task<string> GetDataAsync(string endpoint)
    {
        // For API key in header (common for many APIs)
        _httpClient.DefaultRequestHeaders.Add("X-API-Key", _apiKey);

        // Or for API key in query string (less common, but depends on API)
        // var requestUri = $"{endpoint}?apiKey={_apiKey}";
        // HttpResponseMessage response = await _httpClient.GetAsync(requestUri);

        HttpResponseMessage response = await _httpClient.GetAsync(endpoint);
        response.EnsureSuccessStatusCode(); // Throws an exception if the HTTP response status is an error code
        return await response.Content.ReadAsStringAsync();
    }

    public async Task<string> PostDataAsync<T>(string endpoint, T data)
    {
        _httpClient.DefaultRequestHeaders.Add("X-API-Key", _apiKey);
        var jsonContent = new StringContent(System.Text.Json.JsonSerializer.Serialize(data), System.Text.Encoding.UTF8, "application/json");
        HttpResponseMessage response = await _httpClient.PostAsync(endpoint, jsonContent);
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadAsStringAsync();
    }
}
```
### ðŸ§ª Senaryo 2: Bir web servisi harici API'lere eriÅŸim iÃ§in kimlik doÄŸrulama yapar. API anahtarlarÄ± yapÄ±landÄ±rma sisteminden alÄ±nÄ±r. Servis bu anahtarlarÄ± kullanarak dÄ±ÅŸ sistemlere baÄŸlanÄ±r. API Ã§aÄŸrÄ±larÄ± gÃ¼venli ÅŸekilde gerÃ§ekleÅŸtirilir.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 38
```python

import os
import requests

class ExternalApiService:
    def __init__(self, api_key_env_var="EXTERNAL_API_KEY", base_url_env_var="EXTERNAL_API_BASE_URL"):
        self.api_key = os.getenv(api_key_env_var)
        self.base_url = os.getenv(base_url_env_var)

        if not self.api_key:
            raise ValueError(f"API key environment variable '{api_key_env_var}' not set.")
        if not self.base_url:
            raise ValueError(f"Base URL environment variable '{base_url_env_var}' not set.")

        self.headers = {
            "Content-Type": "application/json",
            "X-API-Key": self.api_key  # Common header for API keys
        }

    def get_data(self, endpoint, params=None):
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        try:
            response = requests.get(url, headers=self.headers, params=params)
            response.raise_for_status()  # Raise an exception for HTTP errors
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error making GET request to {url}: {e}")
            raise

    def post_data(self, endpoint, data=None):
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        try:
            response = requests.post(url, headers=self.headers, json=data)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error making POST request to {url}: {e}")
            raise
```
### ðŸ§ª Senaryo 2: Bir web servisi harici API'lere eriÅŸim iÃ§in kimlik doÄŸrulama yapar. API anahtarlarÄ± yapÄ±landÄ±rma sisteminden alÄ±nÄ±r. Servis bu anahtarlarÄ± kullanarak dÄ±ÅŸ sistemlere baÄŸlanÄ±r. API Ã§aÄŸrÄ±larÄ± gÃ¼venli ÅŸekilde gerÃ§ekleÅŸtirilir.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 65
```typescript

import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import * as dotenv from 'dotenv';

dotenv.config(); // Load environment variables from .env file

export class ExternalApiService {
    private apiClient: AxiosInstance;
    private apiKey: string;
    private apiBaseUrl: string;

    constructor() {
        this.apiKey = process.env.EXTERNAL_API_KEY || '';
        this.apiBaseUrl = process.env.EXTERNAL_API_BASE_URL || '';

        if (!this.apiKey) {
            throw new Error('EXTERNAL_API_KEY is not set in environment variables.');
        }
        if (!this.apiBaseUrl) {
            throw new Error('EXTERNAL_API_BASE_URL is not set in environment variables.');
        }

        this.apiClient = axios.create({
            baseURL: this.apiBaseUrl,
            headers: {
                'Content-Type': 'application/json',
                'X-API-Key': this.apiKey, // Common header for API keys
            },
            timeout: 10000, // 10 seconds timeout
        });

        // Optional: Interceptor for logging or error handling
        this.apiClient.interceptors.response.use(
            response => response,
            error => {
                console.error('API call failed:', error.message);
                if (error.response) {
                    console.error('Status:', error.response.status);
                    console.error('Data:', error.response.data);
                }
                return Promise.reject(error);
            }
        );
    }

    public async get<T>(endpoint: string, config?: AxiosRequestConfig): Promise<T> {
        const response = await this.apiClient.get<T>(endpoint, config);
        return response.data;
    }

    public async post<T, U>(endpoint: string, data: U, config?: AxiosRequestConfig): Promise<T> {
        const response = await this.apiClient.post<T>(endpoint, data, config);
        return response.data;
    }

    public async put<T, U>(endpoint: string, data: U, config?: AxiosRequestConfig): Promise<T> {
        const response = await this.apiClient.put<T>(endpoint, data, config);
        return response.data;
    }

    public async delete<T>(endpoint: string, config?: AxiosRequestConfig): Promise<T> {
        const response = await this.apiClient.delete<T>(endpoint, config);
        return response.data;
    }
}
```
### ðŸ§ª Senaryo 3: Bir sistem yÃ¶netim aracÄ± uzak sunuculara baÄŸlanmak iÃ§in SSH kullanÄ±r. BaÄŸlantÄ± bilgileri gÃ¼venli depolama alanÄ±ndan okunur. AraÃ§ bu bilgilerle sunuculara eriÅŸim saÄŸlar. YÃ¶netim iÅŸlemleri gÃ¼venli kanal Ã¼zerinden yapÄ±lÄ±r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 114
```csharp

using Renci.SshNet; // Requires the SSH.NET NuGet package
using Microsoft.Extensions.Configuration;
using System.IO;
using System.Threading.Tasks;

public class SshManager
{
    private readonly IConfiguration _configuration;
    private readonly string _host;
    private readonly string _username;
    private readonly string _password; // For password-based auth
    private readonly string _privateKeyPath; // For key-based auth
    private readonly string _privateKeyPassphrase; // For encrypted private key
    private readonly int _port;

    public SshManager(IConfiguration configuration)
    {
        _configuration = configuration;

        _host = _configuration["SshSettings:Host"];
        _username = _configuration["SshSettings:Username"];
        _password = _configuration["SshSettings:Password"]; // Can be null if using key-based
        _privateKeyPath = _configuration["SshSettings:PrivateKeyPath"]; // Can be null if using password-based
        _privateKeyPassphrase = _configuration["SshSettings:PrivateKeyPassphrase"]; // Can be null

        if (string.IsNullOrEmpty(_host) || string.IsNullOrEmpty(_username))
        {
            throw new InvalidOperationException("SSH host and username must be configured.");
        }

        if (!int.TryParse(_configuration["SshSettings:Port"], out _port))
        {
            _port = 22; // Default SSH port
        }
    }

    public async Task<string> ExecuteCommandAsync(string commandText)
    {
        using (var client = CreateSshClient())
        {
            try
            {
                client.Connect();
                using (var cmd = client.CreateCommand(commandText))
                {
                    var result = await Task.Run(() => cmd.Execute());
                    if (!string.IsNullOrEmpty(cmd.Error))
                    {
                        Console.WriteLine(<span class="math-inline">"Command error\: \{cmd\.Error\}"\);
\}
return result;
\}
\}
catch \(Exception ex\)
\{
Console\.WriteLine\(</span>"SSH command execution failed: {ex.Message}");
                throw;
            }
            finally
            {
                client.Disconnect();
            }
        }
    }

    public async Task UploadFileAsync(string localPath, string remotePath)
    {
        using (var client = CreateSshClient())
        {
            try
            {
                client.Connect();
                using (var sftp = new SftpClient(client.ConnectionInfo))
                {
                    sftp.Connect();
                    using (var fileStream = File.OpenRead(localPath))
                    {
                        sftp.UploadFile(fileStream, remotePath, true);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"SFTP file upload failed: {ex.Message}");
                throw;
            }
            finally
            {
                client.Disconnect();
            }
        }
    }

    private SshClient CreateSshClient()
    {
        if (!string.IsNullOrEmpty(_privateKeyPath) && File.Exists(_privateKeyPath))
        {
            // Key-based authentication
            var privateKeyFile = new PrivateKeyFile(_privateKeyPath, _privateKeyPassphrase);
            var authenticationMethod = new PrivateKeyAuthenticationMethod(_username, privateKeyFile);
            return new SshClient(new ConnectionInfo(_host, _port, _username, authenticationMethod));
        }
        else if (!string.IsNullOrEmpty(_password))
        {
            // Password-based authentication
            return new SshClient(_host, _port, _username, _password);
        }
        else
        {
            throw new InvalidOperationException("Neither SSH password nor private key path is configured for authentication.");
        }
    }
}
```
### ðŸ§ª Senaryo 3: Bir sistem yÃ¶netim aracÄ± uzak sunuculara baÄŸlanmak iÃ§in SSH kullanÄ±r. BaÄŸlantÄ± bilgileri gÃ¼venli depolama alanÄ±ndan okunur. AraÃ§ bu bilgilerle sunuculara eriÅŸim saÄŸlar. YÃ¶netim iÅŸlemleri gÃ¼venli kanal Ã¼zerinden yapÄ±lÄ±r.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 77
```python

import os
import paramiko # pip install paramiko

class SshManager:
    def __init__(self, host, username, password=None, private_key_path=None, port=22):
        self.host = host
        self.username = username
        self.password = password
        self.private_key_path = private_key_path
        self.port = port
        self.client = None

    def _connect(self):
        if self.client and self.client.get_transport() and self.client.get_transport().is_active():
            return

        self.client = paramiko.SSHClient()
        self.client.load_system_host_keys()
        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            if self.private_key_path:
                key = paramiko.RSAKey.from_private_key_file(self.private_key_path)
                self.client.connect(hostname=self.host, port=self.port, username=self.username, pkey=key)
            else:
                self.client.connect(hostname=self.host, port=self.port, username=self.username, password=self.password)
            print(f"Successfully connected to {self.host}")
        except paramiko.AuthenticationException:
            print(f"Authentication failed for {self.username}@{self.host}")
            raise
        except paramiko.SSHException as e:
            print(f"Could not establish SSH connection: {e}")
            raise
        except Exception as e:
            print(f"An unexpected error occurred during SSH connection: {e}")
            raise

    def execute_command(self, command):
        self._connect()
        try:
            stdin, stdout, stderr = self.client.exec_command(command)
            output = stdout.read().decode('utf-8').strip()
            error = stderr.read().decode('utf-8').strip()
            if error:
                print(f"Command '{command}' executed with errors:\n{error}")
            return output, error
        except Exception as e:
            print(f"Error executing command '{command}': {e}")
            raise

    def upload_file(self, local_path, remote_path):
        self._connect()
        try:
            sftp = self.client.open_sftp()
            sftp.put(local_path, remote_path)
            sftp.close()
            print(f"File '{local_path}' uploaded to '{remote_path}' on {self.host}")
        except Exception as e:
            print(f"Error uploading file: {e}")
            raise

    def download_file(self, remote_path, local_path):
        self._connect()
        try:
            sftp = self.client.open_sftp()
            sftp.get(remote_path, local_path)
            sftp.close()
            print(f"File '{remote_path}' downloaded to '{local_path}' from {self.host}")
        except Exception as e:
            print(f"Error downloading file: {e}")
            raise

    def close(self):
        if self.client:
            self.client.close()
            print(f"SSH connection to {self.host} closed.")
```
### ðŸ§ª Senaryo 3: Bir sistem yÃ¶netim aracÄ± uzak sunuculara baÄŸlanmak iÃ§in SSH kullanÄ±r. BaÄŸlantÄ± bilgileri gÃ¼venli depolama alanÄ±ndan okunur. AraÃ§ bu bilgilerle sunuculara eriÅŸim saÄŸlar. YÃ¶netim iÅŸlemleri gÃ¼venli kanal Ã¼zerinden yapÄ±lÄ±r.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 95
```typescript

import { NodeSSH } from 'node-ssh'; // npm install node-ssh
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';

dotenv.config();

export class SshManager {
    private ssh: NodeSSH;
    private config: {
        host: string;
        username: string;
        password?: string;
        privateKey?: string;
        port?: number;
    };

    constructor() {
        this.ssh = new NodeSSH();
        this.config = {
            host: process.env.SSH_HOST || '',
            username: process.env.SSH_USERNAME || '',
            password: process.env.SSH_PASSWORD,
            privateKey: process.env.SSH_PRIVATE_KEY_PATH ? fs.readFileSync(path.resolve(process.env.SSH_PRIVATE_KEY_PATH), 'utf8') : undefined,
            port: process.env.SSH_PORT ? parseInt(process.env.SSH_PORT) : 22,
        };

        if (!this.config.host || !this.config.username) {
            throw new Error('SSH_HOST and SSH_USERNAME must be set in environment variables.');
        }
        if (!this.config.password && !this.config.privateKey) {
            throw new Error('Either SSH_PASSWORD or SSH_PRIVATE_KEY_PATH must be set for authentication.');
        }
    }

    public async connect(): Promise<void> {
        try {
            await this.ssh.connect(this.config);
            console.log(`Successfully connected to SSH host: ${this.config.host}`);
        } catch (error) {
            console.error(`Failed to connect to SSH host ${this.config.host}:`, error);
            throw error;
        }
    }

    public async executeCommand(command: string): Promise<{ stdout: string; stderr: string }> {
        if (!this.ssh.isConnected()) {
            await this.connect();
        }
        try {
            const result = await this.ssh.execCommand(command);
            if (result.stderr) {
                console.warn(`Command "${command}" produced stderr: ${result.stderr}`);
            }
            return result;
        } catch (error) {
            console.error(`Error executing command "${command}":`, error);
            throw error;
        }
    }

    public async uploadFile(localPath: string, remotePath: string): Promise<void> {
        if (!this.ssh.isConnected()) {
            await this.connect();
        }
        try {
            await this.ssh.putFile(localPath, remotePath);
            console.log(`Uploaded ${localPath} to ${remotePath}`);
        } catch (error) {
            console.error(`Error uploading file ${localPath} to ${remotePath}:`, error);
            throw error;
        }
    }

    public async downloadFile(remotePath: string, localPath: string): Promise<void> {
        if (!this.ssh.isConnected()) {
            await this.connect();
        }
        try {
            await this.ssh.getFile(localPath, remotePath);
            console.log(`Downloaded ${remotePath} to ${localPath}`);
        } catch (error) {
            console.error(`Error downloading file ${remotePath} to ${localPath}:`, error);
            throw error;
        }
    }

    public disconnect(): void {
        if (this.ssh.isConnected()) {
            this.ssh.dispose();
            console.log('SSH connection disconnected.');
        }
    }
}
```
### ðŸ§ª Senaryo 4: Bir dosya transfer uygulamasÄ± FTP sunucularÄ±yla iletiÅŸim kurar. Sunucu bilgileri kullanÄ±cÄ± ayarlarÄ±ndan alÄ±nÄ±r. Uygulama bu bilgilerle dosya transferi gerÃ§ekleÅŸtirir. Transfer iÅŸlemleri gÃ¼venli protokollerle yapÄ±lÄ±r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 96
```csharp

using System.Net.FtpClient; // Requires the FluentFTP NuGet package
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;

public class FtpFileManager
{
    private readonly IConfiguration _configuration;
    private readonly string _host;
    private readonly string _username;
    private readonly string _password;
    private readonly int _port;
    private readonly bool _useSsl;

    public FtpFileManager(IConfiguration configuration)
    {
        _configuration = configuration;

        _host = _configuration["FtpSettings:Host"];
        _username = _configuration["FtpSettings:Username"];
        _password = _configuration["FtpSettings:Password"];

        if (string.IsNullOrEmpty(_host) || string.IsNullOrEmpty(_username) || string.IsNullOrEmpty(_password))
        {
            throw new InvalidOperationException("FTP host, username, and password must be configured.");
        }

        if (!int.TryParse(_configuration["FtpSettings:Port"], out _port))
        {
            _port = 21; // Default FTP port
        }
        if (!bool.TryParse(_configuration["FtpSettings:UseSsl"], out _useSsl))
        {
            _useSsl = true; // Default to FTPS for security
        }
    }

    public async Task UploadFileAsync(string localFilePath, string remoteFilePath)
    {
        using (var client = CreateFtpClient())
        {
            try
            {
                await client.ConnectAsync();
                using (var fileStream = File.OpenRead(localFilePath))
                {
                    await client.UploadFileAsync(fileStream, remoteFilePath, FtpExists.Overwrite, true);
                }
                Console.WriteLine(<span class="math-inline">"File '\{localFilePath\}' uploaded to '\{remoteFilePath\}'\."\);
\}
catch \(Exception ex\)
\{
Console\.WriteLine\(</span>"FTP upload failed: {ex.Message}");
                throw;
            }
            finally
            {
                await client.DisconnectAsync();
            }
        }
    }

    public async Task DownloadFileAsync(string remoteFilePath, string localFilePath)
    {
        using (var client = CreateFtpClient())
        {
            try
            {
                await client.ConnectAsync();
                using (var fileStream = File.Create(localFilePath))
                {
                    await client.DownloadFileAsync(fileStream, remoteFilePath, true);
                }
                Console.WriteLine(<span class="math-inline">"File '\{remoteFilePath\}' downloaded to '\{localFilePath\}'\."\);
\}
catch \(Exception ex\)
\{
Console\.WriteLine\(</span>"FTP download failed: {ex.Message}");
                throw;
            }
            finally
            {
                await client.DisconnectAsync();
            }
        }
    }

    private FtpClient CreateFtpClient()
    {
        var client = new FtpClient(_host, _port, _username, _password);
        client.Config.EncryptionMode = _useSsl ? FtpEncryptionMode.Explicit : FtpEncryptionMode.None;
        client.Config.ValidateAnyCertificate = true; // For testing, production should use proper certificate validation
        return client;
    }
}
```
### ðŸ§ª Senaryo 4: Bir dosya transfer uygulamasÄ± FTP sunucularÄ±yla iletiÅŸim kurar. Sunucu bilgileri kullanÄ±cÄ± ayarlarÄ±ndan alÄ±nÄ±r. Uygulama bu bilgilerle dosya transferi gerÃ§ekleÅŸtirir. Transfer iÅŸlemleri gÃ¼venli protokollerle yapÄ±lÄ±r.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 65
```python

import os
from ftplib import FTP_TLS # For secure FTPS
from ftplib import FTP # For insecure FTP (avoid if possible)
import ssl

class FtpFileManager:
    def __init__(self, host, username, password, port=21, use_ssl=True):
        self.host = host
        self.username = username
        self.password = password
        self.port = port
        self.use_ssl = use_ssl
        self.ftp_client = None

    def connect(self):
        try:
            if self.use_ssl:
                # context = ssl.create_default_context()
                # context.check_hostname = False # Not recommended for production without proper validation
                # context.verify_mode = ssl.CERT_NONE # Not recommended for production without proper validation
                self.ftp_client = FTP_TLS(timeout=30)
                self.ftp_client.connect(self.host, self.port)
                self.ftp_client.auth()
                self.ftp_client.prot_p() # Switch to secure data connection
            else:
                self.ftp_client = FTP(timeout=30)
                self.ftp_client.connect(self.host, self.port)

            self.ftp_client.login(self.username, self.password)
            print(f"Successfully connected to FTP server: {self.host}")
        except Exception as e:
            print(f"Failed to connect to FTP server: {e}")
            self.ftp_client = None
            raise

    def disconnect(self):
        if self.ftp_client:
            self.ftp_client.quit()
            self.ftp_client = None
            print("Disconnected from FTP server.")

    def upload_file(self, local_path, remote_path):
        if not self.ftp_client:
            self.connect()
        if self.ftp_client:
            try:
                with open(local_path, 'rb') as fp:
                    self.ftp_client.storbinary(f'STOR {remote_path}', fp)
                print(f"File '{local_path}' uploaded to '{remote_path}'.")
            except Exception as e:
                print(f"Error uploading file: {e}")
                raise

    def download_file(self, remote_path, local_path):
        if not self.ftp_client:
            self.connect()
        if self.ftp_client:
            try:
                with open(local_path, 'wb') as fp:
                    self.ftp_client.retrbinary(f'RETR {remote_path}', fp.write)
                print(f"File '{remote_path}' downloaded to '{local_path}'.")
            except Exception as e:
                print(f"Error downloading file: {e}")
                raise
```
### ðŸ§ª Senaryo 4: Bir dosya transfer uygulamasÄ± FTP sunucularÄ±yla iletiÅŸim kurar. Sunucu bilgileri kullanÄ±cÄ± ayarlarÄ±ndan alÄ±nÄ±r. Uygulama bu bilgilerle dosya transferi gerÃ§ekleÅŸtirir. Transfer iÅŸlemleri gÃ¼venli protokollerle yapÄ±lÄ±r.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 95
```typescript

import { Client as FtpClient } from 'ftp'; // npm install ftp
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import { Readable } from 'stream';

dotenv.config();

export class FtpFileManager {
    private client: FtpClient;
    private config: {
        host: string;
        user: string;
        password?: string;
        port?: number;
        secure?: boolean | 'implicit';
    };

    constructor() {
        this.client = new FtpClient();
        this.config = {
            host: process.env.FTP_HOST || '',
            user: process.env.FTP_USERNAME || '',
            password: process.env.FTP_PASSWORD,
            port: process.env.FTP_PORT ? parseInt(process.env.FTP_PORT) : 21,
            secure: process.env.FTP_SECURE === 'true', // Use FTPS
        };

        if (!this.config.host || !this.config.user || !this.config.password) {
            throw new Error('FTP_HOST, FTP_USERNAME, and FTP_PASSWORD must be set in environment variables.');
        }

        this.client.on('ready', () => {
            console.log(`FTP client connected to ${this.config.host}`);
        });

        this.client.on('error', (err) => {
            console.error('FTP client error:', err);
        });

        this.client.on('end', () => {
            console.log('FTP client disconnected.');
        });
    }

    public async connect(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.client.connect(this.config);
            this.client.on('ready', resolve);
            this.client.on('error', reject);
        });
    }

    public async disconnect(): Promise<void> {
        return new Promise((resolve) => {
            this.client.end();
            this.client.on('end', resolve);
        });
    }

    public async uploadFile(localPath: string, remotePath: string): Promise<void> {
        if (!this.client) {
            throw new Error('FTP client not connected. Call connect() first.');
        }
        return new Promise((resolve, reject) => {
            this.client.put(localPath, remotePath, (err) => {
                if (err) {
                    console.error(`Error uploading file ${localPath} to ${remotePath}:`, err);
                    return reject(err);
                }
                console.log(`File '${localPath}' uploaded to '${remotePath}'.`);
                resolve();
            });
        });
    }

    public async downloadFile(remotePath: string, localPath: string): Promise<void> {
        if (!this.client) {
            throw new Error('FTP client not connected. Call connect() first.');
        }
        return new Promise((resolve, reject) => {
            this.client.get(remotePath, (err, stream) => {
                if (err) {
                    console.error(`Error getting file ${remotePath}:`, err);
                    return reject(err);
                }
                stream.once('close', () => {
                    console.log(`File '${remotePath}' downloaded to '${localPath}'.`);
                    resolve();
                });
                stream.pipe(fs.createWriteStream(localPath));
            });
        });
    }
}
```
### ðŸ§ª Senaryo 5: Bir e-posta uygulamasÄ± SMTP sunucusu Ã¼zerinden mail gÃ¶nderir. Mail sunucu ayarlarÄ± kullanÄ±cÄ± konfigÃ¼rasyonundan okunur. Uygulama bu ayarlarla mail sunucusuna baÄŸlanÄ±r. E-postalar gÃ¼venli ÅŸekilde iletilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 78
```csharp

using System.Net.Mail;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;

public class EmailSender
{
    private readonly IConfiguration _configuration;
    private readonly string _smtpHost;
    private readonly int _smtpPort;
    private readonly string _username;
    private readonly string _password;
    private readonly bool _enableSsl;
    private readonly string _fromAddress;
    private readonly string _fromDisplayName;

    public EmailSender(IConfiguration configuration)
    {
        _configuration = configuration;

        _smtpHost = _configuration["EmailSettings:SmtpHost"];
        _username = _configuration["EmailSettings:Username"];
        _password = _configuration["EmailSettings:Password"];
        _fromAddress = _configuration["EmailSettings:FromAddress"];
        _fromDisplayName = _configuration["EmailSettings:FromDisplayName"] ?? _fromAddress;

        if (string.IsNullOrEmpty(_smtpHost) || string.IsNullOrEmpty(_username) || string.IsNullOrEmpty(_password) || string.IsNullOrEmpty(_fromAddress))
        {
            throw new InvalidOperationException("SMTP host, username, password, and from address must be configured.");
        }

        if (!int.TryParse(_configuration["EmailSettings:SmtpPort"], out _smtpPort))
        {
            _smtpPort = 587; // Default SMTP port for TLS/SSL
        }
        if (!bool.TryParse(_configuration["EmailSettings:EnableSsl"], out _enableSsl))
        {
            _enableSsl = true; // Default to true for secure email
        }
    }

    public async Task SendEmailAsync(string toAddress, string subject, string body, bool isHtml = false)
    {
        using (var message = new MailMessage())
        {
            message.From = new MailAddress(_fromAddress, _fromDisplayName);
            message.To.Add(toAddress);
            message.Subject = subject;
            message.Body = body;
            message.IsBodyHtml = isHtml;

            using (var smtpClient = new SmtpClient(_smtpHost, _smtpPort))
            {
                smtpClient.Credentials = new NetworkCredential(_username, _password);
                smtpClient.EnableSsl = _enableSsl;
                smtpClient.DeliveryMethod = SmtpDeliveryMethod.Network;
                smtpClient.Timeout = 20000; // 20 seconds

                try
                {
                    await smtpClient.SendMailAsync(message);
                    Console.WriteLine(<span class="math-inline">"Email sent successfully to \{toAddress\}"\);
\}
catch \(SmtpException ex\)
\{
Console\.WriteLine\(</span>"SMTP error occurred: {ex.StatusCode} - {ex.Message}");
                    throw;
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Failed to send email: {ex.Message}");
                    throw;
                }
            }
        }
    }
}
```
### ðŸ§ª Senaryo 5: Bir e-posta uygulamasÄ± SMTP sunucusu Ã¼zerinden mail gÃ¶nderir. Mail sunucu ayarlarÄ± kullanÄ±cÄ± konfigÃ¼rasyonundan okunur. Uygulama bu ayarlarla mail sunucusuna baÄŸlanÄ±r. E-postalar gÃ¼venli ÅŸekilde iletilir.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 60
```python

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import os

class EmailSender:
    def __init__(self, smtp_host, smtp_port, username, password, from_address, from_display_name=None, use_ssl=True):
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.username = username
        self.password = password
        self.from_address = from_address
        self.from_display_name = from_display_name if from_display_name else from_address
        self.use_ssl = use_ssl
        self.server = None

    def connect(self):
        try:
            if self.use_ssl:
                self.server = smtplib.SMTP_SSL(self.smtp_host, self.smtp_port, timeout=30)
            else:
                self.server = smtplib.SMTP(self.smtp_host, self.smtp_port, timeout=30)
                self.server.starttls() # Start TLS encryption

            self.server.login(self.username, self.password)
            print("Successfully connected to SMTP server.")
        except Exception as e:
            print(f"Failed to connect to SMTP server: {e}")
            self.server = None
            raise

    def disconnect(self):
        if self.server:
            self.server.quit()
            self.server = None
            print("Disconnected from SMTP server.")

    def send_email(self, to_address, subject, body, is_html=False):
        if not self.server:
            self.connect()
        if not self.server:
            raise Exception("SMTP server not connected.")

        msg = MIMEMultipart()
        msg['From'] = f"{self.from_display_name} <{self.from_address}>"
        msg['To'] = to_address
        msg['Subject'] = subject

        if is_html:
            msg.attach(MIMEText(body, 'html'))
        else:
            msg.attach(MIMEText(body, 'plain'))

        try:
            self.server.send_message(msg)
            print(f"Email sent successfully to {to_address}")
        except Exception as e:
            print(f"Failed to send email to {to_address}: {e}")
            raise
```
### ðŸ§ª Senaryo 5: Bir e-posta uygulamasÄ± SMTP sunucusu Ã¼zerinden mail gÃ¶nderir. Mail sunucu ayarlarÄ± kullanÄ±cÄ± konfigÃ¼rasyonundan okunur. Uygulama bu ayarlarla mail sunucusuna baÄŸlanÄ±r. E-postalar gÃ¼venli ÅŸekilde iletilir.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 77
```typescript

import * as nodemailer from 'nodemailer'; // npm install nodemailer
import * as dotenv from 'dotenv';

dotenv.config();

export class EmailSender {
    private transporter: nodemailer.Transporter;
    private config: {
        host: string;
        port: number;
        secure: boolean;
        auth: {
            user: string;
            pass: string;
        };
        fromAddress: string;
        fromDisplayName: string;
    };

    constructor() {
        this.config = {
            host: process.env.SMTP_HOST || '',
            port: process.env.SMTP_PORT ? parseInt(process.env.SMTP_PORT) : 587,
            secure: process.env.SMTP_SECURE === 'true', // true for 465, false for other ports (use TLS)
            auth: {
                user: process.env.SMTP_USERNAME || '',
                pass: process.env.SMTP_PASSWORD || '',
            },
            fromAddress: process.env.SMTP_FROM_ADDRESS || '',
            fromDisplayName: process.env.SMTP_FROM_DISPLAY_NAME || process.env.SMTP_FROM_ADDRESS || '',
        };

        if (!this.config.host || !this.config.auth.user || !this.config.auth.pass || !this.config.fromAddress) {
            throw new Error('SMTP_HOST, SMTP_USERNAME, SMTP_PASSWORD, and SMTP_FROM_ADDRESS must be set in environment variables.');
        }

        this.transporter = nodemailer.createTransport({
            host: this.config.host,
            port: this.config.port,
            secure: this.config.secure,
            auth: this.config.auth,
            tls: {
                // Do not fail on invalid certs, for development only!
                // rejectUnauthorized: false,
            },
        });

        // Verify connection configuration
        this.transporter.verify((error, success) => {
            if (error) {
                console.error('SMTP server connection verification failed:', error);
            } else {
                console.log('SMTP server is ready to take messages');
            }
        });
    }

    public async sendEmail(toAddress: string, subject: string, body: string, isHtml: boolean = false): Promise<nodemailer.SentMessageInfo> {
        const mailOptions = {
            from: `"${this.config.fromDisplayName}" <${this.config.fromAddress}>`,
            to: toAddress,
            subject: subject,
            html: isHtml ? body : undefined,
            text: isHtml ? undefined : body,
        };

        try {
            const info = await this.transporter.sendMail(mailOptions);
            console.log('Email sent: %s', info.messageId);
            return info;
        } catch (error) {
            console.error('Error sending email:', error);
            throw error;
        }
    }
}
```
### ðŸ§ª Senaryo 6: Bir bulut depolama aracÄ± uzak depolama servislerine baÄŸlanÄ±r. EriÅŸim bilgileri gÃ¼venli ayar dosyasÄ±ndan alÄ±nÄ±r. AraÃ§ bu bilgilerle bulut servisine eriÅŸim saÄŸlar. Dosya iÅŸlemleri gÃ¼venli API Ã¼zerinden yapÄ±lÄ±r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 105
```csharp

using Amazon.S3; // Requires AWSSDK.S3 NuGet package
using Amazon.S3.Transfer;
using Microsoft.Extensions.Configuration;
using System.IO;
using System.Threading.Tasks;

public class S3CloudStorageManager
{
    private readonly IAmazonS3 _s3Client;
    private readonly TransferUtility _transferUtility;
    private readonly string _bucketName;

    public S3CloudStorageManager(IConfiguration configuration)
    {
        _bucketName = configuration["AwsS3Settings:BucketName"];
        if (string.IsNullOrEmpty(_bucketName))
        {
            throw new InvalidOperationException("AWS S3 BucketName is not configured.");
        }

        // AWS SDK automatically picks up credentials from environment variables,
        // shared credential files, or IAM roles.
        // For explicit configuration:
        // var awsAccessKeyId = configuration["AwsS3Settings:AccessKeyId"];
        // var awsSecretAccessKey = configuration["AwsS3Settings:SecretAccessKey"];
        // if (string.IsNullOrEmpty(awsAccessKeyId) || string.IsNullOrEmpty(awsSecretAccessKey))
        // {
        //     throw new InvalidOperationException("AWS AccessKeyId and SecretAccessKey must be configured.");
        // }
        // _s3Client = new AmazonS3Client(awsAccessKeyId, awsSecretAccessKey, Amazon.RegionEndpoint.EUCentral1); // Example region

        _s3Client = new AmazonS3Client(); // Uses default credential chain
        _transferUtility = new TransferUtility(_s3Client);
    }

    public async Task UploadFileAsync(string localFilePath, string remoteKey)
    {
        try
        {
            var fileTransferRequest = new TransferUtilityUploadRequest
            {
                FilePath = localFilePath,
                BucketName = _bucketName,
                Key = remoteKey,
                CannedACL = S3CannedACL.Private // Recommended for most cases
            };
            await _transferUtility.UploadAsync(fileTransferRequest);
            Console.WriteLine(<span class="math-inline">"Successfully uploaded '\{localFilePath\}' to s3\://\{\_bucketName\}/\{remoteKey\}"\);
\}
catch \(AmazonS3Exception ex\)
\{
Console\.WriteLine\(</span>"Error uploading file to S3: {ex.Message}");
            throw;
        }
        catch (Exception ex)
        {
            Console.WriteLine(<span class="math-inline">"An unexpected error occurred during S3 upload\: \{ex\.Message\}"\);
throw;
\}
\}
public async Task DownloadFileAsync\(string remoteKey, string localFilePath\)
\{
try
\{
var fileTransferRequest \= new TransferUtilityDownloadRequest
\{
BucketName \= \_bucketName,
Key \= remoteKey,
FilePath \= localFilePath
\};
await \_transferUtility\.DownloadAsync\(fileTransferRequest\);
Console\.WriteLine\(</span>"Successfully downloaded s3://{_bucketName}/{remoteKey} to '{localFilePath}'");
        }
        catch (AmazonS3Exception ex)
        {
            Console.WriteLine(<span class="math-inline">"Error downloading file from S3\: \{ex\.Message\}"\);
throw;
\}
catch \(Exception ex\)
\{
Console\.WriteLine\(</span>"An unexpected error occurred during S3 download: {ex.Message}");
            throw;
        }
    }

    public async Task DeleteFileAsync(string remoteKey)
    {
        try
        {
            await _s3Client.DeleteObjectAsync(_bucketName, remoteKey);
            Console.WriteLine(<span class="math-inline">"Successfully deleted s3\://\{\_bucketName\}/\{remoteKey\}"\);
\}
catch \(AmazonS3Exception ex\)
\{
Console\.WriteLine\(</span>"Error deleting file from S3: {ex.Message}");
            throw;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An unexpected error occurred during S3 deletion: {ex.Message}");
            throw;
        }
    }
}
```
### ðŸ§ª Senaryo 6: Bir bulut depolama aracÄ± uzak depolama servislerine baÄŸlanÄ±r. EriÅŸim bilgileri gÃ¼venli ayar dosyasÄ±ndan alÄ±nÄ±r. AraÃ§ bu bilgilerle bulut servisine eriÅŸim saÄŸlar. Dosya iÅŸlemleri gÃ¼venli API Ã¼zerinden yapÄ±lÄ±r.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 55
```python

import os
import boto3 # pip install boto3
from botocore.exceptions import ClientError

class S3CloudStorageManager:
    def __init__(self, bucket_name):
        self.bucket_name = bucket_name
        # boto3 automatically uses credentials from environment variables (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY),
        # shared credential file (~/.aws/credentials), or IAM roles.
        self.s3_client = boto3.client('s3')
        self.s3_resource = boto3.resource('s3') # For higher-level operations

    def upload_file(self, local_file_path, s3_object_name=None):
        if s3_object_name is None:
            s3_object_name = os.path.basename(local_file_path)

        try:
            self.s3_client.upload_file(local_file_path, self.bucket_name, s3_object_name)
            print(f"File '{local_file_path}' uploaded to s3://{self.bucket_name}/{s3_object_name}")
        except ClientError as e:
            print(f"Error uploading file to S3: {e}")
            raise
        except FileNotFoundError:
            print(f"Local file not found: {local_file_path}")
            raise

    def download_file(self, s3_object_name, local_file_path=None):
        if local_file_path is None:
            local_file_path = s3_object_name # Save with same name in current directory

        try:
            self.s3_client.download_file(self.bucket_name, s3_object_name, local_file_path)
            print(f"File 's3://{self.bucket_name}/{s3_object_name}' downloaded to '{local_file_path}'")
        except ClientError as e:
            print(f"Error downloading file from S3: {e}")
            raise

    def delete_file(self, s3_object_name):
        try:
            self.s3_client.delete_object(Bucket=self.bucket_name, Key=s3_object_name)
            print(f"File 's3://{self.bucket_name}/{s3_object_name}' deleted.")
        except ClientError as e:
            print(f"Error deleting file from S3: {e}")
            raise

    def list_files(self, prefix=''):
        try:
            response = self.s3_client.list_objects_v2(Bucket=self.bucket_name, Prefix=prefix)
            if 'Contents' in response:
                return [obj['Key'] for obj in response['Contents']]
            return []
        except ClientError as e:
            print(f"Error listing files in S3 bucket: {e}")
            raise
```
### ðŸ§ª Senaryo 6: Bir bulut depolama aracÄ± uzak depolama servislerine baÄŸlanÄ±r. EriÅŸim bilgileri gÃ¼venli ayar dosyasÄ±ndan alÄ±nÄ±r. AraÃ§ bu bilgilerle bulut servisine eriÅŸim saÄŸlar. Dosya iÅŸlemleri gÃ¼venli API Ã¼zerinden yapÄ±lÄ±r.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 115
```typescript

import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand, ListObjectsV2Command } from '@aws-sdk/client-s3'; // npm install @aws-sdk/client-s3
import { Upload } from '@aws-sdk/lib-storage'; // npm install @aws-sdk/lib-storage
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';

dotenv.config();

export class S3CloudStorageManager {
    private s3Client: S3Client;
    private bucketName: string;

    constructor() {
        this.bucketName = process.env.AWS_S3_BUCKET_NAME || '';
        if (!this.bucketName) {
            throw new Error('AWS_S3_BUCKET_NAME is not set in environment variables.');
        }

        // AWS SDK v3 automatically uses credentials from environment variables (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY),
        // shared credential file (~/.aws/credentials), or IAM roles.
        // You can also explicitly configure credentials and region:
        this.s3Client = new S3Client({
            region: process.env.AWS_REGION || 'us-east-1', // Default region if not specified
            // credentials: {
            //     accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
            //     secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
            // },
        });
    }

    public async uploadFile(localFilePath: string, remoteKey: string): Promise<string | undefined> {
        try {
            const fileStream = fs.createReadStream(localFilePath);
            const upload = new Upload({
                client: this.s3Client,
                params: {
                    Bucket: this.bucketName,
                    Key: remoteKey,
                    Body: fileStream,
                    ACL: 'private', // Access Control List
                },
            });

            upload.on('httpUploadProgress', (progress) => {
                console.log(`Upload progress: ${progress.loaded}/${progress.total} (${(progress.loaded / progress.total * 100).toFixed(2)}%)`);
            });

            const data = await upload.done();
            console.log(`Successfully uploaded '${localFilePath}' to s3://${this.bucketName}/${remoteKey}`);
            return data.Location; // Returns the URL of the uploaded object if successful
        } catch (error) {
            console.error(`Error uploading file to S3:`, error);
            throw error;
        }
    }

    public async downloadFile(remoteKey: string, localFilePath: string): Promise<void> {
        try {
            const command = new GetObjectCommand({
                Bucket: this.bucketName,
                Key: remoteKey,
            });
            const { Body } = await this.s3Client.send(command);

            if (Body) {
                await new Promise((resolve, reject) => {
                    const writeStream = fs.createWriteStream(localFilePath);
                    (Body as ReadableStream).pipe(writeStream)
                        .on('finish', () => {
                            console.log(`Successfully downloaded s3://${this.bucketName}/${remoteKey} to '${localFilePath}'`);
                            resolve(null);
                        })
                        .on('error', (err: Error) => {
                            console.error(`Error writing file to local system:`, err);
                            reject(err);
                        });
                });
            } else {
                throw new Error('File body is empty.');
            }
        } catch (error) {
            console.error(`Error downloading file from S3:`, error);
            throw error;
        }
    }

    public async deleteFile(remoteKey: string): Promise<void> {
        try {
            const command = new DeleteObjectCommand({
                Bucket: this.bucketName,
                Key: remoteKey,
            });
            await this.s3Client.send(command);
            console.log(`Successfully deleted s3://${this.bucketName}/${remoteKey}`);
        } catch (error) {
            console.error(`Error deleting file from S3:`, error);
            throw error;
        }
    }

    public async listFiles(prefix: string = ''): Promise<string[]> {
        try {
            const command = new ListObjectsV2Command({
                Bucket: this.bucketName,
                Prefix: prefix,
            });
            const { Contents } = await this.s3Client.send(command);
            return Contents ? Contents.map(obj => obj.Key || '') : [];
        } catch (error) {
            console.error(`Error listing files in S3 bucket:`, error);
            throw error;
        }
    }
}
```
### ðŸ§ª Senaryo 7: Bir monitoring uygulamasÄ± Ã§eÅŸitli sistemlerin durumunu kontrol eder. EriÅŸim bilgileri ÅŸifreli konfigÃ¼rasyon dosyasÄ±nda tutulur. Uygulama bu bilgilerle sistemlere baÄŸlanÄ±r. Ä°zleme verileri gÃ¼venli ÅŸekilde toplanÄ±r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 130
```csharp

using Microsoft.Extensions.Configuration;
using System.Net.Http;
using System.Threading.Tasks;
using System.Text.Json;
using System.Security.Cryptography;
using System.Text;
using System;

public class SystemMonitor
{
    private readonly HttpClient _httpClient;
    private readonly IConfiguration _configuration;
    private readonly Dictionary<string, SystemConfig> _monitoredSystems;
    private readonly byte[] _encryptionKey;
    private readonly byte[] _encryptionIV; // Initialization Vector

    public SystemMonitor(HttpClient httpClient, IConfiguration configuration)
    {
        _httpClient = httpClient;
        _configuration = configuration;

        // Load encryption key and IV from secure configuration (e.g., Azure Key Vault, environment variables)
        // For demonstration, let's assume they are base64 encoded strings
        var keyBase64 = _configuration["Encryption:Key"];
        var ivBase64 = _configuration["Encryption:IV"];

        if (string.IsNullOrEmpty(keyBase64) || string.IsNullOrEmpty(ivBase64))
        {
            throw new InvalidOperationException("Encryption Key and IV must be configured.");
        }

        _encryptionKey = Convert.FromBase64String(keyBase64);
        _encryptionIV = Convert.FromBase64String(ivBase64);

        _monitoredSystems = new Dictionary<string, SystemConfig>();
        LoadMonitoredSystems();
    }

    private void LoadMonitoredSystems()
    {
        var systemsConfig = _configuration.GetSection("MonitoredSystems").Get<Dictionary<string, EncryptedSystemConfig>>();
        if (systemsConfig == null) return;

        foreach (var entry in systemsConfig)
        {
            try
            {
                var decryptedUsername = DecryptString(entry.Value.EncryptedUsername);
                var decryptedPassword = DecryptString(entry.Value.EncryptedPassword);
                _monitoredSystems.Add(entry.Key, new SystemConfig
                {
                    BaseUrl = entry.Value.BaseUrl,
                    Username = decryptedUsername,
                    Password = decryptedPassword,
                    Type = entry.Value.Type
                });
                Console.WriteLine(<span class="math-inline">"Loaded and decrypted config for system\: \{entry\.Key\}"\);
\}
catch \(Exception ex\)
\{
Console\.WriteLine\(</span>"Error decrypting config for system {entry.Key}: {ex.Message}");
                // Optionally skip this system or re-throw
            }
        }
    }

    public async Task<string> CheckSystemStatusAsync(string systemName, string endpoint)
    {
        if (!_monitoredSystems.TryGetValue(systemName, out var config))
        {
            throw new ArgumentException(<span class="math-inline">"System '\{systemName\}' not found in configuration\."\);
\}
try
\{
// Example\: Basic Auth for a system API
var byteArray \= Encoding\.ASCII\.GetBytes\(</span>"{config.Username}:{config.Password}");
            _httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Basic", Convert.ToBase64String(byteArray));

            var requestUri = <span class="math-inline">"\{config\.BaseUrl\.TrimEnd\('/'\)\}/\{endpoint\.TrimStart\('/'\)\}";
var response \= await \_httpClient\.GetAsync\(requestUri\);
response\.EnsureSuccessStatusCode\(\);
return await response\.Content\.ReadAsStringAsync\(\);
\}
catch \(HttpRequestException ex\)
\{
Console\.WriteLine\(</span>"HTTP request failed for {systemName}: {ex.Message}");
            return <span class="math-inline">"Error\: \{ex\.Message\}";
\}
catch \(Exception ex\)
\{
Console\.WriteLine\(</span>"Error checking status for {systemName}: {ex.Message}");
            return $"Error: {ex.Message}";
        }
    }

    private string DecryptString(string cipherText)
    {
        using (Aes aesAlg = Aes.Create())
        {
            aesAlg.Key = _encryptionKey;
            aesAlg.IV = _encryptionIV;

            ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

            using (MemoryStream msDecrypt = new MemoryStream(Convert.FromBase64String(cipherText)))
            using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
            using (StreamReader srDecrypt = new StreamReader(csDecrypt))
            {
                return srDecrypt.ReadToEnd();
            }
        }
    }
}

public class SystemConfig
{
    public string BaseUrl { get; set; }
    public string Username { get; set; }
    public string Password { get; set; }
    public string Type { get; set; } // e.g., "WebAPI", "Database", "SSH"
}

public class EncryptedSystemConfig // Used for deserializing from config file
{
    public string BaseUrl { get; set; }
    public string EncryptedUsername { get; set; }
    public string EncryptedPassword { get; set; }
    public string Type { get; set; }
}
```
### ðŸ§ª Senaryo 7: Bir monitoring uygulamasÄ± Ã§eÅŸitli sistemlerin durumunu kontrol eder. EriÅŸim bilgileri ÅŸifreli konfigÃ¼rasyon dosyasÄ±nda tutulur. Uygulama bu bilgilerle sistemlere baÄŸlanÄ±r. Ä°zleme verileri gÃ¼venli ÅŸekilde toplanÄ±r.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 88
```python

import os
import json
from base64 import urlsafe_b64encode, urlsafe_b64decode
from cryptography.fernet import Fernet # pip install cryptography
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend

class SystemMonitor:
    def __init__(self, config_file='monitor_config.json', encryption_key_env_var='MONITOR_ENCRYPTION_KEY'):
        self.config_file = config_file
        self.fernet = self._get_fernet_instance(encryption_key_env_var)
        self.monitored_systems = self._load_monitored_systems()

    def _get_fernet_instance(self, env_var):
        key_b64 = os.getenv(env_var)
        if not key_b64:
            raise ValueError(f"Encryption key environment variable '{env_var}' not set. Generate one using Fernet.generate_key().decode().")
        return Fernet(key_b64.encode())

    def _decrypt_value(self, encrypted_value):
        try:
            return self.fernet.decrypt(encrypted_value.encode()).decode()
        except Exception as e:
            raise ValueError(f"Decryption failed: {e}")

    def _load_monitored_systems(self):
        systems = {}
        try:
            with open(self.config_file, 'r') as f:
                encrypted_config = json.load(f)
            
            for system_name, encrypted_details in encrypted_config.items():
                systems[system_name] = {
                    'base_url': encrypted_details['base_url'],
                    'username': self._decrypt_value(encrypted_details['username']),
                    'password': self._decrypt_value(encrypted_details['password']),
                    'type': encrypted_details.get('type', 'Unknown')
                }
                print(f"Loaded and decrypted config for system: {system_name}")
        except FileNotFoundError:
            print(f"Configuration file '{self.config_file}' not found.")
        except json.JSONDecodeError:
            print(f"Error decoding JSON from '{self.config_file}'.")
        except ValueError as e:
            print(f"Error loading or decrypting configuration: {e}")
            raise
        return systems

    def check_system_status(self, system_name, endpoint):
        if system_name not in self.monitored_systems:
            raise ValueError(f"System '{system_name}' not found in configuration.")

        config = self.monitored_systems[system_name]
        full_url = f"{config['base_url'].rstrip('/')}/{endpoint.lstrip('/')}"

        print(f"Checking status of {system_name} ({full_url})...")
        # This is a placeholder for actual monitoring logic (e.g., HTTP request, SSH command)
        # For HTTP, you'd use requests library here with appropriate authentication
        import requests
        try:
            # Example for basic HTTP authentication
            response = requests.get(full_url, auth=(config['username'], config['password']), timeout=10)
            response.raise_for_status()
            return f"System {system_name} is UP. Status: {response.status_code}. Response: {response.text[:100]}..."
        except requests.exceptions.RequestException as e:
            return f"System {system_name} is DOWN or unreachable. Error: {e}"
        except Exception as e:
            return f"An unexpected error occurred while checking {system_name}: {e}"

# Helper function to generate a Fernet key (run once and save securely)
def generate_fernet_key():
    key = Fernet.generate_key()
    return key.decode() # Store this string securely (e.g., in an environment variable)

# Example usage (assuming monitor_config.json exists with encrypted values)
# if __name__ == "__main__":
#     # Generate a key if you don't have one and set it as an environment variable
#     # print(f"Generated Fernet Key: {generate_fernet_key()}")
#     # os.environ['MONITOR_ENCRYPTION_KEY'] = 'your_generated_key_here'

#     try:
#         monitor = SystemMonitor()
#         status = monitor.check_system_status("MyWebService", "health")
#         print(status)
#     except Exception as e:
#         print(f"Application error: {e}")
```
### ðŸ§ª Senaryo 7: Bir monitoring uygulamasÄ± Ã§eÅŸitli sistemlerin durumunu kontrol eder. EriÅŸim bilgileri ÅŸifreli konfigÃ¼rasyon dosyasÄ±nda tutulur. Uygulama bu bilgilerle sistemlere baÄŸlanÄ±r. Ä°zleme verileri gÃ¼venli ÅŸekilde toplanÄ±r.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 150
```typescript

import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import { createCipheriv, createDecipheriv, randomBytes, createHash } from 'crypto'; // Node.js built-in crypto

dotenv.config();

interface SystemConfig {
    baseUrl: string;
    username: string;
    password?: string; // Decrypted password
    type: string;
}

interface EncryptedSystemConfig {
    baseUrl: string;
    encryptedUsername: string;
    encryptedPassword: string;
    type: string;
}

export class SystemMonitor {
    private monitoredSystems: Map<string, SystemConfig> = new Map();
    private encryptionKey: Buffer;
    private iv: Buffer;

    constructor(configFilePath: string = path.join(__dirname, '../config/monitor_systems.enc.json')) {
        const encryptionKeyHex = process.env.ENCRYPTION_KEY_HEX;
        const ivHex = process.env.ENCRYPTION_IV_HEX;

        if (!encryptionKeyHex || !ivHex) {
            throw new Error('ENCRYPTION_KEY_HEX and ENCRYPTION_IV_HEX must be set in environment variables.');
        }

        this.encryptionKey = Buffer.from(encryptionKeyHex, 'hex');
        this.iv = Buffer.from(ivHex, 'hex');

        this.loadMonitoredSystems(configFilePath);
    }

    private decrypt(encryptedText: string): string {
        try {
            const decipher = createDecipheriv('aes-256-cbc', this.encryptionKey, this.iv);
            let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            return decrypted;
        } catch (error) {
            console.error('Decryption failed:', error);
            throw new Error('Failed to decrypt configuration value.');
        }
    }

    private loadMonitoredSystems(configPath: string): void {
        try {
            const encryptedConfigContent = fs.readFileSync(configPath, 'utf8');
            const encryptedSystems: { [key: string]: EncryptedSystemConfig } = JSON.parse(encryptedConfigContent);

            for (const systemName in encryptedSystems) {
                if (encryptedSystems.hasOwnProperty(systemName)) {
                    const encryptedDetails = encryptedSystems[systemName];
                    const decryptedUsername = this.decrypt(encryptedDetails.encryptedUsername);
                    const decryptedPassword = this.decrypt(encryptedDetails.encryptedPassword);

                    this.monitoredSystems.set(systemName, {
                        baseUrl: encryptedDetails.baseUrl,
                        username: decryptedUsername,
                        password: decryptedPassword,
                        type: encryptedDetails.type,
                    });
                    console.log(`Loaded and decrypted config for system: ${systemName}`);
                }
            }
        } catch (error) {
            console.error('Error loading or parsing encrypted configuration file:', error);
            throw new Error('Failed to load monitoring system configurations.');
        }
    }

    public async checkSystemStatus(systemName: string, endpoint: string): Promise<string> {
        const config = this.monitoredSystems.get(systemName);
        if (!config) {
            throw new Error(`System '${systemName}' not found in configuration.`);
        }

        const apiClient = axios.create({
            baseURL: config.baseUrl,
            timeout: 15000, // 15 seconds timeout
        });

        let requestConfig: AxiosRequestConfig = {};

        // Example: Basic Auth
        if (config.username && config.password) {
            const credentials = Buffer.from(`${config.username}:${config.password}`).toString('base64');
            requestConfig.headers = {
                'Authorization': `Basic ${credentials}`,
            };
        }

        try {
            const response = await apiClient.get(endpoint, requestConfig);
            return `System ${systemName} (${config.type}) is UP. Status: ${response.status}. Data: ${JSON.stringify(response.data).substring(0, 100)}...`;
        } catch (error: any) {
            console.error(`Error checking status for ${systemName}:`, error.message);
            if (error.response) {
                return `System ${systemName} (${config.type}) is DOWN (HTTP ${error.response.status}). Response: ${JSON.stringify(error.response.data)}`;
            } else if (error.request) {
                return `System ${systemName} (${config.type}) is DOWN (No response received).`;
            } else {
                return `System ${systemName} (${config.type}) failed: ${error.message}`;
            }
        }
    }

    // --- Helper functions for generating key/IV and encrypting values (for initial setup) ---
    public static generateEncryptionKeyAndIV(): { key: string; iv: string } {
        const key = randomBytes(32); // 256-bit key
        const iv = randomBytes(16);  // 128-bit IV
        return { key: key.toString('hex'), iv: iv.toString('hex') };
    }

    public static encryptValue(value: string, keyHex: string, ivHex: string): string {
        const key = Buffer.from(keyHex, 'hex');
        const iv = Buffer.from(ivHex, 'hex');
        const cipher = createCipheriv('aes-256-cbc', key, iv);
        let encrypted = cipher.update(value, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        return encrypted;
    }
}

/*
// Example of how to generate keys and encrypt values for your config file:
const { key, iv } = SystemMonitor.generateEncryptionKeyAndIV();
console.log('Generated ENCRYPTION_KEY_HEX:', key);
console.log('Generated ENCRYPTION_IV_HEX:', iv);

const usernameToEncrypt = 'myMonitorUser';
const passwordToEncrypt = 'superSecretPass123!';
const encryptedUsername = SystemMonitor.encryptValue(usernameToEncrypt, key, iv);
const encryptedPassword = SystemMonitor.encryptValue(passwordToEncrypt, key, iv);

console.log('Encrypted Username:', encryptedUsername);
console.log('Encrypted Password:', encryptedPassword);

// You would then put these encrypted values into your monitor_systems.enc.json
// and the key/iv into your .env file or a secure secrets management system.
*/
```
### ðŸ§ª Senaryo 8: Bir log toplama servisi farklÄ± kaynaklardan log verilerini alÄ±r. Kaynak sistem bilgileri gÃ¼venli ÅŸekilde saklanÄ±r. Servis bu bilgilerle log kaynaklarÄ±na eriÅŸir. Log verileri merkezi olarak toplanÄ±r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 151
```csharp

using Microsoft.Extensions.Configuration;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using System;

// This example focuses on collecting logs via HTTP/REST API from various sources.
// For other methods like SSH, syslog, etc., dedicated clients would be used.

public class LogCollectorService
{
    private readonly IConfiguration _configuration;
    private readonly HttpClient _httpClient;
    private readonly Dictionary<string, LogSourceConfig> _logSources;

    public LogCollectorService(HttpClient httpClient, IConfiguration configuration)
    {
        _httpClient = httpClient;
        _configuration = configuration;
        _logSources = new Dictionary<string, LogSourceConfig>();
        LoadLogSourceConfigurations();
    }

    private void LoadLogSourceConfigurations()
    {
        var logSourcesSection = _configuration.GetSection("LogSources").Get<Dictionary<string, LogSourceConfig>>();
        if (logSourcesSection != null)
        {
            foreach (var entry in logSourcesSection)
            {
                // In a real application, sensitive fields like API keys/passwords would be decrypted here
                // similar to Senaryo 7, retrieved from a secure vault, or handled by managed identity.
                _logSources.Add(entry.Key, entry.Value);
                Console.WriteLine(<span class="math-inline">"Loaded log source configuration for\: \{entry\.Key\}"\);
\}
\}
else
\{
Console\.WriteLine\("No 'LogSources' section found in configuration\."\);
\}
\}
public async Task CollectLogsFromSourceAsync\(string sourceName\)
\{
if \(\!\_logSources\.TryGetValue\(sourceName, out var config\)\)
\{
Console\.WriteLine\(</span>"Log source '{sourceName}' not found in configuration.");
            return;
        }

        Console.WriteLine(<span class="math-inline">"Attempting to collect logs from \{sourceName\} \(Type\: \{config\.Type\}\)\.\.\."\);
try
\{
switch \(config\.Type\.ToLowerInvariant\(\)\)
\{
case "http\_api"\:
await CollectLogsViaHttpApi\(sourceName, config\);
break;
case "filesystem\_share"\:
await CollectLogsFromFilesystemShare\(sourceName, config\);
break;
// Add other types like "ssh", "syslog", "database" etc\.
default\:
Console\.WriteLine\(</span>"Unsupported log source type: {config.Type} for {sourceName}");
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error collecting logs from {sourceName}: {ex.Message}");
        }
    }

    private async Task CollectLogsViaHttpApi(string sourceName, LogSourceConfig config)
    {
        // Example: If the log source exposes a REST API for logs
        var requestUri = <span class="math-inline">"\{config\.BaseUrl\.TrimEnd\('/'\)\}/\{config\.Endpoint\.TrimStart\('/'\)\}";
\_httpClient\.DefaultRequestHeaders\.Clear\(\);
// Add authentication headers based on config \(e\.g\., API Key, Bearer Token\)
if \(\!string\.IsNullOrEmpty\(config\.ApiKey\)\)
\{
\_httpClient\.DefaultRequestHeaders\.Add\("X\-API\-Key", config\.ApiKey\);
\}
else if \(\!string\.IsNullOrEmpty\(config\.BearerToken\)\)
\{
\_httpClient\.DefaultRequestHeaders\.Authorization \= new AuthenticationHeaderValue\("Bearer", config\.BearerToken\);
\}
// Add other headers as needed \(e\.g\., content type, pagination info\)
HttpResponseMessage response \= await \_httpClient\.GetAsync\(requestUri\);
response\.EnsureSuccessStatusCode\(\);
string logData \= await response\.Content\.ReadAsStringAsync\(\);
Console\.WriteLine\(</span>"Collected {logData.Length} characters of logs from {sourceName} via HTTP API.");
        // Process and store logData (e.g., send to a central log sink, database, file)
        StoreCollectedLogs(sourceName, logData);
    }

    private async Task CollectLogsFromFilesystemShare(string sourceName, LogSourceConfig config)
    {
        // This would typically involve mounting a share or using specific network protocols (SMB/NFS)
        // For simplicity, this example assumes direct file access if the share is mounted or accessible.
        // In a real-world scenario, you might need specific libraries or native OS calls.

        if (!Directory.Exists(config.Path))
        {
            Console.WriteLine(<span class="math-inline">"Log path '\{config\.Path\}' for \{sourceName\} does not exist or is inaccessible\."\);
return;
\}
foreach \(var file in Directory\.GetFiles\(config\.Path, config\.FilePattern ?? "\*\.log"\)\)
\{
try
\{
// Read the log file\. For large files, stream reading is preferred\.
// You'd also typically track last read position to avoid re\-reading\.
string fileContent \= await File\.ReadAllTextAsync\(file\);
Console\.WriteLine\(</span>"Collected {fileContent.Length} characters from file '{file}' on {sourceName}.");
                StoreCollectedLogs(sourceName, fileContent, Path.GetFileName(file));
            }
            catch (Exception ex)
            {
                Console.WriteLine(<span class="math-inline">"Error reading log file '\{file\}'\: \{ex\.Message\}"\);
\}
\}
\}
private void StoreCollectedLogs\(string sourceName, string logContent, string fileName \= null\)
\{
// This is a placeholder for storing logs centrally\.
// This could be\:
// \- Writing to a database \(e\.g\., SQL, NoSQL\)
// \- Sending to a message queue \(e\.g\., Kafka, RabbitMQ\)
// \- Sending to a dedicated log management system \(e\.g\., Elasticsearch, Splunk\)
// \- Writing to a central file share with proper rotation and indexing\.
Console\.WriteLine\(</span>"Storing logs from {sourceName}" + (fileName != null ? $" (File: {fileName})" : "") + $". Content length: {logContent.Length}");
        // Example: Log to console for demonstration
        // Console.WriteLine(logContent);
    }
}

public class LogSourceConfig
{
    public string Type { get; set; } // e.g., "Http_Api", "Filesystem_Share", "SSH_Log"
    public string BaseUrl { get; set; } // For HTTP_API
    public string Endpoint { get; set; } // For HTTP_API
    public string ApiKey { get; set; } // For HTTP_API
    public string BearerToken { get; set; } // For HTTP_API
    public string Path { get; set; } // For Filesystem_Share (e.g., UNC path or local path)
    public string FilePattern { get; set; } // For Filesystem_Share (e.g., "*.log")
    // Add other fields relevant to different log source types (e.g., SshHost, SshUsername, SshPrivateKeyPath)
}
```
### ðŸ§ª Senaryo 8: Bir log toplama servisi farklÄ± kaynaklardan log verilerini alÄ±r. Kaynak sistem bilgileri gÃ¼venli ÅŸekilde saklanÄ±r. Servis bu bilgilerle log kaynaklarÄ±na eriÅŸir. Log verileri merkezi olarak toplanÄ±r.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 143
```python

import os
import json
import requests
import paramiko # For SSH log collection
import time

class LogCollectorService:
    def __init__(self, config_file='log_sources.json'):
        self.config_file = config_file
        self.log_sources = self._load_log_source_configurations()
        self.central_log_store = [] # In-memory for demonstration

    def _load_log_source_configurations(self):
        sources = {}
        try:
            with open(self.config_file, 'r') as f:
                config_data = json.load(f)
            for source_name, details in config_data.items():
                # In a real app, sensitive info (passwords, keys) would be decrypted
                # or fetched from a secure vault like HashiCorp Vault, AWS Secrets Manager.
                sources[source_name] = details
                print(f"Loaded configuration for log source: {source_name}")
        except FileNotFoundError:
            print(f"Log source configuration file '{self.config_file}' not found.")
        except json.JSONDecodeError:
            print(f"Error decoding JSON from '{self.config_file}'.")
        except Exception as e:
            print(f"An error occurred loading log source configurations: {e}")
        return sources

    def collect_logs_from_source(self, source_name):
        if source_name not in self.log_sources:
            print(f"Log source '{source_name}' not found in configuration.")
            return

        config = self.log_sources[source_name]
        source_type = config.get('type', '').lower()

        print(f"Attempting to collect logs from {source_name} (Type: {config.get('type')})...")

        try:
            if source_type == 'http_api':
                self._collect_logs_via_http_api(source_name, config)
            elif source_type == 'ssh_log':
                self._collect_logs_via_ssh(source_name, config)
            elif source_type == 'filesystem':
                self._collect_logs_from_filesystem(source_name, config)
            else:
                print(f"Unsupported log source type: {config.get('type')} for {source_name}")
        except Exception as e:
            print(f"Error collecting logs from {source_name}: {e}")

    def _collect_logs_via_http_api(self, source_name, config):
        url = f"{config['base_url'].rstrip('/')}/{config.get('endpoint', 'logs').lstrip('/')}"
        headers = {'Content-Type': 'application/json'}
        if config.get('api_key'):
            headers['X-API-Key'] = config['api_key']
        elif config.get('bearer_token'):
            headers['Authorization'] = f"Bearer {config['bearer_token']}"

        try:
            response = requests.get(url, headers=headers, timeout=15)
            response.raise_for_status()
            log_data = response.text
            print(f"Collected {len(log_data)} characters of logs from {source_name} via HTTP API.")
            self._store_collected_logs(source_name, log_data, 'http_api_log')
        except requests.exceptions.RequestException as e:
            print(f"HTTP API request failed for {source_name}: {e}")

    def _collect_logs_via_ssh(self, source_name, config):
        ssh_client = paramiko.SSHClient()
        ssh_client.load_system_host_keys()
        ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            if config.get('private_key_path'):
                key = paramiko.RSAKey.from_private_key_file(config['private_key_path'])
                ssh_client.connect(hostname=config['host'], port=config.get('port', 22), username=config['username'], pkey=key)
            else:
                ssh_client.connect(hostname=config['host'], port=config.get('port', 22), username=config['username'], password=config['password'])

            log_file_path = config.get('log_file_path', '/var/log/syslog')
            command = f"cat {log_file_path}" # Or 'tail -n 100 {log_file_path}' for recent logs

            stdin, stdout, stderr = ssh_client.exec_command(command)
            log_data = stdout.read().decode('utf-8').strip()
            error = stderr.read().decode('utf-8').strip()

            if error:
                print(f"SSH command error for {source_name}: {error}")
            print(f"Collected {len(log_data)} characters of logs from {source_name} via SSH.")
            self._store_collected_logs(source_name, log_data, os.path.basename(log_file_path))

        except paramiko.AuthenticationException:
            print(f"SSH authentication failed for {source_name}.")
        except paramiko.SSHException as e:
            print(f"SSH connection or command error for {source_name}: {e}")
        finally:
            if ssh_client:
                ssh_client.close()

    def _collect_logs_from_filesystem(self, source_name, config):
        log_dir = config.get('path')
        file_pattern = config.get('file_pattern', '*.log')

        if not os.path.isdir(log_dir):
            print(f"Filesystem path '{log_dir}' for {source_name} does not exist or is not a directory.")
            return

        import glob
        for file_path in glob.glob(os.path.join(log_dir, file_pattern)):
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    log_data = f.read()
                print(f"Collected {len(log_data)} characters from file '{file_path}' on {source_name}.")
                self._store_collected_logs(source_name, log_data, os.path.basename(file_path))
            except Exception as e:
                print(f"Error reading file '{file_path}': {e}")

    def _store_collected_logs(self, source_name, log_content, origin_identifier='unknown_origin'):
        # This is where logs would be sent to a central logging system
        # e.g., ELK Stack, Splunk, database, Kafka topic.
        # For demonstration, we'll append to an in-memory list.
        log_entry = {
            'timestamp': time.time(),
            'source': source_name,
            'origin_identifier': origin_identifier,
            'log_content': log_content
        }
        self.central_log_store.append(log_entry)
        print(f"Log from {source_name} (Origin: {origin_identifier}) stored. Total logs: {len(self.central_log_store)}")

# Example usage:
# if __name__ == "__main__":
#     # Make sure log_sources.json exists with your configurations
#     collector = LogCollectorService()
#     collector.collect_logs_from_source("WebServerLogs")
#     collector.collect_logs_from_source("DatabaseServerSSH")
#     collector.collect_logs_from_source("AppServiceAPI")
#     print("\n--- Collected Logs Summary ---")
#     for log in collector.central_log_store[:3]: # Print first 3 for brevity
#         print(f"Source: {log['source']}, Origin: {log['origin_identifier']}, Length: {len(log['log_content'])}")
```
### ðŸ§ª Senaryo 8: Bir log toplama servisi farklÄ± kaynaklardan log verilerini alÄ±r. Kaynak sistem bilgileri gÃ¼venli ÅŸekilde saklanÄ±r. Servis bu bilgilerle log kaynaklarÄ±na eriÅŸir. Log verileri merkezi olarak toplanÄ±r.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 220
```typescript

import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import { NodeSSH } from 'node-ssh'; // npm install node-ssh

dotenv.config();

interface LogSourceConfig {
    type: 'http_api' | 'ssh_log' | 'filesystem';
    name: string;
    // Common fields
    baseUrl?: string; // For http_api
    endpoint?: string; // For http_api
    apiKey?: string; // For http_api
    bearerToken?: string; // For http_api
    // SSH fields
    host?: string; // For ssh_log
    username?: string; // For ssh_log
    password?: string; // For ssh_log (use sparingly, prefer privateKey)
    privateKeyPath?: string; // For ssh_log
    port?: number; // For ssh_log
    logFilePath?: string; // For ssh_log or filesystem
    // Filesystem fields
    localPath?: string; // For filesystem
    filePattern?: string; // For filesystem (e.g., "*.log")
}

export class LogCollectorService {
    private logSources: LogSourceConfig[] = [];
    private collectedLogs: any[] = []; // Placeholder for central log store

    constructor(configFilePath: string = path.join(__dirname, '../config/log_sources.json')) {
        this.loadLogSourceConfigurations(configFilePath);
    }

    private loadLogSourceConfigurations(configPath: string): void {
        try {
            const configContent = fs.readFileSync(configPath, 'utf8');
            const parsedConfig: { [key: string]: Omit<LogSourceConfig, 'name'> } = JSON.parse(configContent);

            for (const sourceName in parsedConfig) {
                if (parsedConfig.hasOwnProperty(sourceName)) {
                    this.logSources.push({
                        name: sourceName,
                        ...parsedConfig[sourceName],
                    } as LogSourceConfig); // Type assertion for safety
                    console.log(`Loaded log source configuration for: ${sourceName}`);
                }
            }
        } catch (error) {
            console.error('Error loading or parsing log source configuration file:', error);
            throw new Error('Failed to load log source configurations.');
        }
    }

    public async collectLogsFromSource(sourceName: string): Promise<void> {
        const sourceConfig = this.logSources.find(s => s.name === sourceName);
        if (!sourceConfig) {
            console.warn(`Log source '${sourceName}' not found in configuration.`);
            return;
        }

        console.log(`Attempting to collect logs from ${sourceName} (Type: ${sourceConfig.type})...`);

        try {
            switch (sourceConfig.type) {
                case 'http_api':
                    await this.collectLogsViaHttpApi(sourceConfig);
                    break;
                case 'ssh_log':
                    await this.collectLogsViaSsh(sourceConfig);
                    break;
                case 'filesystem':
                    await this.collectLogsFromFilesystem(sourceConfig);
                    break;
                default:
                    console.warn(`Unsupported log source type: ${sourceConfig.type} for ${sourceName}`);
                    break;
            }
        } catch (error) {
            console.error(`Error collecting logs from ${sourceName}:`, error);
        }
    }

    private async collectLogsViaHttpApi(config: LogSourceConfig): Promise<void> {
        if (!config.baseUrl || !config.endpoint) {
            throw new Error(`HTTP API source '${config.name}' is missing baseUrl or endpoint.`);
        }

        const apiClient = axios.create({
            baseURL: config.baseUrl,
            timeout: 20000,
        });

        const requestConfig: AxiosRequestConfig = { headers: {} };
        if (config.apiKey) {
            requestConfig.headers['X-API-Key'] = config.apiKey;
        } else if (config.bearerToken) {
            requestConfig.headers['Authorization'] = `Bearer ${config.bearerToken}`;
        }

        const response = await apiClient.get(config.endpoint, requestConfig);
        const logData = response.data;
        console.log(`Collected logs from ${config.name} via HTTP API. Data size: ${JSON.stringify(logData).length} bytes.`);
        this.storeCollectedLogs(config.name, logData, 'http_api_log');
    }

    private async collectLogsViaSsh(config: LogSourceConfig): Promise<void> {
        if (!config.host || !config.username || !config.logFilePath) {
            throw new Error(`SSH log source '${config.name}' is missing host, username, or logFilePath.`);
        }

        const ssh = new NodeSSH();
        try {
            await ssh.connect({
                host: config.host,
                username: config.username,
                password: config.password,
                privateKey: config.privateKeyPath ? fs.readFileSync(path.resolve(config.privateKeyPath), 'utf8') : undefined,
                port: config.port || 22,
            });

            // Example: Read the last 100 lines of a log file
            const command = `tail -n 100 ${config.logFilePath}`;
            const result = await ssh.execCommand(command);

            if (result.stderr) {
                console.warn(`SSH command for ${config.name} produced stderr: ${result.stderr}`);
            }
            console.log(`Collected logs from ${config.name} via SSH. Data length: ${result.stdout.length} chars.`);
            this.storeCollectedLogs(config.name, result.stdout, path.basename(config.logFilePath));
        } finally {
            ssh.dispose();
        }
    }

    private async collectLogsFromFilesystem(config: LogSourceConfig): Promise<void> {
        if (!config.localPath) {
            throw new Error(`Filesystem log source '${config.name}' is missing localPath.`);
        }

        if (!fs.existsSync(config.localPath)) {
            console.warn(`Local path '${config.localPath}' for ${config.name} does not exist.`);
            return;
        }

        const filePattern = config.filePattern || '*.log';
        const files = fs.readdirSync(config.localPath).filter(file => {
            const regex = new RegExp(filePattern.replace(/\./g, '\\.').replace(/\*/g, '.*'));
            return regex.test(file);
        });

        for (const file of files) {
            const fullPath = path.join(config.localPath, file);
            try {
                const logContent = fs.readFileSync(fullPath, 'utf8');
                console.log(`Collected logs from file '${fullPath}' on ${config.name}.`);
                this.storeCollectedLogs(config.name, logContent, file);
            } catch (error) {
                console.error(`Error reading file ${fullPath}:`, error);
            }
        }
    }

    private storeCollectedLogs(sourceName: string, logContent: any, originIdentifier: string): void {
        // This is a placeholder for sending logs to a central system (e.g., Kafka, Splunk, database)
        const logEntry = {
            timestamp: new Date().toISOString(),
            source: sourceName,
            originIdentifier: originIdentifier,
            logContent: logContent,
        };
        this.collectedLogs.push(logEntry);
        console.log(`Log from ${sourceName} (Origin: ${originIdentifier}) stored. Total logs in memory: ${this.collectedLogs.length}`);
        // In a real application, you'd send this to a persistent store.
    }
}

/*
// Example usage:
// Ensure log_sources.json exists in config/ directory or adjust path
// Example log_sources.json:
// {
//   "WebAppLogs": {
//     "type": "http_api",
//     "baseUrl": "http://localhost:3000",
//     "endpoint": "/api/logs",
//     "apiKey": "mySecretApiKey"
//   },
//   "DBServerLogs": {
//     "type": "ssh_log",
//     "host": "your_db_server_ip",
//     "username": "admin",
//     "privateKeyPath": "./id_rsa", // Path to your SSH private key
//     "logFilePath": "/var/log/postgresql/postgresql.log"
//   },
//   "LocalSystemLogs": {
//     "type": "filesystem",
//     "localPath": "/var/log",
//     "filePattern": "auth.log*"
//   }
// }

// (async () => {
//     try {
//         const collector = new LogCollectorService();
//         await collector.collectLogsFromSource('WebAppLogs');
//         await collector.collectLogsFromSource('DBServerLogs');
//         await collector.collectLogsFromSource('LocalSystemLogs');
//         console.log('\n--- Collected Logs Summary (in-memory) ---');
//         collector.getCollectedLogs().forEach(log => {
//             console.log(`Source: ${log.source}, Origin: ${log.originIdentifier}, Content length: ${JSON.stringify(log.logContent).length}`);
//         });
//     } catch (error) {
//         console.error('Application error:', error);
//     }
// })();
*/
```
### ðŸ§ª Senaryo 9: Bir Ã¶deme iÅŸlem uygulamasÄ± bankacÄ±lÄ±k API'lerine baÄŸlanÄ±r. API eriÅŸim bilgileri gÃ¼venli vault sisteminde tutulur. Uygulama bu bilgilerle bankacÄ±lÄ±k servislerine eriÅŸir. Ã–deme iÅŸlemleri gÃ¼venli ÅŸekilde gerÃ§ekleÅŸtirilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 140
```csharp

using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using System.Text.Json;
using Microsoft.Extensions.Configuration; // Or a custom secure configuration provider
using System;

public class PaymentGatewayService
{
    private readonly HttpClient _httpClient;
    private readonly string _bankApiBaseUrl;
    private readonly string _clientId;
    private readonly string _clientSecret; // Sensitive, retrieved from vault
    private readonly string _accessToken; // Obtained via OAuth/Auth flow

    public PaymentGatewayService(HttpClient httpClient, IConfiguration configuration)
    {
        _httpClient = httpClient;
        _bankApiBaseUrl = configuration["PaymentGateway:BankApiBaseUrl"];
        _clientId = configuration["PaymentGateway:ClientId"];

        if (string.IsNullOrEmpty(_bankApiBaseUrl) || string.IsNullOrEmpty(_clientId))
        {
            throw new InvalidOperationException("Payment gateway base URL and client ID must be configured.");
        }

        _httpClient.BaseAddress = new Uri(_bankApiBaseUrl);
        _httpClient.DefaultRequestHeaders.Accept.Clear();
        _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

        // In a real application, client_secret would be fetched from a secure vault (e.g., Azure Key Vault, HashiCorp Vault)
        // at application startup or on demand, and never hardcoded or in plain text config.
        // For demonstration, let's assume it's securely retrieved:
        _clientSecret = GetClientSecretFromVault(); // Simulate vault retrieval

        // The access token would be obtained via an OAuth 2.0 client credentials or authorization code flow.
        // It would typically be refreshed periodically.
        _accessToken = GetAccessToken().Result; // Simulate getting token
    }

    private string GetClientSecretFromVault()
    {
        // This method would call out to a secure vault service.
        // Example: Azure Key Vault, HashiCorp Vault, AWS Secrets Manager.
        // For this example, we'll hardcode or read from a highly secured local env variable.
        string secret = Environment.GetEnvironmentVariable("PAYMENT_GATEWAY_CLIENT_SECRET");
        if (string.IsNullOrEmpty(secret))
        {
            throw new InvalidOperationException("PAYMENT_GATEWAY_CLIENT_SECRET environment variable is not set. It should be retrieved from a secure vault.");
        }
        Console.WriteLine("Client secret retrieved from simulated vault.");
        return secret;
    }

    private async Task<string> GetAccessToken()
    {
        // This simulates an OAuth 2.0 client credentials flow to get an access token.
        // In reality, this might be handled by an identity service or dedicated token client.
        var tokenEndpoint = _bankApiBaseUrl.TrimEnd('/') + "/oauth/token"; // Example endpoint

        var requestBody = new Dictionary<string, string>
        {
            { "grant_type", "client_credentials" },
            { "client_id", _clientId },
            { "client_secret", _clientSecret }
        };

        var content = new FormUrlEncodedContent(requestBody);

        using (var tokenClient = new HttpClient())
        {
            try
            {
                var response = await tokenClient.PostAsync(tokenEndpoint, content);
                response.EnsureSuccessStatusCode();
                var responseContent = await response.Content.ReadAsStringAsync();
                var tokenResponse = JsonSerializer.Deserialize<JsonElement>(responseContent);
                if (tokenResponse.TryGetProperty("access_token", out var accessTokenElement))
                {
                    Console.WriteLine("Access token obtained successfully.");
                    return accessTokenElement.GetString();
                }
                throw new InvalidOperationException("Access token not found in response.");
            }
            catch (HttpRequestException ex)
            {
                Console.WriteLine(<span class="math-inline">"Error obtaining access token\: \{ex\.Message\}"\);
throw new InvalidOperationException\("Failed to obtain access token for payment gateway\.", ex\);
\}
\}
\}
public async Task<PaymentResponse\> ProcessPaymentAsync\(PaymentRequest request\)
\{
if \(string\.IsNullOrEmpty\(\_accessToken\)\)
\{
throw new InvalidOperationException\("Access token is not available for payment processing\."\);
\}
\_httpClient\.DefaultRequestHeaders\.Authorization \= new AuthenticationHeaderValue\("Bearer", \_accessToken\);
try
\{
var jsonContent \= new StringContent\(JsonSerializer\.Serialize\(request\), Encoding\.UTF8, "application/json"\);
var response \= await \_httpClient\.PostAsync\("payments", jsonContent\); // "payments" is an example endpoint
response\.EnsureSuccessStatusCode\(\);
var responseBody \= await response\.Content\.ReadAsStringAsync\(\);
return JsonSerializer\.Deserialize<PaymentResponse\>\(responseBody\);
\}
catch \(HttpRequestException ex\)
\{
Console\.WriteLine\(</span>"Payment processing failed: {ex.Message}");
            // Log full response if possible for debugging, but be careful with sensitive data
            throw new InvalidOperationException("Payment processing failed due to API error.", ex);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An unexpected error occurred during payment processing: {ex.Message}");
            throw;
        }
    }
}

public class PaymentRequest
{
    public decimal Amount { get; set; }
    public string Currency { get; set; }
    public string CardNumber { get; set; } // In reality, this would be tokenized or handled by a PCI compliant service
    public string ExpiryMonth { get; set; }
    public string ExpiryYear { get; set; }
    public string Cvv { get; set; }
    public string CustomerId { get; set; }
}

public class PaymentResponse
{
    public string TransactionId { get; set; }
    public string Status { get; set; } // e.g., "Approved", "Declined"
    public string Message { get; set; }
    public decimal ProcessedAmount { get; set; }
    public string ProcessedCurrency { get; set; }
}
```
### ðŸ§ª Senaryo 9: Bir Ã¶deme iÅŸlem uygulamasÄ± bankacÄ±lÄ±k API'lerine baÄŸlanÄ±r. API eriÅŸim bilgileri gÃ¼venli vault sisteminde tutulur. Uygulama bu bilgilerle bankacÄ±lÄ±k servislerine eriÅŸir. Ã–deme iÅŸlemleri gÃ¼venli ÅŸekilde gerÃ§ekleÅŸtirilir.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 120
```python

import os
import requests
import json
import time

class PaymentGatewayService:
    def __init__(self, bank_api_base_url, client_id, vault_secret_name="PAYMENT_GATEWAY_CLIENT_SECRET"):
        self.bank_api_base_url = bank_api_base_url
        self.client_id = client_id
        self.vault_secret_name = vault_secret_name
        self._client_secret = None
        self._access_token = None
        self._token_expiry = 0 # Unix timestamp

        self._retrieve_client_secret()
        self._get_access_token()

    def _retrieve_client_secret(self):
        # In a production environment, this would integrate with a secure vault system
        # like HashiCorp Vault, AWS Secrets Manager, Azure Key Vault, or Google Secret Manager.
        # For this example, we simulate fetching from an environment variable.
        self._client_secret = os.getenv(self.vault_secret_name)
        if not self._client_secret:
            raise ValueError(f"Client secret environment variable '{self.vault_secret_name}' not set. "
                             "It should be retrieved from a secure vault.")
        print("Client secret retrieved from simulated vault.")

    def _get_access_token(self):
        # Implement OAuth 2.0 Client Credentials flow or similar for token retrieval
        if self._access_token and self._token_expiry > time.time() + 60: # Refresh if expiring within 60 seconds
            print("Using existing access token.")
            return

        token_url = f"{self.bank_api_base_url.rstrip('/')}/oauth/token"
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        data = {
            'grant_type': 'client_credentials',
            'client_id': self.client_id,
            'client_secret': self._client_secret
        }

        try:
            response = requests.post(token_url, headers=headers, data=data, timeout=10)
            response.raise_for_status() # Raise an exception for HTTP errors
            token_data = response.json()
            self._access_token = token_data.get('access_token')
            expires_in = token_data.get('expires_in', 3600) # Default to 1 hour
            self._token_expiry = time.time() + expires_in

            if not self._access_token:
                raise ValueError("Access token not found in the response from token endpoint.")
            print("New access token obtained successfully.")
        except requests.exceptions.RequestException as e:
            print(f"Error obtaining access token: {e}")
            raise
        except json.JSONDecodeError:
            print("Failed to decode JSON response from token endpoint.")
            raise

    def process_payment(self, amount, currency, card_details, customer_id):
        # card_details should ideally be tokenized or handled by a PCI compliant solution
        if not self._access_token or self._token_expiry <= time.time():
            self._get_access_token() # Attempt to refresh token

        payment_url = f"{self.bank_api_base_url.rstrip('/')}/payments" # Example payment endpoint
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {self._access_token}'
        }
        payload = {
            'amount': amount,
            'currency': currency,
            'card_number': card_details.get('number'), # In production, avoid sending raw card numbers
            'expiry_month': card_details.get('expiry_month'),
            'expiry_year': card_details.get('expiry_year'),
            'cvv': card_details.get('cvv'),
            'customer_id': customer_id
        }

        try:
            response = requests.post(payment_url, headers=headers, json=payload, timeout=20)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Payment processing failed: {e}")
            if response is not None:
                print(f"API Error Response: {response.text}")
            raise

# Example Usage:
# if __name__ == "__main__":
#     # Set this securely, e.g., via environment variable in deployment
#     # os.environ["PAYMENT_GATEWAY_CLIENT_SECRET"] = "your_actual_client_secret_from_vault"
#     bank_api_url = "[https://mock-bank-api.com](https://mock-bank-api.com)" # Replace with actual bank API base URL
#     client_id_config = "my_app_client_id"

#     try:
#         payment_service = PaymentGatewayService(bank_api_url, client_id_config)
        
#         card_info = {
#             'number': '4111222233334444', # Example, should be tokenized in real apps
#             'expiry_month': '12',
#             'expiry_year': '25',
#             'cvv': '123'
#         }
#         transaction_result = payment_service.process_payment(
#             amount=100.50,
#             currency='USD',
#             card_details=card_info,
#             customer_id='user123'
#         )
#         print("Payment successful:", transaction_result)

#     except ValueError as ve:
#         print(f"Configuration Error: {ve}")
#     except requests.exceptions.RequestException as re:
#         print(f"Network/API Error: {re}")
#     except Exception as e:
#         print(f"An unexpected error occurred: {e}")
```
### ðŸ§ª Senaryo 9: Bir Ã¶deme iÅŸlem uygulamasÄ± bankacÄ±lÄ±k API'lerine baÄŸlanÄ±r. API eriÅŸim bilgileri gÃ¼venli vault sisteminde tutulur. Uygulama bu bilgilerle bankacÄ±lÄ±k servislerine eriÅŸir. Ã–deme iÅŸlemleri gÃ¼venli ÅŸekilde gerÃ§ekleÅŸtirilir.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 152
```typescript

import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import * as dotenv from 'dotenv';

dotenv.config();

interface PaymentRequest {
    amount: number;
    currency: string;
    cardNumber: string; // In a real app, this should be a token or handled by a PCI compliant solution
    expiryMonth: string;
    expiryYear: string;
    cvv: string;
    customerId: string;
}

interface PaymentResponse {
    transactionId: string;
    status: 'Approved' | 'Declined' | 'Pending';
    message: string;
    processedAmount: number;
    processedCurrency: string;
}

export class PaymentGatewayService {
    private apiClient: AxiosInstance;
    private bankApiBaseUrl: string;
    private clientId: string;
    private clientSecret: string; // Fetched from vault
    private accessToken: string | null = null;
    private tokenExpiryTime: number = 0; // Unix timestamp

    constructor() {
        this.bankApiBaseUrl = process.env.BANK_API_BASE_URL || '';
        this.clientId = process.env.BANK_API_CLIENT_ID || '';

        if (!this.bankApiBaseUrl || !this.clientId) {
            throw new Error('BANK_API_BASE_URL and BANK_API_CLIENT_ID must be set in environment variables.');
        }

        // Simulate fetching client secret from a secure vault (e.g., Azure Key Vault, HashiCorp Vault)
        // In a real application, this would be an async call to the vault service.
        this.clientSecret = this.getSecretFromVault('BANK_API_CLIENT_SECRET');

        this.apiClient = axios.create({
            baseURL: this.bankApiBaseUrl,
            headers: {
                'Content-Type': 'application/json',
            },
            timeout: 20000, // 20 seconds
        });
    }

    private getSecretFromVault(secretName: string): string {
        // This function would typically interact with a real vault service SDK.
        // For demonstration, we're reading from environment variables, which should be set securely in production.
        const secret = process.env[secretName];
        if (!secret) {
            throw new Error(`Secret '${secretName}' not found in environment variables. It should be retrieved from a secure vault.`);
        }
        console.log(`Secret '${secretName}' retrieved from simulated vault.`);
        return secret;
    }

    private async getAccessToken(): Promise<string> {
        // Check if token is still valid (e.g., more than 60 seconds until expiry)
        if (this.accessToken && this.tokenExpiryTime > Date.now() / 1000 + 60) {
            console.log('Using existing valid access token.');
            return this.accessToken;
        }

        const tokenUrl = `${this.bankApiBaseUrl.replace(/\/+$/, '')}/oauth/token`;
        const params = new URLSearchParams();
        params.append('grant_type', 'client_credentials');
        params.append('client_id', this.clientId);
        params.append('client_secret', this.clientSecret);

        try {
            const response = await axios.post(tokenUrl, params.toString(), {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
            });

            const { access_token, expires_in } = response.data;
            if (!access_token) {
                throw new Error('Access token not found in the response.');
            }
            this.accessToken = access_token;
            this.tokenExpiryTime = Date.now() / 1000 + (expires_in || 3600); // Default to 1 hour if expires_in is not provided
            console.log('New access token obtained successfully.');
            return this.accessToken;
        } catch (error: any) {
            console.error('Error obtaining access token:', error.message);
            if (error.response) {
                console.error('Token API Response:', error.response.data);
            }
            throw new Error('Failed to obtain access token for payment gateway.');
        }
    }

    public async processPayment(request: PaymentRequest): Promise<PaymentResponse> {
        const token = await this.getAccessToken(); // Ensure token is fresh

        const config: AxiosRequestConfig = {
            headers: {
                'Authorization': `Bearer ${token}`,
            },
        };

        try {
            // In a real application, you would send tokenized card data, not raw.
            // This is a simplified example.
            const response = await this.apiClient.post<PaymentResponse>('/payments', request, config); // Example endpoint: /payments
            return response.data;
        } catch (error: any) {
            console.error('Payment processing failed:', error.message);
            if (error.response) {
                console.error('Payment API Error Response:', error.response.data);
            }
            throw new Error('Payment transaction failed.');
        }
    }
}

/*
// Example Usage:
// (async () => {
//     try {
//         // Ensure these are set as environment variables or fetched securely
//         // process.env.BANK_API_BASE_URL = "[https://api.mockbank.com](https://api.mockbank.com)";
//         // process.env.BANK_API_CLIENT_ID = "your_client_id";
//         // process.env.BANK_API_CLIENT_SECRET = "your_client_secret_from_vault"; // Should be from a secure vault

//         const paymentService = new PaymentGatewayService();
//         const paymentDetails: PaymentRequest = {
//             amount: 250.75,
//             currency: 'EUR',
//             cardNumber: '4242424242424242', // Placeholder, use tokenization in prod
//             expiryMonth: '12',
//             expiryYear: '2027',
//             cvv: '123',
//             customerId: 'cust_001',
//         };

//         const result = await paymentService.processPayment(paymentDetails);
//         console.log('Payment Result:', result);
//     } catch (error) {
//         console.error('Application Error:', error);
//     }
// })();
*/
```
### ðŸ§ª Senaryo 10: Bir rapor uygulamasÄ± farklÄ± veri kaynaklarÄ±ndan bilgi toplar. Kaynak eriÅŸim bilgileri konfigÃ¼rasyon yÃ¶netim sisteminde saklanÄ±r. Uygulama bu bilgilerle veri kaynaklarÄ±na baÄŸlanÄ±r. Raporlar gÃ¼venli veri eriÅŸimi ile oluÅŸturulur.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 181
```csharp

using Microsoft.Extensions.Configuration;
using System.Data.SqlClient; // For SQL Server example
using System.Net.Http; // For REST API example
using System.Text.Json;
using System.Threading.Tasks;
using System.Collections.Generic;
using System;

public class ReportingService
{
    private readonly IConfiguration _configuration;
    private readonly Dictionary<string, DataSourceConfig> _dataSources;
    private readonly HttpClient _httpClient; // For HTTP-based data sources

    public ReportingService(IConfiguration configuration, HttpClient httpClient)
    {
        _configuration = configuration;
        _httpClient = httpClient;
        _dataSources = new Dictionary<string, DataSourceConfig>();
        LoadDataSourceConfigurations();
    }

    private void LoadDataSourceConfigurations()
    {
        var dataSourcesSection = _configuration.GetSection("DataSources").Get<Dictionary<string, DataSourceConfig>>();
        if (dataSourcesSection != null)
        {
            foreach (var entry in dataSourcesSection)
            {
                // In a real system, sensitive information like passwords/API keys would be fetched
                // from a secure configuration management system or vault (e.g., HashiCorp Vault, Azure App Configuration with Key Vault integration).
                // For this example, we assume they are configured securely.
                _dataSources.Add(entry.Key, entry.Value);
                Console.WriteLine(<span class="math-inline">"Loaded data source configuration for\: \{entry\.Key\}"\);
\}
\}
else
\{
Console\.WriteLine\("No 'DataSources' section found in configuration\."\);
\}
\}
public async Task<List<Dictionary<string, object\>\>\> GenerateReportDataAsync\(string reportName\)
\{
var reportData \= new List<Dictionary<string, object\>\>\(\);
// In a real application, report definitions \(which data sources to use, how to join/transform\)
// would be dynamic, perhaps loaded from a database or a specialized report definition file\.
// For simplicity, we'll hardcode which sources to query based on reportName\.
switch \(reportName\.ToLowerInvariant\(\)\)
\{
case "sales\_performance"\:
if \(\_dataSources\.TryGetValue\("SalesDatabase", out var sqlConfig\)\)
\{
var salesData \= await QuerySqlDataSourceAsync\(sqlConfig, "SELECT TOP 10 ProductName, SUM\(Quantity\) AS TotalSold FROM Sales GROUP BY ProductName ORDER BY TotalSold DESC"\);
reportData\.AddRange\(salesData\);
\}
if \(\_dataSources\.TryGetValue\("MarketingApi", out var apiConfig\)\)
\{
var marketingData \= await QueryHttpApiDataSourceAsync\(apiConfig, "campaigns/summary"\);
// Merge or process marketingData with salesData if needed
reportData\.Add\(new Dictionary<string, object\> \{ \{ "MarketingSummary", marketingData \} \}\);
\}
break;
case "user\_activity"\:
if \(\_dataSources\.TryGetValue\("UserLogsApi", out var userLogApiConfig\)\)
\{
var userActivity \= await QueryHttpApiDataSourceAsync\(userLogApiConfig, "activity/last\_day"\);
reportData\.AddRange\(userActivity\);
\}
break;
default\:
Console\.WriteLine\(</span>"Report '{reportName}' definition not found or not supported.");
                break;
        }

        Console.WriteLine(<span class="math-inline">"Generated report data for '\{reportName\}'\. Total records\: \{reportData\.Count\}"\);
return reportData;
\}
private async Task<List<Dictionary<string, object\>\>\> QuerySqlDataSourceAsync\(DataSourceConfig config, string query\)
\{
if \(config\.Type\.ToLowerInvariant\(\) \!\= "sql\_database" \|\| string\.IsNullOrEmpty\(config\.ConnectionString\)\)
\{
throw new ArgumentException\("Invalid SQL database configuration\."\);
\}
var results \= new List<Dictionary<string, object\>\>\(\);
try
\{
using \(var connection \= new SqlConnection\(config\.ConnectionString\)\)
\{
await connection\.OpenAsync\(\);
using \(var command \= new SqlCommand\(query, connection\)\)
using \(var reader \= await command\.ExecuteReaderAsync\(\)\)
\{
while \(await reader\.ReadAsync\(\)\)
\{
var row \= new Dictionary<string, object\>\(\);
for \(int i \= 0; i < reader\.FieldCount; i\+\+\)
\{
row\[reader\.GetName\(i\)\] \= reader\.GetValue\(i\);
\}
results\.Add\(row\);
\}
\}
\}
Console\.WriteLine\(</span>"Queried SQL database '{config.Name}'. Rows: {results.Count}");
        }
        catch (SqlException ex)
        {
            Console.WriteLine($"SQL query failed for {config.Name}: {ex.Message}");
            throw;
        }
        return results;
    }

    private async Task<List<Dictionary<string, object>>> QueryHttpApiDataSourceAsync(DataSourceConfig config, string endpoint)
    {
        if (config.Type.ToLowerInvariant() != "http_api" || string.IsNullOrEmpty(config.BaseUrl) || string.IsNullOrEmpty(endpoint))
        {
            throw new ArgumentException("Invalid HTTP API data source configuration.");
        }

        _httpClient.DefaultRequestHeaders.Clear();
        if (!string.IsNullOrEmpty(config.ApiKey))
        {
            _httpClient.DefaultRequestHeaders.Add("X-API-Key", config.ApiKey);
        }
        else if (!string.IsNullOrEmpty(config.BearerToken))
        {
            _httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", config.BearerToken);
        }

        var requestUri = <span class="math-inline">"\{config\.BaseUrl\.TrimEnd\('/'\)\}/\{endpoint\.TrimStart\('/'\)\}";
var results \= new List<Dictionary<string, object\>\>\(\);
try
\{
var response \= await \_httpClient\.GetAsync\(requestUri\);
response\.EnsureSuccessStatusCode\(\);
var jsonContent \= await response\.Content\.ReadAsStringAsync\(\);
var data \= JsonSerializer\.Deserialize<JsonElement\>\(jsonContent\);
if \(data\.ValueKind \=\= JsonValueKind\.Array\)
\{
foreach \(var item in data\.EnumerateArray\(\)\)
\{
var row \= new Dictionary<string, object\>\(\);
foreach \(var prop in item\.EnumerateObject\(\)\)
\{
row\[prop\.Name\] \= prop\.Value\.GetRawText\(\); // Store as raw text, proper deserialization needed for complex types
\}
results\.Add\(row\);
\}
\}
else if \(data\.ValueKind \=\= JsonValueKind\.Object\)
\{
var row \= new Dictionary<string, object\>\(\);
foreach \(var prop in data\.EnumerateObject\(\)\)
\{
row\[prop\.Name\] \= prop\.Value\.GetRawText\(\);
\}
results\.Add\(row\);
\}
Console\.WriteLine\(</span>"Queried HTTP API '{config.Name}'. Records: {results.Count}");
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"HTTP API query failed for {config.Name}: {ex.Message}");
            throw;
        }
        return results;
    }
}

public class DataSourceConfig
{
    public string Name { get; set; }
    public string Type { get; set; } // e.g., "Sql_Database", "Http_Api"
    public string ConnectionString { get; set; } // For SQL databases
    public string BaseUrl { get; set; } // For HTTP APIs
    public string ApiKey { get; set; } // For HTTP APIs
    public string BearerToken { get; set; } // For HTTP APIs
    // Add other properties for different data source types (e.g., file paths, SSH credentials)
}
```
### ðŸ§ª Senaryo 10: Bir rapor uygulamasÄ± farklÄ± veri kaynaklarÄ±ndan bilgi toplar. Kaynak eriÅŸim bilgileri konfigÃ¼rasyon yÃ¶netim sisteminde saklanÄ±r. Uygulama bu bilgilerle veri kaynaklarÄ±na baÄŸlanÄ±r. Raporlar gÃ¼venli veri eriÅŸimi ile oluÅŸturulur.
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 164
```python

import os
import json
import requests
import psycopg2 # Example for PostgreSQL
import mysql.connector # Example for MySQL
import time

class ReportingService:
    def __init__(self, config_file='data_sources.json'):
        self.config_file = config_file
        self.data_sources = self._load_data_source_configurations()

    def _load_data_source_configurations(self):
        sources = {}
        try:
            with open(self.config_file, 'r') as f:
                config_data = json.load(f)
            for source_name, details in config_data.items():
                # Sensitive details like passwords should be decrypted or fetched from a secure vault
                sources[source_name] = details
                print(f"Loaded configuration for data source: {source_name}")
        except FileNotFoundError:
            print(f"Data source configuration file '{self.config_file}' not found.")
        except json.JSONDecodeError:
            print(f"Error decoding JSON from '{self.config_file}'.")
        except Exception as e:
            print(f"An error occurred loading data source configurations: {e}")
        return sources

    def generate_report_data(self, report_name):
        report_data = []

        # This part defines which data sources contribute to which report.
        # In a real system, this would be more dynamic (e.g., driven by report templates/definitions).
        if report_name.lower() == "sales_dashboard":
            if "SalesDatabase" in self.data_sources:
                db_config = self.data_sources["SalesDatabase"]
                sales_query = "SELECT product_name, SUM(quantity) as total_sold FROM sales GROUP BY product_name ORDER BY total_sold DESC LIMIT 10;"
                sales_results = self._query_sql_data_source(db_config, sales_query)
                report_data.extend(sales_results)
            
            if "MarketingApi" in self.data_sources:
                api_config = self.data_sources["MarketingApi"]
                marketing_data = self._query_http_api_data_source(api_config, "campaign_performance")
                report_data.append({"marketing_summary": marketing_data}) # Add as a separate entry or merge

        elif report_name.lower() == "customer_demographics":
            if "CustomerDatabase" in self.data_sources:
                db_config = self.data_sources["CustomerDatabase"]
                customer_query = "SELECT age_group, COUNT(*) as customer_count FROM customers GROUP BY age_group;"
                customer_results = self._query_sql_data_source(db_config, customer_query)
                report_data.extend(customer_results)
            
        else:
            print(f"Report '{report_name}' definition not found or not supported.")
            return []

        print(f"Generated report data for '{report_name}'. Total records: {len(report_data)}")
        return report_data

    def _query_sql_data_source(self, config, query):
        db_type = config.get('db_type', '').lower()
        results = []
        conn = None
        try:
            if db_type == 'postgresql':
                conn = psycopg2.connect(
                    host=config['host'],
                    database=config['database'],
                    user=config['user'],
                    password=config['password'],
                    port=config.get('port', 5432)
                )
            elif db_type == 'mysql':
                conn = mysql.connector.connect(
                    host=config['host'],
                    database=config['database'],
                    user=config['user'],
                    password=config['password'],
                    port=config.get('port', 3306)
                )
            else:
                raise ValueError(f"Unsupported database type: {db_type}")

            cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor if db_type == 'postgresql' else None) # For dict access
            cursor.execute(query)
            results = [dict(row) for row in cursor.fetchall()] if db_type == 'postgresql' else [row for row in cursor.fetchall()]
            cursor.close()
            print(f"Queried {db_type} database '{config['name']}'. Rows: {len(results)}")
        except Exception as e:
            print(f"Error querying SQL data source '{config['name']}': {e}")
            raise
        finally:
            if conn:
                conn.close()
        return results

    def _query_http_api_data_source(self, config, endpoint):
        url = f"{config['base_url'].rstrip('/')}/{endpoint.lstrip('/')}"
        headers = {'Content-Type': 'application/json'}
        if config.get('api_key'):
            headers['X-API-Key'] = config['api_key']
        elif config.get('bearer_token'):
            headers['Authorization'] = f"Bearer {config['bearer_token']}"

        results = []
        try:
            response = requests.get(url, headers=headers, timeout=15)
            response.raise_for_status()
            data = response.json()
            if isinstance(data, list):
                results = data
            elif isinstance(data, dict):
                results = [data] # Wrap single object in a list for consistency
            print(f"Queried HTTP API '{config['name']}'. Records: {len(results)}")
        except requests.exceptions.RequestException as e:
            print(f"HTTP API request failed for '{config['name']}': {e}")
            raise
        return results

# Example Usage:
# if __name__ == "__main__":
#     # Assume data_sources.json exists with configurations:
#     # {
#     #   "SalesDatabase": {
#     #     "name": "SalesDB",
#     #     "type": "postgresql",
#     #     "host": "localhost",
#     #     "database": "sales_db",
#     #     "user": "report_user",
#     #     "password": "secure_password",
#     #     "port": 5432
#     #   },
#     #   "MarketingApi": {
#     #     "name": "MarketingAPI",
#     #     "type": "http_api",
#     #     "base_url": "[https://api.marketingmetrics.com/v1](https://api.marketingmetrics.com/v1)",
#     #     "api_key": "your_marketing_api_key"
#     #   },
#     #   "CustomerDatabase": {
#     #     "name": "CustomerDB",
#     #     "type": "mysql",
#     #     "host": "localhost",
#     #     "database": "customer_db",
#     #     "user": "report_user",
#     #     "password": "another_secure_password"
#     #   }
#     # }

#     try:
#         reporting_service = ReportingService()
#         sales_report = reporting_service.generate_report_data("Sales_Dashboard")
#         print("\n--- Sales Report Data ---")
#         for item in sales_report:
#             print(item)

#         customer_report = reporting_service.generate_report_data("Customer_Demographics")
#         print("\n--- Customer Demographics Report Data ---")
#         for item in customer_report:
#             print(item)

#     except Exception as e:
#         print(f"Reporting application error: {e}")
```
### ðŸ§ª Senaryo 10: Bir rapor uygulamasÄ± farklÄ± veri kaynaklarÄ±ndan bilgi toplar. Kaynak eriÅŸim bilgileri konfigÃ¼rasyon yÃ¶netim sisteminde saklanÄ±r. Uygulama bu bilgilerle veri kaynaklarÄ±na baÄŸlanÄ±r. Raporlar gÃ¼venli veri eriÅŸimi ile oluÅŸturulur.
**ðŸ’» Dil:** `TypeScript`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 204
```typescript

import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import { createConnection, ConnectionOptions, Connection } from 'typeorm'; // npm install typeorm reflect-metadata
import 'reflect-metadata'; // Required by TypeORM for decorators

dotenv.config();

interface DataSourceConfig {
    name: string;
    type: 'sql_database' | 'http_api';
    // SQL Database specific
    dbType?: string; // e.g., 'mysql', 'postgres', 'mssql'
    host?: string;
    port?: number;
    username?: string;
    password?: string; // Should be retrieved securely
    database?: string;
    connectionString?: string; // Alternative for SQL, if full string is in config
    // HTTP API specific
    baseUrl?: string;
    apiKey?: string; // Should be retrieved securely
    bearerToken?: string; // Should be retrieved securely
}

export class ReportingService {
    private dataSources: Map<string, DataSourceConfig> = new Map();
    private httpClient: AxiosInstance;

    constructor(configFilePath: string = path.join(__dirname, '../config/data_sources.json')) {
        this.httpClient = axios.create({ timeout: 30000 }); // 30 seconds timeout for API calls
        this.loadDataSourceConfigurations(configFilePath);
    }

    private loadDataSourceConfigurations(configPath: string): void {
        try {
            const configContent = fs.readFileSync(configPath, 'utf8');
            const parsedConfig: { [key: string]: Omit<DataSourceConfig, 'name'> } = JSON.parse(configContent);

            for (const sourceName in parsedConfig) {
                if (parsedConfig.hasOwnProperty(sourceName)) {
                    const config = parsedConfig[sourceName];
                    // In a real application, sensitive fields like passwords/API keys would be fetched
                    // from a secure vault at runtime, not directly from a JSON file.
                    // This is a simplification for the example.
                    this.dataSources.set(sourceName, { name: sourceName, ...config } as DataSourceConfig);
                    console.log(`Loaded data source configuration for: ${sourceName}`);
                }
            }
        } catch (error) {
            console.error('Error loading or parsing data source configuration file:', error);
            throw new Error('Failed to load data source configurations.');
        }
    }

    public async generateReportData(reportName: string): Promise<any[]> {
        const reportData: any[] = [];

        // This defines which data sources are used for specific reports.
        // In a complex app, this mapping might come from a DB or report template engine.
        switch (reportName.toLowerCase()) {
            case 'product_sales_summary':
                const salesDbConfig = this.dataSources.get('SalesDatabase');
                if (salesDbConfig && salesDbConfig.type === 'sql_database') {
                    const salesQuery = `SELECT product_name, SUM(quantity) as total_quantity FROM sales GROUP BY product_name ORDER BY total_quantity DESC LIMIT 5;`;
                    const salesResults = await this.querySqlDataSource(salesDbConfig, salesQuery);
                    reportData.push({ source: 'SalesDatabase', data: salesResults });
                } else {
                    console.warn(`SalesDatabase configuration not found or invalid for report '${reportName}'.`);
                }

                const marketingApiConfig = this.dataSources.get('MarketingApi');
                if (marketingApiConfig && marketingApiConfig.type === 'http_api') {
                    const marketingResults = await this.queryHttpApiDataSource(marketingApiConfig, 'campaigns/top_performing');
                    reportData.push({ source: 'MarketingApi', data: marketingResults });
                } else {
                    console.warn(`MarketingApi configuration not found or invalid for report '${reportName}'.`);
                }
                break;
            case 'user_login_activity':
                const authLogsApiConfig = this.dataSources.get('AuthLogsApi');
                if (authLogsApiConfig && authLogsApiConfig.type === 'http_api') {
                    const authLogs = await this.queryHttpApiDataSource(authLogsApiConfig, 'logins/recent');
                    reportData.push({ source: 'AuthLogsApi', data: authLogs });
                } else {
                    console.warn(`AuthLogsApi configuration not found or invalid for report '${reportName}'.`);
                }
                break;
            default:
                console.warn(`Report definition for '${reportName}' not found.`);
                break;
        }

        console.log(`Generated report data for '${reportName}'.`);
        return reportData;
    }

    private async querySqlDataSource(config: DataSourceConfig, query: string): Promise<any[]> {
        let connection: Connection | undefined;
        try {
            const connectionOptions: ConnectionOptions = {
                type: config.dbType as any,
                host: config.host,
                port: config.port,
                username: config.username,
                password: config.password,
                database: config.database,
                // synchronize: false, // Don't synchronize schema in production for reporting
                logging: false,
                entities: [], // No entities needed for raw queries
            };

            // If connectionString is provided, it overrides other connection options
            if (config.connectionString) {
                (connectionOptions as any).url = config.connectionString;
            }

            connection = await createConnection(connectionOptions);
            const rawResult = await connection.query(query);
            console.log(`Successfully queried SQL database: ${config.name}. Rows: ${rawResult.length}`);
            return rawResult;
        } catch (error) {
            console.error(`Error querying SQL data source '${config.name}':`, error);
            throw error;
        } finally {
            if (connection && connection.isConnected) {
                await connection.close();
            }
        }
    }

    private async queryHttpApiDataSource(config: DataSourceConfig, endpoint: string): Promise<any> {
        if (!config.baseUrl) {
            throw new Error(`HTTP API data source '${config.name}' is missing baseUrl.`);
        }

        const requestConfig: AxiosRequestConfig = { headers: {} };
        if (config.apiKey) {
            requestConfig.headers['X-API-Key'] = config.apiKey;
        } else if (config.bearerToken) {
            requestConfig.headers['Authorization'] = `Bearer ${config.bearerToken}`;
        }

        const requestUrl = `${config.baseUrl.replace(/\/+$/, '')}/${endpoint.replace(/^\/+/, '')}`;
        try {
            const response = await this.httpClient.get(requestUrl, requestConfig);
            console.log(`Successfully queried HTTP API: ${config.name}. Status: ${response.status}`);
            return response.data;
        } catch (error: any) {
            console.error(`Error querying HTTP API data source '${config.name}':`, error.message);
            if (error.response) {
                console.error('API Error Response:', error.response.data);
            }
            throw error;
        }
    }
}

/*
// Example Usage:
// (async () => {
//     try {
//         // Ensure data_sources.json exists in config/ directory or adjust path
//         // Example data_sources.json:
//         // {
//         //   "SalesDatabase": {
//         //     "name": "SalesDB",
//         //     "type": "sql_database",
//         //     "dbType": "postgres",
//         //     "host": "localhost",
//         //     "port": 5432,
//         //     "username": "report_user",
//         //     "password": "secure_db_password", // Should be from vault
//         //     "database": "sales"
//         //   },
//         //   "MarketingApi": {
//         //     "name": "MarketingAPI",
//         //     "type": "http_api",
//         //     "baseUrl": "[https://api.marketingmetrics.com/v1](https://api.marketingmetrics.com/v1)",
//         //     "apiKey": "your_marketing_api_key_from_vault" // Should be from vault
//         //   },
//         //   "AuthLogsApi": {
//         //     "name": "AuthLogsAPI",
//         //     "type": "http_api",
//         //     "baseUrl": "[https://api.authlogs.com/v2](https://api.authlogs.com/v2)",
//         //     "bearerToken": "your_auth_token_from_vault" // Should be from vault
//         //   }
//         // }

//         const reportingService = new ReportingService();
//         const salesReport = await reportingService.generateReportData('product_sales_summary');
//         console.log('\n--- Product Sales Summary Report ---');
//         console.log(JSON.stringify(salesReport, null, 2));

//         const userLoginActivityReport = await reportingService.generateReportData('user_login_activity');
//         console.log('\n--- User Login Activity Report ---');
//         console.log(JSON.stringify(userLoginActivityReport, null, 2));

//     } catch (error) {
//         console.error('Reporting application error:', error);
//     }
// })();
```
*/