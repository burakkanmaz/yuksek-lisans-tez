### ðŸ§ª Senaryo 1: Bir e-ticaret sitesinde mÃ¼ÅŸteriler aynÄ± anda Ã¼rÃ¼n satÄ±n alabilir. Son Ã¼rÃ¼n kaldÄ±ÄŸÄ±nda birden Ã§ok kullanÄ±cÄ± Ã¶deme iÅŸlemi baÅŸlatabilir. Sistem stok kontrolÃ¼nÃ¼ Ã¶deme sÄ±rasÄ±nda yapar. Ã–deme baÅŸarÄ±lÄ± olan kullanÄ±cÄ±lar Ã¼rÃ¼nÃ¼ alabilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 138
```csharp

[HttpPost("purchase-product")]
public IActionResult PurchaseProduct([FromBody] PurchaseRequest request)
{
    // Assume productId and userId are available in the request
    // using a simplified context for demonstration
    int productId = request.ProductId;
    int userId = request.UserId;

    // Simulate database context or repository pattern
    using (var dbContext = new YourDbContext())
    {
        // Use a transaction for atomicity
        using (var transaction = dbContext.Database.BeginTransaction())
        {
            try
            {
                // Check stock with a lock or appropriate concurrency control
                // For SQL Server, a row lock (UPDLOCK) or similar could be used
                var product = dbContext.Products.FirstOrDefault(p => p.Id == productId);

                if (product == null || product.Stock <= 0)
                {
                    return BadRequest("Product out of stock or not found.");
                }

                // Decrement stock
                product.Stock--;
                dbContext.SaveChanges();

                // Simulate payment processing
                bool paymentSuccessful = ProcessPayment(userId, product.Price);

                if (paymentSuccessful)
                {
                    // Create order
                    dbContext.Orders.Add(new Order { ProductId = productId, UserId = userId, Quantity = 1, OrderDate = DateTime.UtcNow });
                    dbContext.SaveChanges();
                    transaction.Commit();
                    return Ok("Purchase successful.");
                }
                else
                {
                    transaction.Rollback();
                    // Revert stock if payment failed (important for atomicity)
                    product.Stock++;
                    dbContext.SaveChanges();
                    return BadRequest("Payment failed. Stock reverted.");
                }
            }
            catch (Exception ex)
            {
                transaction.Rollback();
                // Log the exception
                return StatusCode(500, "An error occurred during the purchase process.");
            }
        }
    }
}

// Placeholder for payment processing logic
private bool ProcessPayment(int userId, decimal amount)
{
    // In a real application, this would interact with a payment gateway
    // For demonstration, let's assume it always succeeds.
    return true;
}

public class PurchaseRequest
{
    public int ProductId { get; set; }
    public int UserId { get; set; }
}

public class Product
{
    public int Id { get; set; }
    public int Stock { get; set; }
    public decimal Price { get; set; }
}

public class Order
{
    public int Id { get; set; }
    public int ProductId { get; set; }
    public int UserId { get; set; }
    public int Quantity { get; set; }
    public DateTime OrderDate { get; set; }
}

// Simplified DbContext for demonstration
public class YourDbContext : IDisposable
{
    public List<Product> Products { get; set; } = new List<Product>
    {
        new Product { Id = 1, Stock = 5, Price = 100.00m }
    };
    public List<Order> Orders { get; set; } = new List<Order>();

    public DatabaseFacade Database { get; } = new DatabaseFacade();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}

public class DatabaseFacade
{
    public DbTransaction BeginTransaction()
    {
        return new DbTransaction();
    }
}

public class DbTransaction : IDisposable
{
    public void Commit()
    {
        // Simulate commit
    }

    public void Rollback()
    {
        // Simulate rollback
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 58
```python

from flask import Flask, request, jsonify
from threading import Lock

app = Flask(__name__)

# Simulate a database with a dictionary and a lock for thread-safety
products_db = {
    1: {"id": 1, "stock": 5, "price": 100.00}
}
orders_db = []
db_lock = Lock()

@app.route("/purchase-product", methods=["POST"])
def purchase_product():
    data = request.get_json()
    product_id = data.get("productId")
    user_id = data.get("userId")

    if not product_id or not user_id:
        return jsonify({"message": "Product ID and User ID are required."}), 400

    with db_lock:  # Acquire lock for critical section
        product = products_db.get(product_id)

        if not product or product["stock"] <= 0:
            return jsonify({"message": "Product out of stock or not found."}), 400

        # Decrement stock
        product["stock"] -= 1

        # Simulate payment processing
        payment_successful = process_payment(user_id, product["price"])

        if payment_successful:
            # Create order
            order = {
                "order_id": len(orders_db) + 1,
                "product_id": product_id,
                "user_id": user_id,
                "quantity": 1,
                "order_date": "2025-06-21T17:05:17Z" # Using a fixed date for simplicity
            }
            orders_db.append(order)
            return jsonify({"message": "Purchase successful."}), 200
        else:
            # Revert stock if payment failed
            product["stock"] += 1
            return jsonify({"message": "Payment failed. Stock reverted."}), 400

def process_payment(user_id, amount):
    # In a real application, this would interact with a payment gateway
    # For demonstration, let's assume it always succeeds.
    return True

if __name__ == "__main__":
    # In a production environment, use a proper WSGI server like Gunicorn
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 91
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

// Simulate a database with a Map and a mutex for concurrency control
interface Product {
    id: number;
    stock: number;
    price: number;
}

interface Order {
    id: string;
    productId: number;
    userId: number;
    quantity: number;
    orderDate: string;
}

const productsDb = new Map<number, Product>();
productsDb.set(1, { id: 1, stock: 5, price: 100.00 });

const ordersDb: Order[] = [];
const productMutexes = new Map<number, Mutex>(); // Mutex per product for finer-grained locking

// Initialize mutex for existing products
productsDb.forEach((product) => {
    productMutexes.set(product.id, new Mutex());
});

app.post('/purchase-product', async (req: Request, res: Response) => {
    const { productId, userId } = req.body;

    if (productId === undefined || userId === undefined) {
        return res.status(400).json({ message: 'Product ID and User ID are required.' });
    }

    const mutex = productMutexes.get(productId);
    if (!mutex) {
        return res.status(404).json({ message: 'Product not found.' });
    }

    await mutex.runExclusive(async () => { // Acquire lock for this specific product
        let product = productsDb.get(productId);

        if (!product || product.stock <= 0) {
            return res.status(400).json({ message: 'Product out of stock or not found.' });
        }

        // Decrement stock
        product.stock--;
        productsDb.set(productId, product); // Update the product in the map

        // Simulate payment processing
        const paymentSuccessful = await processPayment(userId, product.price);

        if (paymentSuccessful) {
            // Create order
            const order: Order = {
                id: uuidv4(),
                productId: productId,
                userId: userId,
                quantity: 1,
                orderDate: new Date().toISOString()
            };
            ordersDb.push(order);
            return res.status(200).json({ message: 'Purchase successful.' });
        } else {
            // Revert stock if payment failed
            product.stock++;
            productsDb.set(productId, product); // Update the product in the map
            return res.status(400).json({ message: 'Payment failed. Stock reverted.' });
        }
    });
});

async function processPayment(userId: number, amount: number): Promise<boolean> {
    // In a real application, this would interact with a payment gateway
    // For demonstration, let's simulate a successful payment.
    return true;
}

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

### ðŸ§ª Senaryo 2: Bir rezervasyon sisteminde kullanÄ±cÄ±lar aynÄ± saatte randevu almak isteyebilir. Saat dilimi mÃ¼sait gÃ¶rÃ¼ldÃ¼ÄŸÃ¼nde birden fazla kiÅŸi rezervasyon yapmaya Ã§alÄ±ÅŸÄ±r. Sistem rezervasyon kayÄ±tlarÄ±nÄ± iÅŸlerken mevcut durumu kontrol eder. Ä°ÅŸlem tamamlanan rezervasyonlar sisteme kaydedilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 93
```csharp

[HttpPost("make-appointment")]
public IActionResult MakeAppointment([FromBody] AppointmentRequest request)
{
    int desiredTimeSlotId = request.TimeSlotId;
    int userId = request.UserId;

    using (var dbContext = new YourReservationDbContext())
    {
        using (var transaction = dbContext.Database.BeginTransaction())
        {
            try
            {
                // Retrieve the time slot with a lock to prevent concurrent modifications
                // For SQL Server, a row lock (UPDLOCK) or similar could be used
                var timeSlot = dbContext.TimeSlots.FirstOrDefault(ts => ts.Id == desiredTimeSlotId);

                if (timeSlot == null || timeSlot.IsBooked)
                {
                    return BadRequest("Time slot is not available or does not exist.");
                }

                // Mark the time slot as booked
                timeSlot.IsBooked = true;
                dbContext.SaveChanges();

                // Create the reservation
                dbContext.Reservations.Add(new Reservation
                {
                    TimeSlotId = desiredTimeSlotId,
                    UserId = userId,
                    ReservationDate = DateTime.UtcNow
                });
                dbContext.SaveChanges();

                transaction.Commit();
                return Ok("Appointment successfully made.");
            }
            catch (Exception ex)
            {
                transaction.Rollback();
                // Log the exception
                return StatusCode(500, "An error occurred during the reservation process.");
            }
        }
    }
}

public class AppointmentRequest
{
    public int TimeSlotId { get; set; }
    public int UserId { get; set; }
}

public class TimeSlot
{
    public int Id { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
    public bool IsBooked { get; set; }
}

public class Reservation
{
    public int Id { get; set; }
    public int TimeSlotId { get; set; }
    public int UserId { get; set; }
    public DateTime ReservationDate { get; set; }
}

// Simplified DbContext for demonstration
public class YourReservationDbContext : IDisposable
{
    public List<TimeSlot> TimeSlots { get; set; } = new List<TimeSlot>
    {
        new TimeSlot { Id = 101, StartTime = DateTime.Parse("2025-07-01T10:00:00"), EndTime = DateTime.Parse("2025-07-01T11:00:00"), IsBooked = false },
        new TimeSlot { Id = 102, StartTime = DateTime.Parse("2025-07-01T11:00:00"), EndTime = DateTime.Parse("2025-07-01T12:00:00"), IsBooked = false }
    };
    public List<Reservation> Reservations { get; set; } = new List<Reservation>();

    public DatabaseFacade Database { get; } = new DatabaseFacade();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 46
```python

from flask import Flask, request, jsonify
from threading import Lock
from datetime import datetime

app = Flask(__name__)

# Simulate database
time_slots_db = {
    101: {"id": 101, "start_time": "2025-07-01T10:00:00", "end_time": "2025-07-01T11:00:00", "is_booked": False},
    102: {"id": 102, "start_time": "2025-07-01T11:00:00", "end_time": "2025-07-01T12:00:00", "is_booked": False}
}
reservations_db = []
db_lock = Lock()

@app.route("/make-appointment", methods=["POST"])
def make_appointment():
    data = request.get_json()
    time_slot_id = data.get("timeSlotId")
    user_id = data.get("userId")

    if not time_slot_id or not user_id:
        return jsonify({"message": "Time Slot ID and User ID are required."}), 400

    with db_lock:  # Acquire lock for critical section
        time_slot = time_slots_db.get(time_slot_id)

        if not time_slot or time_slot["is_booked"]:
            return jsonify({"message": "Time slot is not available or does not exist."}), 400

        # Mark the time slot as booked
        time_slot["is_booked"] = True

        # Create the reservation
        reservation = {
            "reservation_id": len(reservations_db) + 1,
            "time_slot_id": time_slot_id,
            "user_id": user_id,
            "reservation_date": datetime.now().isoformat()
        }
        reservations_db.append(reservation)

        return jsonify({"message": "Appointment successfully made."}), 200

if __name__ == "__main__":
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 74
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

interface TimeSlot {
    id: number;
    startTime: string;
    endTime: string;
    isBooked: boolean;
}

interface Reservation {
    id: string;
    timeSlotId: number;
    userId: number;
    reservationDate: string;
}

const timeSlotsDb = new Map<number, TimeSlot>();
timeSlotsDb.set(101, { id: 101, startTime: '2025-07-01T10:00:00', endTime: '2025-07-01T11:00:00', isBooked: false });
timeSlotsDb.set(102, { id: 102, startTime: '2025-07-01T11:00:00', endTime: '2025-07-01T12:00:00', isBooked: false });

const reservationsDb: Reservation[] = [];
const timeSlotMutexes = new Map<number, Mutex>();

timeSlotsDb.forEach((timeSlot) => {
    timeSlotMutexes.set(timeSlot.id, new Mutex());
});

app.post('/make-appointment', async (req: Request, res: Response) => {
    const { timeSlotId, userId } = req.body;

    if (timeSlotId === undefined || userId === undefined) {
        return res.status(400).json({ message: 'Time Slot ID and User ID are required.' });
    }

    const mutex = timeSlotMutexes.get(timeSlotId);
    if (!mutex) {
        return res.status(404).json({ message: 'Time slot not found.' });
    }

    await mutex.runExclusive(async () => {
        let timeSlot = timeSlotsDb.get(timeSlotId);

        if (!timeSlot || timeSlot.isBooked) {
            return res.status(400).json({ message: 'Time slot is not available or does not exist.' });
        }

        // Mark the time slot as booked
        timeSlot.isBooked = true;
        timeSlotsDb.set(timeSlotId, timeSlot);

        // Create the reservation
        const reservation: Reservation = {
            id: uuidv4(),
            timeSlotId: timeSlotId,
            userId: userId,
            reservationDate: new Date().toISOString()
        };
        reservationsDb.push(reservation);

        return res.status(200).json({ message: 'Appointment successfully made.' });
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

### ðŸ§ª Senaryo 3: Bir uÃ§ak rezervasyon platformunda yolcular aynÄ± koltuk iÃ§in iÅŸlem yapabilir. Koltuk mÃ¼sait gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nde farklÄ± kullanÄ±cÄ±lar seÃ§im yapar. Rezervasyon iÅŸlemi sÄ±rasÄ±nda koltuk durumu kontrol edilir. Ä°ÅŸlem tamamlanan rezervasyonlar onaylanÄ±r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 100
```csharp

[HttpPost("reserve-seat")]
public IActionResult ReserveSeat([FromBody] SeatReservationRequest request)
{
    int flightId = request.FlightId;
    string seatNumber = request.SeatNumber;
    int userId = request.UserId;

    using (var dbContext = new YourFlightReservationDbContext())
    {
        using (var transaction = dbContext.Database.BeginTransaction())
        {
            try
            {
                // Retrieve the seat with a lock to prevent concurrent modifications
                var seat = dbContext.Seats.FirstOrDefault(s => s.FlightId == flightId && s.SeatNumber == seatNumber);

                if (seat == null || seat.IsReserved)
                {
                    return BadRequest("Seat is not available or does not exist.");
                }

                // Mark the seat as reserved
                seat.IsReserved = true;
                seat.ReservedByUserId = userId;
                dbContext.SaveChanges();

                // Create the reservation record
                dbContext.FlightReservations.Add(new FlightReservation
                {
                    FlightId = flightId,
                    SeatNumber = seatNumber,
                    UserId = userId,
                    ReservationDate = DateTime.UtcNow,
                    Status = "Confirmed" // Or "Pending" and confirmed after payment
                });
                dbContext.SaveChanges();

                transaction.Commit();
                return Ok("Seat successfully reserved.");
            }
            catch (Exception ex)
            {
                transaction.Rollback();
                // Log the exception
                return StatusCode(500, "An error occurred during the seat reservation process.");
            }
        }
    }
}

public class SeatReservationRequest
{
    public int FlightId { get; set; }
    public string SeatNumber { get; set; }
    public int UserId { get; set; }
}

public class Seat
{
    public int Id { get; set; }
    public int FlightId { get; set; }
    public string SeatNumber { get; set; }
    public bool IsReserved { get; set; }
    public int? ReservedByUserId { get; set; }
}

public class FlightReservation
{
    public int Id { get; set; }
    public int FlightId { get; set; }
    public string SeatNumber { get; set; }
    public int UserId { get; set; }
    public DateTime ReservationDate { get; set; }
    public string Status { get; set; }
}

// Simplified DbContext for demonstration
public class YourFlightReservationDbContext : IDisposable
{
    public List<Seat> Seats { get; set; } = new List<Seat>
    {
        new Seat { Id = 1, FlightId = 101, SeatNumber = "A1", IsReserved = false },
        new Seat { Id = 2, FlightId = 101, SeatNumber = "A2", IsReserved = false }
    };
    public List<FlightReservation> FlightReservations { get; set; } = new List<FlightReservation>();

    public DatabaseFacade Database { get; } = new DatabaseFacade();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 52
```python

from flask import Flask, request, jsonify
from threading import Lock
from datetime import datetime

app = Flask(__name__)

# Simulate database
seats_db = {
    "flight101-A1": {"id": 1, "flight_id": 101, "seat_number": "A1", "is_reserved": False, "reserved_by_user_id": None},
    "flight101-A2": {"id": 2, "flight_id": 101, "seat_number": "A2", "is_reserved": False, "reserved_by_user_id": None}
}
flight_reservations_db = []
db_lock = Lock()

@app.route("/reserve-seat", methods=["POST"])
def reserve_seat():
    data = request.get_json()
    flight_id = data.get("flightId")
    seat_number = data.get("seatNumber")
    user_id = data.get("userId")

    if not flight_id or not seat_number or not user_id:
        return jsonify({"message": "Flight ID, Seat Number, and User ID are required."}), 400

    seat_key = f"flight{flight_id}-{seat_number}"

    with db_lock:  # Acquire lock for critical section
        seat = seats_db.get(seat_key)

        if not seat or seat["is_reserved"]:
            return jsonify({"message": "Seat is not available or does not exist."}), 400

        # Mark the seat as reserved
        seat["is_reserved"] = True
        seat["reserved_by_user_id"] = user_id

        # Create the reservation record
        reservation = {
            "reservation_id": len(flight_reservations_db) + 1,
            "flight_id": flight_id,
            "seat_number": seat_number,
            "user_id": user_id,
            "reservation_date": datetime.now().isoformat(),
            "status": "Confirmed"
        }
        flight_reservations_db.append(reservation)

        return jsonify({"message": "Seat successfully reserved."}), 200

if __name__ == "__main__":
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 81
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

interface Seat {
    id: number;
    flightId: number;
    seatNumber: string;
    isReserved: boolean;
    reservedByUserId: number | null;
}

interface FlightReservation {
    id: string;
    flightId: number;
    seatNumber: string;
    userId: number;
    reservationDate: string;
    status: string;
}

const seatsDb = new Map<string, Seat>();
seatsDb.set('flight101-A1', { id: 1, flightId: 101, seatNumber: 'A1', isReserved: false, reservedByUserId: null });
seatsDb.set('flight101-A2', { id: 2, flightId: 101, seatNumber: 'A2', isReserved: false, reservedByUserId: null });

const flightReservationsDb: FlightReservation[] = [];
const seatMutexes = new Map<string, Mutex>();

seatsDb.forEach((seat, key) => {
    seatMutexes.set(key, new Mutex());
});

app.post('/reserve-seat', async (req: Request, res: Response) => {
    const { flightId, seatNumber, userId } = req.body;

    if (flightId === undefined || seatNumber === undefined || userId === undefined) {
        return res.status(400).json({ message: 'Flight ID, Seat Number, and User ID are required.' });
    }

    const seatKey = `flight${flightId}-${seatNumber}`;
    const mutex = seatMutexes.get(seatKey);
    if (!mutex) {
        return res.status(404).json({ message: 'Seat not found.' });
    }

    await mutex.runExclusive(async () => {
        let seat = seatsDb.get(seatKey);

        if (!seat || seat.isReserved) {
            return res.status(400).json({ message: 'Seat is not available or does not exist.' });
        }

        // Mark the seat as reserved
        seat.isReserved = true;
        seat.reservedByUserId = userId;
        seatsDb.set(seatKey, seat);

        // Create the reservation record
        const reservation: FlightReservation = {
            id: uuidv4(),
            flightId: flightId,
            seatNumber: seatNumber,
            userId: userId,
            reservationDate: new Date().toISOString(),
            status: 'Confirmed'
        };
        flightReservationsDb.push(reservation);

        return res.status(200).json({ message: 'Seat successfully reserved.' });
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

### ðŸ§ª Senaryo 4: Bir bankacÄ±lÄ±k uygulamasÄ±nda kullanÄ±cÄ± aynÄ± hesaptan eÅŸzamanlÄ± para Ã§ekebilir. ATM ve internet bankacÄ±lÄ±ÄŸÄ± Ã¼zerinden iÅŸlem yapÄ±labilir. Her iÅŸlem sÄ±rasÄ±nda bakiye kontrolÃ¼ gerÃ§ekleÅŸtirilir. Yeterli bakiye olan iÅŸlemler onaylanÄ±r.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 104
```csharp

[HttpPost("withdraw")]
public IActionResult Withdraw([FromBody] WithdrawalRequest request)
{
    int accountId = request.AccountId;
    decimal amount = request.Amount;
    string transactionType = request.TransactionType; // e.g., "ATM", "Online"

    using (var dbContext = new YourBankingDbContext())
    {
        using (var transaction = dbContext.Database.BeginTransaction(System.Data.IsolationLevel.Serializable)) // Use Serializable isolation for strong consistency
        {
            try
            {
                // Retrieve the account with a lock or appropriate concurrency control
                // For SQL Server, a row lock (UPDLOCK) could be used if IsolationLevel is lower
                var account = dbContext.Accounts.FirstOrDefault(a => a.Id == accountId);

                if (account == null)
                {
                    return BadRequest("Account not found.");
                }

                if (account.Balance < amount)
                {
                    transaction.Rollback();
                    return BadRequest("Insufficient balance.");
                }

                // Deduct the amount
                account.Balance -= amount;
                dbContext.SaveChanges();

                // Record the transaction
                dbContext.Transactions.Add(new Transaction
                {
                    AccountId = accountId,
                    Amount = amount,
                    Type = "Withdrawal",
                    TransactionType = transactionType,
                    TransactionDate = DateTime.UtcNow,
                    Status = "Approved"
                });
                dbContext.SaveChanges();

                transaction.Commit();
                return Ok("Withdrawal successful.");
            }
            catch (Exception ex)
            {
                transaction.Rollback();
                // Log the exception
                return StatusCode(500, "An error occurred during the withdrawal process.");
            }
        }
    }
}

public class WithdrawalRequest
{
    public int AccountId { get; set; }
    public decimal Amount { get; set; }
    public string TransactionType { get; set; }
}

public class Account
{
    public int Id { get; set; }
    public decimal Balance { get; set; }
}

public class Transaction
{
    public int Id { get; set; }
    public int AccountId { get; set; }
    public decimal Amount { get; set; }
    public string Type { get; set; } // "Withdrawal", "Deposit"
    public string TransactionType { get; set; } // "ATM", "Online"
    public DateTime TransactionDate { get; set; }
    public string Status { get; set; } // "Approved", "Declined"
}

// Simplified DbContext for demonstration
public class YourBankingDbContext : IDisposable
{
    public List<Account> Accounts { get; set; } = new List<Account>
    {
        new Account { Id = 1, Balance = 1000.00m }
    };
    public List<Transaction> Transactions { get; set; } = new List<Transaction>();

    public DatabaseFacade Database { get; } = new DatabaseFacade();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 68
```python

from flask import Flask, request, jsonify
from threading import Lock
from datetime import datetime

app = Flask(__name__)

# Simulate database
accounts_db = {
    1: {"id": 1, "balance": 1000.00}
}
transactions_db = []
account_locks = {
    1: Lock()  # One lock per account for finer-grained locking
}

@app.route("/withdraw", methods=["POST"])
def withdraw():
    data = request.get_json()
    account_id = data.get("accountId")
    amount = data.get("amount")
    transaction_type = data.get("transactionType")

    if not account_id or not amount or not transaction_type:
        return jsonify({"message": "Account ID, Amount, and Transaction Type are required."}), 400

    if account_id not in account_locks:
        return jsonify({"message": "Account not found."}), 404

    with account_locks[account_id]:  # Acquire lock for the specific account
        account = accounts_db.get(account_id)

        if not account:
            return jsonify({"message": "Account not found."}), 404

        if account["balance"] < amount:
            # Record failed transaction
            transaction = {
                "transaction_id": len(transactions_db) + 1,
                "account_id": account_id,
                "amount": amount,
                "type": "Withdrawal",
                "transaction_type": transaction_type,
                "transaction_date": datetime.now().isoformat(),
                "status": "Declined - Insufficient Balance"
            }
            transactions_db.append(transaction)
            return jsonify({"message": "Insufficient balance."}), 400

        # Deduct the amount
        account["balance"] -= amount

        # Record the transaction
        transaction = {
            "transaction_id": len(transactions_db) + 1,
            "account_id": account_id,
            "amount": amount,
            "type": "Withdrawal",
            "transaction_type": transaction_type,
            "transaction_date": datetime.now().isoformat(),
            "status": "Approved"
        }
        transactions_db.append(transaction)

        return jsonify({"message": "Withdrawal successful."}), 200

if __name__ == "__main__":
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 92
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

interface Account {
    id: number;
    balance: number;
}

interface Transaction {
    id: string;
    accountId: number;
    amount: number;
    type: string;
    transactionType: string;
    transactionDate: string;
    status: string;
}

const accountsDb = new Map<number, Account>();
accountsDb.set(1, { id: 1, balance: 1000.00 });

const transactionsDb: Transaction[] = [];
const accountMutexes = new Map<number, Mutex>();

accountsDb.forEach((account) => {
    accountMutexes.set(account.id, new Mutex());
});

app.post('/withdraw', async (req: Request, res: Response) => {
    const { accountId, amount, transactionType } = req.body;

    if (accountId === undefined || amount === undefined || transactionType === undefined) {
        return res.status(400).json({ message: 'Account ID, Amount, and Transaction Type are required.' });
    }

    const mutex = accountMutexes.get(accountId);
    if (!mutex) {
        return res.status(404).json({ message: 'Account not found.' });
    }

    await mutex.runExclusive(async () => {
        let account = accountsDb.get(accountId);

        if (!account) {
            return res.status(404).json({ message: 'Account not found.' });
        }

        if (account.balance < amount) {
            // Record failed transaction
            const transaction: Transaction = {
                id: uuidv4(),
                accountId: accountId,
                amount: amount,
                type: 'Withdrawal',
                transactionType: transactionType,
                transactionDate: new Date().toISOString(),
                status: 'Declined - Insufficient Balance'
            };
            transactionsDb.push(transaction);
            return res.status(400).json({ message: 'Insufficient balance.' });
        }

        // Deduct the amount
        account.balance -= amount;
        accountsDb.set(accountId, account);

        // Record the transaction
        const transaction: Transaction = {
            id: uuidv4(),
            accountId: accountId,
            amount: amount,
            type: 'Withdrawal',
            transactionType: transactionType,
            transactionDate: new Date().toISOString(),
            status: 'Approved'
        };
        transactionsDb.push(transaction);

        return res.status(200).json({ message: 'Withdrawal successful.' });
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

### ðŸ§ª Senaryo 5: Bir sosyal medya platformunda kullanÄ±cÄ±lar aynÄ± iÃ§eriÄŸi beÄŸenebilir. Birden fazla kullanÄ±cÄ± beÄŸeni butonuna aynÄ± anda tÄ±klayabilir. Sistem beÄŸeni sayÄ±sÄ±nÄ± gÃ¼nceller ve veritabanÄ±na kaydeder. BeÄŸeni iÅŸlemleri kullanÄ±cÄ± bazÄ±nda iÅŸlenir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 93
```csharp

[HttpPost("like-content")]
public IActionResult LikeContent([FromBody] LikeRequest request)
{
    int contentId = request.ContentId;
    int userId = request.UserId;

    using (var dbContext = new YourSocialMediaDbContext())
    {
        // Consider using a distributed lock or optimistic concurrency for high-volume scenarios
        // For simplicity, a direct update with a check for existing like is shown.
        // A unique constraint on (ContentId, UserId) in the Likes table is crucial.

        try
        {
            // Check if the user has already liked this content
            var existingLike = dbContext.Likes.FirstOrDefault(l => l.ContentId == contentId && l.UserId == userId);

            if (existingLike != null)
            {
                return BadRequest("User has already liked this content.");
            }

            // Add the like record
            dbContext.Likes.Add(new Like { ContentId = contentId, UserId = userId, LikeDate = DateTime.UtcNow });
            dbContext.SaveChanges();

            // Increment the like count on the content (this is where concurrency can be an issue)
            // Use a database-level increment operation (e.g., UPDATE ... SET LikeCount = LikeCount + 1)
            // or optimistic concurrency (version column)
            var content = dbContext.Contents.FirstOrDefault(c => c.Id == contentId);
            if (content != null)
            {
                content.LikeCount++;
                dbContext.SaveChanges();
            }

            return Ok("Content liked successfully.");
        }
        catch (Microsoft.EntityFrameworkCore.DbUpdateException ex)
        {
            // Handle potential unique constraint violation (if it's not checked explicitly above)
            return StatusCode(409, "A concurrency conflict occurred. User might have already liked this content.");
        }
        catch (Exception ex)
        {
            // Log the exception
            return StatusCode(500, "An error occurred during the like operation.");
        }
    }
}

public class LikeRequest
{
    public int ContentId { get; set; }
    public int UserId { get; set; }
}

public class Content
{
    public int Id { get; set; }
    public string Title { get; set; }
    public int LikeCount { get; set; }
}

public class Like
{
    public int Id { get; set; }
    public int ContentId { get; set; }
    public int UserId { get; set; }
    public DateTime LikeDate { get; set; }
}

// Simplified DbContext for demonstration
public class YourSocialMediaDbContext : IDisposable
{
    public List<Content> Contents { get; set; } = new List<Content>
    {
        new Content { Id = 1, Title = "Awesome Post", LikeCount = 10 }
    };
    public List<Like> Likes { get; set; } = new List<Like>();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 43
```python

from flask import Flask, request, jsonify
from threading import Lock
from datetime import datetime

app = Flask(__name__)

# Simulate database
contents_db = {
    1: {"id": 1, "title": "Awesome Post", "like_count": 10}
}
likes_db = [] # Stores {"content_id": X, "user_id": Y} to track individual likes
db_lock = Lock() # Global lock for simplicity, in reality, finer-grained locks or optimistic locking

@app.route("/like-content", methods=["POST"])
def like_content():
    data = request.get_json()
    content_id = data.get("contentId")
    user_id = data.get("userId")

    if not content_id or not user_id:
        return jsonify({"message": "Content ID and User ID are required."}), 400

    with db_lock:
        content = contents_db.get(content_id)

        if not content:
            return jsonify({"message": "Content not found."}), 404

        # Check if user has already liked this content
        if any(like["content_id"] == content_id and like["user_id"] == user_id for like in likes_db):
            return jsonify({"message": "User has already liked this content."}), 400

        # Add the like record
        likes_db.append({"content_id": content_id, "user_id": user_id, "like_date": datetime.now().isoformat()})

        # Increment the like count
        content["like_count"] += 1

        return jsonify({"message": "Content liked successfully.", "new_like_count": content["like_count"]}), 200

if __name__ == "__main__":
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 78
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

interface Content {
    id: number;
    title: string;
    likeCount: number;
}

interface Like {
    id: string;
    contentId: number;
    userId: number;
    likeDate: string;
}

const contentsDb = new Map<number, Content>();
contentsDb.set(1, { id: 1, title: 'Awesome Post', likeCount: 10 });

const likesDb: Like[] = [];
const contentMutexes = new Map<number, Mutex>();

contentsDb.forEach((content) => {
    contentMutexes.set(content.id, new Mutex());
});

app.post('/like-content', async (req: Request, res: Response) => {
    const { contentId, userId } = req.body;

    if (contentId === undefined || userId === undefined) {
        return res.status(400).json({ message: 'Content ID and User ID are required.' });
    }

    const mutex = contentMutexes.get(contentId);
    if (!mutex) {
        return res.status(404).json({ message: 'Content not found.' });
    }

    await mutex.runExclusive(async () => {
        let content = contentsDb.get(contentId);

        if (!content) {
            return res.status(404).json({ message: 'Content not found.' });
        }

        // Check if user has already liked this content
        const existingLike = likesDb.find(like => like.contentId === contentId && like.userId === userId);
        if (existingLike) {
            return res.status(400).json({ message: 'User has already liked this content.' });
        }

        // Add the like record
        const newLike: Like = {
            id: uuidv4(),
            contentId: contentId,
            userId: userId,
            likeDate: new Date().toISOString()
        };
        likesDb.push(newLike);

        // Increment the like count
        content.likeCount++;
        contentsDb.set(contentId, content);

        return res.status(200).json({ message: 'Content liked successfully.', newLikeCount: content.likeCount });
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

### ðŸ§ª Senaryo 6: Bir dosya paylaÅŸÄ±m sisteminde kullanÄ±cÄ±lar aynÄ± dosyayÄ± dÃ¼zenleyebilir. Dosya aÃ§Ä±k olduÄŸunda birden fazla kiÅŸi deÄŸiÅŸiklik yapabilir. DÃ¼zenleme iÅŸlemleri kaydedilirken mevcut sÃ¼rÃ¼m kontrol edilir. DeÄŸiÅŸiklikler dosya geÃ§miÅŸine eklenir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 112
```csharp

[HttpPost("edit-file")]
public IActionResult EditFile([FromBody] FileEditRequest request)
{
    int fileId = request.FileId;
    int userId = request.UserId;
    string newContent = request.NewContent;
    int expectedVersion = request.ExpectedVersion; // For optimistic concurrency

    using (var dbContext = new YourFileSharingDbContext())
    {
        using (var transaction = dbContext.Database.BeginTransaction())
        {
            try
            {
                // Retrieve the file with optimistic concurrency control (e.g., a version number)
                // In a real application, you might use a row version/timestamp column.
                var file = dbContext.Files.FirstOrDefault(f => f.Id == fileId);

                if (file == null)
                {
                    return BadRequest("File not found.");
                }

                // Check for optimistic concurrency violation
                if (file.Version != expectedVersion)
                {
                    transaction.Rollback();
                    return Conflict("File has been modified by another user. Please refresh and try again.");
                }

                // Update file content and increment version
                file.Content = newContent;
                file.Version++;
                file.LastModifiedByUserId = userId;
                file.LastModifiedDate = DateTime.UtcNow;
                dbContext.SaveChanges();

                // Add to file history
                dbContext.FileHistory.Add(new FileHistory
                {
                    FileId = fileId,
                    UserId = userId,
                    ChangeDescription = $"Content updated to version {file.Version}",
                    ChangedContent = newContent,
                    ChangeDate = DateTime.UtcNow
                });
                dbContext.SaveChanges();

                transaction.Commit();
                return Ok($"File updated successfully to version {file.Version}.");
            }
            catch (Exception ex)
            {
                transaction.Rollback();
                // Log the exception
                return StatusCode(500, "An error occurred during file editing.");
            }
        }
    }
}

public class FileEditRequest
{
    public int FileId { get; set; }
    public int UserId { get; set; }
    public string NewContent { get; set; }
    public int ExpectedVersion { get; set; }
}

public class File
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Content { get; set; }
    public int Version { get; set; } // Optimistic concurrency token
    public int? LastModifiedByUserId { get; set; }
    public DateTime? LastModifiedDate { get; set; }
}

public class FileHistory
{
    public int Id { get; set; }
    public int FileId { get; set; }
    public int UserId { get; set; }
    public string ChangeDescription { get; set; }
    public string ChangedContent { get; set; }
    public DateTime ChangeDate { get; set; }
}

// Simplified DbContext for demonstration
public class YourFileSharingDbContext : IDisposable
{
    public List<File> Files { get; set; } = new List<File>
    {
        new File { Id = 1, Name = "Document.txt", Content = "Initial content.", Version = 1 }
    };
    public List<FileHistory> FileHistory { get; set; } = new List<FileHistory>();

    public DatabaseFacade Database { get; } = new DatabaseFacade();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 60
```python

from flask import Flask, request, jsonify
from threading import Lock
from datetime import datetime

app = Flask(__name__)

# Simulate database
files_db = {
    1: {"id": 1, "name": "Document.txt", "content": "Initial content.", "version": 1, "last_modified_by_user_id": None, "last_modified_date": None}
}
file_history_db = []
file_locks = {
    1: Lock() # One lock per file for finer-grained concurrency control
}

@app.route("/edit-file", methods=["POST"])
def edit_file():
    data = request.get_json()
    file_id = data.get("fileId")
    user_id = data.get("userId")
    new_content = data.get("newContent")
    expected_version = data.get("expectedVersion")

    if not file_id or not user_id or not new_content or expected_version is None:
        return jsonify({"message": "File ID, User ID, New Content, and Expected Version are required."}), 400

    if file_id not in file_locks:
        return jsonify({"message": "File not found."}), 404

    with file_locks[file_id]: # Acquire lock for the specific file
        file = files_db.get(file_id)

        if not file:
            return jsonify({"message": "File not found."}), 404

        # Check for optimistic concurrency violation
        if file["version"] != expected_version:
            return jsonify({"message": "File has been modified by another user. Please refresh and try again."}), 409

        # Update file content and increment version
        file["content"] = new_content
        file["version"] += 1
        file["last_modified_by_user_id"] = user_id
        file["last_modified_date"] = datetime.now().isoformat()

        # Add to file history
        file_history_db.append({
            "history_id": len(file_history_db) + 1,
            "file_id": file_id,
            "user_id": user_id,
            "change_description": f"Content updated to version {file['version']}",
            "changed_content": new_content,
            "change_date": datetime.now().isoformat()
        })

        return jsonify({"message": f"File updated successfully to version {file['version']}.", "new_version": file["version"]}), 200

if __name__ == "__main__":
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 87
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

interface File {
    id: number;
    name: string;
    content: string;
    version: number;
    lastModifiedByUserId: number | null;
    lastModifiedDate: string | null;
}

interface FileHistory {
    id: string;
    fileId: number;
    userId: number;
    changeDescription: string;
    changedContent: string;
    changeDate: string;
}

const filesDb = new Map<number, File>();
filesDb.set(1, { id: 1, name: 'Document.txt', content: 'Initial content.', version: 1, lastModifiedByUserId: null, lastModifiedDate: null });

const fileHistoryDb: FileHistory[] = [];
const fileMutexes = new Map<number, Mutex>();

filesDb.forEach((file) => {
    fileMutexes.set(file.id, new Mutex());
});

app.post('/edit-file', async (req: Request, res: Response) => {
    const { fileId, userId, newContent, expectedVersion } = req.body;

    if (fileId === undefined || userId === undefined || newContent === undefined || expectedVersion === undefined) {
        return res.status(400).json({ message: 'File ID, User ID, New Content, and Expected Version are required.' });
    }

    const mutex = fileMutexes.get(fileId);
    if (!mutex) {
        return res.status(404).json({ message: 'File not found.' });
    }

    await mutex.runExclusive(async () => {
        let file = filesDb.get(fileId);

        if (!file) {
            return res.status(404).json({ message: 'File not found.' });
        }

        // Check for optimistic concurrency violation
        if (file.version !== expectedVersion) {
            return res.status(409).json({ message: 'File has been modified by another user. Please refresh and try again.' });
        }

        // Update file content and increment version
        file.content = newContent;
        file.version++;
        file.lastModifiedByUserId = userId;
        file.lastModifiedDate = new Date().toISOString();
        filesDb.set(fileId, file);

        // Add to file history
        const historyEntry: FileHistory = {
            id: uuidv4(),
            fileId: fileId,
            userId: userId,
            changeDescription: `Content updated to version ${file.version}`,
            changedContent: newContent,
            changeDate: new Date().toISOString()
        };
        fileHistoryDb.push(historyEntry);

        return res.status(200).json({ message: `File updated successfully to version ${file.version}.`, newVersion: file.version });
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

### ðŸ§ª Senaryo 7: Bir kargo sistemi aynÄ± kargo iÃ§in birden fazla gÃ¼ncelleme alabilir. FarklÄ± noktalarda durum gÃ¼ncellemeleri eÅŸzamanlÄ± gelebilir. Sistem gelen gÃ¼ncellemeleri takip numarasÄ±na gÃ¶re iÅŸler. GÃ¼ncellemeler kargo geÃ§miÅŸine kaydedilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 100
```csharp

[HttpPost("update-shipment-status")]
public IActionResult UpdateShipmentStatus([FromBody] ShipmentStatusUpdateRequest request)
{
    string trackingNumber = request.TrackingNumber;
    string newStatus = request.NewStatus;
    string location = request.Location;

    using (var dbContext = new YourShippingDbContext())
    {
        // For concurrent updates to the same shipment, consider using optimistic concurrency (e.g., a version column on the Shipment table)
        // or a messaging queue to process updates sequentially for a given tracking number.
        // For demonstration, a simple update is shown, implying the database handles concurrency (e.g., row-level locking).
        using (var transaction = dbContext.Database.BeginTransaction())
        {
            try
            {
                var shipment = dbContext.Shipments.FirstOrDefault(s => s.TrackingNumber == trackingNumber);

                if (shipment == null)
                {
                    return BadRequest("Shipment not found.");
                }

                // Update the current status of the shipment
                shipment.CurrentStatus = newStatus;
                shipment.LastUpdatedLocation = location;
                shipment.LastUpdatedDate = DateTime.UtcNow;
                dbContext.SaveChanges();

                // Add to shipment history
                dbContext.ShipmentHistory.Add(new ShipmentHistory
                {
                    TrackingNumber = trackingNumber,
                    Status = newStatus,
                    Location = location,
                    UpdateDate = DateTime.UtcNow
                });
                dbContext.SaveChanges();

                transaction.Commit();
                return Ok($"Shipment {trackingNumber} status updated to {newStatus}.");
            }
            catch (Exception ex)
            {
                transaction.Rollback();
                // Log the exception
                return StatusCode(500, "An error occurred during status update.");
            }
        }
    }
}

public class ShipmentStatusUpdateRequest
{
    public string TrackingNumber { get; set; }
    public string NewStatus { get; set; }
    public string Location { get; set; }
}

public class Shipment
{
    public int Id { get; set; }
    public string TrackingNumber { get; set; }
    public string CurrentStatus { get; set; }
    public string LastUpdatedLocation { get; set; }
    public DateTime LastUpdatedDate { get; set; }
}

public class ShipmentHistory
{
    public int Id { get; set; }
    public string TrackingNumber { get; set; }
    public string Status { get; set; }
    public string Location { get; set; }
    public DateTime UpdateDate { get; set; }
}

// Simplified DbContext for demonstration
public class YourShippingDbContext : IDisposable
{
    public List<Shipment> Shipments { get; set; } = new List<Shipment>
    {
        new Shipment { Id = 1, TrackingNumber = "TRK12345", CurrentStatus = "In Transit", LastUpdatedLocation = "Warehouse A", LastUpdatedDate = DateTime.UtcNow }
    };
    public List<ShipmentHistory> ShipmentHistory { get; set; } = new List<ShipmentHistory>();

    public DatabaseFacade Database { get; } = new DatabaseFacade();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 53
```python

from flask import Flask, request, jsonify
from threading import Lock
from datetime import datetime

app = Flask(__name__)

# Simulate database
shipments_db = {
    "TRK12345": {"id": 1, "tracking_number": "TRK12345", "current_status": "In Transit", "last_updated_location": "Warehouse A", "last_updated_date": datetime.now().isoformat()}
}
shipment_history_db = []
shipment_locks = {
    "TRK12345": Lock() # One lock per tracking number
}

@app.route("/update-shipment-status", methods=["POST"])
def update_shipment_status():
    data = request.get_json()
    tracking_number = data.get("trackingNumber")
    new_status = data.get("newStatus")
    location = data.get("location")

    if not tracking_number or not new_status or not location:
        return jsonify({"message": "Tracking Number, New Status, and Location are required."}), 400

    if tracking_number not in shipment_locks:
        return jsonify({"message": "Shipment not found."}), 404

    with shipment_locks[tracking_number]: # Acquire lock for the specific shipment
        shipment = shipments_db.get(tracking_number)

        if not shipment:
            return jsonify({"message": "Shipment not found."}), 404

        # Update the current status of the shipment
        shipment["current_status"] = new_status
        shipment["last_updated_location"] = location
        shipment["last_updated_date"] = datetime.now().isoformat()

        # Add to shipment history
        shipment_history_db.append({
            "history_id": len(shipment_history_db) + 1,
            "tracking_number": tracking_number,
            "status": new_status,
            "location": location,
            "update_date": datetime.now().isoformat()
        })

        return jsonify({"message": f"Shipment {tracking_number} status updated to {new_status}."}), 200

if __name__ == "__main__":
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 78
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

interface Shipment {
    id: number;
    trackingNumber: string;
    currentStatus: string;
    lastUpdatedLocation: string;
    lastUpdatedDate: string;
}

interface ShipmentHistory {
    id: string;
    trackingNumber: string;
    status: string;
    location: string;
    updateDate: string;
}

const shipmentsDb = new Map<string, Shipment>();
shipmentsDb.set('TRK12345', { id: 1, trackingNumber: 'TRK12345', currentStatus: 'In Transit', lastUpdatedLocation: 'Warehouse A', lastUpdatedDate: new Date().toISOString() });

const shipmentHistoryDb: ShipmentHistory[] = [];
const shipmentMutexes = new Map<string, Mutex>();

shipmentsDb.forEach((shipment) => {
    shipmentMutexes.set(shipment.trackingNumber, new Mutex());
});

app.post('/update-shipment-status', async (req: Request, res: Response) => {
    const { trackingNumber, newStatus, location } = req.body;

    if (trackingNumber === undefined || newStatus === undefined || location === undefined) {
        return res.status(400).json({ message: 'Tracking Number, New Status, and Location are required.' });
    }

    const mutex = shipmentMutexes.get(trackingNumber);
    if (!mutex) {
        return res.status(404).json({ message: 'Shipment not found.' });
    }

    await mutex.runExclusive(async () => {
        let shipment = shipmentsDb.get(trackingNumber);

        if (!shipment) {
            return res.status(404).json({ message: 'Shipment not found.' });
        }

        // Update the current status of the shipment
        shipment.currentStatus = newStatus;
        shipment.lastUpdatedLocation = location;
        shipment.lastUpdatedDate = new Date().toISOString();
        shipmentsDb.set(trackingNumber, shipment);

        // Add to shipment history
        const historyEntry: ShipmentHistory = {
            id: uuidv4(),
            trackingNumber: trackingNumber,
            status: newStatus,
            location: location,
            updateDate: new Date().toISOString()
        };
        shipmentHistoryDb.push(historyEntry);

        return res.status(200).json({ message: `Shipment ${trackingNumber} status updated to ${newStatus}.` });
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

### ðŸ§ª Senaryo 8: Bir forum uygulamasÄ±nda kullanÄ±cÄ±lar mesaj gÃ¶ndermeye Ã§alÄ±ÅŸabilir. AynÄ± konuya birden fazla yanÄ±t eÅŸzamanlÄ± gÃ¶nderilebilir. Sistem mesajlarÄ± sÄ±ralÄ± ÅŸekilde iÅŸler ve kayÄ±t altÄ±na alÄ±r. GÃ¶nderilen mesajlar konu altÄ±nda gÃ¶rÃ¼ntÃ¼lenir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 99
```csharp

[HttpPost("post-message")]
public IActionResult PostMessage([FromBody] ForumPostRequest request)
{
    int topicId = request.TopicId;
    int userId = request.UserId;
    string content = request.Content;

    using (var dbContext = new YourForumDbContext())
    {
        // For concurrent posts to the same topic, consider using a queueing mechanism or
        // database-level row locks on the Topic to ensure message ordering or prevent issues
        // if message order is critical beyond just insertion order.
        using (var transaction = dbContext.Database.BeginTransaction())
        {
            try
            {
                var topic = dbContext.Topics.FirstOrDefault(t => t.Id == topicId);

                if (topic == null)
                {
                    return BadRequest("Topic not found.");
                }

                // Create and add the new message
                dbContext.Messages.Add(new ForumMessage
                {
                    TopicId = topicId,
                    UserId = userId,
                    Content = content,
                    PostDate = DateTime.UtcNow
                });
                dbContext.SaveChanges();

                // Optionally, update the topic's last activity date or message count
                topic.LastActivityDate = DateTime.UtcNow;
                topic.MessageCount++;
                dbContext.SaveChanges();

                transaction.Commit();
                return Ok("Message posted successfully.");
            }
            catch (Exception ex)
            {
                transaction.Rollback();
                // Log the exception
                return StatusCode(500, "An error occurred during message posting.");
            }
        }
    }
}

public class ForumPostRequest
{
    public int TopicId { get; set; }
    public int UserId { get; set; }
    public string Content { get; set; }
}

public class Topic
{
    public int Id { get; set; }
    public string Title { get; set; }
    public DateTime CreationDate { get; set; }
    public DateTime LastActivityDate { get; set; }
    public int MessageCount { get; set; }
}

public class ForumMessage
{
    public int Id { get; set; }
    public int TopicId { get; set; }
    public int UserId { get; set; }
    public string Content { get; set; }
    public DateTime PostDate { get; set; }
}

// Simplified DbContext for demonstration
public class YourForumDbContext : IDisposable
{
    public List<Topic> Topics { get; set; } = new List<Topic>
    {
        new Topic { Id = 1, Title = "General Discussion", CreationDate = DateTime.UtcNow.AddDays(-7), LastActivityDate = DateTime.UtcNow.AddDays(-1), MessageCount = 5 }
    };
    public List<ForumMessage> Messages { get; set; } = new List<ForumMessage>();

    public DatabaseFacade Database { get; } = new DatabaseFacade();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 53
```python

from flask import Flask, request, jsonify
from threading import Lock
from datetime import datetime

app = Flask(__name__)

# Simulate database
topics_db = {
    1: {"id": 1, "title": "General Discussion", "creation_date": "2025-06-14T00:00:00Z", "last_activity_date": "2025-06-20T00:00:00Z", "message_count": 5}
}
messages_db = []
topic_locks = {
    1: Lock() # One lock per topic for managing updates to topic metadata
}

@app.route("/post-message", methods=["POST"])
def post_message():
    data = request.get_json()
    topic_id = data.get("topicId")
    user_id = data.get("userId")
    content = data.get("content")

    if not topic_id or not user_id or not content:
        return jsonify({"message": "Topic ID, User ID, and Content are required."}), 400

    if topic_id not in topic_locks:
        return jsonify({"message": "Topic not found."}), 404

    with topic_locks[topic_id]: # Acquire lock for the specific topic
        topic = topics_db.get(topic_id)

        if not topic:
            return jsonify({"message": "Topic not found."}), 404

        # Create and add the new message
        message = {
            "message_id": len(messages_db) + 1,
            "topic_id": topic_id,
            "user_id": user_id,
            "content": content,
            "post_date": datetime.now().isoformat()
        }
        messages_db.append(message)

        # Update the topic's last activity date and message count
        topic["last_activity_date"] = datetime.now().isoformat()
        topic["message_count"] += 1

        return jsonify({"message": "Message posted successfully."}), 200

if __name__ == "__main__":
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 77
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

interface Topic {
    id: number;
    title: string;
    creationDate: string;
    lastActivityDate: string;
    messageCount: number;
}

interface ForumMessage {
    id: string;
    topicId: number;
    userId: number;
    content: string;
    postDate: string;
}

const topicsDb = new Map<number, Topic>();
topicsDb.set(1, { id: 1, title: 'General Discussion', creationDate: '2025-06-14T00:00:00Z', lastActivityDate: '2025-06-20T00:00:00Z', messageCount: 5 });

const messagesDb: ForumMessage[] = [];
const topicMutexes = new Map<number, Mutex>();

topicsDb.forEach((topic) => {
    topicMutexes.set(topic.id, new Mutex());
});

app.post('/post-message', async (req: Request, res: Response) => {
    const { topicId, userId, content } = req.body;

    if (topicId === undefined || userId === undefined || content === undefined) {
        return res.status(400).json({ message: 'Topic ID, User ID, and Content are required.' });
    }

    const mutex = topicMutexes.get(topicId);
    if (!mutex) {
        return res.status(404).json({ message: 'Topic not found.' });
    }

    await mutex.runExclusive(async () => {
        let topic = topicsDb.get(topicId);

        if (!topic) {
            return res.status(404).json({ message: 'Topic not found.' });
        }

        // Create and add the new message
        const newMessage: ForumMessage = {
            id: uuidv4(),
            topicId: topicId,
            userId: userId,
            content: content,
            postDate: new Date().toISOString()
        };
        messagesDb.push(newMessage);

        // Update the topic's last activity date and message count
        topic.lastActivityDate = new Date().toISOString();
        topic.messageCount++;
        topicsDb.set(topicId, topic);

        return res.status(200).json({ message: 'Message posted successfully.' });
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

### ðŸ§ª Senaryo 9: Bir oyun platformunda oyuncular puanlarÄ±nÄ± gÃ¼ncelleyebilir. FarklÄ± oyunlardan aynÄ± anda puan gÃ¼ncellemeleri gelebilir. Sistem toplam puanÄ± hesaplar ve liderlik tablosunu gÃ¼nceller. Puan deÄŸiÅŸiklikleri oyuncu profilinde gÃ¶rÃ¼ntÃ¼lenir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 100
```csharp

[HttpPost("update-player-score")]
public IActionResult UpdatePlayerScore([FromBody] PlayerScoreUpdateRequest request)
{
    int playerId = request.PlayerId;
    int gameId = request.GameId;
    int scoreEarned = request.ScoreEarned;

    using (var dbContext = new YourGamePlatformDbContext())
    {
        // For concurrent score updates for the same player, consider using a transaction
        // with appropriate locking (e.g., row lock on PlayerScore or Player tables)
        // or a queueing system if updates are very frequent and order matters.
        using (var transaction = dbContext.Database.BeginTransaction())
        {
            try
            {
                var player = dbContext.Players.FirstOrDefault(p => p.Id == playerId);

                if (player == null)
                {
                    return BadRequest("Player not found.");
                }

                // Update player's total score
                player.TotalScore += scoreEarned;
                dbContext.SaveChanges();

                // Record the individual game score
                dbContext.GameScores.Add(new GameScore
                {
                    PlayerId = playerId,
                    GameId = gameId,
                    Score = scoreEarned,
                    ScoreDate = DateTime.UtcNow
                });
                dbContext.SaveChanges();

                // In a real system, leaderboard updates might be asynchronous or batched
                // For simplicity, we assume an immediate update here.
                // The leaderboard logic would typically involve re-sorting or recalculating.

                transaction.Commit();
                return Ok($"Player {playerId} score updated. New total score: {player.TotalScore}.");
            }
            catch (Exception ex)
            {
                transaction.Rollback();
                // Log the exception
                return StatusCode(500, "An error occurred during score update.");
            }
        }
    }
}

public class PlayerScoreUpdateRequest
{
    public int PlayerId { get; set; }
    public int GameId { get; set; }
    public int ScoreEarned { get; set; }
}

public class Player
{
    public int Id { get; set; }
    public string Username { get; set; }
    public int TotalScore { get; set; }
}

public class GameScore
{
    public int Id { get; set; }
    public int PlayerId { get; set; }
    public int GameId { get; set; }
    public int Score { get; set; }
    public DateTime ScoreDate { get; set; }
}

// Simplified DbContext for demonstration
public class YourGamePlatformDbContext : IDisposable
{
    public List<Player> Players { get; set; } = new List<Player>
    {
        new Player { Id = 1, Username = "GamerOne", TotalScore = 1000 }
    };
    public List<GameScore> GameScores { get; set; } = new List<GameScore>();

    public DatabaseFacade Database { get; } = new DatabaseFacade();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 56
```python

from flask import Flask, request, jsonify
from threading import Lock
from datetime import datetime

app = Flask(__name__)

# Simulate database
players_db = {
    1: {"id": 1, "username": "GamerOne", "total_score": 1000}
}
game_scores_db = []
player_locks = {
    1: Lock() # One lock per player for score updates
}

@app.route("/update-player-score", methods=["POST"])
def update_player_score():
    data = request.get_json()
    player_id = data.get("playerId")
    game_id = data.get("gameId")
    score_earned = data.get("scoreEarned")

    if not player_id or not game_id or score_earned is None:
        return jsonify({"message": "Player ID, Game ID, and Score Earned are required."}), 400

    if player_id not in player_locks:
        return jsonify({"message": "Player not found."}), 404

    with player_locks[player_id]: # Acquire lock for the specific player
        player = players_db.get(player_id)

        if not player:
            return jsonify({"message": "Player not found."}), 404

        # Update player's total score
        player["total_score"] += score_earned

        # Record the individual game score
        game_score_entry = {
            "score_id": len(game_scores_db) + 1,
            "player_id": player_id,
            "game_id": game_id,
            "score": score_earned,
            "score_date": datetime.now().isoformat()
        }
        game_scores_db.append(game_score_entry)

        # In a real system, leaderboard updates might be asynchronous or batched
        # For simplicity, we assume an immediate update here.
        # The leaderboard logic would typically involve re-sorting or recalculating.

        return jsonify({"message": f"Player {player_id} score updated. New total score: {player['total_score']}."}), 200

if __name__ == "__main__":
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 78
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

interface Player {
    id: number;
    username: string;
    totalScore: number;
}

interface GameScore {
    id: string;
    playerId: number;
    gameId: number;
    score: number;
    scoreDate: string;
}

const playersDb = new Map<number, Player>();
playersDb.set(1, { id: 1, username: 'GamerOne', totalScore: 1000 });

const gameScoresDb: GameScore[] = [];
const playerMutexes = new Map<number, Mutex>();

playersDb.forEach((player) => {
    playerMutexes.set(player.id, new Mutex());
});

app.post('/update-player-score', async (req: Request, res: Response) => {
    const { playerId, gameId, scoreEarned } = req.body;

    if (playerId === undefined || gameId === undefined || scoreEarned === undefined) {
        return res.status(400).json({ message: 'Player ID, Game ID, and Score Earned are required.' });
    }

    const mutex = playerMutexes.get(playerId);
    if (!mutex) {
        return res.status(404).json({ message: 'Player not found.' });
    }

    await mutex.runExclusive(async () => {
        let player = playersDb.get(playerId);

        if (!player) {
            return res.status(404).json({ message: 'Player not found.' });
        }

        // Update player's total score
        player.totalScore += scoreEarned;
        playersDb.set(playerId, player);

        // Record the individual game score
        const newGameScore: GameScore = {
            id: uuidv4(),
            playerId: playerId,
            gameId: gameId,
            score: scoreEarned,
            scoreDate: new Date().toISOString()
        };
        gameScoresDb.push(newGameScore);

        // In a real system, leaderboard updates might be asynchronous or batched
        // For simplicity, we assume an immediate update here.
        // The leaderboard logic would typically involve re-sorting or recalculating.

        return res.status(200).json({ message: `Player ${playerId} score updated. New total score: ${player.totalScore}.`, newTotalScore: player.totalScore });
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

### ðŸ§ª Senaryo 10: Bir etkinlik kayÄ±t sisteminde katÄ±lÄ±mcÄ±lar aynÄ± etkinliÄŸe kaydolabilir. Kontenjan dolmak Ã¼zereyken birden fazla kayÄ±t iÅŸlemi baÅŸlatÄ±labilir. Sistem mevcut katÄ±lÄ±mcÄ± sayÄ±sÄ±nÄ± kontrol eder ve uygun kayÄ±tlarÄ± onaylar. KayÄ±t iÅŸlemleri etkinlik listesinde gÃ¶sterilir.
**ðŸ’» Dil:** `C#`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 100
```csharp

[HttpPost("register-for-event")]
public IActionResult RegisterForEvent([FromBody] EventRegistrationRequest request)
{
    int eventId = request.EventId;
    int userId = request.UserId;

    using (var dbContext = new YourEventRegistrationDbContext())
    {
        // For concurrent registrations, use a transaction with a lock on the Event entity
        // or leverage optimistic concurrency (e.g., a version or concurrency token on the Event table).
        using (var transaction = dbContext.Database.BeginTransaction())
        {
            try
            {
                var @event = dbContext.Events.FirstOrDefault(e => e.Id == eventId);

                if (@event == null)
                {
                    return BadRequest("Event not found.");
                }

                if (@event.CurrentParticipants >= @event.MaxParticipants)
                {
                    transaction.Rollback();
                    return BadRequest("Event is full. No more registrations allowed.");
                }

                // Increment participant count
                @event.CurrentParticipants++;
                dbContext.SaveChanges();

                // Create registration record
                dbContext.EventRegistrations.Add(new EventRegistration
                {
                    EventId = eventId,
                    UserId = userId,
                    RegistrationDate = DateTime.UtcNow,
                    Status = "Confirmed"
                });
                dbContext.SaveChanges();

                transaction.Commit();
                return Ok($"Successfully registered for event {@event.Title}. Current participants: {@event.CurrentParticipants}.");
            }
            catch (Exception ex)
            {
                transaction.Rollback();
                // Log the exception
                return StatusCode(500, "An error occurred during event registration.");
            }
        }
    }
}

public class EventRegistrationRequest
{
    public int EventId { get; set; }
    public int UserId { get; set; }
}

public class Event
{
    public int Id { get; set; }
    public string Title { get; set; }
    public int MaxParticipants { get; set; }
    public int CurrentParticipants { get; set; }
}

public class EventRegistration
{
    public int Id { get; set; }
    public int EventId { get; set; }
    public int UserId { get; set; }
    public DateTime RegistrationDate { get; set; }
    public string Status { get; set; } // "Confirmed", "Waitlisted", "Cancelled"
}

// Simplified DbContext for demonstration
public class YourEventRegistrationDbContext : IDisposable
{
    public List<Event> Events { get; set; } = new List<Event>
    {
        new Event { Id = 1, Title = "Tech Conference 2025", MaxParticipants = 100, CurrentParticipants = 98 }
    };
    public List<EventRegistration> EventRegistrations { get; set; } = new List<EventRegistration>();

    public DatabaseFacade Database { get; } = new DatabaseFacade();

    public int SaveChanges()
    {
        // Simulate saving changes to a database
        return 1;
    }

    public void Dispose()
    {
        // Dispose resources
    }
}
```
**ðŸ’» Dil:** `Python`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 54
```python

from flask import Flask, request, jsonify
from threading import Lock
from datetime import datetime

app = Flask(__name__)

# Simulate database
events_db = {
    1: {"id": 1, "title": "Tech Conference 2025", "max_participants": 100, "current_participants": 98}
}
event_registrations_db = []
event_locks = {
    1: Lock() # One lock per event for registration
}

@app.route("/register-for-event", methods=["POST"])
def register_for_event():
    data = request.get_json()
    event_id = data.get("eventId")
    user_id = data.get("userId")

    if not event_id or not user_id:
        return jsonify({"message": "Event ID and User ID are required."}), 400

    if event_id not in event_locks:
        return jsonify({"message": "Event not found."}), 404

    with event_locks[event_id]: # Acquire lock for the specific event
        event = events_db.get(event_id)

        if not event:
            return jsonify({"message": "Event not found."}), 404

        if event["current_participants"] >= event["max_participants"]:
            return jsonify({"message": "Event is full. No more registrations allowed."}), 400

        # Increment participant count
        event["current_participants"] += 1

        # Create registration record
        registration = {
            "registration_id": len(event_registrations_db) + 1,
            "event_id": event_id,
            "user_id": user_id,
            "registration_date": datetime.now().isoformat(),
            "status": "Confirmed"
        }
        event_registrations_db.append(registration)

        return jsonify({"message": f"Successfully registered for event {event['title']}. Current participants: {event['current_participants']}."}), 200

if __name__ == "__main__":
    app.run(debug=True)
```
**ðŸ’» Dil:** `TypeScript (Node.js)`

**ðŸ¤– AI:** Gemini

**SatÄ±r SayÄ±sÄ±:** 78
```typescript

import express from 'express';
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Mutex } from 'async-mutex';

const app = express();
app.use(express.json());

interface Event {
    id: number;
    title: string;
    maxParticipants: number;
    currentParticipants: number;
}

interface EventRegistration {
    id: string;
    eventId: number;
    userId: number;
    registrationDate: string;
    status: string;
}

const eventsDb = new Map<number, Event>();
eventsDb.set(1, { id: 1, title: 'Tech Conference 2025', maxParticipants: 100, currentParticipants: 98 });

const eventRegistrationsDb: EventRegistration[] = [];
const eventMutexes = new Map<number, Mutex>();

eventsDb.forEach((event) => {
    eventMutexes.set(event.id, new Mutex());
});

app.post('/register-for-event', async (req: Request, res: Response) => {
    const { eventId, userId } = req.body;

    if (eventId === undefined || userId === undefined) {
        return res.status(400).json({ message: 'Event ID and User ID are required.' });
    }

    const mutex = eventMutexes.get(eventId);
    if (!mutex) {
        return res.status(404).json({ message: 'Event not found.' });
    }

    await mutex.runExclusive(async () => {
        let event = eventsDb.get(eventId);

        if (!event) {
            return res.status(404).json({ message: 'Event not found.' });
        }

        if (event.currentParticipants >= event.maxParticipants) {
            return res.status(400).json({ message: 'Event is full. No more registrations allowed.' });
        }

        // Increment participant count
        event.currentParticipants++;
        eventsDb.set(eventId, event);

        // Create registration record
        const newRegistration: EventRegistration = {
            id: uuidv4(),
            eventId: eventId,
            userId: userId,
            registrationDate: new Date().toISOString(),
            status: 'Confirmed'
        };
        eventRegistrationsDb.push(newRegistration);

        return res.status(200).json({ message: `Successfully registered for event ${event.title}. Current participants: ${event.currentParticipants}.` });
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
```
});