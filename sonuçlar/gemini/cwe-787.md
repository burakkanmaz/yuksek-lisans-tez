 


----

### ğŸ§ª Senaryo 1: Bir metin editÃ¶rÃ¼ uygulamasÄ±nda kullanÄ±cÄ±lar belge iÃ§eriÄŸini dÃ¼zenler. Sistem metin verilerini bellek alanlarÄ±nda saklar. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan iÅŸlenir ve kayÄ±t edilir. Belge iÃ§eriÄŸi dÃ¼zenli olarak gÃ¼ncellenir.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** Gemini

```csharp
using System;
using System.Collections.Generic;

public class DocumentEditor
{
    private Dictionary<string, string> documentContent = new Dictionary<string, string>(); // Stores document content in memory

    public void LoadDocument(string documentId, string content)
    {
        documentContent[documentId] = content;
        Console.WriteLine(<span class="math-inline">"Document '\{documentId\}' loaded\."\);
\}
public void EditDocument\(string documentId, string newContent\)
\{
if \(documentContent\.ContainsKey\(documentId\)\)
\{
documentContent\[documentId\] \= newContent; // Process and record user edits
Console\.WriteLine\(</span>"Document '{documentId}' updated successfully.");
            SaveDocument(documentId); // Update document content regularly (simulated save)
        }
        else
        {
            Console.WriteLine(<span class="math-inline">"Document '\{documentId\}' not found\."\);
\}
\}
public string GetDocumentContent\(string documentId\)
\{
if \(documentContent\.ContainsKey\(documentId\)\)
\{
return documentContent\[documentId\];
\}
return "Document not found\.";
\}
private void SaveDocument\(string documentId\)
\{
// In a real application, this would persist the data to a database or file system\.
// For this simulation, we just print a message\.
Console\.WriteLine\(</span>"Document '{documentId}' saved to persistent storage (simulated).");
    }
}

// Example usage (not part of the required code, for demonstration only)
// public class Program
// {
//     public static void Main(string[] args)
//     {
//         DocumentEditor editor = new DocumentEditor();
//         editor.LoadDocument("doc1", "Initial content of the document.");
//         editor.EditDocument("doc1", "Updated content after user edits.");
//         Console.WriteLine($"Current content of doc1: {editor.GetDocumentContent("doc1")}");
//     }
// }
ğŸ§ª Senaryo 1: Bir metin editÃ¶rÃ¼ uygulamasÄ±nda kullanÄ±cÄ±lar belge iÃ§eriÄŸini dÃ¼zenler. Sistem metin verilerini bellek alanlarÄ±nda saklar. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan iÅŸlenir ve kayÄ±t edilir. Belge iÃ§eriÄŸi dÃ¼zenli olarak gÃ¼ncellenir.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class DocumentEditor:
    def __init__(self):
        self.document_content = {}  # Stores document content in memory

    def load_document(self, document_id: str, content: str):
        self.document_content[document_id] = content
        print(f"Document '{document_id}' loaded.")

    def edit_document(self, document_id: str, new_content: str):
        if document_id in self.document_content:
            self.document_content[document_id] = new_content  # Process and record user edits
            print(f"Document '{document_id}' updated successfully.")
            self._save_document(document_id)  # Update document content regularly (simulated save)
        else:
            print(f"Document '{document_id}' not found.")

    def get_document_content(self, document_id: str) -> str:
        return self.document_content.get(document_id, "Document not found.")

    def _save_document(self, document_id: str):
        # In a real application, this would persist the data to a database or file system.
        # For this simulation, we just print a message.
        print(f"Document '{document_id}' saved to persistent storage (simulated).")

# Example usage (not part of the required code, for demonstration only)
# if __name__ == "__main__":
#     editor = DocumentEditor()
#     editor.load_document("doc_py", "Initial content for Python document.")
#     editor.edit_document("doc_py", "New content after Python user edits.")
#     print(f"Current content of doc_py: {editor.get_document_content('doc_py')}")
ğŸ§ª Senaryo 1: Bir metin editÃ¶rÃ¼ uygulamasÄ±nda kullanÄ±cÄ±lar belge iÃ§eriÄŸini dÃ¼zenler. Sistem metin verilerini bellek alanlarÄ±nda saklar. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan iÅŸlenir ve kayÄ±t edilir. Belge iÃ§eriÄŸi dÃ¼zenli olarak gÃ¼ncellenir.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

TypeScript

class DocumentEditor {
    private documentContent: Map<string, string> = new Map(); // Stores document content in memory

    public loadDocument(documentId: string, content: string): void {
        this.documentContent.set(documentId, content);
        console.log(`Document '${documentId}' loaded.`);
    }

    public editDocument(documentId: string, newContent: string): void {
        if (this.documentContent.has(documentId)) {
            this.documentContent.set(documentId, newContent); // Process and record user edits
            console.log(`Document '${documentId}' updated successfully.`);
            this.saveDocument(documentId); // Update document content regularly (simulated save)
        } else {
            console.log(`Document '${documentId}' not found.`);
        }
    }

    public getDocumentContent(documentId: string): string {
        return this.documentContent.get(documentId) || "Document not found.";
    }

    private saveDocument(documentId: string): void {
        // In a real application, this would persist the data to a database or file system.
        // For this simulation, we just print a message.
        console.log(`Document '${documentId}' saved to persistent storage (simulated).`);
    }
}

// Example usage (not part of the required code, for demonstration only)
// const editor = new DocumentEditor();
// editor.loadDocument("doc_ts", "Initial content for TypeScript document.");
// editor.editDocument("doc_ts", "Modified content from TypeScript user.");
// console.log(`Current content of doc_ts: ${editor.getDocumentContent("doc_ts")}`);
ğŸ§ª Senaryo 2: Bir grafik tasarÄ±m uygulamasÄ±nda kullanÄ±cÄ±lar piksel verilerini deÄŸiÅŸtirir. GÃ¶rÃ¼ntÃ¼ verileri bellek buffer'larÄ±nda tutulur. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan iÅŸlenir. GÃ¶rÃ¼ntÃ¼ deÄŸiÅŸiklikleri ekranda gÃ¶sterilir.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

using System;
using System.Collections.Generic;

public class GraphicDesignApp
{
    // Represents a simplified image buffer (e.g., a 2D array of pixel data)
    private Dictionary<string, byte[,]> imageBuffers = new Dictionary<string, byte[,]>(); 

    public void LoadImage(string imageId, byte[,] pixelData)
    {
        imageBuffers[imageId] = pixelData; // Image data held in memory buffers
        Console.WriteLine(<span class="math-inline">"Image '\{imageId\}' loaded with dimensions \{pixelData\.GetLength\(0\)\}x\{pixelData\.GetLength\(1\)\}\."\);
\}
public void ApplyPixelEdit\(string imageId, int x, int y, byte newColor\)
\{
if \(imageBuffers\.ContainsKey\(imageId\)\)
\{
byte\[,\] pixels \= imageBuffers\[imageId\];
if \(x \>\= 0 && x < pixels\.GetLength\(0\) && y \>\= 0 && y < pixels\.GetLength\(1\)\)
\{
pixels\[x, y\] \= newColor; // User edits processed by the system
Console\.WriteLine\(</span>"Pixel at ({x},{y}) in image '{imageId}' changed to {newColor}.");
                DisplayImageChanges(imageId); // Image changes shown on screen (simulated)
            }
            else
            {
                Console.WriteLine(<span class="math-inline">"Coordinates \(\{x\},\{y\}\) are out of bounds for image '\{imageId\}'\."\);
\}
\}
else
\{
Console\.WriteLine\(</span>"Image '{imageId}' not found.");
        }
    }

    private void DisplayImageChanges(string imageId)
    {
        // In a real application, this would involve rendering the image to a UI.
        // For this simulation, we just print a message.
        Console.WriteLine($"Displaying updated image '{imageId}' on screen (simulated rendering).");
    }

    public byte[,] GetImageData(string imageId)
    {
        return imageBuffers.GetValueOrDefault(imageId);
    }
}

// Example usage (not part of the required code)
// public class Program
// {
//     public static void Main(string[] args)
//     {
//         GraphicDesignApp app = new GraphicDesignApp();
//         byte[,] img1 = new byte[10, 10]; // 10x10 image
//         app.LoadImage("image1", img1);
//         app.ApplyPixelEdit("image1", 5, 5, 255); // Change pixel at 5,5 to white
//     }
// }
ğŸ§ª Senaryo 2: Bir grafik tasarÄ±m uygulamasÄ±nda kullanÄ±cÄ±lar piksel verilerini deÄŸiÅŸtirir. GÃ¶rÃ¼ntÃ¼ verileri bellek buffer'larÄ±nda tutulur. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan iÅŸlenir. GÃ¶rÃ¼ntÃ¼ deÄŸiÅŸiklikleri ekranda gÃ¶sterilir.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

import numpy as np

class GraphicDesignApp:
    def __init__(self):
        self.image_buffers = {}  # Stores image data in memory buffers (using NumPy arrays for pixel data)

    def load_image(self, image_id: str, pixel_data: np.ndarray):
        self.image_buffers[image_id] = pixel_data
        print(f"Image '{image_id}' loaded with dimensions {pixel_data.shape[0]}x{pixel_data.shape[1]}.")

    def apply_pixel_edit(self, image_id: str, x: int, y: int, new_color: int):
        if image_id in self.image_buffers:
            pixels = self.image_buffers[image_id]
            if 0 <= x < pixels.shape[0] and 0 <= y < pixels.shape[1]:
                pixels[x, y] = new_color  # User edits processed by the system
                print(f"Pixel at ({x},{y}) in image '{image_id}' changed to {new_color}.")
                self._display_image_changes(image_id)  # Image changes shown on screen (simulated)
            else:
                print(f"Coordinates ({x},{y}) are out of bounds for image '{image_id}'.")
        else:
            print(f"Image '{image_id}' not found.")

    def _display_image_changes(self, image_id: str):
        # In a real application, this would involve rendering the image to a UI.
        # For this simulation, we just print a message.
        print(f"Displaying updated image '{image_id}' on screen (simulated rendering).")

    def get_image_data(self, image_id: str) -> np.ndarray | None:
        return self.image_buffers.get(image_id)

# Example usage (not part of the required code)
# if __name__ == "__main__":
#     app = GraphicDesignApp()
#     img_data = np.zeros((10, 10), dtype=np.uint8) # 10x10 image with black pixels
#     app.load_image("photo1", img_data)
#     app.apply_pixel_edit("photo1", 2, 3, 255) # Change pixel at 2,3 to white
ğŸ§ª Senaryo 2: Bir grafik tasarÄ±m uygulamasÄ±nda kullanÄ±cÄ±lar piksel verilerini deÄŸiÅŸtirir. GÃ¶rÃ¼ntÃ¼ verileri bellek buffer'larÄ±nda tutulur. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan iÅŸlenir. GÃ¶rÃ¼ntÃ¼ deÄŸiÅŸiklikleri ekranda gÃ¶sterilir.
ğŸ’» Dil: TypeScript (ReactJS - simplified)

ğŸ¤– AI: Gemini

TypeScript

import React, { useState } from 'react';

// Simplified representation of pixel data
type PixelData = number[][]; // Array of rows, each row is an array of pixel values

interface ImageBuffer {
  [imageId: string]: PixelData;
}

const GraphicDesignApp: React.FC = () => {
  const [imageBuffers, setImageBuffers] = useState<ImageBuffer>({});
  const [displayedImageId, setDisplayedImageId] = useState<string | null>(null);

  const loadImage = (imageId: string, pixelData: PixelData) => {
    setImageBuffers(prevBuffers => ({
      ...prevBuffers,
      [imageId]: pixelData, // Image data held in memory buffers
    }));
    console.log(`Image '${imageId}' loaded with dimensions ${pixelData.length}x${pixelData[0]?.length || 0}.`);
  };

  const applyPixelEdit = (imageId: string, x: number, y: number, newColor: number) => {
    setImageBuffers(prevBuffers => {
      const currentPixels = prevBuffers[imageId];
      if (currentPixels) {
        if (x >= 0 && x < currentPixels.length && y >= 0 && y < currentPixels[0].length) {
          const newPixels = currentPixels.map((row, rowIndex) =>
            rowIndex === x ? row.map((col, colIndex) => (colIndex === y ? newColor : col)) : row
          );
          console.log(`Pixel at (${x},${y}) in image '${imageId}' changed to ${newColor}.`);
          setDisplayedImageId(imageId); // Image changes shown on screen (trigger re-render)
          return {
            ...prevBuffers,
            [imageId]: newPixels, // User edits processed by the system
          };
        } else {
          console.log(`Coordinates (${x},${y}) are out of bounds for image '${imageId}'.`);
          return prevBuffers;
        }
      } else {
        console.log(`Image '${imageId}' not found.`);
        return prevBuffers;
      }
    });
  };

  // This would be the actual rendering component in a real React app
  const renderImage = (imageId: string | null) => {
    if (!imageId || !imageBuffers[imageId]) {
      return <div>No image selected or image not found.</div>;
    }
    const pixels = imageBuffers[imageId];
    // In a real application, this would draw the pixels onto a canvas.
    // For this simulation, we just represent it as a grid of numbers.
    return (
      <div style={{ display: 'grid', gridTemplateColumns: `repeat(${pixels[0].length}, 20px)`, border: '1px solid black' }}>
        {pixels.flat().map((pixel, index) => (
          <div key={index} style={{ width: '20px', height: '20px', backgroundColor: `rgb(${pixel},${pixel},${pixel})`, border: '1px solid #eee' }}></div>
        ))}
      </div>
    );
  };

  return (
    <div>
      <h1>Graphic Design App</h1>
      <button onClick={() => loadImage('myImage', Array(5).fill(0).map(() => Array(5).fill(128)))}>
        Load Sample Image (5x5 gray)
      </button>
      <button onClick={() => applyPixelEdit('myImage', 2, 2, 255)}>
        Change Center Pixel to White
      </button>
      {displayedImageId && (
        <>
          <h2>Displaying Image: {displayedImageId}</h2>
          {renderImage(displayedImageId)}
        </>
      )}
    </div>
  );
};

export default GraphicDesignApp;
ğŸ§ª Senaryo 3: Bir ses dÃ¼zenleme programÄ±nda kullanÄ±cÄ±lar audio verilerini iÅŸler. Ses Ã¶rnekleri bellek dizilerinde saklanÄ±r. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan uygulanÄ±r. Ses dosyasÄ± yeni haliyle kaydedilir.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

using System;
using System.Collections.Generic;
using System.IO;

public class AudioEditor
{
    // Represents audio samples in memory arrays
    private Dictionary<string, float[]> audioSamples = new Dictionary<string, float[]>(); 

    public void LoadAudioFile(string audioId, float[] samples)
    {
        audioSamples[audioId] = samples;
        Console.WriteLine(<span class="math-inline">"Audio file '\{audioId\}' loaded with \{samples\.Length\} samples\."\);
\}
public void ApplyVolumeChange\(string audioId, float multiplier\)
\{
if \(audioSamples\.ContainsKey\(audioId\)\)
\{
float\[\] samples \= audioSamples\[audioId\];
for \(int i \= 0; i < samples\.Length; i\+\+\)
\{
samples\[i\] \*\= multiplier; // User edits applied by the system
\}
Console\.WriteLine\(</span>"Volume changed for audio '{audioId}' by multiplier {multiplier}.");
            SaveAudioFile(audioId); // Audio file saved with new state
        }
        else
        {
            Console.WriteLine(<span class="math-inline">"Audio '\{audioId\}' not found\."\);
\}
\}
public void TrimAudio\(string audioId, int startSample, int endSample\)
\{
if \(audioSamples\.ContainsKey\(audioId\)\)
\{
float\[\] originalSamples \= audioSamples\[audioId\];
if \(startSample \>\= 0 && endSample < originalSamples\.Length && startSample < endSample\)
\{
float\[\] trimmedSamples \= new float\[endSample \- startSample \+ 1\];
Array\.Copy\(originalSamples, startSample, trimmedSamples, 0, trimmedSamples\.Length\);
audioSamples\[audioId\] \= trimmedSamples; // User edits applied by the system
Console\.WriteLine\(</span>"Audio '{audioId}' trimmed from sample {startSample} to {endSample}.");
                SaveAudioFile(audioId); // Audio file saved with new state
            }
            else
            {
                Console.WriteLine(<span class="math-inline">"Invalid trim range for audio '\{audioId\}'\."\);
\}
\}
else
\{
Console\.WriteLine\(</span>"Audio '{audioId}' not found.");
        }
    }

    private void SaveAudioFile(string audioId)
    {
        // In a real application, this would write the audio data to a file (e.g., WAV, MP3).
        // For this simulation, we just print a message.
        Console.WriteLine($"Audio file '{audioId}' saved to storage (simulated).");
        // Example of writing to a dummy file:
        // string filePath = $"{audioId}.wav";
        // File.WriteAllBytes(filePath, new byte[100]); // Dummy write
    }

    public float[] GetAudioSamples(string audioId)
    {
        return audioSamples.GetValueOrDefault(audioId);
    }
}

// Example usage (not part of the required code)
// public class Program
// {
//     public static void Main(string[] args)
//     {
//         AudioEditor editor = new AudioEditor();
//         float[] samples = new float[1000]; // 1000 audio samples
//         for (int i = 0; i < 1000; i++) samples[i] = (float)Math.Sin(i * 0.1);
//         editor.LoadAudioFile("song1", samples);
//         editor.ApplyVolumeChange("song1", 0.5f); // Half volume
//         editor.TrimAudio("song1", 100, 500);
//     }
// }
ğŸ§ª Senaryo 3: Bir ses dÃ¼zenleme programÄ±nda kullanÄ±cÄ±lar audio verilerini iÅŸler. Ses Ã¶rnekleri bellek dizilerinde saklanÄ±r. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan uygulanÄ±r. Ses dosyasÄ± yeni haliyle kaydedilir.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

import numpy as np

class AudioEditor:
    def __init__(self):
        self.audio_samples = {}  # Stores audio samples in memory arrays (using NumPy arrays)

    def load_audio_file(self, audio_id: str, samples: np.ndarray):
        self.audio_samples[audio_id] = samples
        print(f"Audio file '{audio_id}' loaded with {len(samples)} samples.")

    def apply_volume_change(self, audio_id: str, multiplier: float):
        if audio_id in self.audio_samples:
            samples = self.audio_samples[audio_id]
            samples *= multiplier  # User edits applied by the system
            print(f"Volume changed for audio '{audio_id}' by multiplier {multiplier}.")
            self._save_audio_file(audio_id)  # Audio file saved with new state
        else:
            print(f"Audio '{audio_id}' not found.")

    def trim_audio(self, audio_id: str, start_sample: int, end_sample: int):
        if audio_id in self.audio_samples:
            original_samples = self.audio_samples[audio_id]
            if 0 <= start_sample < len(original_samples) and 0 <= end_sample < len(original_samples) and start_sample < end_sample:
                trimmed_samples = original_samples[start_sample : end_sample + 1]
                self.audio_samples[audio_id] = trimmed_samples  # User edits applied by the system
                print(f"Audio '{audio_id}' trimmed from sample {start_sample} to {end_sample}.")
                self._save_audio_file(audio_id)  # Audio file saved with new state
            else:
                print(f"Invalid trim range for audio '{audio_id}'.")
        else:
            print(f"Audio '{audio_id}' not found.")

    def _save_audio_file(self, audio_id: str):
        # In a real application, this would write the audio data to a file (e.g., WAV, MP3).
        # For this simulation, we just print a message.
        print(f"Audio file '{audio_id}' saved to storage (simulated).")
        # Example of writing to a dummy file:
        # with open(f"{audio_id}.wav", "wb") as f:
        #     f.write(b'\x00' * 100) # Dummy write

    def get_audio_samples(self, audio_id: str) -> np.ndarray | None:
        return self.audio_samples.get(audio_id)

# Example usage (not part of the required code)
# if __name__ == "__main__":
#     editor = AudioEditor()
#     # Generate dummy audio samples
#     samples = np.sin(np.linspace(0, 2 * np.pi * 100, 44100)).astype(np.float32)
#     editor.load_audio_file("my_track", samples)
#     editor.apply_volume_change("my_track", 0.7)
#     editor.trim_audio("my_track", 1000, 5000)
ğŸ§ª Senaryo 3: Bir ses dÃ¼zenleme programÄ±nda kullanÄ±cÄ±lar audio verilerini iÅŸler. Ses Ã¶rnekleri bellek dizilerinde saklanÄ±r. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan uygulanÄ±r. Ses dosyasÄ± yeni haliyle kaydedilir.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

TypeScript

import * as fs from 'fs'; // For simulated file saving

class AudioEditor {
    private audioSamples: Map<string, Float32Array> = new Map(); // Stores audio samples in memory arrays

    public loadAudioFile(audioId: string, samples: Float32Array): void {
        this.audioSamples.set(audioId, samples);
        console.log(`Audio file '${audioId}' loaded with ${samples.length} samples.`);
    }

    public applyVolumeChange(audioId: string, multiplier: number): void {
        const samples = this.audioSamples.get(audioId);
        if (samples) {
            for (let i = 0; i < samples.length; i++) {
                samples[i] *= multiplier; // User edits applied by the system
            }
            console.log(`Volume changed for audio '${audioId}' by multiplier ${multiplier}.`);
            this.saveAudioFile(audioId); // Audio file saved with new state
        } else {
            console.log(`Audio '${audioId}' not found.`);
        }
    }

    public trimAudio(audioId: string, startSample: number, endSample: number): void {
        const originalSamples = this.audioSamples.get(audioId);
        if (originalSamples) {
            if (startSample >= 0 && endSample < originalSamples.length && startSample < endSample) {
                const trimmedSamples = originalSamples.slice(startSample, endSample + 1);
                this.audioSamples.set(audioId, trimmedSamples); // User edits applied by the system
                console.log(`Audio '${audioId}' trimmed from sample ${startSample} to ${endSample}.`);
                this.saveAudioFile(audioId); // Audio file saved with new state
            } else {
                console.log(`Invalid trim range for audio '${audioId}'.`);
            }
        } else {
            console.log(`Audio '${audioId}' not found.`);
        }
    }

    private saveAudioFile(audioId: string): void {
        // In a real application, this would write the audio data to a file (e.g., WAV, MP3).
        // For this simulation, we just print a message and simulate a file write.
        console.log(`Audio file '${audioId}' saved to storage (simulated).`);
        const dummyFilePath = `${audioId}.dat`;
        fs.writeFileSync(dummyFilePath, Buffer.from(this.audioSamples.get(audioId)?.buffer || new ArrayBuffer(0)));
        console.log(`Dummy file '${dummyFilePath}' created.`);
    }

    public getAudioSamples(audioId: string): Float32Array | undefined {
        return this.audioSamples.get(audioId);
    }
}

// Example usage (not part of the required code)
// const editor = new AudioEditor();
// // Generate dummy audio samples (e.g., 44100 samples for 1 second at 44.1kHz)
// const samples = new Float32Array(44100);
// for (let i = 0; i < samples.length; i++) {
//     samples[i] = Math.sin(i * 0.1); // Simple sine wave
// }
// editor.loadAudioFile("mySong", samples);
// editor.applyVolumeChange("mySong", 0.8);
// editor.trimAudio("mySong", 5000, 10000);
ğŸ§ª Senaryo 4: Bir veri iÅŸleme uygulamasÄ±nda kullanÄ±cÄ±lar bÃ¼yÃ¼k veri setlerini yÃ¶netir. Veriler bellek yapÄ±larÄ±nda organize edilir. KullanÄ±cÄ± iÅŸlemleri sistem tarafÄ±ndan gerÃ§ekleÅŸtirilir. Ä°ÅŸlenmiÅŸ veriler kullanÄ±cÄ±ya sunulur.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

using System;
using System.Collections.Generic;
using System.Linq;

public class DataProcessingApp
{
    // Represents large datasets organized in memory structures (e.g., List of Dictionaries)
    private Dictionary<string, List<Dictionary<string, object>>> datasets = new Dictionary<string, List<Dictionary<string, object>>>();

    public void LoadDataset(string datasetId, List<Dictionary<string, object>> data)
    {
        datasets[datasetId] = data;
        Console.WriteLine(<span class="math-inline">"Dataset '\{datasetId\}' loaded with \{data\.Count\} records\."\);
\}
public List<Dictionary<string, object\>\> FilterData\(string datasetId, string key, object value\)
\{
if \(datasets\.ContainsKey\(datasetId\)\)
\{
// User operations performed by the system
var filteredData \= datasets\[datasetId\]
\.Where\(record \=\> record\.ContainsKey\(key\) && record\[key\]\.Equals\(value\)\)
\.ToList\(\);
Console\.WriteLine\(</span>"Filtered dataset '{datasetId}' for '{key}' = '{value}'. Found {filteredData.Count} records.");
            return filteredData; // Processed data presented to the user
        }
        else
        {
            Console.WriteLine(<span class="math-inline">"Dataset '\{datasetId\}' not found\."\);
return new List<Dictionary<string, object\>\>\(\);
\}
\}
public void AddRecord\(string datasetId, Dictionary<string, object\> newRecord\)
\{
if \(datasets\.ContainsKey\(datasetId\)\)
\{
datasets\[datasetId\]\.Add\(newRecord\); // User operations performed by the system
Console\.WriteLine\(</span>"Record added to dataset '{datasetId}'. Total records: {datasets[datasetId].Count}");
        }
        else
        {
            Console.WriteLine(<span class="math-inline">"Dataset '\{datasetId\}' not found\."\);
\}
\}
public List<Dictionary<string, object\>\> GetAllData\(string datasetId\)
\{
return datasets\.GetValueOrDefault\(datasetId\);
\}
\}
// Example usage \(not part of the required code\)
// public class Program
// \{
//     public static void Main\(string\[\] args\)
//     \{
//         DataProcessingApp app \= new DataProcessingApp\(\);
//         var salesData \= new List<Dictionary<string, object\>\>
//         \{
//             new Dictionary<string, object\> \{ \{ "Product", "Laptop" \}, \{ "Price", 1200 \}, \{ "Quantity", 5 \} \},
//             new Dictionary<string, object\> \{ \{ "Product", "Mouse" \}, \{ "Price", 25 \}, \{ "Quantity", 50 \} \},
//             new Dictionary<string, object\> \{ \{ "Product", "Keyboard" \}, \{ "Price", 75 \}, \{ "Quantity", 20 \} \},
//             new Dictionary<string, object\> \{ \{ "Product", "Laptop" \}, \{ "Price", 1500 \}, \{ "Quantity", 3 \} \}
//         \};
//         app\.LoadDataset\("sales", salesData\);
//         var laptops \= app\.FilterData\("sales", "Product", "Laptop"\);
//         foreach \(var item in laptops\)
//         \{
//             Console\.WriteLine\(</span>"  Product: {item["Product"]}, Price: {item["Price"]}");
//         }
//         app.AddRecord("sales", new Dictionary<string, object> { { "Product", "Monitor" }, { "Price", 300 }, { "Quantity", 10 } });
//     }
// }
ğŸ§ª Senaryo 4: Bir veri iÅŸleme uygulamasÄ±nda kullanÄ±cÄ±lar bÃ¼yÃ¼k veri setlerini yÃ¶netir. Veriler bellek yapÄ±larÄ±nda organize edilir. KullanÄ±cÄ± iÅŸlemleri sistem tarafÄ±ndan gerÃ§ekleÅŸtirilir. Ä°ÅŸlenmiÅŸ veriler kullanÄ±cÄ±ya sunulur.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class DataProcessingApp:
    def __init__(self):
        self.datasets = {}  # Stores large datasets organized in memory structures (e.g., dictionary of lists of dictionaries)

    def load_dataset(self, dataset_id: str, data: list[dict]):
        self.datasets[dataset_id] = data
        print(f"Dataset '{dataset_id}' loaded with {len(data)} records.")

    def filter_data(self, dataset_id: str, key: str, value: any) -> list[dict]:
        if dataset_id in self.datasets:
            # User operations performed by the system
            filtered_data = [record for record in self.datasets[dataset_id] if record.get(key) == value]
            print(f"Filtered dataset '{dataset_id}' for '{key}' = '{value}'. Found {len(filtered_data)} records.")
            return filtered_data  # Processed data presented to the user
        else:
            print(f"Dataset '{dataset_id}' not found.")
            return []

    def add_record(self, dataset_id: str, new_record: dict):
        if dataset_id in self.datasets:
            self.datasets[dataset_id].append(new_record)  # User operations performed by the system
            print(f"Record added to dataset '{dataset_id}'. Total records: {len(self.datasets[dataset_id])}")
        else:
            print(f"Dataset '{dataset_id}' not found.")

    def get_all_data(self, dataset_id: str) -> list[dict] | None:
        return self.datasets.get(dataset_id)

# Example usage (not part of the required code)
# if __name__ == "__main__":
#     app = DataProcessingApp()
#     customer_data = [
#         {"id": 1, "name": "Alice", "city": "New York"},
#         {"id": 2, "name": "Bob", "city": "London"},
#         {"id": 3, "name": "Charlie", "city": "New York"}
#     ]
#     app.load_dataset("customers", customer_data)
#     ny_customers = app.filter_data("customers", "city", "New York")
#     print("New York Customers:")
#     for customer in ny_customers:
#         print(f"  {customer['name']}")
#     app.add_record("customers", {"id": 4, "name": "David", "city": "Paris"})
ğŸ§ª Senaryo 4: Bir veri iÅŸleme uygulamasÄ±nda kullanÄ±cÄ±lar bÃ¼yÃ¼k veri setlerini yÃ¶netir. Veriler bellek yapÄ±larÄ±nda organize edilir. KullanÄ±cÄ± iÅŸlemleri sistem tarafÄ±ndan gerÃ§ekleÅŸtirilir. Ä°ÅŸlenmiÅŸ veriler kullanÄ±cÄ±ya sunulur.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

TypeScript

interface DataRecord {
    [key: string]: any;
}

class DataProcessingApp {
    private datasets: Map<string, DataRecord[]> = new Map(); // Stores large datasets organized in memory structures

    public loadDataset(datasetId: string, data: DataRecord[]): void {
        this.datasets.set(datasetId, data);
        console.log(`Dataset '${datasetId}' loaded with ${data.length} records.`);
    }

    public filterData(datasetId: string, key: string, value: any): DataRecord[] {
        const data = this.datasets.get(datasetId);
        if (data) {
            // User operations performed by the system
            const filteredData = data.filter(record => record[key] === value);
            console.log(`Filtered dataset '${datasetId}' for '${key}' = '${value}'. Found ${filteredData.length} records.`);
            return filteredData; // Processed data presented to the user
        } else {
            console.log(`Dataset '${datasetId}' not found.`);
            return [];
        }
    }

    public addRecord(datasetId: string, newRecord: DataRecord): void {
        const data = this.datasets.get(datasetId);
        if (data) {
            data.push(newRecord); // User operations performed by the system
            console.log(`Record added to dataset '${datasetId}'. Total records: ${data.length}`);
        } else {
            console.log(`Dataset '${datasetId}' not found.`);
        }
    }

    public getAllData(datasetId: string): DataRecord[] | undefined {
        return this.datasets.get(datasetId);
    }
}

// Example usage (not part of the required code)
// const app = new DataProcessingApp();
// const productInventory = [
//     { id: 101, name: "Widget A", stock: 150, category: "Electronics" },
//     { id: 102, name: "Gadget B", stock: 75, category: "Office" },
//     { id: 103, name: "Widget C", stock: 200, category: "Electronics" },
// ];
// app.loadDataset("inventory", productInventory);
// const electronics = app.filterData("inventory", "category", "Electronics");
// console.log("Electronics Products:");
// electronics.forEach(item => console.log(`  ${item.name}`));
// app.addRecord("inventory", { id: 104, name: "Tool D", stock: 50, category: "Hardware" });
ğŸ§ª Senaryo 5: Bir oyun uygulamasÄ±nda kullanÄ±cÄ±lar oyun dÃ¼nyasÄ±nÄ± deÄŸiÅŸtirir. Oyun verileri bellek alanlarÄ±nda tutulur. KullanÄ±cÄ± eylemleri sistem tarafÄ±ndan uygulanÄ±r. Oyun durumu sÃ¼rekli gÃ¼ncellenir.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

using System;
using System.Collections.Generic;

public class GameApp
{
    // Represents game data held in memory areas (e.g., player position, item inventory, world state)
    private Dictionary<string, object> gameData = new Dictionary<string, object>(); 

    public void InitializeGame(string gameId)
    {
        gameData[gameId] = new
        {
            PlayerX = 0,
            PlayerY = 0,
            Inventory = new List<string> { "Sword", "Shield" },
            Score = 0,
            WorldState = "Normal"
        };
        Console.WriteLine(<span class="math-inline">"Game '\{gameId\}' initialized\."\);
UpdateGameState\(gameId\); // Game state continuously updated
\}
public void MovePlayer\(string gameId, int deltaX, int deltaY\)
\{
if \(gameData\.ContainsKey\(gameId\)\)
\{
dynamic currentData \= gameData\[gameId\];
currentData\.PlayerX \+\= deltaX; // User actions applied by the system
currentData\.PlayerY \+\= deltaY; // User actions applied by the system
Console\.WriteLine\(</span>"Player in '{gameId}' moved to ({currentData.PlayerX}, {currentData.PlayerY}).");
            UpdateGameState(gameId); // Game state continuously updated
        }
        else
        {
            Console.WriteLine(<span class="math-inline">"Game '\{gameId\}' not found\."\);
\}
\}
public void CollectItem\(string gameId, string item\)
\{
if \(gameData\.ContainsKey\(gameId\)\)
\{
dynamic currentData \= gameData\[gameId\];
currentData\.Inventory\.Add\(item\); // User actions applied by the system
Console\.WriteLine\(</span>"Player in '{gameId}' collected '{item}'. Inventory: {string.Join(", ", currentData.Inventory)}");
            UpdateGameState(gameId); // Game state continuously updated
        }
        else
        {
            Console.WriteLine(<span class="math-inline">"Game '\{gameId\}' not found\."\);
\}
\}
private void UpdateGameState\(string gameId\)
\{
// In a real game, this would involve rendering, AI updates, physics, etc\.
// For this simulation, we just print a message\.
Console\.WriteLine\(</span>"Game state for '{gameId}' updated (simulated game loop).");
    }

    public object GetGameState(string gameId)
    {
        return gameData.GetValueOrDefault(gameId);
    }
}

// Example usage (not part of the required code)
// public class Program
// {
//     public static void Main(string[] args)
//     {
//         GameApp game = new GameApp();
//         game.InitializeGame("adventure_game");
//         game.MovePlayer("adventure_game", 10, 5);
//         game.CollectItem("adventure_game", "Magic Potion");
//     }
// }
ğŸ§ª Senaryo 5: Bir oyun uygulamasÄ±nda kullanÄ±cÄ±lar oyun dÃ¼nyasÄ±nÄ± deÄŸiÅŸtirir. Oyun verileri bellek alanlarÄ±nda tutulur. KullanÄ±cÄ± eylemleri sistem tarafÄ±ndan uygulanÄ±r. Oyun durumu sÃ¼rekli gÃ¼ncellenir.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class GameApp:
    def __init__(self):
        # Represents game data held in memory areas (e.g., player position, item inventory, world state)
        self.game_data = {}

    def initialize_game(self, game_id: str):
        self.game_data[game_id] = {
            "player_x": 0,
            "player_y": 0,
            "inventory": ["Sword", "Shield"],
            "score": 0,
            "world_state": "Normal"
        }
        print(f"Game '{game_id}' initialized.")
        self._update_game_state(game_id)  # Game state continuously updated

    def move_player(self, game_id: str, delta_x: int, delta_y: int):
        if game_id in self.game_data:
            current_data = self.game_data[game_id]
            current_data["player_x"] += delta_x  # User actions applied by the system
            current_data["player_y"] += delta_y  # User actions applied by the system
            print(f"Player in '{game_id}' moved to ({current_data['player_x']}, {current_data['player_y']}).")
            self._update_game_state(game_id)  # Game state continuously updated
        else:
            print(f"Game '{game_id}' not found.")

    def collect_item(self, game_id: str, item: str):
        if game_id in self.game_data:
            current_data = self.game_data[game_id]
            current_data["inventory"].append(item)  # User actions applied by the system
            print(f"Player in '{game_id}' collected '{item}'. Inventory: {', '.join(current_data['inventory'])}")
            self._update_game_state(game_id)  # Game state continuously updated
        else:
            print(f"Game '{game_id}' not found.")

    def _update_game_state(self, game_id: str):
        # In a real game, this would involve rendering, AI updates, physics, etc.
        # For this simulation, we just print a message.
        print(f"Game state for '{game_id}' updated (simulated game loop).")

    def get_game_state(self, game_id: str) -> dict | None:
        return self.game_data.get(game_id)

# Example usage (not part of the required code)
# if __name__ == "__main__":
#     game = GameApp()
#     game.initialize_game("rpg_adventure")
#     game.move_player("rpg_adventure", 5, -2)
#     game.collect_item("rpg_adventure", "Gold Coin")
ğŸ§ª Senaryo 5: Bir oyun uygulamasÄ±nda kullanÄ±cÄ±lar oyun dÃ¼nyasÄ±nÄ± deÄŸiÅŸtirir. Oyun verileri bellek alanlarÄ±nda tutulur. KullanÄ±cÄ± eylemleri sistem tarafÄ±ndan uygulanÄ±r. Oyun durumu sÃ¼rekli gÃ¼ncellenir.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

TypeScript

interface GameState {
    playerX: number;
    playerY: number;
    inventory: string[];
    score: number;
    worldState: string;
}

class GameApp {
    // Represents game data held in memory areas
    private gameData: Map<string, GameState> = new Map();

    public initializeGame(gameId: string): void {
        this.gameData.set(gameId, {
            playerX: 0,
            playerY: 0,
            inventory: ["Sword", "Shield"],
            score: 0,
            worldState: "Normal",
        });
        console.log(`Game '${gameId}' initialized.`);
        this.updateGameState(gameId); // Game state continuously updated
    }

    public movePlayer(gameId: string, deltaX: number, deltaY: number): void {
        const currentState = this.gameData.get(gameId);
        if (currentState) {
            currentState.playerX += deltaX; // User actions applied by the system
            currentState.playerY += deltaY; // User actions applied by the system
            this.gameData.set(gameId, currentState); // Update state in map
            console.log(`Player in '${gameId}' moved to (${currentState.playerX}, ${currentState.playerY}).`);
            this.updateGameState(gameId); // Game state continuously updated
        } else {
            console.log(`Game '${gameId}' not found.`);
        }
    }

    public collectItem(gameId: string, item: string): void {
        const currentState = this.gameData.get(gameId);
        if (currentState) {
            currentState.inventory.push(item); // User actions applied by the system
            this.gameData.set(gameId, currentState); // Update state in map
            console.log(`Player in '${gameId}' collected '${item}'. Inventory: ${currentState.inventory.join(", ")}`);
            this.updateGameState(gameId); // Game state continuously updated
        } else {
            console.log(`Game '${gameId}' not found.`);
        }
    }

    private updateGameState(gameId: string): void {
        // In a real game, this would involve rendering, AI updates, physics, etc.
        // For this simulation, we just print a message.
        console.log(`Game state for '${gameId}' updated (simulated game loop).`);
    }

    public getGameState(gameId: string): GameState | undefined {
        return this.gameData.get(gameId);
    }
}

// Example usage (not part of the required code)
// const game = new GameApp();
// game.initializeGame("myFantasticGame");
// game.movePlayer("myFantasticGame", 3, 7);
// game.collectItem("myFantasticGame", "Orb of Power");
ğŸ§ª Senaryo 6: Bir dosya iÅŸleme uygulamasÄ±nda kullanÄ±cÄ±lar dosya iÃ§eriklerini dÃ¼zenler. Dosya verileri bellek buffer'larÄ±nda saklanÄ±r. KullanÄ±cÄ± deÄŸiÅŸiklikleri sistem tarafÄ±ndan iÅŸlenir. Dosya yeni haliyle kaydedilir.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

public class FileProcessingApp
{
    // Represents file data stored in memory buffers
    private Dictionary<string, byte[]> fileBuffers = new Dictionary<string, byte[]>();

    public void LoadFileIntoBuffer(string filePath, string fileId)
    {
        try
        {
            byte[] fileContent = File.ReadAllBytes(filePath);
            fileBuffers[fileId] = fileContent; // File data stored in memory buffers
            Console.WriteLine(<span class="math-inline">"File '\{filePath\}' loaded into buffer '\{fileId\}'\. Size\: \{fileContent\.Length\} bytes\."\);
\}
catch \(FileNotFoundException\)
\{
Console\.WriteLine\(</span>"Error: File '{filePath}' not found.");
        }
        catch (Exception ex)
        {
            Console.WriteLine(<span class="math-inline">"Error loading file '\{filePath\}'\: \{ex\.Message\}"\);
\}
\}
public void EditTextContent\(string fileId, int startIndex, int length, string newText\)
\{
if \(fileBuffers\.ContainsKey\(fileId\)\)
\{
byte\[\] originalContent \= fileBuffers\[fileId\];
string originalString \= Encoding\.UTF8\.GetString\(originalContent\);
if \(startIndex \>\= 0 && startIndex \+ length <\= originalString\.Length\)
\{
string newString \= originalString\.Remove\(startIndex, length\)\.Insert\(startIndex, newText\);
fileBuffers\[fileId\] \= Encoding\.UTF8\.GetBytes\(newString\); // User changes processed by the system
Console\.WriteLine\(</span>"Content in buffer '{fileId}' modified at index {startIndex}.");
                SaveFile(fileId, "output_" + fileId + ".txt"); // File saved with new state
            }
            else
            {
                Console.WriteLine(<span class="math-inline">"Invalid range for editing in buffer '\{fileId\}'\."\);
\}
\}
else
\{
Console\.WriteLine\(</span>"Buffer '{fileId}' not found.");
        }
    }

    public void SaveFile(string fileId, string outputPath)
    {
        if (fileBuffers.ContainsKey(fileId))
        {
            try
            {
                File.WriteAllBytes(outputPath, fileBuffers[fileId]); // File saved with new state
                Console.WriteLine(<span class="math-inline">"Buffer '\{fileId\}' saved to '\{outputPath\}'\."\);
\}
catch \(Exception ex\)
\{
Console\.WriteLine\(</span>"Error saving buffer '{fileId}' to '{outputPath}': {ex.Message}");
            }
        }
        else
        {
            Console.WriteLine($"Buffer '{fileId}' not found for saving.");
        }
    }

    public byte[] GetFileBuffer(string fileId)
    {
        return fileBuffers.GetValueOrDefault(fileId);
    }
}

// Example usage (not part of the required code)
// public class Program
// {
//     public static void Main(string[] args)
//     {
//         FileProcessingApp app = new FileProcessingApp();
//         // Create a dummy file for testing
//         File.WriteAllText("testfile.txt", "This is some original text content.");
//         app.LoadFileIntoBuffer("testfile.txt", "doc_buffer");
//         app.EditTextContent("doc_buffer", 8, 8, "modified"); // Changes "original" to "modified"
//     }
// }
ğŸ§ª Senaryo 6: Bir dosya iÅŸleme uygulamasÄ±nda kullanÄ±cÄ±lar dosya iÃ§eriklerini dÃ¼zenler. Dosya verileri bellek buffer'larÄ±nda saklanÄ±r. KullanÄ±cÄ± deÄŸiÅŸiklikleri sistem tarafÄ±ndan iÅŸlenir. Dosya yeni haliyle kaydedilir.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

import os

class FileProcessingApp:
    def __init__(self):
        # Represents file data stored in memory buffers (using bytes for binary data)
        self.file_buffers = {}

    def load_file_into_buffer(self, file_path: str, file_id: str):
        try:
            with open(file_path, 'rb') as f:
                file_content = f.read()
            self.file_buffers[file_id] = file_content  # File data stored in memory buffers
            print(f"File '{file_path}' loaded into buffer '{file_id}'. Size: {len(file_content)} bytes.")
        except FileNotFoundError:
            print(f"Error: File '{file_path}' not found.")
        except Exception as ex:
            print(f"Error loading file '{file_path}': {ex}")

    def edit_text_content(self, file_id: str, start_index: int, length: int, new_text: str):
        if file_id in self.file_buffers:
            original_content_bytes = self.file_buffers[file_id]
            original_string = original_content_bytes.decode('utf-8')

            if 0 <= start_index <= len(original_string) and start_index + length <= len(original_string):
                new_string = original_string[:start_index] + new_text + original_string[start_index + length:]
                self.file_buffers[file_id] = new_string.encode('utf-8')  # User changes processed by the system
                print(f"Content in buffer '{file_id}' modified at index {start_index}.")
                self.save_file(file_id, f"output_{file_id}.txt")  # File saved with new state
            else:
                print(f"Invalid range for editing in buffer '{file_id}'.")
        else:
            print(f"Buffer '{file_id}' not found.")

    def save_file(self, file_id: str, output_path: str):
        if file_id in self.file_buffers:
            try:
                with open(output_path, 'wb') as f:
                    f.write(self.file_buffers[file_id])  # File saved with new state
                print(f"Buffer '{file_id}' saved to '{output_path}'.")
            except Exception as ex:
                print(f"Error saving buffer '{file_id}' to '{output_path}': {ex}")
        else:
            print(f"Buffer '{file_id}' not found for saving.")

    def get_file_buffer(self, file_id: str) -> bytes | None:
        return self.file_buffers.get(file_id)

# Example usage (not part of the required code)
# if __name__ == "__main__":
#     app = FileProcessingApp()
#     # Create a dummy file for testing
#     with open("sample.txt", "w") as f:
#         f.write("Hello, this is a test file.")
#     app.load_file_into_buffer("sample.txt", "my_document")
#     app.edit_text_content("my_document", 7, 4, "WORLD") # Change "this" to "WORLD"
ğŸ§ª Senaryo 6: Bir dosya iÅŸleme uygulamasÄ±nda kullanÄ±cÄ±lar dosya iÃ§eriklerini dÃ¼zenler. Dosya verileri bellek buffer'larÄ±nda saklanÄ±r. KullanÄ±cÄ± deÄŸiÅŸiklikleri sistem tarafÄ±ndan iÅŸlenir. Dosya yeni haliyle kaydedilir.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

TypeScript

import * as fs from 'fs';

class FileProcessingApp {
    // Represents file data stored in memory buffers (using Buffer for binary data)
    private fileBuffers: Map<string, Buffer> = new Map();

    public loadFileIntoBuffer(filePath: string, fileId: string): void {
        try {
            const fileContent = fs.readFileSync(filePath);
            this.fileBuffers.set(fileId, fileContent); // File data stored in memory buffers
            console.log(`File '${filePath}' loaded into buffer '${fileId}'. Size: ${fileContent.length} bytes.`);
        } catch (error: any) {
            if (error.code === 'ENOENT') {
                console.log(`Error: File '${filePath}' not found.`);
            } else {
                console.log(`Error loading file '${filePath}': ${error.message}`);
            }
        }
    }

    public async editContentAndSave(fileId: string, startIndex: number, length: number, newText: string, outputPath: string): Promise<void> {
        const originalBuffer = this.fileBuffers.get(fileId);
        if (originalBuffer) {
            const originalString = originalBuffer.toString('utf8');

            if (startIndex >= 0 && startIndex + length <= originalString.length) {
                const newString = originalString.substring(0, startIndex) + newText + originalString.substring(startIndex + length);
                this.fileBuffers.set(fileId, Buffer.from(newString, 'utf8')); // User changes processed by the system
                console.log(`Content in buffer '${fileId}' modified at index ${startIndex}.`);
                await this.saveFile(fileId, outputPath); // File saved with new state
            } else {
                console.log(`Invalid range for editing in buffer '${fileId}'.`);
            }
        } else {
            console.log(`Buffer '${fileId}' not found.`);
        }
    }

    private async saveFile(fileId: string, outputPath: string): Promise<void> {
        const bufferToSave = this.fileBuffers.get(fileId);
        if (bufferToSave) {
            try {
                await fs.promises.writeFile(outputPath, bufferToSave); // File saved with new state
                console.log(`Buffer '${fileId}' saved to '${outputPath}'.`);
            } catch (error: any) {
                console.log(`Error saving buffer '${fileId}' to '${outputPath}': ${error.message}`);
            }
        } else {
            console.log(`Buffer '${fileId}' not found for saving.`);
        }
    }

    public getFileBuffer(fileId: string): Buffer | undefined {
        return this.fileBuffers.get(fileId);
    }
}

// Example usage (not part of the required code)
// async function runScenario6() {
//     const app = new FileProcessingApp();
//     // Create a dummy file for testing
//     fs.writeFileSync("document.txt", "The quick brown fox jumps over the lazy dog.");
//     app.loadFileIntoBuffer("document.txt", "myDoc");
//     await app.editContentAndSave("myDoc", 4, 5, "SLOTH", "modified_document.txt"); // Change "quick" to "SLOTH"
// }
// runScenario6();
ğŸ§ª Senaryo 7: Bir spreadsheet uygulamasÄ±nda kullanÄ±cÄ±lar hÃ¼cre verilerini girer. Tablo verileri bellek matrislerinde tutulur. KullanÄ±cÄ± giriÅŸleri sistem tarafÄ±ndan kaydedilir. Hesaplamalar otomatik olarak yapÄ±lÄ±r.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

using System;
using System.Collections.Generic;

public class SpreadsheetApp
{
    // Represents table data held in memory matrices (2D array for simplicity)
    private Dictionary<string, string[,]> spreadsheets = new Dictionary<string, string[,]>();

    public void CreateSpreadsheet(string sheetId, int rows, int cols)
    {
        spreadsheets[sheetId] = new string[rows, cols];
        Console.WriteLine(<span class="math-inline">"Spreadsheet '\{sheetId\}' created with \{rows\} rows and \{cols\} columns\."\);
\}
public void EnterCellData\(string sheetId, int row, int col, string value\)
\{
if \(spreadsheets\.ContainsKey\(sheetId\)\)
\{
string\[,\] sheet \= spreadsheets\[sheetId\];
if \(row \>\= 0 && row < sheet\.GetLength\(0\) && col \>\= 0 && col < sheet\.GetLength\(1\)\)
\{
sheet\[row, col\] \= value; // User inputs recorded by the system
Console\.WriteLine\(</span>"Data '{value}' entered into cell ({row},{col}) in spreadsheet '{sheetId}'.");
                PerformCalculations(sheetId); // Calculations are performed automatically
            }
            else
            {
                Console.WriteLine(<span class="math-inline">"Cell \(\{row\},\{col\}\) is out of bounds for spreadsheet '\{sheetId\}'\."\);
\}
\}
else
\{
Console\.WriteLine\(</span>"Spreadsheet '{sheetId}' not found.");
        }
    }

    private void PerformCalculations(string sheetId)
    {
        // In a real spreadsheet, this would parse formulas and update dependent cells.
        // For this simulation, we'll just sum a specific column if it contains numbers.
        string[,] sheet = spreadsheets[sheetId];
        if (sheet != null && sheet.GetLength(0) > 0 && sheet.GetLength(1) > 0)
        {
            double sum = 0;
            bool calculated = false;
            // Example: Sum values in the first column (col 0)
            for (int r = 0; r < sheet.GetLength(0); r++)
            {
                if (double.TryParse(sheet[r, 0], out double cellValue))
                {
                    sum += cellValue;
                    calculated = true;
                }
            }
            if (calculated)
            {
                // Put sum in a specific cell (e.g., last row, first col)
                // Note: This simple example overwrites. A real spreadsheet would have designated output cells.
                // sheet[sheet.GetLength(0) - 1, 0] = sum.ToString(); 
                Console.WriteLine(<span class="math-inline">"Calculations performed for '\{sheetId\}'\. \(Simulated\: Sum of first column\: \{sum\}\)"\);
\}
else
\{
Console\.WriteLine\(</span>"No numeric data for calculation in '{sheetId}'.");
            }
        }
    }

    public string[,] GetSpreadsheetData(string sheetId)
    {
        return spreadsheets.GetValueOrDefault(sheetId);
    }
}

// Example usage (not part of the required code)
// public class Program
// {
//     public static void Main(string[] args)
//     {
//         SpreadsheetApp app = new SpreadsheetApp();
//         app.CreateSpreadsheet("budget_2025", 5, 3);
//         app.EnterCellData("budget_2025", 0, 0, "100");
//         app.EnterCellData("budget_2025", 1, 0, "250");
//         app.EnterCellData("budget_2025", 2, 0, "50");
//         app.EnterCellData("budget_2025", 0, 1, "Rent");
//     }
// }
ğŸ§ª Senaryo 7: Bir spreadsheet uygulamasÄ±nda kullanÄ±cÄ±lar hÃ¼cre verilerini girer. Tablo verileri bellek matrislerinde tutulur. KullanÄ±cÄ± giriÅŸleri sistem tarafÄ±ndan kaydedilir. Hesaplamalar otomatik olarak yapÄ±lÄ±r.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

class SpreadsheetApp:
    def __init__(self):
        # Represents table data held in memory matrices (list of lists for simplicity)
        self.spreadsheets = {}

    def create_spreadsheet(self, sheet_id: str, rows: int, cols: int):
        self.spreadsheets[sheet_id] = [['' for _ in range(cols)] for _ in range(rows)]
        print(f"Spreadsheet '{sheet_id}' created with {rows} rows and {cols} columns.")

    def enter_cell_data(self, sheet_id: str, row: int, col: int, value: str):
        if sheet_id in self.spreadsheets:
            sheet = self.spreadsheets[sheet_id]
            if 0 <= row < len(sheet) and 0 <= col < len(sheet[0]):
                sheet[row][col] = value  # User inputs recorded by the system
                print(f"Data '{value}' entered into cell ({row},{col}) in spreadsheet '{sheet_id}'.")
                self._perform_calculations(sheet_id)  # Calculations are performed automatically
            else:
                print(f"Cell ({row},{col}) is out of bounds for spreadsheet '{sheet_id}'.")
        else:
            print(f"Spreadsheet '{sheet_id}' not found.")

    def _perform_calculations(self, sheet_id: str):
        # In a real spreadsheet, this would parse formulas and update dependent cells.
        # For this simulation, we'll just sum a specific column if it contains numbers.
        sheet = self.spreadsheets.get(sheet_id)
        if sheet and sheet: # Ensure sheet and its first row exist
            total_sum = 0
            calculated = False
            # Example: Sum values in the first column (col 0)
            for r in range(len(sheet)):
                try:
                    cell_value = float(sheet[r][0])
                    total_sum += cell_value
                    calculated = True
                except (ValueError, IndexError):
                    continue # Skip if not a number or column doesn't exist

            if calculated:
                print(f"Calculations performed for '{sheet_id}'. (Simulated: Sum of first column: {total_sum})")
            else:
                print(f"No numeric data for calculation in '{sheet_id}'.")

    def get_spreadsheet_data(self, sheet_id: str) -> list[list[str]] | None:
        return self.spreadsheets.get(sheet_id)

# Example usage (not part of the required code)
# if __name__ == "__main__":
#     app = SpreadsheetApp()
#     app.create_spreadsheet("quarterly_report", 4, 2)
#     app.enter_cell_data("quarterly_report", 0, 0, "Revenue")
#     app.enter_cell_data("quarterly_report", 1, 0, "1500")
#     app.enter_cell_data("quarterly_report", 2, 0, "2000")
#     app.enter_cell_data("quarterly_report", 3, 0, "750")
#     app.enter_cell_data("quarterly_report", 0, 1, "Expenses")
ğŸ§ª Senaryo 7: Bir spreadsheet uygulamasÄ±nda kullanÄ±cÄ±lar hÃ¼cre verilerini girer. Tablo verileri bellek matrislerinde tutulur. KullanÄ±cÄ± giriÅŸleri sistem tarafÄ±ndan kaydedilir. Hesaplamalar otomatik olarak yapÄ±lÄ±r.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

TypeScript

type SheetMatrix = string[][];

class SpreadsheetApp {
    // Represents table data held in memory matrices (Map of 2D arrays)
    private spreadsheets: Map<string, SheetMatrix> = new Map();

    public createSpreadsheet(sheetId: string, rows: number, cols: number): void {
        const newSheet: SheetMatrix = Array(rows).fill(0).map(() => Array(cols).fill(''));
        this.spreadsheets.set(sheetId, newSheet);
        console.log(`Spreadsheet '${sheetId}' created with ${rows} rows and ${cols} columns.`);
    }

    public enterCellData(sheetId: string, row: number, col: number, value: string): void {
        const sheet = this.spreadsheets.get(sheetId);
        if (sheet) {
            if (row >= 0 && row < sheet.length && col >= 0 && col < sheet[0].length) {
                sheet[row][col] = value; // User inputs recorded by the system
                console.log(`Data '${value}' entered into cell (${row},${col}) in spreadsheet '${sheetId}'.`);
                this.performCalculations(sheetId); // Calculations are performed automatically
            } else {
                console.log(`Cell (${row},${col}) is out of bounds for spreadsheet '${sheetId}'.`);
            }
        } else {
            console.log(`Spreadsheet '${sheetId}' not found.`);
        }
    }

    private performCalculations(sheetId: string): void {
        // In a real spreadsheet, this would parse formulas and update dependent cells.
        // For this simulation, we'll just sum a specific column if it contains numbers.
        const sheet = this.spreadsheets.get(sheetId);
        if (sheet && sheet.length > 0 && sheet[0].length > 0) {
            let sum = 0;
            let calculated = false;
            // Example: Sum values in the first column (col 0)
            for (let r = 0; r < sheet.length; r++) {
                const cellValue = parseFloat(sheet[r][0]);
                if (!isNaN(cellValue)) {
                    sum += cellValue;
                    calculated = true;
                }
            }
            if (calculated) {
                console.log(`Calculations performed for '${sheetId}'. (Simulated: Sum of first column: ${sum})`);
            } else {
                console.log(`No numeric data for calculation in '${sheetId}'.`);
            }
        }
    }

    public getSpreadsheetData(sheetId: string): SheetMatrix | undefined {
        return this.spreadsheets.get(sheetId);
    }
}

// Example usage (not part of the required code)
// const app = new SpreadsheetApp();
// app.createSpreadsheet("sales_report", 3, 3);
// app.enterCellData("sales_report", 0, 0, "Jan Sales");
// app.enterCellData("sales_report", 1, 0, "500");
// app.enterCellData("sales_report", 2, 0, "750");
// app.enterCellData("sales_report", 1, 1, "Q1");
ğŸ§ª Senaryo 8: Bir Ã§izim uygulamasÄ±nda kullanÄ±cÄ±lar Ã§izgi ve ÅŸekiller oluÅŸturur. Ã‡izim verileri bellek alanlarÄ±nda saklanÄ±r. KullanÄ±cÄ± giriÅŸleri sistem tarafÄ±ndan iÅŸlenir. Ã‡izim ekranda gÃ¶rÃ¼ntÃ¼lenir.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

using System;
using System.Collections.Generic;

// Simple representation of a geometric shape
public abstract class Shape
{
    public string Color { get; set; } = "Black";
}

public class Line : Shape
{
    public int X1 { get; set; }
    public int Y1 { get; set; }
    public int X2 { get; set; }
    public int Y2 { get; set; }
}

public class Circle : Shape
{
    public int CenterX { get; set; }
    public int CenterY { get; set; }
    public int Radius { get; set; }
}

public class DrawingApp
{
    // Drawing data stored in memory areas
    private Dictionary<string, List<Shape>> drawings = new Dictionary<string, List<Shape>>();

    public void CreateNewDrawing(string drawingId)
    {
        drawings[drawingId] = new List<Shape>();
        Console.WriteLine(<span class="math-inline">"New drawing '\{drawingId\}' created\."\);
\}
public void AddLine\(string drawingId, int x1, int y1, int x2, int y2, string color \= "Black"\)
\{
if \(drawings\.ContainsKey\(drawingId\)\)
\{
var line \= new Line \{ X1 \= x1, Y1 \= y1, X2 \= x2, Y2 \= y2, Color \= color \};
drawings\[drawingId\]\.Add\(line\); // User inputs processed by the system
Console\.WriteLine\(</span>"Line added to drawing '{drawingId}': ({x1},{y1}) to ({x2},{y2}).");
            DisplayDrawing(drawingId); // Drawing displayed on screen
        }
        else
        {
            Console.WriteLine(<span class="math-inline">"Drawing '\{drawingId\}' not found\."\);
\}
\}
public void AddCircle\(string drawingId, int centerX, int centerY, int radius, string color \= "Black"\)
\{
if \(drawings\.ContainsKey\(drawingId\)\)
\{
var circle \= new Circle \{ CenterX \= centerX, CenterY \= centerY, Radius \= radius, Color \= color \};
drawings\[drawingId\]\.Add\(circle\); // User inputs processed by the system
Console\.WriteLine\(</span>"Circle added to drawing '{drawingId}': Center ({centerX},{centerY}), Radius {radius}.");
            DisplayDrawing(drawingId); // Drawing displayed on screen
        }
        else
        {
            Console.WriteLine(<span class="math-inline">"Drawing '\{drawingId\}' not found\."\);
\}
\}
private void DisplayDrawing\(string drawingId\)
\{
// In a real application, this would render the shapes onto a canvas/graphics context\.
// For this simulation, we just print a description of the drawing\.
if \(drawings\.ContainsKey\(drawingId\)\)
\{
Console\.WriteLine\(</span>"\n--- Displaying Drawing '{drawingId}' ---");
            foreach (var shape in drawings[drawingId])
            {
                if (shape is Line line)
                {
                    Console.WriteLine(<span class="math-inline">"  Line\: \(\{line\.X1\},\{line\.Y1\}\) to \(\{line\.X2\},\{line\.Y2\}\), Color\: \{line\.Color\}"\);
\}
else if \(shape is Circle circle\)
\{
Console\.WriteLine\(</span>"  Circle: Center ({circle.CenterX},{circle.CenterY}), Radius {circle.Radius}, Color: {circle.Color}");
                }
            }
            Console.WriteLine("----------------------------------\n");
        }
    }

    public List<Shape> GetDrawingShapes(string drawingId)
    {
        return drawings.GetValueOrDefault(drawingId);
    }
}

// Example usage (not part of the required code)
// public class Program
// {
//     public static void Main(string[] args)
//     {
//         DrawingApp app = new DrawingApp();
//         app.CreateNewDrawing("my_sketch");
//         app.AddLine("my_sketch", 10, 10, 50, 50, "Blue");
//         app.AddCircle("my_sketch", 100, 100, 30, "Red");
//     }
// }
ğŸ§ª Senaryo 8: Bir Ã§izim uygulamasÄ±nda kullanÄ±cÄ±lar Ã§izgi ve ÅŸekiller oluÅŸturur. Ã‡izim verileri bellek alanlarÄ±nda saklanÄ±r. KullanÄ±cÄ± giriÅŸleri sistem tarafÄ±ndan iÅŸlenir. Ã‡izim ekranda gÃ¶rÃ¼ntÃ¼lenir.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

from typing import List, Dict, Any

class Shape:
    def __init__(self, shape_type: str, color: str = "black"):
        self.shape_type = shape_type
        self.color = color

class Line(Shape):
    def __init__(self, x1: int, y1: int, x2: int, y2: int, color: str = "black"):
        super().__init__("line", color)
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2

class Circle(Shape):
    def __init__(self, center_x: int, center_y: int, radius: int, color: str = "black"):
        super().__init__("circle", color)
        self.center_x = center_x
        self.center_y = center_y
        self.radius = radius

class DrawingApp:
    def __init__(self):
        # Drawing data stored in memory areas
        self.drawings: Dict[str, List[Shape]] = {}

    def create_new_drawing(self, drawing_id: str):
        self.drawings[drawing_id] = []
        print(f"New drawing '{drawing_id}' created.")

    def add_line(self, drawing_id: str, x1: int, y1: int, x2: int, y2: int, color: str = "black"):
        if drawing_id in self.drawings:
            line = Line(x1, y1, x2, y2, color)
            self.drawings[drawing_id].append(line)  # User inputs processed by the system
            print(f"Line added to drawing '{drawing_id}': ({x1},{y1}) to ({x2},{y2}).")
            self._display_drawing(drawing_id)  # Drawing displayed on screen
        else:
            print(f"Drawing '{drawing_id}' not found.")

    def add_circle(self, drawing_id: str, center_x: int, center_y: int, radius: int, color: str = "black"):
        if drawing_id in self.drawings:
            circle = Circle(center_x, center_y, radius, color)
            self.drawings[drawing_id].append(circle)  # User inputs processed by the system
            print(f"Circle added to drawing '{drawing_id}': Center ({center_x},{center_y}), Radius {radius}.")
            self._display_drawing(drawing_id)  # Drawing displayed on screen
        else:
            print(f"Drawing '{drawing_id}' not found.")

    def _display_drawing(self, drawing_id: str):
        # In a real application, this would render the shapes onto a canvas/graphics context.
        # For this simulation, we just print a description of the drawing.
        if drawing_id in self.drawings:
            print(f"\n--- Displaying Drawing '{drawing_id}' ---")
            for shape in self.drawings[drawing_id]:
                if shape.shape_type == "line":
                    print(f"  Line: ({shape.x1},{shape.y1}) to ({shape.x2},{shape.y2}), Color: {shape.color}")
                elif shape.shape_type == "circle":
                    print(f"  Circle: Center ({shape.center_x},{shape.center_y}), Radius {shape.radius}, Color: {shape.color}")
            print("----------------------------------\n")

    def get_drawing_shapes(self, drawing_id: str) -> List[Shape] | None:
        return self.drawings.get(drawing_id)

# Example usage (not part of the required code)
# if __name__ == "__main__":
#     app = DrawingApp()
#     app.create_new_drawing("my_art")
#     app.add_line("my_art", 0, 0, 100, 100, "red")
#     app.add_circle("my_art", 50, 50, 25, "blue")
ğŸ§ª Senaryo 8: Bir Ã§izim uygulamasÄ±nda kullanÄ±cÄ±lar Ã§izgi ve ÅŸekiller oluÅŸturur. Ã‡izim verileri bellek alanlarÄ±nda saklanÄ±r. KullanÄ±cÄ± giriÅŸleri sistem tarafÄ±ndan iÅŸlenir. Ã‡izim ekranda gÃ¶rÃ¼ntÃ¼lenir.
ğŸ’» Dil: TypeScript (ReactJS - simplified)

ğŸ¤– AI: Gemini

TypeScript

import React, { useState } from 'react';

// Define interfaces for shapes
interface Line {
  type: 'line';
  id: string;
  x1: number;
  y1: number;
  x2: number;
  y2: number;
  color: string;
}

interface Circle {
  type: 'circle';
  id: string;
  centerX: number;
  centerY: number;
  radius: number;
  color: string;
}

type Shape = Line | Circle;

interface DrawingState {
  [drawingId: string]: Shape[];
}

const DrawingApp: React.FC = () => {
  const [drawings, setDrawings] = useState<DrawingState>({});
  const [currentDrawingId, setCurrentDrawingId] = useState<string | null>(null);

  const createNewDrawing = (drawingId: string) => {
    setDrawings(prevDrawings => ({
      ...prevDrawings,
      [drawingId]: [], // Drawing data stored in memory areas
    }));
    setCurrentDrawingId(drawingId);
    console.log(`New drawing '${drawingId}' created.`);
  };

  const addLine = (drawingId: string, x1: number, y1: number, x2: number, y2: number, color: string = 'black') => {
    setDrawings(prevDrawings => {
      const currentDrawing = prevDrawings[drawingId];
      if (currentDrawing) {
        const newLine: Line = { type: 'line', id: `line-${Date.now()}`, x1, y1, x2, y2, color };
        const updatedDrawing = [...currentDrawing, newLine]; // User inputs processed by the system
        console.log(`Line added to drawing '${drawingId}': (${x1},${y1}) to (${x2},${y2}).`);
        return {
          ...prevDrawings,
          [drawingId]: updatedDrawing,
        };
      } else {
        console.log(`Drawing '${drawingId}' not found.`);
        return prevDrawings;
      }
    });
  };

  const addCircle = (drawingId: string, centerX: number, centerY: number, radius: number, color: string = 'black') => {
    setDrawings(prevDrawings => {
      const currentDrawing = prevDrawings[drawingId];
      if (currentDrawing) {
        const newCircle: Circle = { type: 'circle', id: `circle-${Date.now()}`, centerX, centerY, radius, color };
        const updatedDrawing = [...currentDrawing, newCircle]; // User inputs processed by the system
        console.log(`Circle added to drawing '${drawingId}': Center (${centerX},${centerY}), Radius ${radius}.`);
        return {
          ...prevDrawings,
          [drawingId]: updatedDrawing,
        };
      } else {
        console.log(`Drawing '${drawingId}' not found.`);
        return prevDrawings;
      }
    });
  };

  // This component would typically render shapes on an SVG or Canvas element
  const renderDrawing = (drawingId: string | null) => {
    if (!drawingId || !drawings[drawingId]) {
      return <div>No drawing selected or drawing not found.</div>;
    }
    const shapes = drawings[drawingId];
    return (
      <svg width="400" height="400" style={{ border: '1px solid black' }}>
        {shapes.map(shape => {
          if (shape.type === 'line') {
            return (
              <line
                key={shape.id}
                x1={shape.x1}
                y1={shape.y1}
                x2={shape.x2}
                y2={shape.y2}
                stroke={shape.color}
                strokeWidth="2"
              />
            );
          } else if (shape.type === 'circle') {
            return (
              <circle
                key={shape.id}
                cx={shape.centerX}
                cy={shape.centerY}
                r={shape.radius}
                fill="none"
                stroke={shape.color}
                strokeWidth="2"
              />
            );
          }
          return null;
        })}
      </svg>
    );
  };

  return (
    <div>
      <h1>Drawing App</h1>
      <button onClick={() => createNewDrawing('mySketch')}>Create New Sketch</button>
      {currentDrawingId && (
        <>
          <button onClick={() => addLine(currentDrawingId, 20, 20, 180, 180, 'blue')}>Add Blue Line</button>
          <button onClick={() => addCircle(currentDrawingId, 100, 100, 50, 'red')}>Add Red Circle</button>
          <h2>Current Drawing: {currentDrawingId}</h2>
          {renderDrawing(currentDrawingId)} {/* Drawing displayed on screen */}
        </>
      )}
    </div>
  );
};

export default DrawingApp;
ğŸ§ª Senaryo 9: Bir video dÃ¼zenleme uygulamasÄ±nda kullanÄ±cÄ±lar frame verilerini deÄŸiÅŸtirir. Video verileri bellek buffer'larÄ±nda tutulur. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan uygulanÄ±r. Video yeni haliyle oluÅŸturulur.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

using System;
using System.Collections.Generic;
using System.Linq;

public class VideoEditingApp
{
    // Represents video data held in memory buffers (list of byte arrays, each byte array is a frame)
    private Dictionary<string, List<byte[]>> videoBuffers = new Dictionary<string, List<byte[]>>();

    public void LoadVideo(string videoId, List<byte[]> frames)
    {
        videoBuffers[videoId] = frames; // Video data held in memory buffers
        Console.WriteLine(<span class="math-inline">"Video '\{videoId\}' loaded with \{frames\.Count\} frames\."\);
\}
public void ApplyGrayscaleFilter\(string videoId\)
\{
if \(videoBuffers\.ContainsKey\(videoId\)\)
\{
List<byte\[\]\> frames \= videoBuffers\[videoId\];
foreach \(var frame in frames\)
\{
// Simulate grayscale conversion for each pixel \(simplistic\: average R, G, B\)
// Assuming frame is a flat array of R, G, B bytes
for \(int i \= 0; i < frame\.Length; i \+\= 3\)
\{
if \(i \+ 2 < frame\.Length\) // Ensure we have R, G, B
\{
byte r \= frame\[i\];
byte g \= frame\[i \+ 1\];
byte b \= frame\[i \+ 2\];
byte gray \= \(byte\)\(\(r \+ g \+ b\) / 3\);
frame\[i\] \= gray;
frame\[i \+ 1\] \= gray;
frame\[i \+ 2\] \= gray;
\}
\}
\}
Console\.WriteLine\(</span>"Grayscale filter applied to video '{videoId}'.");
            GenerateNewVideo(videoId); // Video created with new state
        }
        else
        {
            Console.WriteLine(<span class="math-inline">"Video '\{videoId\}' not found\."\);
\}
\}
public void TrimVideo\(string videoId, int startFrame, int endFrame\)
\{
if \(videoBuffers\.ContainsKey\(videoId\)\)
\{
List<byte\[\]\> frames \= videoBuffers\[videoId\];
if \(startFrame \>\= 0 && endFrame < frames\.Count && startFrame <\= endFrame\)
\{
List<byte\[\]\> trimmedFrames \= frames\.GetRange\(startFrame, endFrame \- startFrame \+ 1\);
videoBuffers\[videoId\] \= trimmedFrames; // User edits applied by the system
Console\.WriteLine\(</span>"Video '{videoId}' trimmed from frame {startFrame} to {endFrame}. New frame count: {trimmedFrames.Count}.");
                GenerateNewVideo(videoId); // Video created with new state
            }
            else
            {
                Console.WriteLine(<span class="math-inline">"Invalid trim range for video '\{videoId\}'\."\);
\}
\}
else
\{
Console\.WriteLine\(</span>"Video '{videoId}' not found.");
        }
    }

    private void GenerateNewVideo(string videoId)
    {
        // In a real application, this would involve encoding the frames into a video file format (e.g., MP4, AVI).
        // For this simulation, we just print a message.
        Console.WriteLine($"New version of video '{videoId}' generated (simulated encoding).");
    }

    public List<byte[]> GetVideoFrames(string videoId)
    {
        return videoBuffers.GetValueOrDefault(videoId);
    }
}

// Example usage (not part of the required code)
// public class Program
// {
//     public static void Main(string[] args)
//     {
//         VideoEditingApp app = new VideoEditingApp();
//         // Simulate 10 frames, each 100 bytes (e.g., 10x10 RGB pixels)
//         List<byte[]> videoFrames = new List<byte[]>();
//         for (int i = 0; i < 10; i++)
//         {
//             byte[] frame = new byte[10 * 10 * 3]; // R G B for each pixel
//             for (int j = 0; j < frame.Length; j++) frame[j] = (byte)(i * 20 + j % 255); // Dummy pixel data
//             videoFrames.Add(frame);
//         }
//         app.LoadVideo("my_movie", videoFrames);
//         app.ApplyGrayscaleFilter("my_movie");
//         app.TrimVideo("my_movie", 2, 7);
//     }
// }
ğŸ§ª Senaryo 9: Bir video dÃ¼zenleme uygulamasÄ±nda kullanÄ±cÄ±lar frame verilerini deÄŸiÅŸtirir. Video verileri bellek buffer'larÄ±nda tutulur. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan uygulanÄ±r. Video yeni haliyle oluÅŸturulur.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

import numpy as np

class VideoEditingApp:
    def __init__(self):
        # Represents video data held in memory buffers (dictionary of lists of NumPy arrays, each array is a frame)
        self.video_buffers = {}

    def load_video(self, video_id: str, frames: list[np.ndarray]):
        self.video_buffers[video_id] = frames  # Video data held in memory buffers
        print(f"Video '{video_id}' loaded with {len(frames)} frames.")

    def apply_grayscale_filter(self, video_id: str):
        if video_id in self.video_buffers:
            frames = self.video_buffers[video_id]
            for i, frame in enumerate(frames):
                # Assuming frame is (height, width, 3) for RGB
                if frame.ndim == 3 and frame.shape[2] == 3:
                    # Simple grayscale conversion: average R, G, B
                    grayscale_frame = frame.mean(axis=2, keepdims=True).astype(np.uint8)
                    frames[i] = np.repeat(grayscale_frame, 3, axis=2) # Convert back to 3 channels for display
                else:
                    print(f"Warning: Frame {i} in video '{video_id}' is not in expected RGB format for grayscale.")
            print(f"Grayscale filter applied to video '{video_id}'.")
            self._generate_new_video(video_id)  # Video created with new state
        else:
            print(f"Video '{video_id}' not found.")

    def trim_video(self, video_id: str, start_frame: int, end_frame: int):
        if video_id in self.video_buffers:
            frames = self.video_buffers[video_id]
            if 0 <= start_frame < len(frames) and 0 <= end_frame < len(frames) and start_frame <= end_frame:
                trimmed_frames = frames[start_frame : end_frame + 1]
                self.video_buffers[video_id] = trimmed_frames  # User edits applied by the system
                print(f"Video '{video_id}' trimmed from frame {start_frame} to {end_frame}. New frame count: {len(trimmed_frames)}.")
                self._generate_new_video(video_id)  # Video created with new state
            else:
                print(f"Invalid trim range for video '{video_id}'.")
        else:
            print(f"Video '{video_id}' not found.")

    def _generate_new_video(self, video_id: str):
        # In a real application, this would involve encoding the frames into a video file format (e.g., MP4, AVI).
        # For this simulation, we just print a message.
        print(f"New version of video '{video_id}' generated (simulated encoding).")

    def get_video_frames(self, video_id: str) -> list[np.ndarray] | None:
        return self.video_buffers.get(video_id)

# Example usage (not part of the required code)
# if __name__ == "__main__":
#     app = VideoEditingApp()
#     # Simulate 5 frames, each 10x10 RGB pixels (height, width, channels)
#     dummy_frames = [np.random.randint(0, 256, (10, 10, 3), dtype=np.uint8) for _ in range(5)]
#     app.load_video("vacation_clip", dummy_frames)
#     app.apply_grayscale_filter("vacation_clip")
#     app.trim_video("vacation_clip", 1, 3)
ğŸ§ª Senaryo 9: Bir video dÃ¼zenleme uygulamasÄ±nda kullanÄ±cÄ±lar frame verilerini deÄŸiÅŸtirir. Video verileri bellek buffer'larÄ±nda tutulur. KullanÄ±cÄ± dÃ¼zenlemeleri sistem tarafÄ±ndan uygulanÄ±r. Video yeni haliyle oluÅŸturulur.
ğŸ’» Dil: TypeScript (Node.js)

ğŸ¤– AI: Gemini

TypeScript

import * as fs from 'fs';

// A frame represented as a Uint8ClampedArray (like ImageData.data)
type VideoFrame = Uint8ClampedArray; // Represents [R, G, B, A, R, G, B, A, ...] pixel data

class VideoEditingApp {
    // Represents video data held in memory buffers (Map of lists of frames)
    private videoBuffers: Map<string, VideoFrame[]> = new Map();

    public loadVideo(videoId: string, frames: VideoFrame[]): void {
        this.videoBuffers.set(videoId, frames); // Video data held in memory buffers
        console.log(`Video '${videoId}' loaded with ${frames.length} frames.`);
    }

    public applyGrayscaleFilter(videoId: string): void {
        const frames = this.videoBuffers.get(videoId);
        if (frames) {
            frames.forEach(frame => {
                // Simulate grayscale conversion (assuming RGBA format for simplicity)
                for (let i = 0; i < frame.length; i += 4) {
                    const r = frame[i];
                    const g = frame[i + 1];
                    const b = frame[i + 2];
                    const gray = (r + g + b) / 3;
                    frame[i] = gray;
                    frame[i + 1] = gray;
                    frame[i + 2] = gray;
                }
            });
            console.log(`Grayscale filter applied to video '${videoId}'.`);
            this.generateNewVideo(videoId); // Video created with new state
        } else {
            console.log(`Video '${videoId}' not found.`);
        }
    }

    public trimVideo(videoId: string, startFrame: number, endFrame: number): void {
        const frames = this.videoBuffers.get(videoId);
        if (frames) {
            if (startFrame >= 0 && endFrame < frames.length && startFrame <= endFrame) {
                const trimmedFrames = frames.slice(startFrame, endFrame + 1);
                this.videoBuffers.set(videoId, trimmedFrames); // User edits applied by the system
                console.log(`Video '${videoId}' trimmed from frame ${startFrame} to ${endFrame}. New frame count: ${trimmedFrames.length}.`);
                this.generateNewVideo(videoId); // Video created with new state
            } else {
                console.log(`Invalid trim range for video '${videoId}'.`);
            }
        } else {
            console.log(`Video '${videoId}' not found.`);
        }
    }

    private generateNewVideo(videoId: string): void {
        // In a real application, this would involve encoding the frames into a video file format.
        // For this simulation, we just print a message and simulate a file write.
        console.log(`New version of video '${videoId}' generated (simulated encoding).`);
        // Example: write a dummy file
        // fs.writeFileSync(`${videoId}_output.bin`, Buffer.from(this.videoBuffers.get(videoId)?.flat().map(v => v) || []));
    }

    public getVideoFrames(videoId: string): VideoFrame[] | undefined {
        return this.videoBuffers.get(videoId);
    }
}

// Example usage (not part of the required code)
// const app = new VideoEditingApp();
// // Simulate 3 frames, each 10x10 pixels (10*10*4 bytes for RGBA)
// const dummyFrames: VideoFrame[] = [];
// for (let i = 0; i < 3; i++) {
//     const frameData = new Uint8ClampedArray(10 * 10 * 4);
//     for (let j = 0; j < frameData.length; j++) {
//         frameData[j] = Math.floor(Math.random() * 256);
//     }
//     dummyFrames.push(frameData);
// }
// app.loadVideo("conference_footage", dummyFrames);
// app.applyGrayscaleFilter("conference_footage");
// app.trimVideo("conference_footage", 0, 1);
ğŸ§ª Senaryo 10: Bir form uygulamasÄ±nda kullanÄ±cÄ±lar form alanlarÄ±nÄ± doldurur. Form verileri bellek yapÄ±larÄ±nda saklanÄ±r. KullanÄ±cÄ± giriÅŸleri sistem tarafÄ±ndan iÅŸlenir. Form verileri doÄŸrulanÄ±r ve kaydedilir.
ğŸ’» Dil: C#

ğŸ¤– AI: Gemini

C#

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

public class FormApp
{
    // Form data stored in memory structures (e.g., dictionary of dictionaries)
    private Dictionary<string, Dictionary<string, string>> formData = new Dictionary<string, Dictionary<string, string>>();

    public void InitializeForm(string formId, Dictionary<string, string> initialFields)
    {
        formData[formId] = new Dictionary<string, string>(initialFields);
        Console.WriteLine(<span class="math-inline">"Form '\{formId\}' initialized with fields\: \{string\.Join\(", ", initialFields\.Keys\)\}\."\);
\}
public void FillFormField\(string formId, string fieldName, string value\)
\{
if \(formData\.ContainsKey\(formId\)\)
\{
if \(formData\[formId\]\.ContainsKey\(fieldName\)\)
\{
formData\[formId\]\[fieldName\] \= value; // User inputs processed by the system
Console\.WriteLine\(</span>"Field '{fieldName}' in form '{formId}' filled with '{value}'.");
                // In a real app, validation might happen per field, or on submission
            }
            else
            {
                Console.WriteLine(<span class="math-inline">"Field '\{fieldName\}' not found in form '\{formId\}'\."\);
\}
\}
else
\{
Console\.WriteLine\(</span>"Form '{formId}' not found.");
        }
    }

    public bool SubmitForm(string formId)
    {
        if (formData.ContainsKey(formId))
        {
            Console.WriteLine(<span class="math-inline">"Attempting to submit form '\{formId\}'\."\);
if \(ValidateFormData\(formId\)\) // Form data is validated
\{
SaveFormData\(formId\); // Form data is saved
Console\.WriteLine\(</span>"Form '{formId}' submitted and saved successfully.");
                return true;
            }
            else
            {
                Console.WriteLine(<span class="math-inline">"Form '\{formId\}' validation failed\. Cannot submit\."\);
return false;
\}
\}
else
\{
Console\.WriteLine\(</span>"Form '{formId}' not found for submission.");
            return false;
        }
    }

    private bool ValidateFormData(string formId)
    {
        // Simple validation rules (e.g., email format, required fields)
        var form = formData[formId];
        bool isValid = true;

        if (form.ContainsKey("Email") && !Regex.IsMatch(form["Email"], @"^[^@\s]+@[^@\s]+\.[^@\s]+<span class="math-inline">"\)\)
\{
Console\.WriteLine\("Validation Error\: Invalid Email format\."\);
isValid \= false;
\}
if \(form\.ContainsKey\("Password"\) && form\["Password"\]\.Length < 6\)
\{
Console\.WriteLine\("Validation Error\: Password must be at least 6 characters long\."\);
isValid \= false;
\}
// Example\: Check if a "Name" field is present and not empty
if \(form\.ContainsKey\("Name"\) && string\.IsNullOrWhiteSpace\(form\["Name"\]\)\)
\{
Console\.WriteLine\("Validation Error\: Name is a required field\."\);
isValid \= false;
\}
Console\.WriteLine\(</span>"Form '{formId}' validation result: {isValid}");
        return isValid;
    }

    private void SaveFormData(string formId)
    {
        // In a real application, this would persist data to a database.
        // For this simulation, we just print the data.
        Console.WriteLine(<span class="math-inline">"Saving data for form '\{formId\}'\:"\);
foreach \(var entry in formData\[formId\]\)
\{
Console\.WriteLine\(</span>"  {entry.Key}: {entry.Value}");
        }
        // Example: Insert into a database
        // using (var db = new AppDbContext()) { db.Forms.Add(form); db.SaveChanges(); }
    }

    public Dictionary<string, string> GetFormData(string formId)
    {
        return formData.GetValueOrDefault(formId);
    }
}

// Example usage (not part of the required code)
// public class Program
// {
//     public static void Main(string[] args)
//     {
//         FormApp app = new FormApp();
//         app.InitializeForm("registration", new Dictionary<string, string>
//         {
//             { "Name", "" },
//             { "Email", "" },
//             { "Password", "" }
//         });
//         app.FillFormField("registration", "Name", "John Doe");
//         app.FillFormField("registration", "Email", "john.doe@example.com");
//         app.FillFormField("registration", "Password", "pass123");
//         app.SubmitForm("registration");
//
//         Console.WriteLine("\n--- Testing Invalid Form ---");
//         app.InitializeForm("contact_us", new Dictionary<string, string>
//         {
//             { "Subject", "" },
//             { "Email", "" }
//         });
//         app.FillFormField("contact_us", "Subject", "Inquiry");
//         app.FillFormField("contact_us", "Email", "invalid-email"); // Invalid email
//         app.SubmitForm("contact_us");
//     }
// }
ğŸ§ª Senaryo 10: Bir form uygulamasÄ±nda kullanÄ±cÄ±lar form alanlarÄ±nÄ± doldurur. Form verileri bellek yapÄ±larÄ±nda saklanÄ±r. KullanÄ±cÄ± giriÅŸleri sistem tarafÄ±ndan iÅŸlenir. Form verileri doÄŸrulanÄ±r ve kaydedilir.
ğŸ’» Dil: Python

ğŸ¤– AI: Gemini

Python

import re

class FormApp:
    def __init__(self):
        # Form data stored in memory structures (dictionary of dictionaries)
        self.form_data = {}

    def initialize_form(self, form_id: str, initial_fields: dict[str, str]):
        self.form_data[form_id] = initial_fields.copy()
        print(f"Form '{form_id}' initialized with fields: {', '.join(initial_fields.keys())}.")

    def fill_form_field(self, form_id: str, field_name: str, value: str):
        if form_id in self.form_data:
            if field_name in self.form_data[form_id]:
                self.form_data[form_id][field_name] = value  # User inputs processed by the system
                print(f"Field '{field_name}' in form '{form_id}' filled with '{value}'.")
                # In a real app, validation might happen per field, or on submission
            else:
                print(f"Field '{field_name}' not found in form '{form_id}'.")
        else:
            print(f"Form '{form_id}' not found.")

    def submit_form(self, form_id: str) -> bool:
        if form_id in self.form_data:
            print(f"Attempting to submit form '{form_id}'.")
            if self._validate_form_data(form_id):  # Form data is validated
                self._save_form_data(form_id)  # Form data is saved
                print(f"Form '{form_id}' submitted and saved successfully.")
                return True
            else:
                print(f"Form '{form_id}' validation failed. Cannot submit.")
                return False
        else:
            print(f"Form '{form_id}' not found for submission.")
            return False

    def _validate_form_data(self, form_id: str) -> bool:
        # Simple validation rules (e.g., email format, required fields)
        form = self.form_data[form_id]
        is_valid = True

        if "Email" in form and not re.match(r"^[^\s@]+@[^\s@]+\.[^\s@]+$", form["Email"]):
            print("Validation Error: Invalid Email format.")
            is_valid = False

        if "Password" in form and len(form["Password"]) < 6:
            print("Validation Error: Password must be at least 6 characters long.")
            is_valid = False

        # Example: Check if a "Name" field is present and not empty
        if "Name" in form and not form["Name"].strip():
            print("Validation Error: Name is a required field.")
            is_valid = False

        print(f"Form '{form_id}' validation result: {is_valid}")
        return is_valid

    def _save_form_data(self, form_id: str):
        # In a real application, this would persist data to a database.
        # For this simulation, we just print the data.
        print(f"Saving data for form '{form_id}':")
        for key, value in self.form_data[form_id].items():
            print(f"  {key}: {value}")
        # Example: Insert into a database
        # db.forms.insert_one(self.form_data[form_id])

    def get_form_data(self, form_id: str) -> dict[str, str] | None:
        return self.form_data.get(form_id)

# Example usage (not part of the required code)
# if __name__ == "__main__":
#     app = FormApp()
#     app.initialize_form("signup_form", {"Username": "", "Email": "", "Password": ""})
#     app.fill_form_field("signup_form", "Username", "user123")
#     app.fill_form_field("signup_form", "Email", "user123@example.com")
#     app.fill_form_field("signup_form", "Password", "securepass")
#     app.submit_form("signup_form")
#
#     print("\n--- Testing Invalid Form ---")
#     app.initialize_form("feedback_form", {"Message": "", "Email": ""})
#     app.fill_form_field("feedback_form", "Message", "This is a test message.")
#     app.fill_form_field("feedback_form", "Email", "bad_email") # Invalid email
#     app.submit_form("feedback_form")
ğŸ§ª Senaryo 10: Bir form uygulamasÄ±nda kullanÄ±cÄ±lar form alanlarÄ±nÄ± doldurur. Form verileri bellek yapÄ±larÄ±nda saklanÄ±r. KullanÄ±cÄ± giriÅŸleri sistem tarafÄ±ndan iÅŸlenir. Form verileri doÄŸrulanÄ±r ve kaydedilir.
ğŸ’» Dil: TypeScript (ReactJS - simplified)

ğŸ¤– AI: Gemini

TypeScript

import React, { useState } from 'react';

interface FormData {
  [key: string]: string;
}

interface FormDefinition {
  [formId: string]: FormData;
}

const FormApp: React.FC = () => {
  const [forms, setForms] = useState<FormDefinition>({});
  const [currentFormId, setCurrentFormId] = useState<string | null>(null);

  const initializeForm = (formId: string, initialFields: FormData) => {
    setForms(prevForms => ({
      ...prevForms,
      [formId]: { ...initialFields }, // Form data stored in memory structures
    }));
    setCurrentFormId(formId);
    console.log(`Form '${formId}' initialized with fields: ${Object.keys(initialFields).join(', ')}.`);
  };

  const fillFormField = (formId: string, fieldName: string, value: string) => {
    setForms(prevForms => {
      const currentForm = prevForms[formId];
      if (currentForm && currentForm.hasOwnProperty(fieldName)) {
        console.log(`Field '${fieldName}' in form '${formId}' filled with '${value}'.`);
        return {
          ...prevForms,
          [formId]: {
            ...currentForm,
            [fieldName]: value, // User inputs processed by the system
          },
        };
      } else {
        console.log(`Field '${fieldName}' not found in form '${formId}' or form not found.`);
        return prevForms;
      }
    });
  };

  const validateFormData = (form: FormData): boolean => {
    let isValid = true;
    console.log("Starting form validation...");

    if (form.Email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(form.Email)) {
      console.log("Validation Error: Invalid Email format.");
      isValid = false;
    }

    if (form.Password && form.Password.length < 6) {
      console.log("Validation Error: Password must be at least 6 characters long.");
      isValid = false;
    }

    if (form.Name !== undefined && form.Name.trim() === "") { // Check for presence and emptiness if 'Name' is a field
      console.log("Validation Error: Name is a required field.");
      isValid = false;
    }

    console.log(`Form validation result: ${isValid}`);
    return isValid;
  };

  const submitForm = (formId: string) => {
    const formToSubmit = forms[formId];
    if (formToSubmit) {
      console.log(`Attempting to submit form '${formId}'.`);
      if (validateFormData(formToSubmit)) { // Form data is validated
        saveFormData(formToSubmit); // Form data is saved
        console.log(`Form '${formId}' submitted and saved successfully.`);
        return true;
      } else {
        console.log(`Form '${formId}' validation failed. Cannot submit.`);
        return false;
      }
    } else {
      console.log(`Form '${formId}' not found for submission.`);
      return false;
    }
  };

  const saveFormData = (data: FormData) => {
    // In a real application, this would persist data to a backend database or API.
    // For this simulation, we just log the data to the console.
    console.log("Saving form data (simulated save to database):", data);
  };

  return (
    <div>
      <h1>Form Application</h1>
      <button onClick={() => initializeForm('userRegistration', { Name: '', Email: '', Password: '' })}>
        Initialize Registration Form
      </button>
      {currentFormId === 'userRegistration' && (
        <div>
          <h2>User Registration Form</h2>
          <input
            type="text"
            placeholder="Name"
            onChange={(e) => fillFormField('userRegistration', 'Name', e.target.value)}
          />
          <br />
          <input
            type="email"
            placeholder="Email"
            onChange={(e) => fillFormField('userRegistration', 'Email', e.target.value)}
          />
          <br />
          <input
            type="password"
            placeholder="Password"
            onChange={(e) => fillFormField('userRegistration', 'Password', e.target.value)}
          />
          <br />
          <button onClick={() => submitForm('userRegistration')}>Submit Registration</button>
        </div>
      )}

      <button onClick={() => initializeForm('contactUs', { Subject: '', Message: '', Email: '' })}>
        Initialize Contact Us Form
      </button>
      {currentFormId === 'contactUs' && (
        <div>
          <h2>Contact Us Form</h2>
          <input
            type="text"
            placeholder="Subject"
            onChange={(e) => fillFormField('contactUs', 'Subject', e.target.value)}
          />
          <br />
          <textarea
            placeholder="Message"
            onChange={(e) => fillFormField('contactUs', 'Message', e.target.value)}
          ></textarea>
          <br />
          <input
            type="email"
            placeholder="Email"
            onChange={(e) => fillFormField('contactUs', 'Email', e.target.value)}
          />
          <br />
          <button onClick={() => submitForm('contactUs')}>Submit Contact Form</button>
        </div>
      )}
    </div>
  );
};

export default FormApp;