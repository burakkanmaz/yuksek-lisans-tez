### ğŸ§ª Senaryo 1: Bir e-ticaret sitesinde mÃ¼ÅŸteriler aynÄ± anda Ã¼rÃ¼n satÄ±n alabilir. Son Ã¼rÃ¼n kaldÄ±ÄŸÄ±nda birden Ã§ok kullanÄ±cÄ± Ã¶deme iÅŸlemi baÅŸlatabilir. Sistem stok kontrolÃ¼nÃ¼ Ã¶deme sÄ±rasÄ±nda yapar. Ã–deme baÅŸarÄ±lÄ± olan kullanÄ±cÄ±lar Ã¼rÃ¼nÃ¼ alabilir.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 19
```csharp
[HttpPost("process-payment")]
public async Task<IActionResult> ProcessPayment(int productId, int userId)
{
    using var transaction = _context.Database.BeginTransaction();
    try
    {
        var product = await _context.Products.FirstOrDefaultAsync(p => p.Id == productId && p.Stock > 0);
        if (product == null) return BadRequest("Product out of stock");

        product.Stock--;
        await _context.SaveChangesAsync();
        transaction.Commit();
        return Ok("Payment successful");
    }
    catch
    {
        transaction.Rollback();
        return StatusCode(500, "Payment failed");
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 9
```python
@app.post("/process-payment")
async def process_payment(product_id: int, user_id: int):
    async with database.transaction():
        product = await Product.filter(id=product_id, stock__gt=0).first()
        if not product:
            raise HTTPException(status_code=400, detail="Product out of stock")
        
        product.stock -= 1
        await product.save()
        return {"message": "Payment successful"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 25
```typescript
app.post("/process-payment", async (req: Request, res: Response) => {
    const { productId, userId } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        const result = await client.query(
            'SELECT * FROM products WHERE id = $1 AND stock > 0 FOR UPDATE', 
            [productId]
        );
        
        if (result.rows.length === 0) {
            throw new Error("Product out of stock");
        }

        await client.query(
            'UPDATE products SET stock = stock - 1 WHERE id = $1',
            [productId]
        );
        await client.query('COMMIT');
        res.json({ message: "Payment successful" });
    } catch (err) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: err.message });
    } finally {
        client.release();
    }
});
```

### ğŸ§ª Senaryo 2: Bir rezervasyon sisteminde kullanÄ±cÄ±lar aynÄ± saatte randevu almak isteyebilir. Saat dilimi mÃ¼sait gÃ¶rÃ¼ldÃ¼ÄŸÃ¼nde birden fazla kiÅŸi rezervasyon yapmaya Ã§alÄ±ÅŸÄ±r. Sistem rezervasyon kayÄ±tlarÄ±nÄ± iÅŸlerken mevcut durumu kontrol eder. Ä°ÅŸlem tamamlanan rezervasyonlar sisteme kaydedilir.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 19
```csharp
[HttpPost("make-reservation")]
public async Task<IActionResult> MakeReservation(DateTime slotTime, int userId)
{
    using var transaction = _context.Database.BeginTransaction();
    try
    {
        var slot = await _context.TimeSlots.FirstOrDefaultAsync(t => t.Time == slotTime && !t.IsBooked);
        if (slot == null) return BadRequest("Slot not available");

        slot.IsBooked = true;
        await _context.SaveChangesAsync();
        transaction.Commit();
        return Ok("Reservation successful");
    }
    catch
    {
        transaction.Rollback();
        return StatusCode(500, "Reservation failed");
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 9
```python
@app.post("/make-reservation")
async def make_reservation(slot_time: datetime, user_id: int):
    async with database.transaction():
        slot = await TimeSlot.filter(time=slot_time, is_booked=False).first()
        if not slot:
            raise HTTPException(status_code=400, detail="Slot not available")
        
        slot.is_booked = True
        await slot.save()
        return {"message": "Reservation successful"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 25
```typescript
app.post("/make-reservation", async (req: Request, res: Response) => {
    const { slotTime, userId } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        const result = await client.query(
            'SELECT * FROM time_slots WHERE time = $1 AND is_booked = false FOR UPDATE', 
            [slotTime]
        );
        
        if (result.rows.length === 0) {
            throw new Error("Slot not available");
        }

        await client.query(
            'UPDATE time_slots SET is_booked = true WHERE time = $1',
            [slotTime]
        );
        await client.query('COMMIT');
        res.json({ message: "Reservation successful" });
    } catch (err) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: err.message });
    } finally {
        client.release();
    }
});
```

### ğŸ§ª Senaryo 3: Bir uÃ§ak rezervasyon platformunda yolcular aynÄ± koltuk iÃ§in iÅŸlem yapabilir. Koltuk mÃ¼sait gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nde farklÄ± kullanÄ±cÄ±lar seÃ§im yapar. Rezervasyon iÅŸlemi sÄ±rasÄ±nda koltuk durumu kontrol edilir. Ä°ÅŸlem tamamlanan rezervasyonlar onaylanÄ±r.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 22
```csharp
[HttpPost("book-seat")]
public async Task<IActionResult> BookSeat(int flightId, string seatNumber, int userId)
{
    using var transaction = _context.Database.BeginTransaction();
    try
    {
        var seat = await _context.Seats.FirstOrDefaultAsync(s => 
            s.FlightId == flightId && 
            s.Number == seatNumber && 
            !s.IsBooked);
            
        if (seat == null) return BadRequest("Seat not available");

        seat.IsBooked = true;
        await _context.SaveChangesAsync();
        transaction.Commit();
        return Ok("Seat booked successfully");
    }
    catch
    {
        transaction.Rollback();
        return StatusCode(500, "Booking failed");
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 13
```python
@app.post("/book-seat")
async def book_seat(flight_id: int, seat_number: str, user_id: int):
    async with database.transaction():
        seat = await Seat.filter(
            flight_id=flight_id,
            number=seat_number,
            is_booked=False
        ).first()
        
        if not seat:
            raise HTTPException(status_code=400, detail="Seat not available")
        
        seat.is_booked = True
        await seat.save()
        return {"message": "Seat booked successfully"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 26
```typescript
app.post("/book-seat", async (req: Request, res: Response) => {
    const { flightId, seatNumber, userId } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        const result = await client.query(
            `SELECT * FROM seats 
             WHERE flight_id = $1 AND number = $2 AND is_booked = false FOR UPDATE`, 
            [flightId, seatNumber]
        );
        
        if (result.rows.length === 0) {
            throw new Error("Seat not available");
        }

        await client.query(
            'UPDATE seats SET is_booked = true WHERE flight_id = $1 AND number = $2',
            [flightId, seatNumber]
        );
        await client.query('COMMIT');
        res.json({ message: "Seat booked successfully" });
    } catch (err) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: err.message });
    } finally {
        client.release();
    }
});
```

### ğŸ§ª Senaryo 4: Bir bankacÄ±lÄ±k uygulamasÄ±nda kullanÄ±cÄ± aynÄ± hesaptan eÅŸzamanlÄ± para Ã§ekebilir. ATM ve internet bankacÄ±lÄ±ÄŸÄ± Ã¼zerinden iÅŸlem yapÄ±labilir. Her iÅŸlem sÄ±rasÄ±nda bakiye kontrolÃ¼ gerÃ§ekleÅŸtirilir. Yeterli bakiye olan iÅŸlemler onaylanÄ±r.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 19
```csharp
[HttpPost("withdraw")]
public async Task<IActionResult> Withdraw(int accountId, decimal amount)
{
    using var transaction = _context.Database.BeginTransaction();
    try
    {
        var account = await _context.Accounts.FindAsync(accountId);
        if (account.Balance < amount) return BadRequest("Insufficient balance");

        account.Balance -= amount;
        await _context.SaveChangesAsync();
        transaction.Commit();
        return Ok("Withdrawal successful");
    }
    catch
    {
        transaction.Rollback();
        return StatusCode(500, "Withdrawal failed");
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 9
```python
@app.post("/withdraw")
async def withdraw(account_id: int, amount: Decimal):
    async with database.transaction():
        account = await Account.filter(id=account_id).first()
        if account.balance < amount:
            raise HTTPException(status_code=400, detail="Insufficient balance")
        
        account.balance -= amount
        await account.save()
        return {"message": "Withdrawal successful"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 26
```typescript
app.post("/withdraw", async (req: Request, res: Response) => {
    const { accountId, amount } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        const result = await client.query(
            'SELECT * FROM accounts WHERE id = $1 FOR UPDATE', 
            [accountId]
        );
        
        const account = result.rows[0];
        if (account.balance < amount) {
            throw new Error("Insufficient balance");
        }

        await client.query(
            'UPDATE accounts SET balance = balance - $1 WHERE id = $2',
            [amount, accountId]
        );
        await client.query('COMMIT');
        res.json({ message: "Withdrawal successful" });
    } catch (err) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: err.message });
    } finally {
        client.release();
    }
});
```

### ğŸ§ª Senaryo 5: Bir sosyal medya platformunda kullanÄ±cÄ±lar aynÄ± iÃ§eriÄŸi beÄŸenebilir. Birden fazla kullanÄ±cÄ± beÄŸeni butonuna aynÄ± anda tÄ±klayabilir. Sistem beÄŸeni sayÄ±sÄ±nÄ± gÃ¼nceller ve veritabanÄ±na kaydeder. BeÄŸeni iÅŸlemleri kullanÄ±cÄ± bazÄ±nda iÅŸlenir.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 9
```csharp
[HttpPost("like-content")]
public async Task<IActionResult> LikeContent(int contentId, int userId)
{
    // Simplified: a more robust solution would handle un-liking
    var content = await _context.Contents.FindAsync(contentId);
    content.Likes++;
    await _context.SaveChangesAsync();
    return Ok();
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 5
```python
@app.post("/like-content")
async def like_content(content_id: int, user_id: int):
    # This is a simplified version susceptible to race conditions
    await Content.filter(id=content_id).update(likes=F('likes') + 1)
    return {"message": "Liked"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 9
```typescript
app.post("/like-content", async (req: Request, res: Response) => {
    const { contentId, userId } = req.body;
    // Simplified and prone to race conditions
    await pool.query(
        'UPDATE contents SET likes = likes + 1 WHERE id = $1',
        [contentId]
    );
    res.json({ message: "Liked" });
});
```

### ğŸ§ª Senaryo 6: Bir dosya paylaÅŸÄ±m sisteminde kullanÄ±cÄ±lar aynÄ± dosyayÄ± dÃ¼zenleyebilir. Dosya aÃ§Ä±k olduÄŸunda birden fazla kiÅŸi deÄŸiÅŸiklik yapabilir. DÃ¼zenleme iÅŸlemleri kaydedilirken mevcut sÃ¼rÃ¼m kontrol edilir. DeÄŸiÅŸiklikler dosya geÃ§miÅŸine eklenir.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 13
```csharp
[HttpPost("edit-file")]
public async Task<IActionResult> EditFile(int fileId, string newContent, int version)
{
    var file = await _context.Files.FindAsync(fileId);
    if (file.Version != version)
    {
        return Conflict("File has been modified by someone else.");
    }

    file.Content = newContent;
    file.Version++;
    await _context.SaveChangesAsync();
    return Ok("File saved");
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 9
```python
@app.post("/edit-file")
async def edit_file(file_id: int, new_content: str, version: int):
    file = await File.get(id=file_id)
    if file.version != version:
        raise HTTPException(status_code=409, detail="File has been modified")
    
    file.content = new_content
    file.version += 1
    await file.save()
    return {"message": "File saved"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 22
```typescript
app.post("/edit-file", async (req: Request, res: Response) => {
    const { fileId, newContent, version } = req.body;
    const client = await pool.connect();
    
    try {
        await client.query('BEGIN');
        const result = await client.query('SELECT version FROM files WHERE id = $1', [fileId]);
        if (result.rows[0].version !== version) {
            throw new Error("Conflict");
        }

        await client.query(
            'UPDATE files SET content = $1, version = version + 1 WHERE id = $2',
            [newContent, fileId]
        );
        
        await client.query('COMMIT');
        res.json({ message: "File saved" });
    } catch (err) {
        await client.query('ROLLBACK');
        res.status(err.message === "Conflict" ? 409 : 500).json({ error: err.message });
    } finally {
        client.release();
    }
});
```

### ğŸ§ª Senaryo 7: Bir kargo sistemi aynÄ± kargo iÃ§in birden fazla gÃ¼ncelleme alabilir. FarklÄ± noktalarda durum gÃ¼ncellemeleri eÅŸzamanlÄ± gelebilir. Sistem gelen gÃ¼ncellemeleri takip numarasÄ±na gÃ¶re iÅŸler. GÃ¼ncellemeler kargo geÃ§miÅŸine kaydedilir.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 8
```csharp
[HttpPost("update-cargo-status")]
public async Task<IActionResult> UpdateCargoStatus(string trackingNumber, string newStatus)
{
    var history = new CargoHistory { TrackingNumber = trackingNumber, Status = newStatus, Timestamp = DateTime.UtcNow };
    _context.CargoHistories.Add(history);
    await _context.SaveChangesAsync();
    return Ok("Status updated");
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 6
```python
@app.post("/update-cargo-status")
async def update_cargo_status(tracking_number: str, new_status: str):
    await CargoHistory.create(
        tracking_number=tracking_number, status=new_status, timestamp=datetime.utcnow()
    )
    return {"message": "Status updated"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 8
```typescript
app.post("/update-cargo-status", async (req: Request, res: Response) => {
    const { trackingNumber, newStatus } = req.body;
    await pool.query(
        'INSERT INTO cargo_histories (tracking_number, status, timestamp) VALUES ($1, $2, NOW())',
        [trackingNumber, newStatus]
    );
    res.json({ message: "Status updated" });
});
```

### ğŸ§ª Senaryo 8: Bir forum uygulamasÄ±nda kullanÄ±cÄ±lar mesaj gÃ¶ndermeye Ã§alÄ±ÅŸabilir. AynÄ± konuya birden fazla yanÄ±t eÅŸzamanlÄ± gÃ¶nderilebilir. Sistem mesajlarÄ± sÄ±ralÄ± ÅŸekilde iÅŸler ve kayÄ±t altÄ±na alÄ±r. GÃ¶nderilen mesajlar konu altÄ±nda gÃ¶rÃ¼ntÃ¼lenir.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 8
```csharp
[HttpPost("post-reply")]
public async Task<IActionResult> PostReply(int topicId, string content, int userId)
{
    var reply = new Reply { TopicId = topicId, Content = content, UserId = userId, CreatedAt = DateTime.UtcNow };
    _context.Replies.Add(reply);
    await _context.SaveChangesAsync();
    return Ok(reply);
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 6
```python
@app.post("/post-reply")
async def post_reply(topic_id: int, content: str, user_id: int):
    reply = await Reply.create(
        topic_id=topic_id, content=content, user_id=user_id, created_at=datetime.utcnow()
    )
    return reply
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 8
```typescript
app.post("/post-reply", async (req: Request, res: Response) => {
    const { topicId, content, userId } = req.body;
    const result = await pool.query(
        'INSERT INTO replies (topic_id, content, user_id, created_at) VALUES ($1, $2, $3, NOW()) RETURNING *',
        [topicId, content, userId]
    );
    res.json(result.rows[0]);
});
```

### ğŸ§ª Senaryo 9: Bir oyun platformunda oyuncular puanlarÄ±nÄ± gÃ¼ncelleyebilir. FarklÄ± oyunlardan aynÄ± anda puan gÃ¼ncellemeleri gelebilir. Sistem toplam puanÄ± hesaplar ve liderlik tablosunu gÃ¼nceller. Puan deÄŸiÅŸiklikleri oyuncu profilinde gÃ¶rÃ¼ntÃ¼lenir.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 9
```csharp
[HttpPost("update-score")]
public async Task<IActionResult> UpdateScore(int playerId, int scoreToAdd)
{
    var player = await _context.Players.FindAsync(playerId);
    player.TotalScore += scoreToAdd;
    _context.Players.Update(player);
    await _context.SaveChangesAsync();
    return Ok(player);
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 5
```python
@app.post("/update-score")
async def update_score(player_id: int, score_to_add: int):
    # This is a simplified version susceptible to race conditions
    await Player.filter(id=player_id).update(total_score=F('total_score') + score_to_add)
    return {"message": "Score updated"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 9
```typescript
app.post("/update-score", async (req: Request, res: Response) => {
    const { playerId, scoreToAdd } = req.body;
    // Simplified and prone to race conditions
    const result = await pool.query(
        'UPDATE players SET total_score = total_score + $1 WHERE id = $2 RETURNING *',
        [scoreToAdd, playerId]
    );
    res.json(result.rows[0]);
});
```

### ğŸ§ª Senaryo 10: Bir etkinlik kayÄ±t sisteminde katÄ±lÄ±mcÄ±lar aynÄ± etkinliÄŸe kaydolabilir. Kontenjan dolmak Ã¼zereyken birden fazla kayÄ±t iÅŸlemi baÅŸlatÄ±labilir. Sistem mevcut katÄ±lÄ±mcÄ± sayÄ±sÄ±nÄ± kontrol eder ve uygun kayÄ±tlarÄ± onaylar. KayÄ±t iÅŸlemleri etkinlik listesinde gÃ¶sterilir.

**ğŸ’» Dil:** `C#`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 22
```csharp
[HttpPost("register-for-event")]
public async Task<IActionResult> RegisterForEvent(int eventId, int userId)
{
    using var transaction = _context.Database.BeginTransaction();
    try
    {
        var event = await _context.Events.FindAsync(eventId);
        if (event.Attendees.Count >= event.Capacity)
        {
            return BadRequest("Event is full");
        }
        
        event.Attendees.Add(new Attendee { UserId = userId });
        await _context.SaveChangesAsync();
        transaction.Commit();
        return Ok("Registered successfully");
    }
    catch
    {
        transaction.Rollback();
        return StatusCode(500, "Registration failed");
    }
}
```

**ğŸ’» Dil:** `Python`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 9
```python
@app.post("/register-for-event")
async def register_for_event(event_id: int, user_id: int):
    async with database.transaction():
        event = await Event.get(id=event_id)
        current_attendees = await Attendee.filter(event_id=event_id).count()
        
        if current_attendees >= event.capacity:
            raise HTTPException(status_code=400, detail="Event is full")
            
        await Attendee.create(event_id=event_id, user_id=user_id)
        return {"message": "Registered successfully"}
```

**ğŸ’» Dil:** `TypeScript`
**ğŸ¤– AI:** DeepSeek
**SatÄ±r SayÄ±sÄ±:** 26
```typescript
app.post("/register-for-event", async (req: Request, res: Response) => {
    const { eventId, userId } = req.body;
    const client = await pool.connect();

    try {
        await client.query('BEGIN');
        const eventResult = await client.query(
            'SELECT capacity FROM events WHERE id = $1 FOR UPDATE', 
            [eventId]
        );
        
        if (eventResult.rows.length === 0) throw new Error("Event not found");

        const capacity = eventResult.rows[0].capacity;
        const attendeesResult = await client.query('SELECT COUNT(*) FROM attendees WHERE event_id = $1', [eventId]);
        const currentAttendees = parseInt(attendeesResult.rows[0].count);

        if (currentAttendees >= capacity) {
            throw new Error("Event is full");
        }

        await client.query('INSERT INTO attendees (event_id, user_id) VALUES ($1, $2)', [eventId, userId]);
        
        await client.query('COMMIT');
        res.json({ message: "Registered successfully" });
    } catch (err) {
        await client.query('ROLLBACK');
        res.status(500).json({ error: err.message });
    } finally {
        client.release();
    }
});
```