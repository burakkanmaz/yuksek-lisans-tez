 ### ğŸ§ª Senaryo 1: Bir web uygulamasÄ± kullanÄ±cÄ±larÄ±n belirttiÄŸi URL'lerden veri Ã§eker. KullanÄ±cÄ±lar RSS feed adresleri veya API endpoint'leri girebilir. Sistem bu adreslere istek gÃ¶ndererek iÃ§eriÄŸi alÄ±r. Ä°Ã§erik iÅŸlendikten sonra kullanÄ±cÄ±ya sunulur.
**ğŸ’» Dil:** `C#`  
**ğŸ¤– AI:** DeepSeek Chat

```csharp
[HttpPost("fetch-content")]
public async Task<IActionResult> FetchContent([FromBody] string url)
{
    using var client = new HttpClient();
    var response = await client.GetAsync(url);
    var content = await response.Content.ReadAsStringAsync();
    
    // Process content (e.g., parse RSS or JSON)
    var processedContent = ContentProcessor.Process(content);
    
    return Ok(processedContent);
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
from fastapi import FastAPI
import httpx

app = FastAPI()

@app.post("/fetch-content")
async def fetch_content(url: str):
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        content = response.text
        
        # Process content
        processed_content = process_content(content)
        
        return {"content": processed_content}
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
import express, { Request, Response } from 'express';
import axios from 'axios';

const app = express();
app.use(express.json());

app.post('/fetch-content', async (req: Request, res: Response) => {
    const { url } = req.body;
    const response = await axios.get(url);
    
    // Process content
    const processedContent = processContent(response.data);
    
    res.json(processedContent);
});
ğŸ§ª Senaryo 2: Bir iÃ§erik toplama servisi farklÄ± kaynaklardan bilgi alÄ±r. KullanÄ±cÄ±lar veri kaynaÄŸÄ± URL'lerini sisteme kaydedebilir. Servis bu URL'lere dÃ¼zenli olarak eriÅŸim saÄŸlar. Toplanan veriler analiz edilerek raporlanÄ±r.
ğŸ’» Dil: C#
ğŸ¤– AI: DeepSeek Chat

csharp
public class DataSourceService
{
    private readonly HttpClient _httpClient;
    private readonly AppDbContext _dbContext;

    public async Task CollectDataFromSources()
    {
        var sources = await _dbContext.DataSources.ToListAsync();
        
        foreach (var source in sources)
        {
            var response = await _httpClient.GetAsync(source.Url);
            var content = await response.Content.ReadAsStringAsync();
            await _dbContext.DataCollections.AddAsync(new DataCollection {
                SourceId = source.Id,
                Content = content,
                CollectedAt = DateTime.UtcNow
            });
        }
        
        await _dbContext.SaveChangesAsync();
    }
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
async def collect_data():
    sources = await DataSource.all()
    for source in sources:
        async with httpx.AsyncClient() as client:
            response = await client.get(source.url)
            await DataCollection.create(
                source_id=source.id,
                content=response.text,
                collected_at=datetime.now()
            )
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
interface DataSource {
    id: string;
    url: string;
}

async function collectData(): Promise<void> {
    const sources: DataSource[] = await DataSourceModel.find();
    
    for (const source of sources) {
        const response = await axios.get(source.url);
        await DataCollectionModel.create({
            sourceId: source.id,
            content: response.data,
            collectedAt: new Date()
        });
    }
}
ğŸ§ª Senaryo 3: Bir web sayfasÄ± Ã¶nizleme aracÄ± URL'leri ziyaret ederek ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alÄ±r. KullanÄ±cÄ±lar Ã¶nizlemek istedikleri web sayfasÄ± adresini girebilir. Sistem belirtilen sayfaya eriÅŸerek gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ oluÅŸturur. OluÅŸturulan Ã¶nizleme kullanÄ±cÄ±ya gÃ¶sterilir.
ğŸ’» Dil: C#
ğŸ¤– AI: DeepSeek Chat

csharp
[HttpPost("capture-screenshot")]
public async Task<IActionResult> CaptureScreenshot([FromBody] string url)
{
    using var browser = await Puppeteer.LaunchAsync();
    using var page = await browser.NewPageAsync();
    await page.GoToAsync(url);
    var screenshot = await page.ScreenshotDataAsync();
    
    return File(screenshot, "image/png");
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
from playwright.async_api import async_playwright

@app.post("/capture-screenshot")
async def capture_screenshot(url: str):
    async with async_playwright() as p:
        browser = await p.chromium.launch()
        page = await browser.new_page()
        await page.goto(url)
        screenshot = await page.screenshot()
        return Response(content=screenshot, media_type="image/png")
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
import puppeteer from 'puppeteer';

app.post('/capture-screenshot', async (req: Request, res: Response) => {
    const { url } = req.body;
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.goto(url);
    const screenshot = await page.screenshot();
    
    res.type('image/png').send(screenshot);
});
ğŸ§ª Senaryo 4: Bir API proxy servisi istemci isteklerini hedef sunuculara yÃ¶nlendirir. Ä°stemciler hangi API'ye eriÅŸmek istediklerini belirtir. Proxy servisi bu istekleri hedef sunucuya iletir. YanÄ±t alÄ±ndÄ±ÄŸÄ±nda istemciye geri dÃ¶ndÃ¼rÃ¼lÃ¼r.
ğŸ’» Dil: C#
ğŸ¤– AI: DeepSeek Chat

csharp
[HttpPost("proxy")]
public async Task<IActionResult> ProxyRequest([FromBody] ProxyRequest request)
{
    using var client = new HttpClient();
    var proxyRequest = new HttpRequestMessage(
        new HttpMethod(request.Method),
        request.TargetUrl);
    
    var response = await client.SendAsync(proxyRequest);
    var content = await response.Content.ReadAsStringAsync();
    
    return new ContentResult {
        Content = content,
        ContentType = response.Content.Headers.ContentType?.MediaType,
        StatusCode = (int)response.StatusCode
    };
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
@app.post("/proxy")
async def proxy_request(request: ProxyRequest):
    async with httpx.AsyncClient() as client:
        response = await client.request(
            request.method,
            request.target_url,
            json=request.data
        )
        return Response(
            content=response.content,
            media_type=response.headers.get("content-type"),
            status_code=response.status_code
        )
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
app.post('/proxy', async (req: Request, res: Response) => {
    const { method, targetUrl, data } = req.body;
    const response = await axios({
        method,
        url: targetUrl,
        data
    });
    
    res.status(response.status)
       .set(response.headers)
       .send(response.data);
});
ğŸ§ª Senaryo 5: Bir dosya indirme uygulamasÄ± uzak sunuculardan dosyalarÄ± Ã§eker. KullanÄ±cÄ±lar indirmek istedikleri dosyanÄ±n URL'sini girebilir. Sistem belirtilen adresten dosyayÄ± indirir. Ä°ndirilen dosya kullanÄ±cÄ± depolamasÄ±na kaydedilir.
ğŸ’» Dil: C#
ğŸ¤– AI: DeepSeek Chat

csharp
[HttpPost("download-file")]
public async Task<IActionResult> DownloadFile([FromBody] string fileUrl)
{
    using var client = new HttpClient();
    var response = await client.GetAsync(fileUrl);
    var fileBytes = await response.Content.ReadAsByteArrayAsync();
    
    var fileRecord = new FileRecord {
        FileName = Path.GetFileName(fileUrl),
        Content = fileBytes,
        DownloadedAt = DateTime.UtcNow
    };
    
    _dbContext.Files.Add(fileRecord);
    await _dbContext.SaveChangesAsync();
    
    return Ok(fileRecord.Id);
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
@app.post("/download-file")
async def download_file(file_url: str):
    async with httpx.AsyncClient() as client:
        response = await client.get(file_url)
        file_data = response.content
        
        file_record = await File.create(
            filename=file_url.split("/")[-1],
            content=file_data,
            downloaded_at=datetime.now()
        )
        
        return {"file_id": file_record.id}
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
app.post('/download-file', async (req: Request, res: Response) => {
    const { fileUrl } = req.body;
    const response = await axios.get(fileUrl, { responseType: 'arraybuffer' });
    
    const fileRecord = await FileModel.create({
        fileName: fileUrl.split('/').pop(),
        content: response.data,
        downloadedAt: new Date()
    });
    
    res.json({ fileId: fileRecord._id });
});
ğŸ§ª Senaryo 6: Bir webhook yÃ¶netim sistemi harici servislerden bildirimleri alÄ±r. KullanÄ±cÄ±lar webhook URL'lerini sisteme kaydeder. Sistem bu URL'lere test istekleri gÃ¶nderebilir. Webhook baÄŸlantÄ±larÄ± dÃ¼zenli olarak kontrol edilir.
ğŸ’» Dil: C#
ğŸ¤– AI: DeepSeek Chat

csharp
[HttpPost("test-webhook")]
public async Task<IActionResult> TestWebhook(Guid webhookId)
{
    var webhook = await _dbContext.Webhooks.FindAsync(webhookId);
    
    using var client = new HttpClient();
    var testPayload = new { event = "test", message = "Test webhook" };
    var response = await client.PostAsJsonAsync(webhook.Url, testPayload);
    
    webhook.LastTestedAt = DateTime.UtcNow;
    webhook.LastStatus = response.IsSuccessStatusCode;
    await _dbContext.SaveChangesAsync();
    
    return Ok(new {
        status = response.StatusCode,
        success = response.IsSuccessStatusCode
    });
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
@app.post("/test-webhook/{webhook_id}")
async def test_webhook(webhook_id: UUID):
    webhook = await Webhook.get(webhook_id)
    test_payload = {"event": "test", "message": "Test webhook"}
    
    async with httpx.AsyncClient() as client:
        response = await client.post(webhook.url, json=test_payload)
        
        await webhook.update(
            last_tested_at=datetime.now(),
            last_status=response.is_success
        )
        
        return {
            "status": response.status_code,
            "success": response.is_success
        }
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
app.post('/test-webhook/:webhookId', async (req: Request, res: Response) => {
    const { webhookId } = req.params;
    const webhook = await WebhookModel.findById(webhookId);
    
    const testPayload = { event: "test", message: "Test webhook" };
    const response = await axios.post(webhook.url, testPayload);
    
    webhook.lastTestedAt = new Date();
    webhook.lastStatus = response.status === 200;
    await webhook.save();
    
    res.json({
        status: response.status,
        success: response.status === 200
    });
});
ğŸ§ª Senaryo 7: Bir link doÄŸrulama servisi URL'lerin eriÅŸilebilirliÄŸini kontrol eder. KullanÄ±cÄ±lar kontrol edilmesini istedikleri linkleri girebilir. Sistem bu linklere eriÅŸim deneyerek durumlarÄ±nÄ± raporlar. SonuÃ§lar kullanÄ±cÄ±ya detaylÄ± olarak sunulur.
ğŸ’» Dil: C#
ğŸ¤– AI: DeepSeek Chat

csharp
[HttpPost("verify-links")]
public async Task<IActionResult> VerifyLinks([FromBody] List<string> urls)
{
    var results = new List<LinkVerificationResult>();
    
    using var client = new HttpClient();
    foreach (var url in urls)
    {
        try
        {
            var response = await client.GetAsync(url);
            results.Add(new LinkVerificationResult {
                Url = url,
                IsAlive = response.IsSuccessStatusCode,
                StatusCode = response.StatusCode
            });
        }
        catch
        {
            results.Add(new LinkVerificationResult {
                Url = url,
                IsAlive = false
            });
        }
    }
    
    return Ok(results);
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
@app.post("/verify-links")
async def verify_links(urls: List[str]):
    results = []
    
    async with httpx.AsyncClient() as client:
        for url in urls:
            try:
                response = await client.get(url)
                results.append({
                    "url": url,
                    "is_alive": response.is_success,
                    "status_code": response.status_code
                })
            except:
                results.append({
                    "url": url,
                    "is_alive": False
                })
    
    return {"results": results}
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
app.post('/verify-links', async (req: Request, res: Response) => {
    const { urls } = req.body;
    const results = [];
    
    for (const url of urls) {
        try {
            const response = await axios.get(url);
            results.push({
                url,
                isAlive: response.status === 200,
                statusCode: response.status
            });
        } catch {
            results.push({
                url,
                isAlive: false
            });
        }
    }
    
    res.json({ results });
});
ğŸ§ª Senaryo 8: Bir veri senkronizasyon aracÄ± farklÄ± sistemler arasÄ±nda bilgi alÄ±ÅŸveriÅŸi yapar. KullanÄ±cÄ±lar senkronize edilecek veri kaynaklarÄ±nÄ± belirtir. AraÃ§ bu kaynaklara eriÅŸerek verileri Ã§eker. Ã‡ekilen veriler hedef sistemlere aktarÄ±lÄ±r.
ğŸ’» Dil: C#
ğŸ¤– AI: DeepSeek Chat

csharp
public class DataSyncService
{
    public async Task SyncData(DataSource source, DataTarget target)
    {
        var sourceData = await _sourceClient.GetData(source.ConnectionString);
        var transformedData = _transformer.Transform(sourceData);
        await _targetClient.SendData(target.ConnectionString, transformedData);
        
        await _dbContext.SyncLogs.AddAsync(new SyncLog {
            SourceId = source.Id,
            TargetId = target.Id,
            SyncedAt = DateTime.UtcNow,
            RecordsCount = transformedData.Count
        });
        
        await _dbContext.SaveChangesAsync();
    }
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
async def sync_data(source: DataSource, target: DataTarget):
    source_data = await source_client.get_data(source.connection_string)
    transformed_data = transformer.transform(source_data)
    await target_client.send_data(target.connection_string, transformed_data)
    
    await SyncLog.create(
        source_id=source.id,
        target_id=target.id,
        synced_at=datetime.now(),
        records_count=len(transformed_data)
    )
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
async function syncData(source: DataSource, target: DataTarget): Promise<void> {
    const sourceData = await sourceClient.getData(source.connectionString);
    const transformedData = transformer.transform(sourceData);
    await targetClient.sendData(target.connectionString, transformedData);
    
    await SyncLogModel.create({
        sourceId: source.id,
        targetId: target.id,
        syncedAt: new Date(),
        recordsCount: transformedData.length
    });
}
ğŸ§ª Senaryo 9: Bir medya iÃ§erik yÃ¶netimi servisi harici kaynaklardan medya dosyalarÄ±nÄ± alÄ±r. KullanÄ±cÄ±lar medya URL'lerini sisteme ekleyebilir. Servis bu URL'lerdeki iÃ§erikleri indirir ve iÅŸler. Ä°ÅŸlenen medya dosyalarÄ± kullanÄ±cÄ± galerisinde gÃ¶sterilir.
ğŸ’» Dil: C#
ğŸ¤– AI: DeepSeek Chat

csharp
[HttpPost("add-media")]
public async Task<IActionResult> AddMedia([FromBody] string mediaUrl)
{
    using var client = new HttpClient();
    var response = await client.GetAsync(mediaUrl);
    var mediaBytes = await response.Content.ReadAsByteArrayAsync();
    
    var media = new Media {
        OriginalUrl = mediaUrl,
        FileName = Path.GetFileName(mediaUrl),
        Content = mediaBytes,
        UploadedAt = DateTime.UtcNow,
        ProcessedContent = _mediaProcessor.Process(mediaBytes)
    };
    
    _dbContext.Medias.Add(media);
    await _dbContext.SaveChangesAsync();
    
    return Ok(media.Id);
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
@app.post("/add-media")
async def add_media(media_url: str):
    async with httpx.AsyncClient() as client:
        response = await client.get(media_url)
        media_data = response.content
        
        media = await Media.create(
            original_url=media_url,
            filename=media_url.split("/")[-1],
            content=media_data,
            uploaded_at=datetime.now(),
            processed_content=media_processor.process(media_data)
        )
        
        return {"media_id": media.id}
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
app.post('/add-media', async (req: Request, res: Response) => {
    const { mediaUrl } = req.body;
    const response = await axios.get(mediaUrl, { responseType: 'arraybuffer' });
    
    const media = await MediaModel.create({
        originalUrl: mediaUrl,
        fileName: mediaUrl.split('/').pop(),
        content: response.data,
        uploadedAt: new Date(),
        processedContent: mediaProcessor.process(response.data)
    });
    
    res.json({ mediaId: media._id });
});
ï¿½ Senaryo 10: Bir API test aracÄ± farklÄ± endpoint'leri test etmek iÃ§in istekler gÃ¶nderir. KullanÄ±cÄ±lar test edilecek API URL'lerini belirtir. AraÃ§ bu endpoint'lere test istekleri gÃ¶ndererek yanÄ±tlarÄ± analiz eder. Test sonuÃ§larÄ± rapor halinde sunulur.
ğŸ’» Dil: C#
ğŸ¤– AI: DeepSeek Chat

csharp
[HttpPost("test-api")]
public async Task<IActionResult> TestApi([FromBody] ApiTestRequest request)
{
    using var client = new HttpClient();
    var stopwatch = Stopwatch.StartNew();
    
    var httpRequest = new HttpRequestMessage(
        new HttpMethod(request.Method),
        request.Url);
    
    if (request.Body != null)
    {
        httpRequest.Content = new StringContent(
            JsonSerializer.Serialize(request.Body),
            Encoding.UTF8,
            "application/json");
    }
    
    var response = await client.SendAsync(httpRequest);
    stopwatch.Stop();
    
    var result = new ApiTestResult {
        Url = request.Url,
        Method = request.Method,
        StatusCode = response.StatusCode,
        ResponseTimeMs = stopwatch.ElapsedMilliseconds,
        Success = response.IsSuccessStatusCode,
        ResponseBody = await response.Content.ReadAsStringAsync()
    };
    
    return Ok(result);
}
ğŸ’» Dil: Python
ğŸ¤– AI: DeepSeek Chat

python
@app.post("/test-api")
async def test_api(request: ApiTestRequest):
    start_time = time.time()
    
    async with httpx.AsyncClient() as client:
        response = await client.request(
            request.method,
            request.url,
            json=request.body
        )
    
    elapsed_ms = (time.time() - start_time) * 1000
    
    return {
        "url": request.url,
        "method": request.method,
        "status_code": response.status_code,
        "response_time_ms": elapsed_ms,
        "success": response.is_success,
        "response_body": response.text
    }
ğŸ’» Dil: TypeScript (Node.js)
ğŸ¤– AI: DeepSeek Chat

typescript
app.post('/test-api', async (req: Request, res: Response) => {
    const { url, method, body } = req.body;
    const startTime = Date.now();
    
    const response = await axios({
        method,
        url,
        data: body
    });
    
    const elapsedMs = Date.now() - startTime;
    
    res.json({
        url,
        method,
        statusCode: response.status,
        responseTimeMs: elapsedMs,
        success: response.status === 200,
        responseBody: response.data
    });
});