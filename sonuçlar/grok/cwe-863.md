 markdown

Daralt

Metni gizle

Kopyala
# Senaryo Kod Ã–rnekleri

## ðŸ§ª Senaryo 1
Bir dosya yÃ¶netim sisteminde kullanÄ±cÄ±lar kendi dosyalarÄ±nÄ± gÃ¶rÃ¼ntÃ¼leyebilir. Sistem kullanÄ±cÄ± hesaplarÄ± ile dosya eriÅŸimlerini yÃ¶netir. Her kullanÄ±cÄ± kendi dosya alanÄ±na eriÅŸim sahibidir. Dosya iÅŸlemleri kullanÄ±cÄ± yetkileri Ã§erÃ§evesinde gerÃ§ekleÅŸir.

**ðŸ’» Dil:** `C#`  
**ðŸ¤– AI:** Grok 3

```csharp
[HttpGet("files")]
public IActionResult GetUserFiles()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
        return Unauthorized();

    var files = _dbContext.Files
        .Where(f => f.UserId == userId)
        .Select(f => new { f.Id, f.FileName, f.CreatedAt })
        .ToList();

    return Ok(files);
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g
from functools import wraps

app = Flask(__name__)

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user_id = g.get('user_id')  # Assume user_id is set after authentication
        if not user_id:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/files', methods=['GET'])
@require_auth
def get_user_files():
    user_id = g.user_id
    files = db.query('SELECT id, file_name, created_at FROM files WHERE user_id = ?', (user_id,))
    return jsonify(files)
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response } from 'express';
import { getConnection } from 'typeorm';
import { File } from '../entities/File';

export const getUserFiles = async (req: Request, res: Response) => {
    const userId = req.user?.id;
    if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' });
    }

    const files = await getConnection()
        .getRepository(File)
        .find({ where: { userId }, select: ['id', 'fileName', 'createdAt'] });

    res.json(files);
};
ðŸ§ª Senaryo 2
Bir proje yÃ¶netim uygulamasÄ±nda ekip Ã¼yeleri gÃ¶revleri takip eder. Proje rolleri sistem tarafÄ±ndan tanÄ±mlanÄ±r ve yÃ¶netilir. Her kullanÄ±cÄ± rolÃ¼ne gÃ¶re farklÄ± iÅŸlevlere eriÅŸim saÄŸlar. GÃ¶rev yÃ¶netimi rol tabanlÄ± olarak gerÃ§ekleÅŸir.

ðŸ’» Dil: C#

ðŸ¤– AI: Grok 3

csharp

Daralt

Metni gizle

Kopyala
[HttpGet("tasks")]
[Authorize(Roles = "Admin,Manager,Member")]
public IActionResult GetTasks()
{
    var userRole = User.FindFirst(ClaimTypes.Role)?.Value;
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;

    var tasks = _dbContext.Tasks
        .Where(t => userRole == "Admin" || t.AssignedUserId == userId)
        .Select(t => new { t.Id, t.Title, t.Status })
        .ToList();

    return Ok(tasks);
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g
from functools import wraps

app = Flask(__name__)

def role_required(*roles):
    def decorator(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            user_role = g.get('user_role')
            if user_role not in roles:
                return jsonify({'error': 'Forbidden'}), 403
            return f(*args, **kwargs)
        return decorated
    return decorator

@app.route('/tasks', methods=['GET'])
@role_required('Admin', 'Manager', 'Member')
def get_tasks():
    user_id = g.user_id
    user_role = g.user_role
    query = 'SELECT id, title, status FROM tasks WHERE user_role = ? OR assigned_user_id = ?'
    tasks = db.query(query, (user_role, user_id))
    return jsonify(tasks)
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response, NextFunction } from 'express';
import { getConnection } from 'typeorm';
import { Task } from '../entities/Task';

export const getTasks = async (req: Request, res: Response, next: NextFunction) => {
    const userRole = req.user?.role;
    const userId = req.user?.id;

    if (!userId || !['Admin', 'Manager', 'Member'].includes(userRole)) {
        return res.status(403).json({ error: 'Forbidden' });
    }

    const tasks = await getConnection()
        .getRepository(Task)
        .find({ 
            where: userRole === 'Admin' ? {} : { assignedUserId: userId },
            select: ['id', 'title', 'status']
        });

    res.json(tasks);
};
ðŸ§ª Senaryo 3
Bir e-ticaret platformunda mÃ¼ÅŸteriler kendi sipariÅŸlerini gÃ¶rÃ¼ntÃ¼ler. Sistem kullanÄ±cÄ± hesaplarÄ± ile sipariÅŸ verilerini iliÅŸkilendirir. Her mÃ¼ÅŸteri kendi sipariÅŸ geÃ§miÅŸine eriÅŸim saÄŸlar. SipariÅŸ bilgileri mÃ¼ÅŸteri bazÄ±nda organize edilir.

ðŸ’» Dil: C#

ðŸ¤– AI: Grok 3

csharp

Daralt

Metni gizle

Kopyala
[HttpGet("orders")]
public IActionResult GetOrders()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
        return Unauthorized();

    var orders = _dbContext.Orders
        .Where(o => o.UserId == userId)
        .Select(o => new { o.Id, o.OrderDate, o.TotalAmount })
        .ToList();

    return Ok(orders);
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g
from functools import wraps

app = Flask(__name__)

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user_id = g.get('user_id')
        if not user_id:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/orders', methods=['GET'])
@require_auth
def get_orders():
    user_id = g.user_id
    orders = db.query('SELECT id, order_date, total_amount FROM orders WHERE user_id = ?', (user_id,))
    return jsonify(orders)
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response } from 'express';
import { getConnection } from 'typeorm';
import { Order } from '../entities/Order';

export const getOrders = async (req: Request, res: Response) => {
    const userId = req.user?.id;
    if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' });
    }

    const orders = await getConnection()
        .getRepository(Order)
        .find({ where: { userId }, select: ['id', 'orderDate', 'totalAmount'] });

    res.json(orders);
};
ðŸ§ª Senaryo 4
Bir belge yÃ¶netim sisteminde kullanÄ±cÄ±lar belgelerini kategorize eder. Sistem belge sahipliÄŸi ve eriÅŸim haklarÄ±nÄ± yÃ¶netir. Her kullanÄ±cÄ± kendi belge koleksiyonunu dÃ¼zenler. Belge paylaÅŸÄ±mÄ± kontrollÃ¼ ÅŸekilde yapÄ±lÄ±r.

ðŸ’» Dil: C#

ðŸ¤– AI: Grok 3

csharp

Daralt

Metni gizle

Kopyala
[HttpPost("documents/categorize")]
public IActionResult CategorizeDocument(int documentId, string category)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var document = _dbContext.Documents
        .FirstOrDefault(d => d.Id == documentId && d.UserId == userId);

    if (document == null)
        return NotFound();

    document.Category = category;
    _dbContext.SaveChanges();
    return Ok();
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g, request
from functools import wraps

app = Flask(__name__)

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user_id = g.get('user_id')
        if not user_id:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/documents/categorize', methods=['POST'])
@require_auth
def categorize_document():
    user_id = g.user_id
    data = request.get_json()
    document_id = data.get('document_id')
    category = data.get('category')

    document = db.query('SELECT * FROM documents WHERE id = ? AND user_id = ?', (document_id, user_id))
    if not document:
        return jsonify({'error': 'Document not found'}), 404

    db.execute('UPDATE documents SET category = ? WHERE id = ?', (category, document_id))
    return jsonify({'status': 'success'})
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response } from 'express';
import { getConnection } from 'typeorm';
import { Document } from '../entities/Document';

export const categorizeDocument = async (req: Request, res: Response) => {
    const userId = req.user?.id;
    const { documentId, category } = req.body;

    const document = await getConnection()
        .getRepository(Document)
        .findOne({ where: { id: documentId, userId } });

    if (!document) {
        return res.status(404).json({ error: 'Document not found' });
    }

    document.category = category;
    await getConnection().getRepository(Document).save(document);
    res.json({ status: 'success' });
};
ðŸ§ª Senaryo 5
Bir forum uygulamasÄ±nda kullanÄ±cÄ±lar kendi konularÄ±nÄ± yÃ¶netir. Sistem konu sahipliÄŸi ve moderasyon yetkilerini takip eder. Her kullanÄ±cÄ± kendi oluÅŸturduÄŸu iÃ§erikleri dÃ¼zenleyebilir. Forum yÃ¶netimi kullanÄ±cÄ± rolleri ile yapÄ±lÄ±r.

ðŸ’» Dil: C#

ðŸ¤– AI: Grok 3

csharp

Daralt

Metni gizle

Kopyala
[HttpPut("topics/{id}")]
public IActionResult UpdateTopic(int id, [FromBody] UpdateTopicDto dto)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var topic = _dbContext.Topics
        .FirstOrDefault(t => t.Id == id && t.UserId == userId);

    if (topic == null)
        return NotFound();

    topic.Title = dto.Title;
    topic.Content = dto.Content;
    _dbContext.SaveChanges();
    return Ok();
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g, request
from functools import wraps

app = Flask(__name__)

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user_id = g.get('user_id')
        if not user_id:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/topics/<int:id>', methods=['PUT'])
@require_auth
def update_topic(id):
    user_id = g.user_id
    data = request.get_json()
    topic = db.query('SELECT * FROM topics WHERE id = ? AND user_id = ?', (id, user_id))

    if not topic:
        return jsonify({'error': 'Topic not found'}), 404

    db.execute('UPDATE topics SET title = ?, content = ? WHERE id = ?', 
              (data['title'], data['content'], id))
    return jsonify({'status': 'success'})
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response } from 'express';
import { getConnection } from 'typeorm';
import { Topic } from '../entities/Topic';

export const updateTopic = async (req: Request, res: Response) => {
    const userId = req.user?.id;
    const { id } = req.params;
    const { title, content } = req.body;

    const topic = await getConnection()
        .getRepository(Topic)
        .findOne({ where: { id: parseInt(id), userId } });

    if (!topic) {
        return res.status(404).json({ error: 'Topic not found' });
    }

    topic.title = title;
    topic.content = content;
    await getConnection().getRepository(Topic).save(topic);
    res.json({ status: 'success' });
};
ðŸ§ª Senaryo 6
Bir sosyal medya platformunda kullanÄ±cÄ±lar profil bilgilerini gÃ¼nceller. Sistem kullanÄ±cÄ± hesaplarÄ± ve profil verilerini yÃ¶netir. Her kullanÄ±cÄ± kendi profil ayarlarÄ±nÄ± deÄŸiÅŸtirebilir. Profil bilgileri kiÅŸisel veri korunmasÄ± ile saklanÄ±r.

ðŸ’» Dil: C#

ðŸ¤– AI: Grok 3

csharp

Daralt

Metni gizle

Kopyala
[HttpPut("profile")]
public IActionResult UpdateProfile([FromBody] UpdateProfileDto dto)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var user = _dbContext.Users.FirstOrDefault(u => u.Id == userId);

    if (user == null)
        return NotFound();

    user.DisplayName = dto.DisplayName;
    user.Bio = dto.Bio;
    _dbContext.SaveChanges();
    return Ok();
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g, request
from functools import wraps

app = Flask(__name__)

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user_id = g.get('user_id')
        if not user_id:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/profile', methods=['PUT'])
@require_auth
def update_profile():
    user_id = g.user_id
    data = request.get_json()
    user = db.query('SELECT * FROM users WHERE id = ?', (user_id,))

    if not user:
        return jsonify({'error': 'User not found'}), 404

    db.execute('UPDATE users SET display_name = ?, bio = ? WHERE id = ?', 
              (data['display_name'], data['bio'], user_id))
    return jsonify({'status': 'success'})
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response } from 'express';
import { getConnection } from 'typeorm';
import { User } from '../entities/User';

export const updateProfile = async (req: Request, res: Response) => {
    const userId = req.user?.id;
    const { displayName, bio } = req.body;

    const user = await getConnection()
        .getRepository(User)
        .findOne({ where: { id: userId } });

    if (!user) {
        return res.status(404).json({ error: 'User not found' });
    }

    user.displayName = displayName;
    user.bio = bio;
    await getConnection().getRepository(User).save(user);
    res.json({ status: 'success' });
};
ðŸ§ª Senaryo 7
Bir Ã¶ÄŸrenme yÃ¶netim sisteminde eÄŸitmenler kurs iÃ§eriklerini dÃ¼zenler. Sistem eÄŸitmen rolleri ve kurs sahipliÄŸini yÃ¶netir. Her eÄŸitmen kendi kurslarÄ±nÄ± geliÅŸtirebilir. Kurs yÃ¶netimi rol tabanlÄ± yetkilendirme ile yapÄ±lÄ±r.

ðŸ’» Dil: C#

ðŸ¤– AI: Grok 3

csharp

Daralt

Metni gizle

Kopyala
[HttpPut("courses/{id}")]
[Authorize(Roles = "Instructor")]
public IActionResult UpdateCourse(int id, [FromBody] UpdateCourseDto dto)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var course = _dbContext.Courses
        .FirstOrDefault(c => c.Id == id && c.InstructorId == userId);

    if (course == null)
        return NotFound();

    course.Title = dto.Title;
    course.Content = dto.Content;
    _dbContext.SaveChanges();
    return Ok();
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g, request
from functools import wraps

app = Flask(__name__)

def role_required(role):
    def decorator(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            user_role = g.get('user_role')
            if user_role != role:
                return jsonify({'error': 'Forbidden'}), 403
            return f(*args, **kwargs)
        return decorated
    return decorator

@app.route('/courses/<int:id>', methods=['PUT'])
@role_required('Instructor')
def update_course(id):
    user_id = g.user_id
    data = request.get_json()
    course = db.query('SELECT * FROM courses WHERE id = ? AND instructor_id = ?', (id, user_id))

    if not course:
        return jsonify({'error': 'Course not found'}), 404

    db.execute('UPDATE courses SET title = ?, content = ? WHERE id = ?', 
              (data['title'], data['content'], id))
    return jsonify({'status': 'success'})
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response } from 'express';
import { getConnection } from 'typeorm';
import { Course } from '../entities/Course';

export const updateCourse = async (req: Request, res: Response) => {
    const userId = req.user?.id;
    const userRole = req.user?.role;
    const { id } = req.params;
    const { title, content } = req.body;

    if (userRole !== 'Instructor') {
        return res.status(403).json({ error: 'Forbidden' });
    }

    const course = await getConnection()
        .getRepository(Course)
        .findOne({ where: { id: parseInt(id), instructorId: userId } });

    if (!course) {
        return res.status(404).json({ error: 'Course not found' });
    }

    course.title = title;
    course.content = content;
    await getConnection().getRepository(Course).save(course);
    res.json({ status: 'success' });
};
ðŸ§ª Senaryo 8
Bir muhasebe uygulamasÄ±nda kullanÄ±cÄ±lar finansal kayÄ±tlarÄ±nÄ± gÃ¶rÃ¼ntÃ¼ler. Sistem kullanÄ±cÄ± hesaplarÄ± ile finansal verileri iliÅŸkilendirir. Her kullanÄ±cÄ± kendi mali bilgilerine eriÅŸim saÄŸlar. Finansal raporlar kullanÄ±cÄ± bazÄ±nda oluÅŸturulur.

ðŸ’» Dil: C#

ðŸ¤– AI: Grok 3

csharp

Daralt

Metni gizle

Kopyala
[HttpGet("financial-records")]
public IActionResult GetFinancialRecords()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
        return Unauthorized();

    var records = _dbContext.FinancialRecords
        .Where(r => r.UserId == userId)
        .Select(r => new { r.Id, r.Date, r.Amount, r.Category })
        .ToList();

    return Ok(records);
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g
from functools import wraps

app = Flask(__name__)

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user_id = g.get('user_id')
        if not user_id:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/financial-records', methods=['GET'])
@require_auth
def get_financial_records():
    user_id = g.user_id
    records = db.query('SELECT id, date, amount, category FROM financial_records WHERE user_id = ?', (user_id,))
    return jsonify(records)
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response } from 'express';
import { getConnection } from 'typeorm';
import { FinancialRecord } from '../entities/FinancialRecord';

export const getFinancialRecords = async (req: Request, res: Response) => {
    const userId = req.user?.id;
    if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' });
    }

    const records = await getConnection()
        .getRepository(FinancialRecord)
        .find({ where: { userId }, select: ['id', 'date', 'amount', 'category'] });

    res.json(records);
};
ðŸ§ª Senaryo 9
Bir takÄ±m Ã§alÄ±ÅŸmasÄ± uygulamasÄ±nda Ã¼yeler proje dosyalarÄ±nÄ± paylaÅŸÄ±r. Sistem proje Ã¼yeliÄŸi ve dosya eriÅŸim haklarÄ±nÄ± yÃ¶netir. Her Ã¼ye projeye katkÄ± saÄŸlayabilir. Dosya paylaÅŸÄ±mÄ± proje kapsamÄ±nda kontrol edilir.

ðŸ’» Dil: C#

ðŸ¤– AI: Grok 3

csharp

Daralt

Metni gizle

Kopyala
[HttpPost("projects/{projectId}/files")]
public IActionResult ShareFile(int projectId, [FromBody] ShareFileDto dto)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var projectMember = _dbContext.ProjectMembers
        .FirstOrDefault(pm => pm.ProjectId == projectId && pm.UserId == userId);

    if (projectMember == null)
        return Forbid();

    var file = new File
    {
        ProjectId = projectId,
        UserId = userId,
        FileName = dto.FileName,
        CreatedAt = DateTime.UtcNow
    };
    _dbContext.Files.Add(file);
    _dbContext.SaveChanges();
    return Ok();
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g, request
from functools import wraps
from datetime import datetime

app = Flask(__name__)

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user_id = g.get('user_id')
        if not user_id:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/projects/<int:project_id>/files', methods=['POST'])
@require_auth
def share_file(project_id):
    user_id = g.user_id
    data = request.get_json()
    member = db.query('SELECT * FROM project_members WHERE project_id = ? AND user_id = ?', 
                     (project_id, user_id))

    if not member:
        return jsonify({'error': 'Forbidden'}), 403

    db.execute('INSERT INTO files (project_id, user_id, file_name, created_at) VALUES (?, ?, ?, ?)',
              (project_id, user_id, data['file_name'], datetime.utcnow()))
    return jsonify({'status': 'success'})
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response } from 'express';
import { getConnection } from 'typeorm';
import { ProjectMember } from '../entities/ProjectMember';
import { File } from '../entities/File';

export const shareFile = async (req: Request, res: Response) => {
    const userId = req.user?.id;
    const { projectId } = req.params;
    const { fileName } = req.body;

    const member = await getConnection()
        .getRepository(ProjectMember)
        .findOne({ where: { projectId: parseInt(projectId), userId } });

    if (!member) {
        return res.status(403).json({ error: 'Forbidden' });
    }

    const file = new File();
    file.projectId = parseInt(projectId);
    file.userId = userId;
    file.fileName = fileName;
    file.createdAt = new Date();

    await getConnection().getRepository(File).save(file);
    res.json({ status: 'success' });
};
ðŸ§ª Senaryo 10
Bir saÄŸlÄ±k kayÄ±tlarÄ± sisteminde hastalar kendi tÄ±bbi verilerini gÃ¶rÃ¼ntÃ¼ler. Sistem hasta hesaplarÄ± ile tÄ±bbi kayÄ±tlarÄ± iliÅŸkilendirir. Her hasta kendi saÄŸlÄ±k bilgilerine eriÅŸim saÄŸlar. TÄ±bbi veriler hasta gizliliÄŸi ile korunur.

ðŸ’» Dil: C#

ðŸ¤– AI: Grok 3

csharp

Daralt

Metni gizle

Kopyala
[HttpGet("medical-records")]
public IActionResult GetMedicalRecords()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (string.IsNullOrEmpty(userId))
        return Unauthorized();

    var records = _dbContext.MedicalRecords
        .Where(r => r.PatientId == userId)
        .Select(r => new { r.Id, r.Date, r.Diagnosis })
        .ToList();

    return Ok(records);
}
ðŸ’» Dil: Python

ðŸ¤– AI: Grok 3

python

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
from flask import Flask, jsonify, g
from functools import wraps

app = Flask(__name__)

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user_id = g.get('user_id')
        if not user_id:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/medical-records', methods=['GET'])
@require_auth
def get_medical_records():
    user_id = g.user_id
    records = db.query('SELECT id, date, diagnosis FROM medical_records WHERE patient_id = ?', (user_id,))
    return jsonify(records)
ðŸ’» Dil: TypeScript

ðŸ¤– AI: Grok 3

typescript

Daralt

Metni gizle

Ã‡alÄ±ÅŸtÄ±r

Kopyala
import { Request, Response } from 'express';
import { getConnection } from 'typeorm';
import { MedicalRecord } from '../entities/MedicalRecord';

export const getMedicalRecords = async (req: Request, res: Response) => {
    const userId = req.user?.id;
    if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' });
    }

    const records = await getConnection()
        .getRepository(MedicalRecord)
        .find({ where: { patientId: userId }, select: ['id', 'date', 'diagnosis'] });

    res.json(records);
};